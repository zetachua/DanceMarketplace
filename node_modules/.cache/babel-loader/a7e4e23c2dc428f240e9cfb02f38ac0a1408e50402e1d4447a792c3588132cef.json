{"ast":null,"code":"var _jsxFileName = \"/Users/zetachua/Documents/GitHub/DanceMarketplace/src/Components/ScreenrecordToGif/screenRecordToGif.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState } from 'react';\nimport GIF from 'gif.js-upgrade';\nimport { Cloudinary } from \"@cloudinary/url-gen\";\nimport { AdvancedVideo } from '@cloudinary/react';\nimport { fill } from \"@cloudinary/url-gen/actions/resize\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ScreenRecorderWithGIFConversion = () => {\n  _s();\n  const videoRef = useRef();\n  const [recording, setRecording] = useState(false);\n  const [videoUrl, setVideoUrl] = useState(null); // Use videoUrl state\n\n  const startRecording = async () => {\n    try {\n      const stream = await navigator.mediaDevices.getDisplayMedia({\n        video: {\n          aspectRatio: 480 / 820 // Set the aspect ratio for portrait mode\n        }\n      });\n\n      const recorder = new MediaRecorder(stream);\n      const chunks = [];\n      recorder.ondataavailable = event => {\n        if (event.data.size > 0) {\n          chunks.push(event.data);\n        }\n      };\n      recorder.onstop = () => {\n        const webmBlob = new Blob(chunks, {\n          type: 'video/webm'\n        });\n        const webmUrl = URL.createObjectURL(webmBlob);\n        setVideoUrl(webmUrl); // Update videoUrl state instead of manipulating videoRef.current.src\n\n        convertWebMToGIF(webmBlob);\n      };\n      recorder.start();\n      setRecording(true);\n      setTimeout(() => {\n        recorder.stop();\n        stream.getTracks().forEach(track => track.stop());\n        setRecording(false);\n      }, 5000); // Recording for exactly 5 seconds\n    } catch (error) {\n      console.error('Error starting recording:', error);\n    }\n  };\n  const convertWebMToGIF = webmBlob => {\n    const videoElement = document.createElement('video');\n    videoElement.src = URL.createObjectURL(webmBlob);\n    videoElement.addEventListener('loadeddata', async () => {\n      const gif = new GIF({\n        workers: 2,\n        quality: 10\n      });\n      const originalCanvas = document.createElement('canvas');\n      const originalCtx = originalCanvas.getContext('2d');\n      const processingCanvas = document.createElement('canvas');\n      const processingCtx = processingCanvas.getContext('2d');\n\n      // Set original canvas dimensions to the video dimensions\n      originalCanvas.width = videoElement.videoWidth;\n      originalCanvas.height = videoElement.videoHeight;\n\n      // Set processing canvas dimensions to the desired aspect ratio\n      const aspectRatio = 9 / 16; // Example: 9:16 for portrait mode\n      processingCanvas.width = videoElement.videoWidth;\n      processingCanvas.height = videoElement.videoWidth * aspectRatio;\n      const frameDuration = 40; // Adjust the delay as needed (25 frames per second)\n\n      let currentTime = 0;\n      const processFrame = () => {\n        originalCtx.drawImage(videoElement, 0, 0, videoElement.videoWidth, videoElement.videoHeight);\n\n        // Crop the frame to achieve the desired aspect ratio\n        const cropY = (videoElement.videoHeight - videoElement.videoWidth * aspectRatio) / 2;\n        originalCtx.drawImage(originalCanvas, 0, cropY, originalCanvas.width, originalCanvas.height - 2 * cropY, 0, 0, processingCanvas.width, processingCanvas.height);\n\n        // Get the current frame as imageData\n        const imageData = originalCtx.getImageData(0, 0, processingCanvas.width, processingCanvas.height);\n\n        // Add the imageData as a frame to the GIF\n        gif.addFrame(imageData, {\n          delay: frameDuration\n        });\n\n        // Update the currentTime for the next frame\n        currentTime += frameDuration / 1000;\n\n        // Request the next frame\n        if (currentTime < videoElement.duration) {\n          requestAnimationFrame(processFrame);\n        } else {\n          // Finish and render the GIF when all frames are processed\n          gif.on('finished', blob => {\n            const gifUrl = URL.createObjectURL(blob);\n            setVideoUrl(gifUrl); // Update videoUrl state instead of manipulating videoRef.current.src\n          });\n\n          gif.render();\n        }\n      };\n\n      // Start processing frames\n      processFrame();\n    });\n  };\n  const cld = new Cloudinary({\n    cloud: {\n      cloudName: 'demo'\n    }\n  });\n  const mobile = cld.video(\"demo4\").resize(fill().width(400).aspectRatio(\"9:16\"));\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: startRecording,\n      disabled: recording,\n      children: recording ? 'Recording...' : 'Start Recording'\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 136,\n      columnNumber: 7\n    }, this), videoUrl && /*#__PURE__*/_jsxDEV(AdvancedVideo, {\n      cldVid: mobile,\n      autoPlay: true,\n      loop: true,\n      src: videoUrl // Use videoUrl state\n      ,\n      style: {\n        height: '100px',\n        marginTop: '10px'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 140,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 135,\n    columnNumber: 5\n  }, this);\n};\n_s(ScreenRecorderWithGIFConversion, \"lPHH/dUMoPx6klXnXZdbLKLHWUM=\");\n_c = ScreenRecorderWithGIFConversion;\nexport default ScreenRecorderWithGIFConversion;\nvar _c;\n$RefreshReg$(_c, \"ScreenRecorderWithGIFConversion\");","map":{"version":3,"names":["React","useRef","useState","GIF","Cloudinary","AdvancedVideo","fill","jsxDEV","_jsxDEV","ScreenRecorderWithGIFConversion","_s","videoRef","recording","setRecording","videoUrl","setVideoUrl","startRecording","stream","navigator","mediaDevices","getDisplayMedia","video","aspectRatio","recorder","MediaRecorder","chunks","ondataavailable","event","data","size","push","onstop","webmBlob","Blob","type","webmUrl","URL","createObjectURL","convertWebMToGIF","start","setTimeout","stop","getTracks","forEach","track","error","console","videoElement","document","createElement","src","addEventListener","gif","workers","quality","originalCanvas","originalCtx","getContext","processingCanvas","processingCtx","width","videoWidth","height","videoHeight","frameDuration","currentTime","processFrame","drawImage","cropY","imageData","getImageData","addFrame","delay","duration","requestAnimationFrame","on","blob","gifUrl","render","cld","cloud","cloudName","mobile","resize","children","onClick","disabled","fileName","_jsxFileName","lineNumber","columnNumber","cldVid","autoPlay","loop","style","marginTop","_c","$RefreshReg$"],"sources":["/Users/zetachua/Documents/GitHub/DanceMarketplace/src/Components/ScreenrecordToGif/screenRecordToGif.js"],"sourcesContent":["import React, { useRef, useState } from 'react';\nimport GIF from 'gif.js-upgrade';\nimport { Cloudinary } from \"@cloudinary/url-gen\";\nimport { AdvancedVideo } from '@cloudinary/react';\nimport { fill } from \"@cloudinary/url-gen/actions/resize\";\n\nconst ScreenRecorderWithGIFConversion = () => {\n  const videoRef = useRef();\n  const [recording, setRecording] = useState(false);\n  const [videoUrl, setVideoUrl] = useState(null); // Use videoUrl state\n\n  const startRecording = async () => {\n    try {\n      const stream = await navigator.mediaDevices.getDisplayMedia({\n        video: {\n          aspectRatio: 480 / 820, // Set the aspect ratio for portrait mode\n        },\n      });\n      const recorder = new MediaRecorder(stream);\n\n      const chunks = [];\n      recorder.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          chunks.push(event.data);\n        }\n      };\n\n      recorder.onstop = () => {\n        const webmBlob = new Blob(chunks, { type: 'video/webm' });\n        const webmUrl = URL.createObjectURL(webmBlob);\n        setVideoUrl(webmUrl); // Update videoUrl state instead of manipulating videoRef.current.src\n\n        convertWebMToGIF(webmBlob);\n      };\n\n      recorder.start();\n      setRecording(true);\n\n      setTimeout(() => {\n        recorder.stop();\n        stream.getTracks().forEach((track) => track.stop());\n        setRecording(false);\n      }, 5000); // Recording for exactly 5 seconds\n    } catch (error) {\n      console.error('Error starting recording:', error);\n    }\n  };\n\n  const convertWebMToGIF = (webmBlob) => {\n    const videoElement = document.createElement('video');\n    videoElement.src = URL.createObjectURL(webmBlob);\n    videoElement.addEventListener('loadeddata', async () => {\n      const gif = new GIF({ workers: 2, quality: 10 });\n      const originalCanvas = document.createElement('canvas');\n      const originalCtx = originalCanvas.getContext('2d');\n\n      const processingCanvas = document.createElement('canvas');\n      const processingCtx = processingCanvas.getContext('2d');\n\n      // Set original canvas dimensions to the video dimensions\n      originalCanvas.width = videoElement.videoWidth;\n      originalCanvas.height = videoElement.videoHeight;\n\n      // Set processing canvas dimensions to the desired aspect ratio\n      const aspectRatio = 9 / 16; // Example: 9:16 for portrait mode\n      processingCanvas.width = videoElement.videoWidth;\n      processingCanvas.height = videoElement.videoWidth * aspectRatio;\n\n      const frameDuration = 40; // Adjust the delay as needed (25 frames per second)\n\n      let currentTime = 0;\n\n      const processFrame = () => {\n        originalCtx.drawImage(\n          videoElement,\n          0,\n          0,\n          videoElement.videoWidth,\n          videoElement.videoHeight\n        );\n\n        // Crop the frame to achieve the desired aspect ratio\n        const cropY = (videoElement.videoHeight - videoElement.videoWidth * aspectRatio) / 2;\n        originalCtx.drawImage(\n          originalCanvas,\n          0,\n          cropY,\n          originalCanvas.width,\n          originalCanvas.height - 2 * cropY,\n          0,\n          0,\n          processingCanvas.width,\n          processingCanvas.height\n        );\n\n        // Get the current frame as imageData\n        const imageData = originalCtx.getImageData(0, 0, processingCanvas.width, processingCanvas.height);\n\n        // Add the imageData as a frame to the GIF\n        gif.addFrame(imageData, { delay: frameDuration });\n\n        // Update the currentTime for the next frame\n        currentTime += frameDuration / 1000;\n\n        // Request the next frame\n        if (currentTime < videoElement.duration) {\n          requestAnimationFrame(processFrame);\n        } else {\n          // Finish and render the GIF when all frames are processed\n          gif.on('finished', (blob) => {\n            const gifUrl = URL.createObjectURL(blob);\n            setVideoUrl(gifUrl); // Update videoUrl state instead of manipulating videoRef.current.src\n          });\n\n          gif.render();\n        }\n      };\n\n      // Start processing frames\n      processFrame();\n    });\n  };\n\n  const cld = new Cloudinary({\n    cloud: {\n      cloudName: 'demo',\n    }\n  });\n\n  const mobile = cld\n    .video(\"demo4\")\n    .resize(fill().width(400).aspectRatio(\"9:16\"));\n\n  return (\n    <div>\n      <button onClick={startRecording} disabled={recording}>\n        {recording ? 'Recording...' : 'Start Recording'}\n      </button>\n      {videoUrl && (\n        <AdvancedVideo\n          cldVid={mobile}\n          autoPlay\n          loop\n          src={videoUrl} // Use videoUrl state\n          style={{\n            height: '100px',\n            marginTop: '10px',\n          }}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default ScreenRecorderWithGIFConversion;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}