{"ast":null,"code":"// src/index.ts\nimport { memoize } from \"lodash\";\nimport ndarray5 from \"ndarray\";\n\n// src/utils.ts\nimport ndarray2 from \"ndarray\";\n\n// src/codecs.ts\nimport ndarray from \"ndarray\";\nasync function imageDecode(blob) {\n  const imageBitmap = await createImageBitmap(blob);\n  const imageData = imageBitmapToImageData(imageBitmap);\n  return ndarray(imageData.data, [imageData.height, imageData.width, 4]);\n}\nasync function imageEncode(imageTensor, quality = 0.8, format = \"image/png\") {\n  const [height, width, channels] = imageTensor.shape;\n  switch (format) {\n    case \"image/x-r8\":\n      return new Blob([imageTensor.data], {\n        type: \"image/x-alpha8\"\n      });\n    case \"image/x-rgba8\":\n      return new Blob([imageTensor.data], {\n        type: \"image/x-rgba8\"\n      });\n    case `image/png`:\n    case `image/jpeg`:\n    case `image/webp`:\n      const imageData = new ImageData(new Uint8ClampedArray(imageTensor.data), width, height);\n      var canvas = new OffscreenCanvas(imageData.width, imageData.height);\n      var ctx = canvas.getContext(\"2d\");\n      ctx.putImageData(imageData, 0, 0);\n      return canvas.convertToBlob({\n        quality,\n        type: format\n      });\n    default:\n      throw new Error(`Invalid format: ${format}`);\n  }\n}\n\n// src/url.ts\nfunction isAbsoluteURI(url) {\n  const regExp = new RegExp(\"^(?:[a-z+]+:)?//\", \"i\");\n  return regExp.test(url);\n}\nfunction ensureAbsoluteURI(url, baseUrl) {\n  if (isAbsoluteURI(url)) {\n    return url;\n  } else {\n    return new URL(url, baseUrl).href;\n  }\n}\n\n// src/utils.ts\nfunction imageBitmapToImageData(imageBitmap) {\n  var canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);\n  var ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(imageBitmap, 0, 0);\n  return ctx.getImageData(0, 0, canvas.width, canvas.height);\n}\nfunction tensorResizeBilinear(imageTensor, newWidth, newHeight) {\n  const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;\n  const scaleX = srcWidth / newWidth;\n  const scaleY = srcHeight / newHeight;\n  const resizedImageData = ndarray2(new Uint8Array(srcChannels * newWidth * newHeight), [newHeight, newWidth, srcChannels]);\n  for (let y = 0; y < newHeight; y++) {\n    for (let x = 0; x < newWidth; x++) {\n      const srcX = x * scaleX;\n      const srcY = y * scaleY;\n      const x1 = Math.max(Math.floor(srcX), 0);\n      const x2 = Math.min(Math.ceil(srcX), srcWidth - 1);\n      const y1 = Math.max(Math.floor(srcY), 0);\n      const y2 = Math.min(Math.ceil(srcY), srcHeight - 1);\n      const dx = srcX - x1;\n      const dy = srcY - y1;\n      for (let c = 0; c < srcChannels; c++) {\n        const p1 = imageTensor.get(y1, x1, c);\n        const p2 = imageTensor.get(y1, x2, c);\n        const p3 = imageTensor.get(y2, x1, c);\n        const p4 = imageTensor.get(y2, x2, c);\n        const interpolatedValue = (1 - dx) * (1 - dy) * p1 + dx * (1 - dy) * p2 + (1 - dx) * dy * p3 + dx * dy * p4;\n        resizedImageData.set(y, x, c, Math.round(interpolatedValue));\n      }\n    }\n  }\n  return resizedImageData;\n}\nfunction tensorHWCtoBCHW(imageTensor, mean = [128, 128, 128], std = [256, 256, 256]) {\n  var imageBufferData = imageTensor.data;\n  const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;\n  const stride = srcHeight * srcWidth;\n  const float32Data = new Float32Array(3 * stride);\n  for (let i = 0, j = 0; i < imageBufferData.length; i += 4, j += 1) {\n    float32Data[j] = (imageBufferData[i] - mean[0]) / std[0];\n    float32Data[j + stride] = (imageBufferData[i + 1] - mean[1]) / std[1];\n    float32Data[j + stride + stride] = (imageBufferData[i + 2] - mean[2]) / std[2];\n  }\n  return ndarray2(float32Data, [1, 3, srcHeight, srcWidth]);\n}\nasync function imageSourceToImageData(image, config) {\n  if (typeof image === \"string\") {\n    image = ensureAbsoluteURI(image, config.publicPath);\n    image = new URL(image);\n  }\n  if (image instanceof URL) {\n    const response = await fetch(image, {});\n    image = await response.blob();\n  }\n  if (image instanceof ArrayBuffer || ArrayBuffer.isView(image)) {\n    image = new Blob([image]);\n  }\n  if (image instanceof Blob) {\n    image = await imageDecode(image);\n  }\n  return image;\n}\nfunction convertFloat32ToUint8(float32Array) {\n  const uint8Array = new Uint8Array(float32Array.data.length);\n  for (let i = 0; i < float32Array.data.length; i++) {\n    uint8Array[i] = float32Array.data[i] * 255;\n  }\n  return ndarray2(uint8Array, float32Array.shape);\n}\n\n// src/onnx.ts\nimport ndarray3 from \"ndarray\";\nimport * as ort from \"onnxruntime-web\";\n\n// src/resource.ts\nasync function preload(config) {\n  const resourceUrl = new URL(\"resources.json\", config.publicPath);\n  const resourceResponse = await fetch(resourceUrl);\n  if (!resourceResponse.ok) {\n    throw new Error(`Resource metadata not found. Ensure that the config.publicPath is configured correctly.`);\n  }\n  const resourceMap = await resourceResponse.json();\n  const keys = Object.keys(resourceMap);\n  await Promise.all(keys.map(async key => {\n    return loadAsBlob(key, config);\n  }));\n}\nasync function loadAsUrl(url, config) {\n  return URL.createObjectURL(await loadAsBlob(url, config));\n}\nasync function loadAsBlob(key, config) {\n  const resourceUrl = new URL(\"resources.json\", config.publicPath);\n  const resourceResponse = await fetch(resourceUrl);\n  if (!resourceResponse.ok) {\n    throw new Error(`Resource metadata not found. Ensure that the config.publicPath is configured correctly.`);\n  }\n  const resourceMap = await resourceResponse.json();\n  const entry = resourceMap[key];\n  if (!entry) {\n    throw new Error(`Resource ${key} not found. Ensure that the config.publicPath is configured correctly.`);\n  }\n  const chunks = entry.chunks;\n  let downloadedSize = 0;\n  const responses = chunks.map(async chunk => {\n    const url = config.publicPath ? new URL(chunk.hash, config.publicPath).toString() : chunk.hash;\n    const response = await fetch(url, config.fetchArgs);\n    const blob = await response.blob();\n    if (chunk.size !== blob.size) {\n      throw new Error(`Failed to fetch ${key} with size ${chunk.size} but got ${blob.size}`);\n    }\n    if (config.progress) {\n      downloadedSize += chunk.size;\n      config.progress(`fetch:${key}`, downloadedSize, entry.size);\n    }\n    return blob;\n  });\n  const allChunkData = await Promise.all(responses);\n  const data = new Blob(allChunkData, {\n    type: entry.mime\n  });\n  if (data.size !== entry.size) {\n    throw new Error(`Failed to fetch ${key} with size ${entry.size} but got ${data.size}`);\n  }\n  return data;\n}\n\n// src/feature-detect.js\nvar simd = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]));\nvar threads = () => (async e => {\n  try {\n    return \"undefined\" != typeof MessageChannel && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(e);\n  } catch (e2) {\n    return false;\n  }\n})(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11]));\n\n// src/onnx.ts\nasync function createOnnxSession(model, config) {\n  const capabilities = {\n    simd: await simd(),\n    threads: await threads(),\n    numThreads: navigator.hardwareConcurrency ?? 4,\n    // @ts-ignore\n    webgpu: navigator.gpu !== void 0\n  };\n  if (config.debug) {\n    console.debug(\"Capabilities:\", capabilities);\n    ort.env.debug = true;\n    ort.env.logLevel = \"verbose\";\n  }\n  ort.env.wasm.numThreads = capabilities.numThreads;\n  ort.env.wasm.simd = capabilities.simd;\n  ort.env.wasm.proxy = config.proxyToWorker;\n  ort.env.wasm.wasmPaths = {\n    \"ort-wasm-simd-threaded.wasm\": capabilities.simd && capabilities.threads ? await loadAsUrl(\"/onnxruntime-web/ort-wasm-simd-threaded.wasm\", config) : void 0,\n    \"ort-wasm-simd.wasm\": capabilities.simd && !capabilities.threads ? await loadAsUrl(\"/onnxruntime-web/ort-wasm-simd.wasm\", config) : void 0,\n    \"ort-wasm-threaded.wasm\": !capabilities.simd && capabilities.threads ? await loadAsUrl(\"/onnxruntime-web/ort-wasm-threaded.wasm\", config) : void 0,\n    \"ort-wasm.wasm\": !capabilities.simd && !capabilities.threads ? await loadAsUrl(\"/onnxruntime-web/ort-wasm.wasm\", config) : void 0\n  };\n  if (config.debug) {\n    console.debug(\"ort.env.wasm:\", ort.env.wasm);\n  }\n  const ort_config = {\n    executionProviders: [\"wasm\"],\n    graphOptimizationLevel: \"all\",\n    executionMode: \"parallel\",\n    enableCpuMemArena: true\n  };\n  const session = await ort.InferenceSession.create(model, ort_config).catch(e => {\n    throw new Error(`Failed to create session: ${e}. Please check if the publicPath is set correctly.`);\n  });\n  return session;\n}\nasync function runOnnxSession(session, inputs, outputs) {\n  const feeds = {};\n  for (const [key, tensor] of inputs) {\n    feeds[key] = new ort.Tensor(\"float32\", new Float32Array(tensor.data), tensor.shape);\n  }\n  const outputData = await session.run(feeds, {});\n  const outputKVPairs = [];\n  for (const key of outputs) {\n    const output = outputData[key];\n    const shape = output.dims;\n    const data = output.data;\n    const tensor = ndarray3(data, shape);\n    outputKVPairs.push(tensor);\n  }\n  return outputKVPairs;\n}\n\n// src/schema.ts\nimport { z } from \"zod\";\n\n// package.json\nvar package_default = {\n  name: \"@imgly/background-removal\",\n  version: \"1.3.0\",\n  description: \"Background Removal in the Browser\",\n  keywords: [\"background-removal\", \"client-side\", \"data-privacy\", \"image-segmentation\", \"image-matting\", \"onnx\"],\n  repository: {\n    type: \"git\",\n    url: \"git+https://github.com/imgly/background-removal-js.git\"\n  },\n  license: \"SEE LICENSE IN LICENSE.md\",\n  author: {\n    name: \"IMG.LY GmbH\",\n    email: \"support@img.ly\",\n    url: \"https://img.ly\"\n  },\n  bugs: {\n    email: \"support@img.ly\"\n  },\n  source: \"./src/index.ts\",\n  main: \"./dist/index.cjs\",\n  module: \"./dist/index.mjs\",\n  types: \"./dist/index.d.ts\",\n  exports: {\n    \".\": {\n      require: \"./dist/index.cjs\",\n      import: \"./dist/index.mjs\",\n      types: \"./dist/index.d.ts\"\n    }\n  },\n  homepage: \"https://img.ly/showcases/cesdk/web/background-removal\",\n  files: [\"LICENSE.md\", \"README.md\", \"CHANGELOG.md\", \"dist/\", \"bin/\"],\n  scripts: {\n    start: \"npm run watch\",\n    clean: \"npx rimraf dist\",\n    test: \"true\",\n    resources: \"node ../../scripts/package-resources.mjs\",\n    \"changelog:create\": \"node ../../scripts/changelog/create.mjs\",\n    \"changelog:generate\": \"node ../../scripts/changelog/generate.mjs\",\n    build: \"npm run clean && npm run resources && npm run changelog:generate && node scripts/build.mjs\",\n    watch: \"npm run clean && npm run resources && npm run changelog:generate && node scripts/watch.mjs\",\n    publish: \"npm run build && npm publish --access public\",\n    lint: \"npx prettier --write .\"\n  },\n  dependencies: {\n    \"@types/lodash\": \"^4.14.195\",\n    \"@types/node\": \"^20.3.1\",\n    lodash: \"^4.17.21\",\n    ndarray: \"^1.0.19\",\n    \"onnxruntime-web\": \"^1.16.3\",\n    zod: \"^3.21.4\"\n  },\n  devDependencies: {\n    assert: \"^2.0.0\",\n    esbuild: \"^0.18.18\",\n    glob: \"^10.3.3\",\n    \"npm-dts\": \"^1.3.12\",\n    process: \"^0.11.10\",\n    \"ts-loader\": \"^9.4.3\",\n    tslib: \"^2.5.3\",\n    typescript: \"^5.1.3\",\n    util: \"^0.12.5\",\n    webpack: \"^5.85.1\",\n    \"webpack-cli\": \"^5.1.4\"\n  }\n};\n\n// src/schema.ts\nvar ConfigSchema = z.object({\n  publicPath: z.string().optional().describe(\"The public path to the wasm files and the onnx model.\").default(\"https://unpkg.com/${PACKAGE_NAME}@${PACKAGE_VERSION}/dist/\").transform(val => {\n    return val.replace(\"${PACKAGE_NAME}\", package_default.name).replace(\"${PACKAGE_VERSION}\", package_default.version);\n  }),\n  debug: z.boolean().default(false).describe(\"Whether to enable debug logging.\"),\n  proxyToWorker: z.boolean().default(true).describe(\"Whether to proxy inference to a web worker.\"),\n  fetchArgs: z.any().default({}).describe(\"Arguments to pass to fetch when loading the model.\"),\n  progress: z.function().args(z.string(), z.number(), z.number()).returns(z.void()).describe(\"Progress callback.\").optional(),\n  model: z.enum([\"small\", \"medium\"]).default(\"medium\"),\n  output: z.object({\n    format: z.enum([\"image/png\", \"image/jpeg\", \"image/webp\", \"image/x-rgba8\", \"image/x-alpha8\"]).default(\"image/png\"),\n    quality: z.number().default(0.8)\n  }).default({})\n}).default({});\nfunction validateConfig(configuration) {\n  const config = ConfigSchema.parse(configuration ?? {});\n  if (config.debug) console.log(\"Config:\", config);\n  if (config.debug && !config.progress) {\n    config.progress = config.progress ?? ((key, current, total) => {\n      console.debug(`Downloading ${key}: ${current} of ${total}`);\n    });\n    if (!crossOriginIsolated) {\n      console.debug(\"Cross-Origin-Isolated is not enabled. Performance will be degraded. Please see  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer.\");\n    }\n  }\n  return config;\n}\n\n// src/inference.ts\nimport ndarray4 from \"ndarray\";\nasync function initInference(config) {\n  config = validateConfig(config);\n  if (config.debug) console.debug(\"Loading model...\");\n  const model = config.model;\n  const blob = await loadAsBlob(`/models/${model}`, config);\n  const arrayBuffer = await blob.arrayBuffer();\n  const session = await createOnnxSession(arrayBuffer, config);\n  return {\n    config,\n    session\n  };\n}\nasync function runInference(imageTensor, config, session) {\n  if (config.progress) config.progress(\"compute:inference\", 0, 1);\n  const resolution = 1024;\n  const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;\n  let tensorImage = tensorResizeBilinear(imageTensor, resolution, resolution);\n  const inputTensor = tensorHWCtoBCHW(tensorImage);\n  const predictionsDict = await runOnnxSession(session, [[\"input\", inputTensor]], [\"output\"]);\n  let alphamask = ndarray4(predictionsDict[0].data, [resolution, resolution, 1]);\n  alphamask = convertFloat32ToUint8(alphamask);\n  alphamask = tensorResizeBilinear(alphamask, srcWidth, srcHeight);\n  if (config.progress) config.progress(\"compute:inference\", 1, 1);\n  return alphamask;\n}\n\n// src/index.ts\nvar src_default = removeBackground;\nvar init = memoize(initInference, config => JSON.stringify(config));\nasync function preload2(configuration) {\n  const config = validateConfig(configuration);\n  await preload(config);\n  return;\n}\nasync function removeBackground(image, configuration) {\n  const {\n    config,\n    session\n  } = await init(configuration);\n  const imageTensor = await imageSourceToImageData(image, config);\n  const [width, height, channels] = imageTensor.shape;\n  const alphamask = await runInference(imageTensor, config, session);\n  const stride = width * height;\n  const outImageTensor = imageTensor;\n  for (let i = 0; i < stride; i += 1) {\n    outImageTensor.data[4 * i + 3] = alphamask.data[i];\n  }\n  const outImage = await imageEncode(outImageTensor, config.output.quality, config.output.format);\n  return outImage;\n}\nasync function removeForeground(image, configuration) {\n  const {\n    config,\n    session\n  } = await init(configuration);\n  const imageTensor = await imageSourceToImageData(image, config);\n  const [width, height, channels] = imageTensor.shape;\n  const alphamask = await runInference(imageTensor, config, session);\n  const stride = width * height;\n  const outImageTensor = imageTensor;\n  for (let i = 0; i < stride; i += 1) {\n    outImageTensor.data[4 * i + 3] = 255 - alphamask.data[i];\n  }\n  const outImage = await imageEncode(outImageTensor, config.output.quality, config.output.format);\n  return outImage;\n}\nasync function segmentForeground(image, configuration) {\n  const {\n    config,\n    session\n  } = await init(configuration);\n  const imageTensor = await imageSourceToImageData(image, config);\n  const [height, width, channels] = imageTensor.shape;\n  const alphamask = await runInference(imageTensor, config, session);\n  const stride = width * height;\n  if (config.output.format === \"image/x-alpha8\") {\n    const outImage = await imageEncode(alphamask, config.output.quality, config.output.format);\n    return outImage;\n  } else {\n    const outImageTensor = ndarray5(new Uint8Array(channels * stride), [height, width, channels]);\n    for (let i = 0; i < stride; i += 1) {\n      const index = 4 * i + 3;\n      outImageTensor.data[index] = alphamask.data[i];\n      outImageTensor.data[index + 1] = alphamask.data[i];\n      outImageTensor.data[index + 2] = alphamask.data[i];\n      outImageTensor.data[index + 3] = 255;\n    }\n    const outImage = await imageEncode(outImageTensor, config.output.quality, config.output.format);\n    return outImage;\n  }\n}\nexport { src_default as default, preload2 as preload, removeBackground, removeForeground, segmentForeground };","map":{"version":3,"names":["memoize","ndarray5","ndarray2","ndarray","imageDecode","blob","imageBitmap","createImageBitmap","imageData","imageBitmapToImageData","data","height","width","imageEncode","imageTensor","quality","format","channels","shape","Blob","type","ImageData","Uint8ClampedArray","canvas","OffscreenCanvas","ctx","getContext","putImageData","convertToBlob","Error","isAbsoluteURI","url","regExp","RegExp","test","ensureAbsoluteURI","baseUrl","URL","href","drawImage","getImageData","tensorResizeBilinear","newWidth","newHeight","srcHeight","srcWidth","srcChannels","scaleX","scaleY","resizedImageData","Uint8Array","y","x","srcX","srcY","x1","Math","max","floor","x2","min","ceil","y1","y2","dx","dy","c","p1","get","p2","p3","p4","interpolatedValue","set","round","tensorHWCtoBCHW","mean","std","imageBufferData","stride","float32Data","Float32Array","i","j","length","imageSourceToImageData","image","config","publicPath","response","fetch","ArrayBuffer","isView","convertFloat32ToUint8","float32Array","uint8Array","ndarray3","ort","preload","resourceUrl","resourceResponse","ok","resourceMap","json","keys","Object","Promise","all","map","key","loadAsBlob","loadAsUrl","createObjectURL","entry","chunks","downloadedSize","responses","chunk","hash","toString","fetchArgs","size","progress","allChunkData","mime","simd","WebAssembly","validate","threads","e","MessageChannel","port1","postMessage","SharedArrayBuffer","e2","createOnnxSession","model","capabilities","numThreads","navigator","hardwareConcurrency","webgpu","gpu","debug","console","env","logLevel","wasm","proxy","proxyToWorker","wasmPaths","ort_config","executionProviders","graphOptimizationLevel","executionMode","enableCpuMemArena","session","InferenceSession","create","catch","runOnnxSession","inputs","outputs","feeds","tensor","Tensor","outputData","run","outputKVPairs","output","dims","push","z","package_default","name","version","description","keywords","repository","license","author","email","bugs","source","main","module","types","exports","require","import","homepage","files","scripts","start","clean","resources","build","watch","publish","lint","dependencies","lodash","zod","devDependencies","assert","esbuild","glob","process","tslib","typescript","util","webpack","ConfigSchema","object","string","optional","describe","default","transform","val","replace","boolean","any","function","args","number","returns","void","enum","validateConfig","configuration","parse","log","current","total","crossOriginIsolated","ndarray4","initInference","arrayBuffer","runInference","resolution","tensorImage","inputTensor","predictionsDict","alphamask","src_default","removeBackground","init","JSON","stringify","preload2","outImageTensor","outImage","removeForeground","segmentForeground","index"],"sources":["/Users/zetachua/Documents/GitHub/DanceMarketplace/node_modules/@imgly/background-removal/src/index.ts","/Users/zetachua/Documents/GitHub/DanceMarketplace/node_modules/@imgly/background-removal/src/utils.ts","/Users/zetachua/Documents/GitHub/DanceMarketplace/node_modules/@imgly/background-removal/src/codecs.ts","/Users/zetachua/Documents/GitHub/DanceMarketplace/node_modules/@imgly/background-removal/src/url.ts","/Users/zetachua/Documents/GitHub/DanceMarketplace/node_modules/@imgly/background-removal/src/onnx.ts","/Users/zetachua/Documents/GitHub/DanceMarketplace/node_modules/@imgly/background-removal/src/resource.ts","/Users/zetachua/Documents/GitHub/DanceMarketplace/node_modules/@imgly/background-removal/src/feature-detect.js","/Users/zetachua/Documents/GitHub/DanceMarketplace/node_modules/@imgly/background-removal/src/schema.ts","/Users/zetachua/Documents/GitHub/DanceMarketplace/node_modules/@imgly/background-removal/package.json","/Users/zetachua/Documents/GitHub/DanceMarketplace/node_modules/@imgly/background-removal/src/inference.ts"],"sourcesContent":["export default removeBackground;\nexport { preload, removeBackground, removeForeground, segmentForeground };\nexport type { Config, ImageSource };\n\nimport { memoize } from 'lodash';\nimport ndarray from 'ndarray';\nimport { initInference, runInference } from './inference';\nimport { preload as preloadResources } from './resource';\nimport { Config, validateConfig } from './schema';\nimport * as utils from './utils';\nimport { ImageSource } from './utils';\n\nconst init = memoize(initInference, (config) => JSON.stringify(config));\n\nasync function preload(configuration?: Config): Promise<void> {\n  const config = validateConfig(configuration);\n  await preloadResources(config);\n  return;\n}\n\n/**\n * Removes the background from an image.\n *\n * @param image - The image to remove the background from.\n * @param configuration - Optional configuration for the background removal process.\n * @returns A Promise that resolves to the resulting image with the background removed.\n */\nasync function removeBackground(\n  image: ImageSource,\n  configuration?: Config\n): Promise<Blob> {\n  const { config, session } = await init(configuration);\n\n  const imageTensor = await utils.imageSourceToImageData(image, config);\n  const [width, height, channels] = imageTensor.shape;\n\n  const alphamask = await runInference(imageTensor, config, session);\n  const stride = width * height;\n\n  const outImageTensor = imageTensor;\n  for (let i = 0; i < stride; i += 1) {\n    outImageTensor.data[4 * i + 3] = alphamask.data[i];\n  }\n\n  const outImage = await utils.imageEncode(\n    outImageTensor,\n    config.output.quality,\n    config.output.format\n  );\n\n  return outImage;\n}\n\n/**\n * Removes the foreground from an image.\n *\n * @param image - The image to remove the foreground from.\n * @param configuration - Optional configuration for the foreground removal process.\n * @returns A Promise that resolves to the resulting image with the foreground removed.\n */\nasync function removeForeground(\n  image: ImageSource,\n  configuration?: Config\n): Promise<Blob> {\n  const { config, session } = await init(configuration);\n\n  const imageTensor = await utils.imageSourceToImageData(image, config);\n  const [width, height, channels] = imageTensor.shape;\n\n  const alphamask = await runInference(imageTensor, config, session);\n  const stride = width * height;\n  const outImageTensor = imageTensor;\n  for (let i = 0; i < stride; i += 1) {\n    outImageTensor.data[4 * i + 3] = 255 - alphamask.data[i];\n  }\n\n  const outImage = await utils.imageEncode(\n    outImageTensor,\n    config.output.quality,\n    config.output.format\n  );\n\n  return outImage;\n}\n\n/**\n * Segments the foreground of an image using a given configuration.\n *\n * @param image - The image source to segment.\n * @param configuration - The optional configuration for the segmentation.\n * @returns A Promise that resolves to the segmented foreground as a Blob.\n */\nasync function segmentForeground(\n  image: ImageSource,\n  configuration?: Config\n): Promise<Blob> {\n  const { config, session } = await init(configuration);\n\n  const imageTensor = await utils.imageSourceToImageData(image, config);\n  const [height, width, channels] = imageTensor.shape;\n\n  const alphamask = await runInference(imageTensor, config, session);\n  const stride = width * height;\n\n  if (config.output.format === 'image/x-alpha8') {\n    const outImage = await utils.imageEncode(\n      alphamask,\n      config.output.quality,\n      config.output.format\n    );\n    return outImage;\n  } else {\n    const outImageTensor = ndarray(new Uint8Array(channels * stride), [\n      height,\n      width,\n      channels\n    ]);\n    for (let i = 0; i < stride; i += 1) {\n      const index = 4 * i + 3;\n      outImageTensor.data[index] = alphamask.data[i]; //Red\n      outImageTensor.data[index + 1] = alphamask.data[i]; //Green\n      outImageTensor.data[index + 2] = alphamask.data[i]; // Blue\n      outImageTensor.data[index + 3] = 255;\n    }\n\n    const outImage = await utils.imageEncode(\n      outImageTensor,\n      config.output.quality,\n      config.output.format\n    );\n\n    return outImage;\n  }\n}\n","export {\n  imageDecode,\n  imageEncode,\n  tensorResizeBilinear,\n  tensorHWCtoBCHW,\n  imageBitmapToImageData,\n  calculateProportionalSize,\n  imageSourceToImageData,\n  ImageSource\n};\n\nimport ndarray, { NdArray } from 'ndarray';\nimport { imageDecode, imageEncode } from './codecs';\nimport { ensureAbsoluteURI } from './url';\nimport { Config } from './schema';\n\ntype ImageSource = ImageData | ArrayBuffer | Uint8Array | Blob | URL | string;\n\nfunction imageBitmapToImageData(imageBitmap: ImageBitmap): ImageData {\n  var canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);\n  var ctx = canvas.getContext('2d')!;\n  ctx.drawImage(imageBitmap, 0, 0);\n  return ctx.getImageData(0, 0, canvas.width, canvas.height);\n}\n\nfunction tensorResizeBilinear(\n  imageTensor: NdArray<Uint8Array>,\n  newWidth: number,\n  newHeight: number\n): NdArray<Uint8Array> {\n  const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;\n  // Calculate the scaling factors\n  const scaleX = srcWidth / newWidth;\n  const scaleY = srcHeight / newHeight;\n\n  // Create a new NdArray to store the resized image\n  const resizedImageData = ndarray(\n    new Uint8Array(srcChannels * newWidth * newHeight),\n    [newHeight, newWidth, srcChannels]\n  );\n  // Perform interpolation to fill the resized NdArray\n  for (let y = 0; y < newHeight; y++) {\n    for (let x = 0; x < newWidth; x++) {\n      const srcX = x * scaleX;\n      const srcY = y * scaleY;\n      const x1 = Math.max(Math.floor(srcX), 0);\n      const x2 = Math.min(Math.ceil(srcX), srcWidth - 1);\n      const y1 = Math.max(Math.floor(srcY), 0);\n      const y2 = Math.min(Math.ceil(srcY), srcHeight - 1);\n\n      const dx = srcX - x1;\n      const dy = srcY - y1;\n\n      for (let c = 0; c < srcChannels; c++) {\n        const p1 = imageTensor.get(y1, x1, c);\n        const p2 = imageTensor.get(y1, x2, c);\n        const p3 = imageTensor.get(y2, x1, c);\n        const p4 = imageTensor.get(y2, x2, c);\n\n        // Perform bilinear interpolation\n        const interpolatedValue =\n          (1 - dx) * (1 - dy) * p1 +\n          dx * (1 - dy) * p2 +\n          (1 - dx) * dy * p3 +\n          dx * dy * p4;\n\n        resizedImageData.set(y, x, c, Math.round(interpolatedValue));\n      }\n    }\n  }\n\n  return resizedImageData;\n}\n\nfunction tensorHWCtoBCHW(\n  imageTensor: NdArray<Uint8Array>,\n  mean: number[] = [128, 128, 128],\n  std: number[] = [256, 256, 256]\n): NdArray<Float32Array> {\n  var imageBufferData = imageTensor.data;\n  const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;\n  const stride = srcHeight * srcWidth;\n  const float32Data = new Float32Array(3 * stride);\n\n  // r_0, r_1, .... g_0,g_1, .... b_0\n  for (let i = 0, j = 0; i < imageBufferData.length; i += 4, j += 1) {\n    float32Data[j] = (imageBufferData[i] - mean[0]) / std[0];\n    float32Data[j + stride] = (imageBufferData[i + 1] - mean[1]) / std[1];\n    float32Data[j + stride + stride] =\n      (imageBufferData[i + 2] - mean[2]) / std[2];\n  }\n\n  return ndarray(float32Data, [1, 3, srcHeight, srcWidth]);\n}\n\nfunction calculateProportionalSize(\n  originalWidth: number,\n  originalHeight: number,\n  maxWidth: number,\n  maxHeight: number\n): [number, number] {\n  const widthRatio = maxWidth / originalWidth;\n  const heightRatio = maxHeight / originalHeight;\n  const scalingFactor = Math.min(widthRatio, heightRatio);\n  const newWidth = Math.floor(originalWidth * scalingFactor);\n  const newHeight = Math.floor(originalHeight * scalingFactor);\n  return [newWidth, newHeight];\n}\n\nasync function imageSourceToImageData(\n  image: ImageSource,\n  config: Config\n): Promise<NdArray<Uint8Array>> {\n  if (typeof image === 'string') {\n    image = ensureAbsoluteURI(image, config.publicPath);\n    image = new URL(image);\n  }\n  if (image instanceof URL) {\n    const response = await fetch(image, {});\n    image = await response.blob();\n  }\n  if (image instanceof ArrayBuffer || ArrayBuffer.isView(image)) {\n    image = new Blob([image]);\n  }\n  if (image instanceof Blob) {\n    image = await imageDecode(image);\n  }\n\n  return image as NdArray<Uint8Array>;\n}\nexport function convertFloat32ToUint8(\n  float32Array: NdArray<Float32Array>\n): NdArray<Uint8Array> {\n  const uint8Array = new Uint8Array(float32Array.data.length);\n  for (let i = 0; i < float32Array.data.length; i++) {\n    uint8Array[i] = float32Array.data[i] * 255;\n  }\n  return ndarray(uint8Array, float32Array.shape);\n}\n","export { imageEncode, imageDecode };\nimport { imageBitmapToImageData } from './utils';\nimport ndarray, { NdArray } from 'ndarray';\n\nasync function imageDecode(blob: Blob): Promise<NdArray<Uint8Array>> {\n  const imageBitmap = await createImageBitmap(blob);\n  const imageData = imageBitmapToImageData(imageBitmap);\n  return ndarray(imageData.data, [imageData.height, imageData.width, 4]);\n}\n\nasync function imageEncode(\n  imageTensor: NdArray<Uint8Array>,\n  quality: number = 0.8,\n  format: string = 'image/png'\n): Promise<Blob> {\n  const [height, width, channels] = imageTensor.shape;\n\n  switch (format) {\n    case 'image/x-r8':\n      return new Blob([imageTensor.data], { type: 'image/x-alpha8' });\n    case 'image/x-rgba8':\n      return new Blob([imageTensor.data], { type: 'image/x-rgba8' });\n    case `image/png`:\n    case `image/jpeg`:\n    case `image/webp`:\n      const imageData = new ImageData(\n        new Uint8ClampedArray(imageTensor.data),\n        width,\n        height\n      );\n      var canvas = new OffscreenCanvas(imageData.width, imageData.height);\n      var ctx = canvas.getContext('2d')!;\n      ctx.putImageData(imageData, 0, 0);\n      return canvas.convertToBlob({ quality, type: format });\n    default:\n      throw new Error(`Invalid format: ${format}`);\n  }\n}\n","export { isAbsoluteURI, ensureAbsoluteURI };\n\nfunction isAbsoluteURI(url: string): boolean {\n  const regExp = new RegExp('^(?:[a-z+]+:)?//', 'i');\n  return regExp.test(url); // true - regular http absolute URL\n}\n\nconst isNode = typeof window === 'undefined';\nconst isBrowser = typeof window !== 'undefined';\n\nfunction ensureAbsoluteURI(url: string, baseUrl: string): string {\n  if (isAbsoluteURI(url)) {\n    return url;\n  } else {\n    return new URL(url, baseUrl).href;\n  }\n}\n","export { createOnnxSession, runOnnxSession };\n\nimport ndarray, { NdArray } from 'ndarray';\nimport * as ort from 'onnxruntime-web';\nimport { loadAsUrl } from './resource';\nimport { simd, threads } from './feature-detect';\nimport { Config } from './schema';\n\nasync function createOnnxSession(model: any, config: Config) {\n  const capabilities = {\n    simd: await simd(),\n    threads: await threads(),\n    numThreads: navigator.hardwareConcurrency ?? 4,\n    // @ts-ignore\n    webgpu: navigator.gpu !== undefined\n  };\n  if (config.debug) {\n    console.debug('Capabilities:', capabilities);\n    ort.env.debug = true;\n    ort.env.logLevel = 'verbose';\n  }\n\n  ort.env.wasm.numThreads = capabilities.numThreads;\n  ort.env.wasm.simd = capabilities.simd;\n  ort.env.wasm.proxy = config.proxyToWorker;\n\n  ort.env.wasm.wasmPaths = {\n    'ort-wasm-simd-threaded.wasm':\n      capabilities.simd && capabilities.threads\n        ? await loadAsUrl(\n            '/onnxruntime-web/ort-wasm-simd-threaded.wasm',\n            config\n          )\n        : undefined,\n    'ort-wasm-simd.wasm':\n      capabilities.simd && !capabilities.threads\n        ? await loadAsUrl('/onnxruntime-web/ort-wasm-simd.wasm', config)\n        : undefined,\n    'ort-wasm-threaded.wasm':\n      !capabilities.simd && capabilities.threads\n        ? await loadAsUrl('/onnxruntime-web/ort-wasm-threaded.wasm', config)\n        : undefined,\n    'ort-wasm.wasm':\n      !capabilities.simd && !capabilities.threads\n        ? await loadAsUrl('/onnxruntime-web/ort-wasm.wasm', config)\n        : undefined\n  };\n\n  if (config.debug) {\n    console.debug('ort.env.wasm:', ort.env.wasm);\n  }\n\n  const ort_config: ort.InferenceSession.SessionOptions = {\n    executionProviders: ['wasm'],\n    graphOptimizationLevel: 'all',\n    executionMode: 'parallel',\n    enableCpuMemArena: true\n  };\n\n  const session = await ort.InferenceSession.create(model, ort_config).catch(\n    (e: any) => {\n      throw new Error(\n        `Failed to create session: ${e}. Please check if the publicPath is set correctly.`\n      );\n    }\n  );\n  return session;\n}\n\nasync function runOnnxSession(\n  session: any,\n  inputs: [string, NdArray<Float32Array>][],\n  outputs: [string]\n) {\n  const feeds: Record<string, any> = {};\n  for (const [key, tensor] of inputs) {\n    feeds[key] = new ort.Tensor(\n      'float32',\n      new Float32Array(tensor.data),\n      tensor.shape\n    );\n  }\n  const outputData = await session.run(feeds, {});\n  const outputKVPairs: NdArray<Float32Array>[] = [];\n\n  for (const key of outputs) {\n    const output: ort.Tensor = outputData[key];\n    const shape: Number[] = output.dims as number[];\n    const data: Float32Array = output.data as Float32Array;\n    const tensor = ndarray(data, shape);\n    outputKVPairs.push(tensor);\n  }\n\n  return outputKVPairs;\n}\n","export { loadAsBlob, loadAsUrl, preload };\n\nimport { Config } from './schema';\n\nasync function preload(config: Config): Promise<void> {\n  // load resource metadata\n  const resourceUrl = new URL('resources.json', config.publicPath);\n  const resourceResponse = await fetch(resourceUrl);\n  if (!resourceResponse.ok) {\n    throw new Error(\n      `Resource metadata not found. Ensure that the config.publicPath is configured correctly.`\n    );\n  }\n  const resourceMap = await resourceResponse.json();\n  const keys = Object.keys(resourceMap);\n\n  await Promise.all(\n    keys.map(async (key) => {\n      return loadAsBlob(key, config);\n    })\n  );\n}\n\nasync function loadAsUrl(url: string, config: Config): Promise<string> {\n  return URL.createObjectURL(await loadAsBlob(url, config));\n}\n\nasync function loadAsBlob(key: string, config: Config) {\n  // load resource metadata\n  const resourceUrl = new URL('resources.json', config.publicPath);\n  const resourceResponse = await fetch(resourceUrl);\n  if (!resourceResponse.ok) {\n    throw new Error(\n      `Resource metadata not found. Ensure that the config.publicPath is configured correctly.`\n    );\n  }\n  const resourceMap = await resourceResponse.json();\n  const entry = resourceMap[key];\n\n  if (!entry) {\n    throw new Error(\n      `Resource ${key} not found. Ensure that the config.publicPath is configured correctly.`\n    );\n  }\n\n  const chunks = entry.chunks; // list of entries\n\n  let downloadedSize = 0;\n  const responses = chunks.map(async (chunk) => {\n    const url = config.publicPath\n      ? new URL(chunk.hash, config.publicPath).toString()\n      : chunk.hash;\n    const response = await fetch(url, config.fetchArgs);\n    const blob = await response.blob();\n\n    if (chunk.size !== blob.size) {\n      throw new Error(\n        `Failed to fetch ${key} with size ${chunk.size} but got ${blob.size}`\n      );\n    }\n\n    if (config.progress) {\n      downloadedSize += chunk.size;\n      config.progress(`fetch:${key}`, downloadedSize, entry.size);\n    }\n    return blob;\n  });\n\n  // we could create a new buffer here and use the chunk entries and combine the file instead\n\n  const allChunkData = await Promise.all(responses);\n\n  const data = new Blob(allChunkData, { type: entry.mime });\n  if (data.size !== entry.size) {\n    throw new Error(\n      `Failed to fetch ${key} with size ${entry.size} but got ${data.size}`\n    );\n  }\n  return data;\n}\n","export const bigInt = () =>\n    (async (e) => {\n      try {\n        return (\n          (await WebAssembly.instantiate(e)).instance.exports.b(BigInt(0)) ===\n          BigInt(0)\n        );\n      } catch (e) {\n        return !1;\n      }\n    })(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 1, 126, 1, 126, 3, 2, 1, 0, 7,\n        5, 1, 1, 98, 0, 0, 10, 6, 1, 4, 0, 32, 0, 11\n      ])\n    ),\n  bulkMemory = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 3, 1, 0,\n        1, 10, 14, 1, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11\n      ])\n    ),\n  exceptions = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 8, 1, 6,\n        0, 6, 64, 25, 11, 11\n      ])\n    ),\n  extendedConst = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 5, 3, 1, 0, 1, 11, 9, 1, 0, 65, 1, 65, 2,\n        106, 11, 0\n      ])\n    ),\n  gc = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 10, 2, 95, 1, 125, 0, 96, 0, 1, 107, 0,\n        3, 2, 1, 1, 10, 12, 1, 10, 0, 67, 0, 0, 0, 0, 251, 7, 0, 11\n      ])\n    ),\n  memory64 = async () =>\n    WebAssembly.validate(\n      new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 5, 3, 1, 4, 1])\n    ),\n  multiValue = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 0, 2, 127, 127, 3, 2, 1, 0,\n        10, 8, 1, 6, 0, 65, 0, 65, 0, 11\n      ])\n    ),\n  mutableGlobals = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 2, 8, 1, 1, 97, 1, 98, 3, 127, 1, 6, 6, 1,\n        127, 1, 65, 0, 11, 7, 5, 1, 1, 97, 3, 1\n      ])\n    ),\n  referenceTypes = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 7, 1, 5,\n        0, 208, 112, 26, 11\n      ])\n    ),\n  relaxedSimd = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 15,\n        1, 13, 0, 65, 1, 253, 15, 65, 2, 253, 15, 253, 128, 2, 11\n      ])\n    ),\n  saturatedFloatToInt = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 12, 1,\n        10, 0, 67, 0, 0, 0, 0, 252, 0, 26, 11\n      ])\n    ),\n  signExtensions = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 8, 1, 6,\n        0, 65, 0, 192, 26, 11\n      ])\n    ),\n  simd = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10,\n        1, 8, 0, 65, 0, 253, 15, 253, 98, 11\n      ])\n    ),\n  streamingCompilation = () =>\n    (async () => 'compileStreaming' in WebAssembly)(),\n  tailCall = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 6, 1, 4,\n        0, 18, 0, 11\n      ])\n    ),\n  threads = () =>\n    (async (e) => {\n      try {\n        return (\n          'undefined' != typeof MessageChannel &&\n            new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),\n          WebAssembly.validate(e)\n        );\n      } catch (e) {\n        return !1;\n      }\n    })(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3,\n        1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11\n      ])\n    );\n","export { Config, ConfigSchema, validateConfig };\n\nimport { z } from 'zod';\n\nimport pkg from '../package.json';\n\nconst ConfigSchema = z\n  .object({\n    publicPath: z\n      .string()\n      .optional()\n      .describe('The public path to the wasm files and the onnx model.')\n      .default('https://unpkg.com/${PACKAGE_NAME}@${PACKAGE_VERSION}/dist/')\n      .transform((val) => {\n        return val\n          .replace('${PACKAGE_NAME}', pkg.name)\n          .replace('${PACKAGE_VERSION}', pkg.version);\n      }),\n    debug: z\n      .boolean()\n      .default(false)\n      .describe('Whether to enable debug logging.'),\n    proxyToWorker: z\n      .boolean()\n      .default(true)\n      .describe('Whether to proxy inference to a web worker.'),\n    fetchArgs: z\n      .any()\n      .default({})\n      .describe('Arguments to pass to fetch when loading the model.'),\n    progress: z\n      .function()\n      .args(z.string(), z.number(), z.number())\n      .returns(z.void())\n      .describe('Progress callback.')\n      .optional(),\n    model: z.enum(['small', 'medium']).default('medium'),\n    output: z\n      .object({\n        format: z\n          .enum([\n            'image/png',\n            'image/jpeg',\n            'image/webp',\n            'image/x-rgba8',\n            'image/x-alpha8'\n          ])\n          .default('image/png'),\n        quality: z.number().default(0.8)\n      })\n      .default({})\n  })\n  .default({});\n\ntype Config = z.infer<typeof ConfigSchema>;\n\nfunction validateConfig(configuration?: Config): Config {\n  const config = ConfigSchema.parse(configuration ?? {});\n  if (config.debug) console.log('Config:', config);\n  if (config.debug && !config.progress) {\n    config.progress =\n      config.progress ??\n      ((key, current, total) => {\n        console.debug(`Downloading ${key}: ${current} of ${total}`);\n      });\n\n    if (!crossOriginIsolated) {\n      console.debug(\n        'Cross-Origin-Isolated is not enabled. Performance will be degraded. Please see  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer.'\n      );\n    }\n  }\n  return config;\n}\n","{\n  \"name\": \"@imgly/background-removal\",\n  \"version\": \"1.3.0\",\n  \"description\": \"Background Removal in the Browser\",\n  \"keywords\": [\n    \"background-removal\",\n    \"client-side\",\n    \"data-privacy\",\n    \"image-segmentation\",\n    \"image-matting\",\n    \"onnx\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/imgly/background-removal-js.git\"\n  },\n  \"license\": \"SEE LICENSE IN LICENSE.md\",\n  \"author\": {\n    \"name\": \"IMG.LY GmbH\",\n    \"email\": \"support@img.ly\",\n    \"url\": \"https://img.ly\"\n  },\n  \"bugs\": {\n    \"email\": \"support@img.ly\"\n  },\n  \"source\": \"./src/index.ts\",\n  \"main\": \"./dist/index.cjs\",\n  \"module\": \"./dist/index.mjs\",\n  \"types\": \"./dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"require\": \"./dist/index.cjs\",\n      \"import\": \"./dist/index.mjs\",\n      \"types\": \"./dist/index.d.ts\"\n    }\n  },\n  \"homepage\": \"https://img.ly/showcases/cesdk/web/background-removal\",\n  \"files\": [\n    \"LICENSE.md\",\n    \"README.md\",\n    \"CHANGELOG.md\",\n    \"dist/\",\n    \"bin/\"\n  ],\n  \"scripts\": {\n    \"start\": \"npm run watch\",\n    \"clean\": \"npx rimraf dist\",\n    \"test\": \"true\",\n    \"resources\": \"node ../../scripts/package-resources.mjs\",\n    \"changelog:create\": \"node ../../scripts/changelog/create.mjs\",\n    \"changelog:generate\": \"node ../../scripts/changelog/generate.mjs\",\n    \"build\": \"npm run clean && npm run resources && npm run changelog:generate && node scripts/build.mjs\",\n    \"watch\": \"npm run clean && npm run resources && npm run changelog:generate && node scripts/watch.mjs\",\n    \"publish\": \"npm run build && npm publish --access public\",\n    \"lint\": \"npx prettier --write .\"\n  },\n  \"dependencies\": {\n    \"@types/lodash\": \"^4.14.195\",\n    \"@types/node\": \"^20.3.1\",\n    \"lodash\": \"^4.17.21\",\n    \"ndarray\": \"^1.0.19\",\n    \"onnxruntime-web\": \"^1.16.3\",\n    \"zod\": \"^3.21.4\"\n  },\n  \"devDependencies\": {\n    \"assert\": \"^2.0.0\",\n    \"esbuild\": \"^0.18.18\",\n    \"glob\": \"^10.3.3\",\n    \"npm-dts\": \"^1.3.12\",\n    \"process\": \"^0.11.10\",\n    \"ts-loader\": \"^9.4.3\",\n    \"tslib\": \"^2.5.3\",\n    \"typescript\": \"^5.1.3\",\n    \"util\": \"^0.12.5\",\n    \"webpack\": \"^5.85.1\",\n    \"webpack-cli\": \"^5.1.4\"\n  }\n}","export { initInference, runInference };\n\nimport { tensorResizeBilinear, tensorHWCtoBCHW } from './utils';\nimport { createOnnxSession, runOnnxSession } from './onnx';\nimport { Config, validateConfig } from './schema';\n\nimport { loadAsBlob } from './resource';\nimport ndarray, { NdArray } from 'ndarray';\nimport { convertFloat32ToUint8 } from './utils';\n\nasync function initInference(config?: Config) {\n  config = validateConfig(config);\n\n  if (config.debug) console.debug('Loading model...');\n  const model = config.model;\n  const blob = await loadAsBlob(`/models/${model}`, config);\n  const arrayBuffer = await blob.arrayBuffer();\n  const session = await createOnnxSession(arrayBuffer, config);\n  return { config, session };\n}\n\nasync function runInference(\n  imageTensor: NdArray<Uint8Array>,\n  config: Config,\n  session: any\n): Promise<NdArray<Uint8Array>> {\n  if (config.progress) config.progress('compute:inference', 0, 1);\n  const resolution = 1024;\n  const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;\n\n  let tensorImage = tensorResizeBilinear(imageTensor, resolution, resolution);\n  const inputTensor = tensorHWCtoBCHW(tensorImage); // this converts also from float to rgba\n\n  // run\n  const predictionsDict = await runOnnxSession(\n    session,\n    [['input', inputTensor]],\n    ['output']\n  );\n\n  let alphamask = ndarray(predictionsDict[0].data, [resolution, resolution, 1]);\n  alphamask = convertFloat32ToUint8(alphamask);\n  alphamask = tensorResizeBilinear(alphamask, srcWidth, srcHeight);\n\n  if (config.progress) config.progress('compute:inference', 1, 1);\n  return alphamask;\n}\n"],"mappings":";AAIA,SAASA,OAAA,QAAe;AACxB,OAAOC,QAAA,MAAa;;;ACMpB,OAAOC,QAAA,MAA0B;;;ACTjC,OAAOC,OAAA,MAA0B;AAEjC,eAAeC,YAAYC,IAAA,EAA0C;EACnE,MAAMC,WAAA,GAAc,MAAMC,iBAAA,CAAkBF,IAAI;EAChD,MAAMG,SAAA,GAAYC,sBAAA,CAAuBH,WAAW;EACpD,OAAOH,OAAA,CAAQK,SAAA,CAAUE,IAAA,EAAM,CAACF,SAAA,CAAUG,MAAA,EAAQH,SAAA,CAAUI,KAAA,EAAO,CAAC,CAAC;AACvE;AAEA,eAAeC,YACbC,WAAA,EACAC,OAAA,GAAkB,KAClBC,MAAA,GAAiB,aACF;EACf,MAAM,CAACL,MAAA,EAAQC,KAAA,EAAOK,QAAQ,IAAIH,WAAA,CAAYI,KAAA;EAE9C,QAAQF,MAAA;IACN,KAAK;MACH,OAAO,IAAIG,IAAA,CAAK,CAACL,WAAA,CAAYJ,IAAI,GAAG;QAAEU,IAAA,EAAM;MAAiB,CAAC;IAChE,KAAK;MACH,OAAO,IAAID,IAAA,CAAK,CAACL,WAAA,CAAYJ,IAAI,GAAG;QAAEU,IAAA,EAAM;MAAgB,CAAC;IAC/D,KAAK;IACL,KAAK;IACL,KAAK;MACH,MAAMZ,SAAA,GAAY,IAAIa,SAAA,CACpB,IAAIC,iBAAA,CAAkBR,WAAA,CAAYJ,IAAI,GACtCE,KAAA,EACAD,MACF;MACA,IAAIY,MAAA,GAAS,IAAIC,eAAA,CAAgBhB,SAAA,CAAUI,KAAA,EAAOJ,SAAA,CAAUG,MAAM;MAClE,IAAIc,GAAA,GAAMF,MAAA,CAAOG,UAAA,CAAW,IAAI;MAChCD,GAAA,CAAIE,YAAA,CAAanB,SAAA,EAAW,GAAG,CAAC;MAChC,OAAOe,MAAA,CAAOK,aAAA,CAAc;QAAEb,OAAA;QAASK,IAAA,EAAMJ;MAAO,CAAC;IACvD;MACE,MAAM,IAAIa,KAAA,CAAM,mBAAmBb,MAAM,EAAE;EAC/C;AACF;;;ACnCA,SAASc,cAAcC,GAAA,EAAsB;EAC3C,MAAMC,MAAA,GAAS,IAAIC,MAAA,CAAO,oBAAoB,GAAG;EACjD,OAAOD,MAAA,CAAOE,IAAA,CAAKH,GAAG;AACxB;AAKA,SAASI,kBAAkBJ,GAAA,EAAaK,OAAA,EAAyB;EAC/D,IAAIN,aAAA,CAAcC,GAAG,GAAG;IACtB,OAAOA,GAAA;EACT,OAAO;IACL,OAAO,IAAIM,GAAA,CAAIN,GAAA,EAAKK,OAAO,EAAEE,IAAA;EAC/B;AACF;;;AFEA,SAAS7B,uBAAuBH,WAAA,EAAqC;EACnE,IAAIiB,MAAA,GAAS,IAAIC,eAAA,CAAgBlB,WAAA,CAAYM,KAAA,EAAON,WAAA,CAAYK,MAAM;EACtE,IAAIc,GAAA,GAAMF,MAAA,CAAOG,UAAA,CAAW,IAAI;EAChCD,GAAA,CAAIc,SAAA,CAAUjC,WAAA,EAAa,GAAG,CAAC;EAC/B,OAAOmB,GAAA,CAAIe,YAAA,CAAa,GAAG,GAAGjB,MAAA,CAAOX,KAAA,EAAOW,MAAA,CAAOZ,MAAM;AAC3D;AAEA,SAAS8B,qBACP3B,WAAA,EACA4B,QAAA,EACAC,SAAA,EACqB;EACrB,MAAM,CAACC,SAAA,EAAWC,QAAA,EAAUC,WAAW,IAAIhC,WAAA,CAAYI,KAAA;EAEvD,MAAM6B,MAAA,GAASF,QAAA,GAAWH,QAAA;EAC1B,MAAMM,MAAA,GAASJ,SAAA,GAAYD,SAAA;EAG3B,MAAMM,gBAAA,GAAmB/C,QAAA,CACvB,IAAIgD,UAAA,CAAWJ,WAAA,GAAcJ,QAAA,GAAWC,SAAS,GACjD,CAACA,SAAA,EAAWD,QAAA,EAAUI,WAAW,CACnC;EAEA,SAASK,CAAA,GAAI,GAAGA,CAAA,GAAIR,SAAA,EAAWQ,CAAA,IAAK;IAClC,SAASC,CAAA,GAAI,GAAGA,CAAA,GAAIV,QAAA,EAAUU,CAAA,IAAK;MACjC,MAAMC,IAAA,GAAOD,CAAA,GAAIL,MAAA;MACjB,MAAMO,IAAA,GAAOH,CAAA,GAAIH,MAAA;MACjB,MAAMO,EAAA,GAAKC,IAAA,CAAKC,GAAA,CAAID,IAAA,CAAKE,KAAA,CAAML,IAAI,GAAG,CAAC;MACvC,MAAMM,EAAA,GAAKH,IAAA,CAAKI,GAAA,CAAIJ,IAAA,CAAKK,IAAA,CAAKR,IAAI,GAAGR,QAAA,GAAW,CAAC;MACjD,MAAMiB,EAAA,GAAKN,IAAA,CAAKC,GAAA,CAAID,IAAA,CAAKE,KAAA,CAAMJ,IAAI,GAAG,CAAC;MACvC,MAAMS,EAAA,GAAKP,IAAA,CAAKI,GAAA,CAAIJ,IAAA,CAAKK,IAAA,CAAKP,IAAI,GAAGV,SAAA,GAAY,CAAC;MAElD,MAAMoB,EAAA,GAAKX,IAAA,GAAOE,EAAA;MAClB,MAAMU,EAAA,GAAKX,IAAA,GAAOQ,EAAA;MAElB,SAASI,CAAA,GAAI,GAAGA,CAAA,GAAIpB,WAAA,EAAaoB,CAAA,IAAK;QACpC,MAAMC,EAAA,GAAKrD,WAAA,CAAYsD,GAAA,CAAIN,EAAA,EAAIP,EAAA,EAAIW,CAAC;QACpC,MAAMG,EAAA,GAAKvD,WAAA,CAAYsD,GAAA,CAAIN,EAAA,EAAIH,EAAA,EAAIO,CAAC;QACpC,MAAMI,EAAA,GAAKxD,WAAA,CAAYsD,GAAA,CAAIL,EAAA,EAAIR,EAAA,EAAIW,CAAC;QACpC,MAAMK,EAAA,GAAKzD,WAAA,CAAYsD,GAAA,CAAIL,EAAA,EAAIJ,EAAA,EAAIO,CAAC;QAGpC,MAAMM,iBAAA,IACH,IAAIR,EAAA,KAAO,IAAIC,EAAA,IAAME,EAAA,GACtBH,EAAA,IAAM,IAAIC,EAAA,IAAMI,EAAA,IACf,IAAIL,EAAA,IAAMC,EAAA,GAAKK,EAAA,GAChBN,EAAA,GAAKC,EAAA,GAAKM,EAAA;QAEZtB,gBAAA,CAAiBwB,GAAA,CAAItB,CAAA,EAAGC,CAAA,EAAGc,CAAA,EAAGV,IAAA,CAAKkB,KAAA,CAAMF,iBAAiB,CAAC;MAC7D;IACF;EACF;EAEA,OAAOvB,gBAAA;AACT;AAEA,SAAS0B,gBACP7D,WAAA,EACA8D,IAAA,GAAiB,CAAC,KAAK,KAAK,GAAG,GAC/BC,GAAA,GAAgB,CAAC,KAAK,KAAK,GAAG,GACP;EACvB,IAAIC,eAAA,GAAkBhE,WAAA,CAAYJ,IAAA;EAClC,MAAM,CAACkC,SAAA,EAAWC,QAAA,EAAUC,WAAW,IAAIhC,WAAA,CAAYI,KAAA;EACvD,MAAM6D,MAAA,GAASnC,SAAA,GAAYC,QAAA;EAC3B,MAAMmC,WAAA,GAAc,IAAIC,YAAA,CAAa,IAAIF,MAAM;EAG/C,SAASG,CAAA,GAAI,GAAGC,CAAA,GAAI,GAAGD,CAAA,GAAIJ,eAAA,CAAgBM,MAAA,EAAQF,CAAA,IAAK,GAAGC,CAAA,IAAK,GAAG;IACjEH,WAAA,CAAYG,CAAC,KAAKL,eAAA,CAAgBI,CAAC,IAAIN,IAAA,CAAK,CAAC,KAAKC,GAAA,CAAI,CAAC;IACvDG,WAAA,CAAYG,CAAA,GAAIJ,MAAM,KAAKD,eAAA,CAAgBI,CAAA,GAAI,CAAC,IAAIN,IAAA,CAAK,CAAC,KAAKC,GAAA,CAAI,CAAC;IACpEG,WAAA,CAAYG,CAAA,GAAIJ,MAAA,GAASA,MAAM,KAC5BD,eAAA,CAAgBI,CAAA,GAAI,CAAC,IAAIN,IAAA,CAAK,CAAC,KAAKC,GAAA,CAAI,CAAC;EAC9C;EAEA,OAAO3E,QAAA,CAAQ8E,WAAA,EAAa,CAAC,GAAG,GAAGpC,SAAA,EAAWC,QAAQ,CAAC;AACzD;AAgBA,eAAewC,uBACbC,KAAA,EACAC,MAAA,EAC8B;EAC9B,IAAI,OAAOD,KAAA,KAAU,UAAU;IAC7BA,KAAA,GAAQnD,iBAAA,CAAkBmD,KAAA,EAAOC,MAAA,CAAOC,UAAU;IAClDF,KAAA,GAAQ,IAAIjD,GAAA,CAAIiD,KAAK;EACvB;EACA,IAAIA,KAAA,YAAiBjD,GAAA,EAAK;IACxB,MAAMoD,QAAA,GAAW,MAAMC,KAAA,CAAMJ,KAAA,EAAO,CAAC,CAAC;IACtCA,KAAA,GAAQ,MAAMG,QAAA,CAASpF,IAAA,CAAK;EAC9B;EACA,IAAIiF,KAAA,YAAiBK,WAAA,IAAeA,WAAA,CAAYC,MAAA,CAAON,KAAK,GAAG;IAC7DA,KAAA,GAAQ,IAAInE,IAAA,CAAK,CAACmE,KAAK,CAAC;EAC1B;EACA,IAAIA,KAAA,YAAiBnE,IAAA,EAAM;IACzBmE,KAAA,GAAQ,MAAMlF,WAAA,CAAYkF,KAAK;EACjC;EAEA,OAAOA,KAAA;AACT;AACO,SAASO,sBACdC,YAAA,EACqB;EACrB,MAAMC,UAAA,GAAa,IAAI7C,UAAA,CAAW4C,YAAA,CAAapF,IAAA,CAAK0E,MAAM;EAC1D,SAASF,CAAA,GAAI,GAAGA,CAAA,GAAIY,YAAA,CAAapF,IAAA,CAAK0E,MAAA,EAAQF,CAAA,IAAK;IACjDa,UAAA,CAAWb,CAAC,IAAIY,YAAA,CAAapF,IAAA,CAAKwE,CAAC,IAAI;EACzC;EACA,OAAOhF,QAAA,CAAQ6F,UAAA,EAAYD,YAAA,CAAa5E,KAAK;AAC/C;;;AGxIA,OAAO8E,QAAA,MAA0B;AACjC,YAAYC,GAAA,MAAS;;;ACCrB,eAAeC,QAAQX,MAAA,EAA+B;EAEpD,MAAMY,WAAA,GAAc,IAAI9D,GAAA,CAAI,kBAAkBkD,MAAA,CAAOC,UAAU;EAC/D,MAAMY,gBAAA,GAAmB,MAAMV,KAAA,CAAMS,WAAW;EAChD,IAAI,CAACC,gBAAA,CAAiBC,EAAA,EAAI;IACxB,MAAM,IAAIxE,KAAA,CACR,yFACF;EACF;EACA,MAAMyE,WAAA,GAAc,MAAMF,gBAAA,CAAiBG,IAAA,CAAK;EAChD,MAAMC,IAAA,GAAOC,MAAA,CAAOD,IAAA,CAAKF,WAAW;EAEpC,MAAMI,OAAA,CAAQC,GAAA,CACZH,IAAA,CAAKI,GAAA,CAAI,MAAOC,GAAA,IAAQ;IACtB,OAAOC,UAAA,CAAWD,GAAA,EAAKtB,MAAM;EAC/B,CAAC,CACH;AACF;AAEA,eAAewB,UAAUhF,GAAA,EAAawD,MAAA,EAAiC;EACrE,OAAOlD,GAAA,CAAI2E,eAAA,CAAgB,MAAMF,UAAA,CAAW/E,GAAA,EAAKwD,MAAM,CAAC;AAC1D;AAEA,eAAeuB,WAAWD,GAAA,EAAatB,MAAA,EAAgB;EAErD,MAAMY,WAAA,GAAc,IAAI9D,GAAA,CAAI,kBAAkBkD,MAAA,CAAOC,UAAU;EAC/D,MAAMY,gBAAA,GAAmB,MAAMV,KAAA,CAAMS,WAAW;EAChD,IAAI,CAACC,gBAAA,CAAiBC,EAAA,EAAI;IACxB,MAAM,IAAIxE,KAAA,CACR,yFACF;EACF;EACA,MAAMyE,WAAA,GAAc,MAAMF,gBAAA,CAAiBG,IAAA,CAAK;EAChD,MAAMU,KAAA,GAAQX,WAAA,CAAYO,GAAG;EAE7B,IAAI,CAACI,KAAA,EAAO;IACV,MAAM,IAAIpF,KAAA,CACR,YAAYgF,GAAG,wEACjB;EACF;EAEA,MAAMK,MAAA,GAASD,KAAA,CAAMC,MAAA;EAErB,IAAIC,cAAA,GAAiB;EACrB,MAAMC,SAAA,GAAYF,MAAA,CAAON,GAAA,CAAI,MAAOS,KAAA,IAAU;IAC5C,MAAMtF,GAAA,GAAMwD,MAAA,CAAOC,UAAA,GACf,IAAInD,GAAA,CAAIgF,KAAA,CAAMC,IAAA,EAAM/B,MAAA,CAAOC,UAAU,EAAE+B,QAAA,CAAS,IAChDF,KAAA,CAAMC,IAAA;IACV,MAAM7B,QAAA,GAAW,MAAMC,KAAA,CAAM3D,GAAA,EAAKwD,MAAA,CAAOiC,SAAS;IAClD,MAAMnH,IAAA,GAAO,MAAMoF,QAAA,CAASpF,IAAA,CAAK;IAEjC,IAAIgH,KAAA,CAAMI,IAAA,KAASpH,IAAA,CAAKoH,IAAA,EAAM;MAC5B,MAAM,IAAI5F,KAAA,CACR,mBAAmBgF,GAAG,cAAcQ,KAAA,CAAMI,IAAI,YAAYpH,IAAA,CAAKoH,IAAI,EACrE;IACF;IAEA,IAAIlC,MAAA,CAAOmC,QAAA,EAAU;MACnBP,cAAA,IAAkBE,KAAA,CAAMI,IAAA;MACxBlC,MAAA,CAAOmC,QAAA,CAAS,SAASb,GAAG,IAAIM,cAAA,EAAgBF,KAAA,CAAMQ,IAAI;IAC5D;IACA,OAAOpH,IAAA;EACT,CAAC;EAID,MAAMsH,YAAA,GAAe,MAAMjB,OAAA,CAAQC,GAAA,CAAIS,SAAS;EAEhD,MAAM1G,IAAA,GAAO,IAAIS,IAAA,CAAKwG,YAAA,EAAc;IAAEvG,IAAA,EAAM6F,KAAA,CAAMW;EAAK,CAAC;EACxD,IAAIlH,IAAA,CAAK+G,IAAA,KAASR,KAAA,CAAMQ,IAAA,EAAM;IAC5B,MAAM,IAAI5F,KAAA,CACR,mBAAmBgF,GAAG,cAAcI,KAAA,CAAMQ,IAAI,YAAY/G,IAAA,CAAK+G,IAAI,EACrE;EACF;EACA,OAAO/G,IAAA;AACT;;;AC/EO,IA0FLmH,IAAA,GAAO,MAAAA,CAAA,KACLC,WAAA,CAAYC,QAAA,CACV,IAAI7E,UAAA,CAAW,CACb,GAAG,IAAI,KAAK,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,KAAK,GAAG,GAAG,GAAG,GAAG,IAAI,IACrE,GAAG,GAAG,GAAG,IAAI,GAAG,KAAK,IAAI,KAAK,IAAI,GACnC,CACH;AAhGG,IA0GL8E,OAAA,GAAUA,CAAA,MACP,MAAOC,CAAA,IAAM;EACZ,IAAI;IACF,OACE,eAAe,OAAOC,cAAA,IACpB,IAAIA,cAAA,CAAe,EAAEC,KAAA,CAAMC,WAAA,CAAY,IAAIC,iBAAA,CAAkB,CAAC,CAAC,GACjEP,WAAA,CAAYC,QAAA,CAASE,CAAC;EAE1B,SAASK,EAAA,EAAG;IACV,OAAO;EACT;AACF,GACE,IAAIpF,UAAA,CAAW,CACb,GAAG,IAAI,KAAK,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GACrE,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,KAAK,IAAI,GAAG,GAAG,IAAI,GAClD,CACH;;;AFlHJ,eAAeqF,kBAAkBC,KAAA,EAAYjD,MAAA,EAAgB;EAC3D,MAAMkD,YAAA,GAAe;IACnBZ,IAAA,EAAM,MAAMA,IAAA,CAAK;IACjBG,OAAA,EAAS,MAAMA,OAAA,CAAQ;IACvBU,UAAA,EAAYC,SAAA,CAAUC,mBAAA,IAAuB;IAAA;IAE7CC,MAAA,EAAQF,SAAA,CAAUG,GAAA,KAAQ;EAC5B;EACA,IAAIvD,MAAA,CAAOwD,KAAA,EAAO;IAChBC,OAAA,CAAQD,KAAA,CAAM,iBAAiBN,YAAY;IACvCxC,GAAA,CAAAgD,GAAA,CAAIF,KAAA,GAAQ;IACZ9C,GAAA,CAAAgD,GAAA,CAAIC,QAAA,GAAW;EACrB;EAEIjD,GAAA,CAAAgD,GAAA,CAAIE,IAAA,CAAKT,UAAA,GAAaD,YAAA,CAAaC,UAAA;EACnCzC,GAAA,CAAAgD,GAAA,CAAIE,IAAA,CAAKtB,IAAA,GAAOY,YAAA,CAAaZ,IAAA;EAC7B5B,GAAA,CAAAgD,GAAA,CAAIE,IAAA,CAAKC,KAAA,GAAQ7D,MAAA,CAAO8D,aAAA;EAExBpD,GAAA,CAAAgD,GAAA,CAAIE,IAAA,CAAKG,SAAA,GAAY;IACvB,+BACEb,YAAA,CAAaZ,IAAA,IAAQY,YAAA,CAAaT,OAAA,GAC9B,MAAMjB,SAAA,CACJ,gDACAxB,MACF,IACA;IACN,sBACEkD,YAAA,CAAaZ,IAAA,IAAQ,CAACY,YAAA,CAAaT,OAAA,GAC/B,MAAMjB,SAAA,CAAU,uCAAuCxB,MAAM,IAC7D;IACN,0BACE,CAACkD,YAAA,CAAaZ,IAAA,IAAQY,YAAA,CAAaT,OAAA,GAC/B,MAAMjB,SAAA,CAAU,2CAA2CxB,MAAM,IACjE;IACN,iBACE,CAACkD,YAAA,CAAaZ,IAAA,IAAQ,CAACY,YAAA,CAAaT,OAAA,GAChC,MAAMjB,SAAA,CAAU,kCAAkCxB,MAAM,IACxD;EACR;EAEA,IAAIA,MAAA,CAAOwD,KAAA,EAAO;IAChBC,OAAA,CAAQD,KAAA,CAAM,iBAAqB9C,GAAA,CAAAgD,GAAA,CAAIE,IAAI;EAC7C;EAEA,MAAMI,UAAA,GAAkD;IACtDC,kBAAA,EAAoB,CAAC,MAAM;IAC3BC,sBAAA,EAAwB;IACxBC,aAAA,EAAe;IACfC,iBAAA,EAAmB;EACrB;EAEA,MAAMC,OAAA,GAAU,MAAU3D,GAAA,CAAA4D,gBAAA,CAAiBC,MAAA,CAAOtB,KAAA,EAAOe,UAAU,EAAEQ,KAAA,CAClE9B,CAAA,IAAW;IACV,MAAM,IAAIpG,KAAA,CACR,6BAA6BoG,CAAC,oDAChC;EACF,CACF;EACA,OAAO2B,OAAA;AACT;AAEA,eAAeI,eACbJ,OAAA,EACAK,MAAA,EACAC,OAAA,EACA;EACA,MAAMC,KAAA,GAA6B,CAAC;EACpC,WAAW,CAACtD,GAAA,EAAKuD,MAAM,KAAKH,MAAA,EAAQ;IAClCE,KAAA,CAAMtD,GAAG,IAAI,IAAQZ,GAAA,CAAAoE,MAAA,CACnB,WACA,IAAIpF,YAAA,CAAamF,MAAA,CAAO1J,IAAI,GAC5B0J,MAAA,CAAOlJ,KACT;EACF;EACA,MAAMoJ,UAAA,GAAa,MAAMV,OAAA,CAAQW,GAAA,CAAIJ,KAAA,EAAO,CAAC,CAAC;EAC9C,MAAMK,aAAA,GAAyC,EAAC;EAEhD,WAAW3D,GAAA,IAAOqD,OAAA,EAAS;IACzB,MAAMO,MAAA,GAAqBH,UAAA,CAAWzD,GAAG;IACzC,MAAM3F,KAAA,GAAkBuJ,MAAA,CAAOC,IAAA;IAC/B,MAAMhK,IAAA,GAAqB+J,MAAA,CAAO/J,IAAA;IAClC,MAAM0J,MAAA,GAASpE,QAAA,CAAQtF,IAAA,EAAMQ,KAAK;IAClCsJ,aAAA,CAAcG,IAAA,CAAKP,MAAM;EAC3B;EAEA,OAAOI,aAAA;AACT;;;AG5FA,SAASI,CAAA,QAAS;;;ACFlB,IAAAC,eAAA;EACEC,IAAA,EAAQ;EACRC,OAAA,EAAW;EACXC,WAAA,EAAe;EACfC,QAAA,EAAY,CACV,sBACA,eACA,gBACA,sBACA,iBACA,OACF;EACAC,UAAA,EAAc;IACZ9J,IAAA,EAAQ;IACRW,GAAA,EAAO;EACT;EACAoJ,OAAA,EAAW;EACXC,MAAA,EAAU;IACRN,IAAA,EAAQ;IACRO,KAAA,EAAS;IACTtJ,GAAA,EAAO;EACT;EACAuJ,IAAA,EAAQ;IACND,KAAA,EAAS;EACX;EACAE,MAAA,EAAU;EACVC,IAAA,EAAQ;EACRC,MAAA,EAAU;EACVC,KAAA,EAAS;EACTC,OAAA,EAAW;IACT,KAAK;MACHC,OAAA,EAAW;MACXC,MAAA,EAAU;MACVH,KAAA,EAAS;IACX;EACF;EACAI,QAAA,EAAY;EACZC,KAAA,EAAS,CACP,cACA,aACA,gBACA,SACA,OACF;EACAC,OAAA,EAAW;IACTC,KAAA,EAAS;IACTC,KAAA,EAAS;IACThK,IAAA,EAAQ;IACRiK,SAAA,EAAa;IACb,oBAAoB;IACpB,sBAAsB;IACtBC,KAAA,EAAS;IACTC,KAAA,EAAS;IACTC,OAAA,EAAW;IACXC,IAAA,EAAQ;EACV;EACAC,YAAA,EAAgB;IACd,iBAAiB;IACjB,eAAe;IACfC,MAAA,EAAU;IACVtM,OAAA,EAAW;IACX,mBAAmB;IACnBuM,GAAA,EAAO;EACT;EACAC,eAAA,EAAmB;IACjBC,MAAA,EAAU;IACVC,OAAA,EAAW;IACXC,IAAA,EAAQ;IACR,WAAW;IACXC,OAAA,EAAW;IACX,aAAa;IACbC,KAAA,EAAS;IACTC,UAAA,EAAc;IACdC,IAAA,EAAQ;IACRC,OAAA,EAAW;IACX,eAAe;EACjB;AACF;;;ADvEA,IAAMC,YAAA,GAAexC,CAAA,CAClByC,MAAA,CAAO;EACN7H,UAAA,EAAYoF,CAAA,CACT0C,MAAA,CAAO,EACPC,QAAA,CAAS,EACTC,QAAA,CAAS,uDAAuD,EAChEC,OAAA,CAAQ,4DAA4D,EACpEC,SAAA,CAAWC,GAAA,IAAQ;IAClB,OAAOA,GAAA,CACJC,OAAA,CAAQ,mBAAmB/C,eAAA,CAAIC,IAAI,EACnC8C,OAAA,CAAQ,sBAAsB/C,eAAA,CAAIE,OAAO;EAC9C,CAAC;EACHhC,KAAA,EAAO6B,CAAA,CACJiD,OAAA,CAAQ,EACRJ,OAAA,CAAQ,KAAK,EACbD,QAAA,CAAS,kCAAkC;EAC9CnE,aAAA,EAAeuB,CAAA,CACZiD,OAAA,CAAQ,EACRJ,OAAA,CAAQ,IAAI,EACZD,QAAA,CAAS,6CAA6C;EACzDhG,SAAA,EAAWoD,CAAA,CACRkD,GAAA,CAAI,EACJL,OAAA,CAAQ,CAAC,CAAC,EACVD,QAAA,CAAS,oDAAoD;EAChE9F,QAAA,EAAUkD,CAAA,CACPmD,QAAA,CAAS,EACTC,IAAA,CAAKpD,CAAA,CAAE0C,MAAA,CAAO,GAAG1C,CAAA,CAAEqD,MAAA,CAAO,GAAGrD,CAAA,CAAEqD,MAAA,CAAO,CAAC,EACvCC,OAAA,CAAQtD,CAAA,CAAEuD,IAAA,CAAK,CAAC,EAChBX,QAAA,CAAS,oBAAoB,EAC7BD,QAAA,CAAS;EACZ/E,KAAA,EAAOoC,CAAA,CAAEwD,IAAA,CAAK,CAAC,SAAS,QAAQ,CAAC,EAAEX,OAAA,CAAQ,QAAQ;EACnDhD,MAAA,EAAQG,CAAA,CACLyC,MAAA,CAAO;IACNrM,MAAA,EAAQ4J,CAAA,CACLwD,IAAA,CAAK,CACJ,aACA,cACA,cACA,iBACA,iBACD,EACAX,OAAA,CAAQ,WAAW;IACtB1M,OAAA,EAAS6J,CAAA,CAAEqD,MAAA,CAAO,EAAER,OAAA,CAAQ,GAAG;EACjC,CAAC,EACAA,OAAA,CAAQ,CAAC,CAAC;AACf,CAAC,EACAA,OAAA,CAAQ,CAAC,CAAC;AAIb,SAASY,eAAeC,aAAA,EAAgC;EACtD,MAAM/I,MAAA,GAAS6H,YAAA,CAAamB,KAAA,CAAMD,aAAA,IAAiB,CAAC,CAAC;EACrD,IAAI/I,MAAA,CAAOwD,KAAA,EAAOC,OAAA,CAAQwF,GAAA,CAAI,WAAWjJ,MAAM;EAC/C,IAAIA,MAAA,CAAOwD,KAAA,IAAS,CAACxD,MAAA,CAAOmC,QAAA,EAAU;IACpCnC,MAAA,CAAOmC,QAAA,GACLnC,MAAA,CAAOmC,QAAA,KACN,CAACb,GAAA,EAAK4H,OAAA,EAASC,KAAA,KAAU;MACxB1F,OAAA,CAAQD,KAAA,CAAM,eAAelC,GAAG,KAAK4H,OAAO,OAAOC,KAAK,EAAE;IAC5D;IAEF,IAAI,CAACC,mBAAA,EAAqB;MACxB3F,OAAA,CAAQD,KAAA,CACN,qLACF;IACF;EACF;EACA,OAAOxD,MAAA;AACT;;;AElEA,OAAOqJ,QAAA,MAA0B;AAGjC,eAAeC,cAActJ,MAAA,EAAiB;EAC5CA,MAAA,GAAS8I,cAAA,CAAe9I,MAAM;EAE9B,IAAIA,MAAA,CAAOwD,KAAA,EAAOC,OAAA,CAAQD,KAAA,CAAM,kBAAkB;EAClD,MAAMP,KAAA,GAAQjD,MAAA,CAAOiD,KAAA;EACrB,MAAMnI,IAAA,GAAO,MAAMyG,UAAA,CAAW,WAAW0B,KAAK,IAAIjD,MAAM;EACxD,MAAMuJ,WAAA,GAAc,MAAMzO,IAAA,CAAKyO,WAAA,CAAY;EAC3C,MAAMlF,OAAA,GAAU,MAAMrB,iBAAA,CAAkBuG,WAAA,EAAavJ,MAAM;EAC3D,OAAO;IAAEA,MAAA;IAAQqE;EAAQ;AAC3B;AAEA,eAAemF,aACbjO,WAAA,EACAyE,MAAA,EACAqE,OAAA,EAC8B;EAC9B,IAAIrE,MAAA,CAAOmC,QAAA,EAAUnC,MAAA,CAAOmC,QAAA,CAAS,qBAAqB,GAAG,CAAC;EAC9D,MAAMsH,UAAA,GAAa;EACnB,MAAM,CAACpM,SAAA,EAAWC,QAAA,EAAUC,WAAW,IAAIhC,WAAA,CAAYI,KAAA;EAEvD,IAAI+N,WAAA,GAAcxM,oBAAA,CAAqB3B,WAAA,EAAakO,UAAA,EAAYA,UAAU;EAC1E,MAAME,WAAA,GAAcvK,eAAA,CAAgBsK,WAAW;EAG/C,MAAME,eAAA,GAAkB,MAAMnF,cAAA,CAC5BJ,OAAA,EACA,CAAC,CAAC,SAASsF,WAAW,CAAC,GACvB,CAAC,QAAQ,CACX;EAEA,IAAIE,SAAA,GAAYR,QAAA,CAAQO,eAAA,CAAgB,CAAC,EAAEzO,IAAA,EAAM,CAACsO,UAAA,EAAYA,UAAA,EAAY,CAAC,CAAC;EAC5EI,SAAA,GAAYvJ,qBAAA,CAAsBuJ,SAAS;EAC3CA,SAAA,GAAY3M,oBAAA,CAAqB2M,SAAA,EAAWvM,QAAA,EAAUD,SAAS;EAE/D,IAAI2C,MAAA,CAAOmC,QAAA,EAAUnC,MAAA,CAAOmC,QAAA,CAAS,qBAAqB,GAAG,CAAC;EAC9D,OAAO0H,SAAA;AACT;;;AT9CA,IAAOC,WAAA,GAAQC,gBAAA;AAYf,IAAMC,IAAA,GAAOvP,OAAA,CAAQ6O,aAAA,EAAgBtJ,MAAA,IAAWiK,IAAA,CAAKC,SAAA,CAAUlK,MAAM,CAAC;AAEtE,eAAemK,SAAQpB,aAAA,EAAuC;EAC5D,MAAM/I,MAAA,GAAS8I,cAAA,CAAeC,aAAa;EAC3C,MAAMpI,OAAA,CAAiBX,MAAM;EAC7B;AACF;AASA,eAAe+J,iBACbhK,KAAA,EACAgJ,aAAA,EACe;EACf,MAAM;IAAE/I,MAAA;IAAQqE;EAAQ,IAAI,MAAM2F,IAAA,CAAKjB,aAAa;EAEpD,MAAMxN,WAAA,GAAc,MAAYuE,sBAAA,CAAuBC,KAAA,EAAOC,MAAM;EACpE,MAAM,CAAC3E,KAAA,EAAOD,MAAA,EAAQM,QAAQ,IAAIH,WAAA,CAAYI,KAAA;EAE9C,MAAMkO,SAAA,GAAY,MAAML,YAAA,CAAajO,WAAA,EAAayE,MAAA,EAAQqE,OAAO;EACjE,MAAM7E,MAAA,GAASnE,KAAA,GAAQD,MAAA;EAEvB,MAAMgP,cAAA,GAAiB7O,WAAA;EACvB,SAASoE,CAAA,GAAI,GAAGA,CAAA,GAAIH,MAAA,EAAQG,CAAA,IAAK,GAAG;IAClCyK,cAAA,CAAejP,IAAA,CAAK,IAAIwE,CAAA,GAAI,CAAC,IAAIkK,SAAA,CAAU1O,IAAA,CAAKwE,CAAC;EACnD;EAEA,MAAM0K,QAAA,GAAW,MAAY/O,WAAA,CAC3B8O,cAAA,EACApK,MAAA,CAAOkF,MAAA,CAAO1J,OAAA,EACdwE,MAAA,CAAOkF,MAAA,CAAOzJ,MAChB;EAEA,OAAO4O,QAAA;AACT;AASA,eAAeC,iBACbvK,KAAA,EACAgJ,aAAA,EACe;EACf,MAAM;IAAE/I,MAAA;IAAQqE;EAAQ,IAAI,MAAM2F,IAAA,CAAKjB,aAAa;EAEpD,MAAMxN,WAAA,GAAc,MAAYuE,sBAAA,CAAuBC,KAAA,EAAOC,MAAM;EACpE,MAAM,CAAC3E,KAAA,EAAOD,MAAA,EAAQM,QAAQ,IAAIH,WAAA,CAAYI,KAAA;EAE9C,MAAMkO,SAAA,GAAY,MAAML,YAAA,CAAajO,WAAA,EAAayE,MAAA,EAAQqE,OAAO;EACjE,MAAM7E,MAAA,GAASnE,KAAA,GAAQD,MAAA;EACvB,MAAMgP,cAAA,GAAiB7O,WAAA;EACvB,SAASoE,CAAA,GAAI,GAAGA,CAAA,GAAIH,MAAA,EAAQG,CAAA,IAAK,GAAG;IAClCyK,cAAA,CAAejP,IAAA,CAAK,IAAIwE,CAAA,GAAI,CAAC,IAAI,MAAMkK,SAAA,CAAU1O,IAAA,CAAKwE,CAAC;EACzD;EAEA,MAAM0K,QAAA,GAAW,MAAY/O,WAAA,CAC3B8O,cAAA,EACApK,MAAA,CAAOkF,MAAA,CAAO1J,OAAA,EACdwE,MAAA,CAAOkF,MAAA,CAAOzJ,MAChB;EAEA,OAAO4O,QAAA;AACT;AASA,eAAeE,kBACbxK,KAAA,EACAgJ,aAAA,EACe;EACf,MAAM;IAAE/I,MAAA;IAAQqE;EAAQ,IAAI,MAAM2F,IAAA,CAAKjB,aAAa;EAEpD,MAAMxN,WAAA,GAAc,MAAYuE,sBAAA,CAAuBC,KAAA,EAAOC,MAAM;EACpE,MAAM,CAAC5E,MAAA,EAAQC,KAAA,EAAOK,QAAQ,IAAIH,WAAA,CAAYI,KAAA;EAE9C,MAAMkO,SAAA,GAAY,MAAML,YAAA,CAAajO,WAAA,EAAayE,MAAA,EAAQqE,OAAO;EACjE,MAAM7E,MAAA,GAASnE,KAAA,GAAQD,MAAA;EAEvB,IAAI4E,MAAA,CAAOkF,MAAA,CAAOzJ,MAAA,KAAW,kBAAkB;IAC7C,MAAM4O,QAAA,GAAW,MAAY/O,WAAA,CAC3BuO,SAAA,EACA7J,MAAA,CAAOkF,MAAA,CAAO1J,OAAA,EACdwE,MAAA,CAAOkF,MAAA,CAAOzJ,MAChB;IACA,OAAO4O,QAAA;EACT,OAAO;IACL,MAAMD,cAAA,GAAiB1P,QAAA,CAAQ,IAAIiD,UAAA,CAAWjC,QAAA,GAAW8D,MAAM,GAAG,CAChEpE,MAAA,EACAC,KAAA,EACAK,QAAA,CACD;IACD,SAASiE,CAAA,GAAI,GAAGA,CAAA,GAAIH,MAAA,EAAQG,CAAA,IAAK,GAAG;MAClC,MAAM6K,KAAA,GAAQ,IAAI7K,CAAA,GAAI;MACtByK,cAAA,CAAejP,IAAA,CAAKqP,KAAK,IAAIX,SAAA,CAAU1O,IAAA,CAAKwE,CAAC;MAC7CyK,cAAA,CAAejP,IAAA,CAAKqP,KAAA,GAAQ,CAAC,IAAIX,SAAA,CAAU1O,IAAA,CAAKwE,CAAC;MACjDyK,cAAA,CAAejP,IAAA,CAAKqP,KAAA,GAAQ,CAAC,IAAIX,SAAA,CAAU1O,IAAA,CAAKwE,CAAC;MACjDyK,cAAA,CAAejP,IAAA,CAAKqP,KAAA,GAAQ,CAAC,IAAI;IACnC;IAEA,MAAMH,QAAA,GAAW,MAAY/O,WAAA,CAC3B8O,cAAA,EACApK,MAAA,CAAOkF,MAAA,CAAO1J,OAAA,EACdwE,MAAA,CAAOkF,MAAA,CAAOzJ,MAChB;IAEA,OAAO4O,QAAA;EACT;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}