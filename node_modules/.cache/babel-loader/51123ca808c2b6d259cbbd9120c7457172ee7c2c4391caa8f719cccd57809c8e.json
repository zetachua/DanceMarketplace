{"ast":null,"code":"/*!\n* ONNX Runtime Web v1.16.3\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n!function (e, t) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define([], t) : \"object\" == typeof exports ? exports.ort = t() : e.ort = t();\n}(self, () => (() => {\n  var __webpack_modules__ = {\n      5716: (e, t, n) => {\n        \"use strict\";\n\n        t.R = void 0;\n        const r = n(6027),\n          o = n(1723);\n        t.R = new class {\n          async init() {}\n          async createSessionHandler(e, t) {\n            const n = new r.Session(t);\n            return await n.loadModel(e), new o.OnnxjsSessionHandler(n);\n          }\n        }();\n      },\n      2818: (e, t, n) => {\n        \"use strict\";\n\n        t.c8 = t.rX = void 0;\n        const r = n(2235),\n          o = n(5381),\n          i = n(9544),\n          a = n(6640);\n        t.rX = () => {\n          if ((\"number\" != typeof r.env.wasm.initTimeout || r.env.wasm.initTimeout < 0) && (r.env.wasm.initTimeout = 0), \"boolean\" != typeof r.env.wasm.simd && (r.env.wasm.simd = !0), \"boolean\" != typeof r.env.wasm.proxy && (r.env.wasm.proxy = !1), \"number\" != typeof r.env.wasm.numThreads || !Number.isInteger(r.env.wasm.numThreads) || r.env.wasm.numThreads <= 0) {\n            const e = \"undefined\" == typeof navigator ? (0, o.cpus)().length : navigator.hardwareConcurrency;\n            r.env.wasm.numThreads = Math.min(4, Math.ceil((e || 1) / 2));\n          }\n        }, t.c8 = new class {\n          async init() {\n            (0, t.rX)(), await (0, i.initializeWebAssemblyInstance)();\n          }\n          async createSessionHandler(e, t) {\n            const n = new a.OnnxruntimeWebAssemblySessionHandler();\n            return await n.loadModel(e, t), Promise.resolve(n);\n          }\n        }();\n      },\n      1057: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__createBinding || (Object.create ? function (e, t, n, r) {\n            void 0 === r && (r = n);\n            var o = Object.getOwnPropertyDescriptor(t, n);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[n];\n              }\n            }), Object.defineProperty(e, r, o);\n          } : function (e, t, n, r) {\n            void 0 === r && (r = n), e[r] = t[n];\n          }),\n          o = this && this.__exportStar || function (e, t) {\n            for (var n in e) \"default\" === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), o(n(2235), t);\n        const i = n(2235),\n          a = n(8408);\n        {\n          const e = n(5716).R;\n          (0, i.registerBackend)(\"webgl\", e, -10);\n        }\n        {\n          const e = n(2818).c8;\n          (0, i.registerBackend)(\"cpu\", e, 10), (0, i.registerBackend)(\"wasm\", e, 10), (0, i.registerBackend)(\"xnnpack\", e, 9), (0, i.registerBackend)(\"webnn\", e, 9);\n        }\n        i.env.versions.web = a.version;\n      },\n      4910: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.createAttributeWithCacheKey = void 0;\n        class n {\n          constructor(e) {\n            Object.assign(this, e);\n          }\n          get cacheKey() {\n            return this._cacheKey || (this._cacheKey = Object.getOwnPropertyNames(this).sort().map(e => `${this[e]}`).join(\";\")), this._cacheKey;\n          }\n        }\n        t.createAttributeWithCacheKey = e => new n(e);\n      },\n      6874: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Attribute = void 0;\n        const r = n(5127),\n          o = n(2446),\n          i = n(9240),\n          a = n(7273);\n        var s = r.onnxruntime.experimental.fbs;\n        class u {\n          constructor(e) {\n            if (this._attributes = new Map(), null != e) {\n              for (const t of e) t instanceof o.onnx.AttributeProto ? this._attributes.set(t.name, [u.getValue(t), u.getType(t)]) : t instanceof s.Attribute && this._attributes.set(t.name(), [u.getValue(t), u.getType(t)]);\n              if (this._attributes.size < e.length) throw new Error(\"duplicated attribute names\");\n            }\n          }\n          set(e, t, n) {\n            this._attributes.set(e, [n, t]);\n          }\n          delete(e) {\n            this._attributes.delete(e);\n          }\n          getFloat(e, t) {\n            return this.get(e, \"float\", t);\n          }\n          getInt(e, t) {\n            return this.get(e, \"int\", t);\n          }\n          getString(e, t) {\n            return this.get(e, \"string\", t);\n          }\n          getTensor(e, t) {\n            return this.get(e, \"tensor\", t);\n          }\n          getFloats(e, t) {\n            return this.get(e, \"floats\", t);\n          }\n          getInts(e, t) {\n            return this.get(e, \"ints\", t);\n          }\n          getStrings(e, t) {\n            return this.get(e, \"strings\", t);\n          }\n          getTensors(e, t) {\n            return this.get(e, \"tensors\", t);\n          }\n          get(e, t, n) {\n            const r = this._attributes.get(e);\n            if (void 0 === r) {\n              if (void 0 !== n) return n;\n              throw new Error(`required attribute not found: ${e}`);\n            }\n            if (r[1] !== t) throw new Error(`type mismatch: expected ${t} but got ${r[1]}`);\n            return r[0];\n          }\n          static getType(e) {\n            const t = e instanceof o.onnx.AttributeProto ? e.type : e.type();\n            switch (t) {\n              case o.onnx.AttributeProto.AttributeType.FLOAT:\n                return \"float\";\n              case o.onnx.AttributeProto.AttributeType.INT:\n                return \"int\";\n              case o.onnx.AttributeProto.AttributeType.STRING:\n                return \"string\";\n              case o.onnx.AttributeProto.AttributeType.TENSOR:\n                return \"tensor\";\n              case o.onnx.AttributeProto.AttributeType.FLOATS:\n                return \"floats\";\n              case o.onnx.AttributeProto.AttributeType.INTS:\n                return \"ints\";\n              case o.onnx.AttributeProto.AttributeType.STRINGS:\n                return \"strings\";\n              case o.onnx.AttributeProto.AttributeType.TENSORS:\n                return \"tensors\";\n              default:\n                throw new Error(`attribute type is not supported yet: ${o.onnx.AttributeProto.AttributeType[t]}`);\n            }\n          }\n          static getValue(e) {\n            const t = e instanceof o.onnx.AttributeProto ? e.type : e.type();\n            if (t === o.onnx.AttributeProto.AttributeType.GRAPH || t === o.onnx.AttributeProto.AttributeType.GRAPHS) throw new Error(\"graph attribute is not supported yet\");\n            const n = this.getValueNoCheck(e);\n            if (t === o.onnx.AttributeProto.AttributeType.INT && a.LongUtil.isLong(n)) return a.LongUtil.longToNumber(n);\n            if (t === o.onnx.AttributeProto.AttributeType.INTS) {\n              const e = n,\n                t = new Array(e.length);\n              for (let n = 0; n < e.length; n++) {\n                const r = e[n];\n                t[n] = a.LongUtil.longToNumber(r);\n              }\n              return t;\n            }\n            if (t === o.onnx.AttributeProto.AttributeType.TENSOR) return e instanceof o.onnx.AttributeProto ? i.Tensor.fromProto(n) : i.Tensor.fromOrtTensor(n);\n            if (t === o.onnx.AttributeProto.AttributeType.TENSORS) {\n              if (e instanceof o.onnx.AttributeProto) return n.map(e => i.Tensor.fromProto(e));\n              if (e instanceof s.Attribute) return n.map(e => i.Tensor.fromOrtTensor(e));\n            }\n            if (t === o.onnx.AttributeProto.AttributeType.STRING && e instanceof o.onnx.AttributeProto) {\n              const e = n;\n              return (0, a.decodeUtf8String)(e);\n            }\n            return t === o.onnx.AttributeProto.AttributeType.STRINGS && e instanceof o.onnx.AttributeProto ? n.map(a.decodeUtf8String) : n;\n          }\n          static getValueNoCheck(e) {\n            return e instanceof o.onnx.AttributeProto ? this.getValueNoCheckFromOnnxFormat(e) : this.getValueNoCheckFromOrtFormat(e);\n          }\n          static getValueNoCheckFromOnnxFormat(e) {\n            switch (e.type) {\n              case o.onnx.AttributeProto.AttributeType.FLOAT:\n                return e.f;\n              case o.onnx.AttributeProto.AttributeType.INT:\n                return e.i;\n              case o.onnx.AttributeProto.AttributeType.STRING:\n                return e.s;\n              case o.onnx.AttributeProto.AttributeType.TENSOR:\n                return e.t;\n              case o.onnx.AttributeProto.AttributeType.GRAPH:\n                return e.g;\n              case o.onnx.AttributeProto.AttributeType.FLOATS:\n                return e.floats;\n              case o.onnx.AttributeProto.AttributeType.INTS:\n                return e.ints;\n              case o.onnx.AttributeProto.AttributeType.STRINGS:\n                return e.strings;\n              case o.onnx.AttributeProto.AttributeType.TENSORS:\n                return e.tensors;\n              case o.onnx.AttributeProto.AttributeType.GRAPHS:\n                return e.graphs;\n              default:\n                throw new Error(`unsupported attribute type: ${o.onnx.AttributeProto.AttributeType[e.type]}`);\n            }\n          }\n          static getValueNoCheckFromOrtFormat(e) {\n            switch (e.type()) {\n              case s.AttributeType.FLOAT:\n                return e.f();\n              case s.AttributeType.INT:\n                return e.i();\n              case s.AttributeType.STRING:\n                return e.s();\n              case s.AttributeType.TENSOR:\n                return e.t();\n              case s.AttributeType.GRAPH:\n                return e.g();\n              case s.AttributeType.FLOATS:\n                return e.floatsArray();\n              case s.AttributeType.INTS:\n                {\n                  const t = [];\n                  for (let n = 0; n < e.intsLength(); n++) t.push(e.ints(n));\n                  return t;\n                }\n              case s.AttributeType.STRINGS:\n                {\n                  const t = [];\n                  for (let n = 0; n < e.stringsLength(); n++) t.push(e.strings(n));\n                  return t;\n                }\n              case s.AttributeType.TENSORS:\n                {\n                  const t = [];\n                  for (let n = 0; n < e.tensorsLength(); n++) t.push(e.tensors(n));\n                  return t;\n                }\n              default:\n                throw new Error(`unsupported attribute type: ${s.AttributeType[e.type()]}`);\n            }\n          }\n        }\n        t.Attribute = u;\n      },\n      1975: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.resolveBackend = t.backend = void 0;\n        const r = n(4418),\n          o = new Map();\n        async function i(e) {\n          const n = t.backend;\n          if (void 0 !== n[e] && function (e) {\n            const t = e;\n            return \"initialize\" in t && \"function\" == typeof t.initialize && \"createSessionHandler\" in t && \"function\" == typeof t.createSessionHandler && \"dispose\" in t && \"function\" == typeof t.dispose;\n          }(n[e])) {\n            const t = n[e];\n            let r = t.initialize();\n            if (\"object\" == typeof r && \"then\" in r && (r = await r), r) return o.set(e, t), t;\n          }\n        }\n        t.backend = {\n          webgl: new r.WebGLBackend()\n        }, t.resolveBackend = async function e(t) {\n          if (!t) return e([\"webgl\"]);\n          {\n            const e = \"string\" == typeof t ? [t] : t;\n            for (const t of e) {\n              const e = o.get(t);\n              if (e) return e;\n              const n = await i(t);\n              if (n) return n;\n            }\n          }\n          throw new Error(\"no available backend to use\");\n        };\n      },\n      4418: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.WebGLBackend = void 0;\n        const r = n(2235),\n          o = n(1315),\n          i = n(2171),\n          a = n(3389);\n        t.WebGLBackend = class {\n          get contextId() {\n            return r.env.webgl.contextId;\n          }\n          set contextId(e) {\n            r.env.webgl.contextId = e;\n          }\n          get matmulMaxBatchSize() {\n            return r.env.webgl.matmulMaxBatchSize;\n          }\n          set matmulMaxBatchSize(e) {\n            r.env.webgl.matmulMaxBatchSize = e;\n          }\n          get textureCacheMode() {\n            return r.env.webgl.textureCacheMode;\n          }\n          set textureCacheMode(e) {\n            r.env.webgl.textureCacheMode = e;\n          }\n          get pack() {\n            return r.env.webgl.pack;\n          }\n          set pack(e) {\n            r.env.webgl.pack = e;\n          }\n          get async() {\n            return r.env.webgl.async;\n          }\n          set async(e) {\n            r.env.webgl.async = e;\n          }\n          initialize() {\n            try {\n              return this.glContext = (0, a.createWebGLContext)(this.contextId), \"number\" != typeof this.matmulMaxBatchSize && (this.matmulMaxBatchSize = 16), \"string\" != typeof this.textureCacheMode && (this.textureCacheMode = \"full\"), \"boolean\" != typeof this.pack && (this.pack = !1), \"boolean\" != typeof this.async && (this.async = !1), o.Logger.setWithEnv(r.env), o.Logger.verbose(\"WebGLBackend\", `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`), !0;\n            } catch (e) {\n              return o.Logger.warning(\"WebGLBackend\", `Unable to initialize WebGLBackend. ${e}`), !1;\n            }\n          }\n          createSessionHandler(e) {\n            return new i.WebGLSessionHandler(this, e);\n          }\n          dispose() {\n            this.glContext.dispose();\n          }\n        };\n      },\n      6859: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.CoordsGlslLib = void 0;\n        const r = n(7273),\n          o = n(1997),\n          i = n(6757),\n          a = n(7618),\n          s = n(432);\n        class u extends o.GlslLib {\n          constructor(e) {\n            super(e);\n          }\n          getFunctions() {\n            return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.offsetToCoords()), this.coordsToOffset()), this.toVec()), this.valueFrom()), this.getCommonUtilFuncs()), this.getInputsSamplingSnippets()), this.getOutputSamplingSnippet());\n          }\n          getCustomTypes() {\n            return {};\n          }\n          offsetToCoords() {\n            return {\n              offsetToCoords: new o.GlslLibRoutine(\"\\n      vec2 offsetToCoords(int offset, int width, int height) {\\n        int t = offset / width;\\n        int s = offset - t*width;\\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\\n        return coords;\\n      }\\n      \")\n            };\n          }\n          coordsToOffset() {\n            return {\n              coordsToOffset: new o.GlslLibRoutine(\"\\n      int coordsToOffset(vec2 coords, int width, int height) {\\n        float s = coords.s * float(width);\\n        float t = coords.t * float(height);\\n        int offset = int(t) * width + int(s);\\n        return offset;\\n      }\\n      \")\n            };\n          }\n          getOutputSamplingSnippet() {\n            const e = this.context.outputTextureLayout;\n            return e.isPacked ? this.getPackedOutputSamplingSnippet(e) : this.getUnpackedOutputSamplingSnippet(e);\n          }\n          getPackedOutputSamplingSnippet(e) {\n            const t = e.unpackedShape,\n              n = [e.width, e.height],\n              r = {},\n              a = \"getOutputCoords\";\n            switch (t.length) {\n              case 0:\n                r[a] = this.getOutputScalarCoords();\n                break;\n              case 1:\n                r[a] = this.getOutputPacked1DCoords(t, n);\n                break;\n              case 2:\n                r[a] = this.getOutputPacked2DCoords(t, n);\n                break;\n              case 3:\n                r[a] = this.getOutputPacked3DCoords(t, n);\n                break;\n              default:\n                r[a] = this.getOutputPackedNDCoords(t, n);\n            }\n            const s = `\\n      void setOutput(vec4 val) {\\n        ${(0, i.getGlsl)(this.context.glContext.version).output} = val;\\n      }\\n    `;\n            return r.floatTextureSetRGBA = new o.GlslLibRoutine(s), r;\n          }\n          getUnpackedOutputSamplingSnippet(e) {\n            const t = e.unpackedShape,\n              n = [e.width, e.height],\n              r = {},\n              a = \"getOutputCoords\";\n            switch (t.length) {\n              case 0:\n                r[a] = this.getOutputScalarCoords();\n                break;\n              case 1:\n                r[a] = this.getOutputUnpacked1DCoords(t, n);\n                break;\n              case 2:\n                r[a] = this.getOutputUnpacked2DCoords(t, n);\n                break;\n              case 3:\n                r[a] = this.getOutputUnpacked3DCoords(t, n);\n                break;\n              case 4:\n                r[a] = this.getOutputUnpacked4DCoords(t, n);\n                break;\n              case 5:\n                r[a] = this.getOutputUnpacked5DCoords(t, n);\n                break;\n              case 6:\n                r[a] = this.getOutputUnpacked6DCoords(t, n);\n                break;\n              default:\n                throw new Error(`Unsupported output dimensionality: ${t.length}`);\n            }\n            const s = `\\n        void setOutput(float val) {\\n          ${(0, i.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);\\n        }\\n    `;\n            return r.floatTextureSetR = new o.GlslLibRoutine(s), r;\n          }\n          getOutputScalarCoords() {\n            return new o.GlslLibRoutine(\"\\n      int getOutputCoords() {\\n        return 0;\\n      }\\n    \");\n          }\n          getOutputPacked1DCoords(e, t) {\n            const n = t;\n            let r = \"\";\n            return 1 === n[0] ? (r = `\\n          int getOutputCoords() {\\n            return 2 * int(TexCoords.y * ${n[1]}.0);\\n          }\\n        `, new o.GlslLibRoutine(r)) : 1 === n[1] ? (r = `\\n          int getOutputCoords() {\\n            return 2 * int(TexCoords.x * ${n[0]}.0);\\n          }\\n        `, new o.GlslLibRoutine(r)) : (r = `\\n        int getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                 vec2(${n[0]}, ${n[1]}));\\n          return 2 * (resTexRC.y * ${n[0]} + resTexRC.x);\\n        }\\n      `, new o.GlslLibRoutine(r));\n          }\n          getOutputPacked2DCoords(e, t) {\n            let n = \"\";\n            if (r.ArrayUtil.arraysEqual(e, t)) return n = `\\n        ivec2 getOutputCoords() {\\n          return 2 * ivec2(TexCoords.xy * vec2(${t[0]}, ${t[1]}));\\n        }\\n      `, new o.GlslLibRoutine(n);\n            const i = t,\n              a = Math.ceil(e[1] / 2);\n            return n = `\\n        ivec2 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${i[0]}, ${i[1]}));\\n\\n          int index = resTexRC.y * ${i[0]} + resTexRC.x;\\n\\n          // reverse r and c order for packed texture\\n          int r = imod(index, ${a}) * 2;\\n          int c = 2 * (index / ${a});\\n\\n          return ivec2(r, c);\\n        }\\n      `, new o.GlslLibRoutine(n);\n          }\n          getOutputPacked3DCoords(e, t) {\n            const n = [t[0], t[1]],\n              r = Math.ceil(e[2] / 2),\n              i = r * Math.ceil(e[1] / 2),\n              a = `\\n        ivec3 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${n[0]}, ${n[1]}));\\n          int index = resTexRC.y * ${n[0]} + resTexRC.x;\\n\\n          int b = index / ${i};\\n          index -= b * ${i};\\n\\n          // reverse r and c order for packed texture\\n          int r = imod(index, ${r}) * 2;\\n          int c = 2 * (index / ${r});\\n\\n          return ivec3(b, r, c);\\n        }\\n      `;\n            return new o.GlslLibRoutine(a);\n          }\n          getOutputPackedNDCoords(e, t) {\n            const n = [t[0], t[1]],\n              r = Math.ceil(e[e.length - 1] / 2),\n              i = r * Math.ceil(e[e.length - 2] / 2);\n            let a = i,\n              s = \"\",\n              u = \"b, r, c\";\n            for (let t = 2; t < e.length - 1; t++) a *= e[e.length - t - 1], s = `\\n      int b${t} = index / ${a};\\n      index -= b${t} * ${a};\\n    ` + s, u = `b${t}, ` + u;\n            const l = `\\n      ivec${e.length} getOutputCoords() {\\n        ivec2 resTexRC = ivec2(TexCoords.xy *\\n                              vec2(${n[0]}, ${n[1]}));\\n        int index = resTexRC.y * ${n[0]} + resTexRC.x;\\n\\n        ${s}\\n\\n        int b = index / ${i};\\n        index -= b * ${i};\\n\\n        // reverse r and c order for packed texture\\n        int r = imod(index, ${r}) * 2;\\n        int c = 2 * (index / ${r});\\n\\n        return ivec${e.length}(${u});\\n      }\\n    `;\n            return new o.GlslLibRoutine(l);\n          }\n          getOutputUnpacked1DCoords(e, t) {\n            const n = `\\n        int getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${t[0]}, ${t[1]}));\\n          return resTexRC.y * ${t[0]} + resTexRC.x;\\n        }\\n      `;\n            return new o.GlslLibRoutine(n);\n          }\n          getOutputUnpacked2DCoords(e, t) {\n            const n = `\\n        ivec2 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${t[0]}, ${t[1]}));\\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\\n          int r = index / ${e[1]};\\n          int c = index - r * ${e[1]};\\n          return ivec2(r, c);\\n        }\\n      `;\n            return new o.GlslLibRoutine(n);\n          }\n          getOutputUnpacked3DCoords(e, t) {\n            let n = \"\";\n            const r = e.length;\n            let i = null;\n            r < 2 && (i = []), i = new Array(r - 1), i[r - 2] = e[r - 1];\n            for (let t = r - 3; t >= 0; --t) i[t] = i[t + 1] * e[t + 1];\n            const a = [\"r\", \"c\", \"d\"],\n              s = i.map((e, t) => `int ${a[t]} = index / ${e}; ${t === i.length - 1 ? `int ${a[t + 1]} = index - ${a[t]} * ${e}` : `index -= ${a[t]} * ${e}`};`).join(\"\");\n            return n = `\\n        ivec3 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${t[0]}, ${t[1]}));\\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\\n          ${s}\\n          return ivec3(r, c, d);\\n        }\\n      `, new o.GlslLibRoutine(n);\n          }\n          getOutputUnpacked4DCoords(e, t) {\n            let n = \"\";\n            const r = e.length;\n            let i = null;\n            r < 2 && (i = []), i = new Array(r - 1), i[r - 2] = e[r - 1];\n            for (let t = r - 3; t >= 0; --t) i[t] = i[t + 1] * e[t + 1];\n            const a = [\"r\", \"c\", \"d\", \"d2\"],\n              s = i.map((e, t) => `int ${a[t]} = index / ${e}; ${t === i.length - 1 ? `int ${a[t + 1]} = index - ${a[t]} * ${e}` : `index -= ${a[t]} * ${e}`};`).join(\"\");\n            return n = `\\n      ivec4 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${t[0]}, ${t[1]}));\\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\\n          ${s}\\n          return ivec4(r, c, d, d2);\\n        }\\n      `, new o.GlslLibRoutine(n);\n          }\n          getOutputUnpacked5DCoords(e, t) {\n            let n = \"\";\n            const r = e.length;\n            let i = null;\n            r < 2 && (i = []), i = new Array(r - 1), i[r - 2] = e[r - 1];\n            for (let t = r - 3; t >= 0; --t) i[t] = i[t + 1] * e[t + 1];\n            const a = [\"r\", \"c\", \"d\", \"d2\", \"d3\"],\n              s = i.map((e, t) => `int ${a[t]} = index / ${e}; ${t === i.length - 1 ? `int ${a[t + 1]} = index - ${a[t]} * ${e}` : `index -= ${a[t]} * ${e}`};`).join(\"\");\n            return n = `\\n      ivec5 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${t[0]}, ${t[1]}));\\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\\n          ${s}\\n          return ivec5(r, c, d, d2, d3);\\n        }\\n      `, new o.GlslLibRoutine(n);\n          }\n          getOutputUnpacked6DCoords(e, t) {\n            let n = \"\";\n            const r = e.length;\n            let i = null;\n            r < 2 && (i = []), i = new Array(r - 1), i[r - 2] = e[r - 1];\n            for (let t = r - 3; t >= 0; --t) i[t] = i[t + 1] * e[t + 1];\n            const a = [\"r\", \"c\", \"d\", \"d2\", \"d3\", \"d4\"],\n              s = i.map((e, t) => `int ${a[t]} = index / ${e}; ${t === i.length - 1 ? `int ${a[t + 1]} = index - ${a[t]} * ${e}` : `index -= ${a[t]} * ${e}`};`).join(\"\");\n            return n = `\\n     ivec6 getOutputCoords() {\\n         ivec2 resTexRC = ivec2(TexCoords.xy *\\n                               vec2(${t[0]}, ${t[1]}));\\n         int index = resTexRC.y * ${t[0]} + resTexRC.x;\\n         ${s}\\n         return ivec6(r, c, d, d2, d3, d4);\\n       }\\n     `, new o.GlslLibRoutine(n);\n          }\n          getCommonUtilFuncs() {\n            const e = {};\n            let t = \"uvFromFlat\";\n            e[t] = new o.GlslLibRoutine(\"\\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\\n      int texC = index / texNumR;\\n      int texR = index - texC * texNumR;\\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\\n      //       v.\\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\\n    }\\n    \"), t = \"packedUVfrom1D\", e[t] = new o.GlslLibRoutine(\"\\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\\n        int texelIndex = index / 2;\\n        int texR = texelIndex / texNumC;\\n        int texC = texelIndex - texR * texNumC;\\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n      }\\n      \"), t = \"packedUVfrom2D\", e[t] = new o.GlslLibRoutine(\"\\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\\n        int texR = texelIndex / texNumC;\\n        int texC = texelIndex - texR * texNumC;\\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n      }\\n      \"), t = \"packedUVfrom3D\", e[t] = new o.GlslLibRoutine(\"\\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\\n          int texelsInBatch, int texelsInLogicalRow, int b,\\n          int row, int col) {\\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\\n        int texR = index / texNumC;\\n        int texC = index - texR * texNumC;\\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n      }\\n      \"), t = \"sampleTexture\";\n            const n = (0, i.getGlsl)(this.context.glContext.version);\n            return e[t] = new o.GlslLibRoutine(`\\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\\n            return ${n.texture2D}(textureSampler, uv).r;\\n        }`), e;\n          }\n          getInputsSamplingSnippets() {\n            const e = {},\n              t = this.context.outputTextureLayout;\n            return this.context.programInfo.inputNames.forEach((n, r) => {\n              const o = this.context.inputTextureLayouts[r],\n                i = (0, s.generateShaderFuncNameFromInputSamplerName)(n);\n              o.isPacked ? e[i] = this.getPackedSamplerFromInput(i, n, o) : e[i] = this.getUnpackedSamplerFromInput(i, n, o);\n              const a = (0, s.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(n);\n              o.unpackedShape.length <= t.unpackedShape.length && (o.isPacked ? e[a] = this.getPackedSamplerAtOutputCoords(a, o, t, n) : e[a] = this.getUnpackedSamplerAtOutputCoords(a, o, t, n));\n            }), e;\n          }\n          getPackedSamplerAtOutputCoords(e, t, n, i) {\n            const a = t.unpackedShape,\n              u = n.unpackedShape,\n              l = i,\n              c = (0, s.generateShaderFuncNameFromInputSamplerName)(l),\n              p = a.length,\n              d = u.length,\n              f = r.BroadcastUtil.getBroadcastDims(a, u),\n              h = (0, s.getCoordsDataType)(d),\n              g = d - p;\n            let b;\n            const m = (0, s.getGlChannels)();\n            b = 0 === p ? \"\" : d < 2 && f.length >= 1 ? \"coords = 0;\" : f.map(e => `coords.${m[e + g]} = 0;`).join(\"\\n\");\n            let y = \"\";\n            y = d < 2 && p > 0 ? \"coords\" : a.map((e, t) => `coords.${m[t + g]}`).join(\", \");\n            let v = \"return outputValue;\";\n            const _ = 1 === r.ShapeUtil.size(a),\n              w = 1 === r.ShapeUtil.size(u);\n            if (1 !== p || _ || w) {\n              if (_ && !w) v = 1 === d ? \"\\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\\n        \" : \"\\n          return vec4(outputValue.x);\\n        \";else if (f.length) {\n                const e = p - 2,\n                  t = p - 1;\n                f.indexOf(e) > -1 && f.indexOf(t) > -1 ? v = \"return vec4(outputValue.x);\" : f.indexOf(e) > -1 ? v = \"return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);\" : f.indexOf(t) > -1 && (v = \"return vec4(outputValue.xx, outputValue.zz);\");\n              }\n            } else v = \"\\n        return vec4(outputValue.xy, outputValue.xy);\\n      \";\n            const T = `\\n      vec4 ${e}() {\\n        ${h} coords = getOutputCoords();\\n        \\n        int lastDim = coords.${m[d - 1]};\\n        coords.${m[d - 1]} = coords.${m[d - 2]};\\n        coords.${m[d - 2]} = lastDim;\\n      \\n        ${b}\\n        vec4 outputValue = ${c}(${y});\\n        ${v}\\n      }\\n    `;\n            return new o.GlslLibRoutine(T, [\"coordinates.getOutputCoords\"]);\n          }\n          getUnpackedSamplerAtOutputCoords(e, t, n, i) {\n            const a = [n.width, n.height],\n              u = [t.width, t.height],\n              l = t.unpackedShape.length,\n              c = n.unpackedShape.length,\n              p = t.unpackedShape,\n              d = n.unpackedShape,\n              f = (0, s.generateShaderFuncNameFromInputSamplerName)(i);\n            if (l === c && r.ArrayUtil.arraysEqual(u, a)) {\n              const t = `\\n          float ${e}() {\\n            return sampleTexture(${i}, TexCoords);\\n          }\\n        `;\n              return new o.GlslLibRoutine(t, [\"coordinates.sampleTexture\"]);\n            }\n            const h = (0, s.getCoordsDataType)(c),\n              g = r.BroadcastUtil.getBroadcastDims(p, d),\n              b = c - l;\n            let m;\n            const y = (0, s.getGlChannels)();\n            m = 0 === l ? \"\" : c < 2 && g.length >= 1 ? \"coords = 0;\" : g.map(e => `coords.${y[e + b]} = 0;`).join(\"\\n\");\n            let v = \"\";\n            v = c < 2 && l > 0 ? \"coords\" : t.unpackedShape.map((e, t) => `coords.${y[t + b]}`).join(\", \");\n            const _ = `\\n        float ${e}() {\\n          ${h} coords = getOutputCoords();\\n          ${m}\\n          return ${f}(${v});\\n        }\\n      `;\n            return new o.GlslLibRoutine(_, [\"coordinates.getOutputCoords\"]);\n          }\n          getPackedSamplerFromInput(e, t, n) {\n            switch (n.unpackedShape.length) {\n              case 0:\n                return this.getPackedSamplerScalar(e, t);\n              case 1:\n                return this.getPackedSampler1D(e, t, n);\n              case 2:\n                return this.getPackedSampler2D(e, t, n);\n              case 3:\n                return this.getPackedSampler3D(e, t, n);\n              default:\n                return this.getPackedSamplerND(e, t, n);\n            }\n          }\n          getUnpackedSamplerFromInput(e, t, n) {\n            const r = n.unpackedShape;\n            switch (r.length) {\n              case 0:\n                return this.getUnpackedSamplerScalar(e, t, n);\n              case 1:\n                return this.getUnpackedSampler1D(e, t, n);\n              case 2:\n                return this.getUnpackedSampler2D(e, t, n);\n              case 3:\n                return this.getUnpackedSampler3D(e, t, n);\n              case 4:\n                return this.getUnpackedSampler4D(e, t, n);\n              case 5:\n                return this.getUnpackedSampler5D(e, t, n);\n              case 6:\n                return this.getUnpackedSampler6D(e, t, n);\n              default:\n                throw new Error(`Unsupported dimension ${r.length}-D`);\n            }\n          }\n          getPackedSamplerScalar(e, t) {\n            const n = `\\n          vec4 ${e}() {\\n            return ${(0, i.getGlsl)(this.context.glContext.version).texture2D}(${t}, halfCR);\\n          }\\n        `;\n            return new o.GlslLibRoutine(n);\n          }\n          getPackedSampler1D(e, t, n) {\n            const r = [n.width, n.height],\n              a = [r[1], r[0]],\n              s = (0, i.getGlsl)(this.context.glContext.version),\n              u = `vec4 ${e}(int index) {\\n      vec2 uv = packedUVfrom1D(\\n      ${a[0]}, ${a[1]}, index);\\n      return ${s.texture2D}(${t}, uv);\\n    }`;\n            return new o.GlslLibRoutine(u, [\"coordinates.packedUVfrom1D\"]);\n          }\n          getPackedSampler2D(e, t, n) {\n            const a = n.unpackedShape,\n              s = [n.width, n.height],\n              u = (0, i.getGlsl)(this.context.glContext.version),\n              l = s[0],\n              c = s[1];\n            if (null != s && r.ArrayUtil.arraysEqual(a, s)) {\n              const n = `vec4 ${e}(int row, int col) {\\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${c}.0, ${l}.0);\\n        return ${u.texture2D}(${t}, uv);\\n      }`;\n              return new o.GlslLibRoutine(n);\n            }\n            const p = s,\n              d = Math.ceil(a[1] / 2),\n              f = `vec4 ${e}(int row, int col) {\\n      vec2 uv = packedUVfrom2D(${p[1]}, ${p[0]}, ${d}, row, col);\\n      return ${u.texture2D}(${t}, uv);\\n    }`;\n            return new o.GlslLibRoutine(f, [\"coordinates.packedUVfrom2D\"]);\n          }\n          getPackedSampler3D(e, t, n) {\n            const r = n.unpackedShape,\n              a = [n.width, n.height],\n              u = [a[0], a[1]],\n              l = (0, i.getGlsl)(this.context.glContext.version);\n            if (1 === r[0]) {\n              const i = r.slice(1),\n                a = [1, 2],\n                u = (0, s.squeezeInputShape)(r, i),\n                l = [\"b\", \"row\", \"col\"],\n                c = JSON.parse(JSON.stringify(n));\n              c.unpackedShape = u;\n              const p = this.getPackedSamplerFromInput(e, t, c),\n                d = `${p.routineBody}\\n      vec4 ${e}(int b, int row, int col) {\\n        return ${e}(${(0, s.getSqueezedParams)(l, a)});\\n      } `;\n              return new o.GlslLibRoutine(d, p.dependencies);\n            }\n            const c = u[0],\n              p = u[1],\n              d = Math.ceil(r[2] / 2),\n              f = `vec4 ${e}(int b, int row, int col) {\\n      vec2 uv = packedUVfrom3D(\\n        ${p}, ${c}, ${d * Math.ceil(r[1] / 2)}, ${d}, b, row, col);\\n      return ${l.texture2D}(${t}, uv);}`;\n            return new o.GlslLibRoutine(f, [\"coordinates.packedUVfrom3D\"]);\n          }\n          getPackedSamplerND(e, t, n) {\n            const r = n.unpackedShape,\n              a = r.length,\n              s = [n.width, n.height],\n              u = (0, i.getGlsl)(this.context.glContext.version),\n              l = [s[0], s[1]],\n              c = l[1],\n              p = l[0],\n              d = Math.ceil(r[a - 1] / 2);\n            let f = d * Math.ceil(r[a - 2] / 2),\n              h = \"int b, int row, int col\",\n              g = `b * ${f} + (row / 2) * ${d} + (col / 2)`;\n            for (let e = 2; e < a - 1; e++) h = `int b${e}, ` + h, f *= r[a - e - 1], g = `b${e} * ${f} + ` + g;\n            const b = `vec4 ${e}(${h}) {\\n      int index = ${g};\\n      int texR = index / ${p};\\n      int texC = index - texR * ${p};\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${c});\\n      return ${u.texture2D}(${t}, uv);\\n    }`;\n            return new o.GlslLibRoutine(b);\n          }\n          getUnpackedSamplerScalar(e, t, n) {\n            const [r, i] = [n.width, n.height];\n            if (1 === r && 1 === i) {\n              const n = `\\n          float ${e}() {\\n            return sampleTexture(${t}, halfCR);\\n          }\\n        `;\n              return new o.GlslLibRoutine(n, [\"coordinates.sampleTexture\"]);\n            }\n            const a = `\\n        float ${e}() {\\n          int offset_${t} = coordsToOffset(TexCoords, ${r}, ${i});\\n          vec2 uv = uvFromFlat(${r}, ${i}, offset_${t});\\n          return sampleTexture(${t}, uv);\\n        }\\n      `;\n            return new o.GlslLibRoutine(a, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n          }\n          getUnpackedSampler1D(e, t, n) {\n            const r = n.width,\n              i = n.height;\n            if (1 === i && 1 === r) {\n              const n = `\\n        float ${e}(int index) {\\n          return sampleTexture(${t}, halfCR);\\n        }\\n      `;\n              return new o.GlslLibRoutine(n, [\"coordinates.sampleTexture\"]);\n            }\n            if (1 === i) {\n              const n = `\\n          float ${e}(int index) {\\n            vec2 uv = vec2((float(index) + 0.5) / ${r}.0, 0.5);\\n            return sampleTexture(${t}, uv);\\n          }\\n        `;\n              return new o.GlslLibRoutine(n, [\"coordinates.sampleTexture\"]);\n            }\n            if (1 === r) {\n              const n = `\\n          float ${e}(int index) {\\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${i}.0);\\n            return sampleTexture(${t}, uv);\\n          }\\n        `;\n              return new o.GlslLibRoutine(n, [\"coordinates.sampleTexture\"]);\n            }\n            const a = `\\n        float ${e}(int index) {\\n          vec2 uv = uvFromFlat(${r}, ${i}, index);\\n          return sampleTexture(${t}, uv);\\n        }\\n      `;\n            return new o.GlslLibRoutine(a, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\"]);\n          }\n          getUnpackedSampler2D(e, t, n) {\n            const i = n.unpackedShape,\n              u = [n.height, n.width];\n            if (null != u && r.ArrayUtil.arraysEqual(i, u)) {\n              const n = `\\n          float ${e}(int row, int col) {\\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${u[1]}.0, ${u[0]}.0);\\n            return sampleTexture(${t}, uv);\\n          }\\n        `;\n              return new o.GlslLibRoutine(n, [\"coordinates.sampleTexture\"]);\n            }\n            const {\n                newShape: l,\n                keptDims: c\n              } = (0, a.squeezeShape)(i),\n              p = l;\n            if (p.length < i.length) {\n              const r = (0, s.squeezeInputShape)(i, p),\n                a = JSON.parse(JSON.stringify(n));\n              a.unpackedShape = r;\n              const u = [\"col\", \"row\"],\n                l = `\\n          ${this.getUnpackedSamplerFromInput(e, t, a).routineBody}\\n          float ${e}(int row, int col) {\\n            return ${e}(${(0, s.getSqueezedParams)(u, c)});\\n          }\\n        `;\n              return new o.GlslLibRoutine(l, [\"coordinates.sampleTexture\"]);\n            }\n            const d = u[1],\n              f = u[0];\n            if (1 === f) {\n              const n = `\\n          float ${e}(int row, int col) {\\n            int offset_${t} = coordsToOffset(TexCoords, ${d}, ${f});\\n            float index = dot(vec3(row, col, offset_${t}), vec3(${i[1]}, 1, 1));\\n            vec2 uv = vec2(0.5, (index + 0.5) / ${d}.0);\\n            return sampleTexture(${t}, uv);\\n          }\\n        `;\n              return new o.GlslLibRoutine(n, [\"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n            }\n            if (1 === d) {\n              const n = `\\n          float ${e}(int row, int col) {\\n            int offset_${t} = coordsToOffset(TexCoords, ${d}, ${f});\\n            float index = dot(vec3(row, col, offset_${t}), vec3(${i[1]}, 1, 1));\\n            vec2 uv = vec2((index + 0.5) / ${f}.0, 0.5);\\n            return sampleTexture(${t}, uv);\\n          }\\n        `;\n              return new o.GlslLibRoutine(n, [\"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n            }\n            const h = `\\n        float ${e}(int row, int col) {\\n          int index = col * ${i[1]} + row;\\n          vec2 uv = uvFromFlat(${d}, ${f}, index);\\n          return sampleTexture(${t}, uv);\\n        }\\n      `;\n            return new o.GlslLibRoutine(h, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n          }\n          getUnpackedSampler3D(e, t, n) {\n            const r = n.unpackedShape,\n              i = r[1] * r[2],\n              u = r[2],\n              {\n                newShape: l,\n                keptDims: c\n              } = (0, a.squeezeShape)(r),\n              p = l;\n            if (p.length < r.length) {\n              const i = (0, s.squeezeInputShape)(r, p),\n                a = [\"batch\", \"col\", \"row\"],\n                u = JSON.parse(JSON.stringify(n));\n              u.unpackedShape = i;\n              const l = this.getUnpackedSamplerFromInput(e, t, u),\n                d = c.reverse(),\n                f = `\\n          ${l.routineBody}\\n          float ${e}(int batch, int row, int col) {\\n            return ${e}(${(0, s.getSqueezedParams)(a, d)});\\n          }\\n        `;\n              return new o.GlslLibRoutine(f, l.dependencies);\n            }\n            const d = `\\n          float ${e}(int depth, int row, int col) {\\n            // Explicitly use integer operations as dot() only works on floats.\\n            int index = depth * ${i} + col * ${u} + row;\\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\\n            return sampleTexture(${t}, uv);\\n          }\\n      `;\n            return new o.GlslLibRoutine(d, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n          }\n          getUnpackedSampler4D(e, t, n) {\n            const r = n.unpackedShape,\n              i = r[3],\n              a = r[2] * i,\n              s = `\\n        float ${e}(int row, int col, int depth, int depth2) {\\n          int index = row * ${r[1] * a} + col * ${a} +\\n              depth2 * ${i} + depth;\\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\\n          return sampleTexture(${t}, uv);\\n        }\\n      `;\n            return new o.GlslLibRoutine(s, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\"]);\n          }\n          getUnpackedSampler5D(e, t, n) {\n            const r = n.unpackedShape,\n              i = r[4],\n              u = r[3] * i,\n              l = r[2] * u,\n              c = r[1] * l,\n              {\n                newShape: p,\n                keptDims: d\n              } = (0, a.squeezeShape)(r);\n            if (p.length < r.length) {\n              const i = (0, s.squeezeInputShape)(r, p),\n                a = [\"row\", \"col\", \"depth\", \"depth2\", \"depth3\"],\n                u = JSON.parse(JSON.stringify(n));\n              u.unpackedShape = i;\n              const l = `\\n          ${this.getUnpackedSamplerFromInput(e, t, u).routineBody}\\n          float ${e}(int row, int col, int depth, int depth2, int depth3) {\\n            return ${e}(${(0, s.getSqueezedParams)(a, d)});\\n          }\\n        `;\n              return new o.GlslLibRoutine(l, [\"coordinates.sampleTexture\", \"coordinates.uvFromFlat\"]);\n            }\n            const f = `\\n        float ${e}(int row, int col, int depth, int depth2, int depth3) {\\n          int index = row * ${c} + col * ${l} + depth * ${u} +\\n          depth3 * ${i} + depth2;\\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\\n          return sampleTexture(${t}, uv);\\n        }\\n      `;\n            return new o.GlslLibRoutine(f, [\"coordinates.sampleTexture\", \"coordinates.uvFromFlat\"]);\n          }\n          getUnpackedSampler6D(e, t, n) {\n            const r = n.unpackedShape,\n              i = r[5],\n              u = r[4] * i,\n              l = r[3] * u,\n              c = r[2] * l,\n              p = r[1] * c,\n              {\n                newShape: d,\n                keptDims: f\n              } = (0, a.squeezeShape)(r);\n            if (d.length < r.length) {\n              const i = (0, s.squeezeInputShape)(r, d),\n                a = [\"row\", \"col\", \"depth\", \"depth2\", \"depth3\", \"depth4\"],\n                u = JSON.parse(JSON.stringify(n));\n              u.unpackedShape = i;\n              const l = `\\n            ${this.getUnpackedSamplerFromInput(e, t, u).routineBody}\\n            float ${e}(int row, int col, int depth,\\n              int depth2, int depth3, int depth4) {\\n              return ${e}(${(0, s.getSqueezedParams)(a, f)});\\n            }\\n          `;\n              return new o.GlslLibRoutine(l, [\"coordinates.sampleTexture\", \"coordinates.uvFromFlat\"]);\n            }\n            const h = `\\n          float ${e}(int row, int col, int depth,\\n            int depth2, int depth3, int depth4) {\\n            int index = row * ${p} + col * ${c} + depth * ${l} +\\n            depth2 * ${u} + depth3 * ${i} + depth4;\\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\\n            return sampleTexture(${t}, uv);\\n          }\\n        `;\n            return new o.GlslLibRoutine(h, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n          }\n          toVec() {\n            const e = this.context.outputTextureLayout,\n              t = e.shape.length,\n              n = e.strides,\n              r = e.width,\n              i = e.height,\n              a = [];\n            for (let e = 0; e < t - 1; ++e) a.push(`\\n        c[${e}] = offset / ${n[e]};`), a.push(`\\n        offset -= c[${e}] * ${n[e]};`);\n            a.push(`\\n        c[${t - 1}] = offset;`);\n            const s = `\\n      void toVec(vec2 texCoords, out int c[${t}]) {\\n        int offset = coordsToOffset(texCoords, ${r}, ${i});\\n        ${a.join(\"\")}\\n      }\\n      void toVec(int offset, out int c[${t}]) {\\n        ${a.join(\"\")}\\n      }\\n    `;\n            return {\n              toVec: new o.GlslLibRoutine(s, [\"coordinates.coordsToOffset\"])\n            };\n          }\n          valueFrom() {\n            const e = {};\n            return this.context.programInfo.inputNames.forEach((t, n) => {\n              const r = this.context.inputTextureLayouts[n],\n                i = (r.unpackedShape.length > 0 ? r.unpackedShape : r.shape).length;\n              let a = `_${t}`;\n              e[a] = new o.GlslLibRoutine(this.getValueFromSingle(t, i, r.width, r.height, !1), [`shapeUtils.indicesToOffset${a}`, \"coordinates.offsetToCoords\", \"fragcolor.getColorAsFloat\"]), a += \"_T\", e[a] = new o.GlslLibRoutine(this.getValueFromSingle(t, i, r.width, r.height, !0), [`shapeUtils.indicesToOffset${a}`, \"coordinates.offsetToCoords\", \"fragcolor.getColorAsFloat\"]);\n            }), e;\n          }\n          getValueFromSingle(e, t, n, r, o) {\n            let a = `_${e}`;\n            return o && (a += \"_T\"), `\\n        float ${a}(int m[${t}]) {\\n          int offset = indicesToOffset${a}(m);\\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\\n          float value = getColorAsFloat(${(0, i.getGlsl)(this.context.glContext.version).texture2D}(${e}, coords));\\n          return value;\\n        }\\n        `;\n          }\n          getPackedValueFrom(e, t, n, r, o) {\n            let a = `_${e}_Pack`;\n            return o && (a += \"_T\"), `\\n        vec4 ${a}(int m[${t}]) {\\n          int offset = indicesToOffset_${e}(m);\\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\\n          return ${(0, i.getGlsl)(this.context.glContext.version).texture2D}(${e}, coords);\\n        }\\n        `;\n          }\n        }\n        t.CoordsGlslLib = u;\n      },\n      1997: (e, t) => {\n        \"use strict\";\n\n        var n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.TopologicalSortGlslRoutines = t.GlslLibRoutineNode = t.GlslLibRoutine = t.GlslLib = t.GlslContext = t.FunctionType = void 0, (n = t.FunctionType || (t.FunctionType = {}))[n.ValueBased = 0] = \"ValueBased\", n[n.Positional = 1] = \"Positional\", t.GlslContext = class {\n          constructor(e, t, n, r) {\n            this.glContext = e, this.programInfo = t, this.inputTextureLayouts = n, this.outputTextureLayout = r;\n          }\n        }, t.GlslLib = class {\n          constructor(e) {\n            this.context = e;\n          }\n        }, t.GlslLibRoutine = class {\n          constructor(e, t) {\n            this.routineBody = e, this.dependencies = t;\n          }\n        }, t.GlslLibRoutineNode = class {\n          constructor(e, t, n) {\n            this.name = e, this.dependencies = n || [], t && (this.routineBody = t);\n          }\n          addDependency(e) {\n            e && this.dependencies.push(e);\n          }\n        }, t.TopologicalSortGlslRoutines = class {\n          static returnOrderedNodes(e) {\n            if (!e || 0 === e.length) return [];\n            if (1 === e.length) return e;\n            const t = new Set(),\n              n = new Set(),\n              r = new Array();\n            return this.createOrderedNodes(e, t, n, r), r;\n          }\n          static createOrderedNodes(e, t, n, r) {\n            for (let o = 0; o < e.length; ++o) this.dfsTraverse(e[o], t, n, r);\n          }\n          static dfsTraverse(e, t, n, r) {\n            if (!e || n.has(e.name)) return;\n            if (t.has(e.name)) throw new Error(\"Cyclic dependency detected. Can't topologically sort routines needed for shader.\");\n            t.add(e.name);\n            const o = e.dependencies;\n            if (o && o.length > 0) for (let e = 0; e < o.length; ++e) this.dfsTraverse(o[e], t, n, r);\n            r.push(e), n.add(e.name), t.delete(e.name);\n          }\n        };\n      },\n      1371: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.EncodingGlslLib = void 0;\n        const r = n(1997);\n        class o extends r.GlslLib {\n          constructor(e) {\n            super(e);\n          }\n          getFunctions() {\n            return Object.assign(Object.assign({}, this.encodeFloat32()), this.decodeFloat32());\n          }\n          getCustomTypes() {\n            return {};\n          }\n          encodeFloat32() {\n            return {\n              encode: new r.GlslLibRoutine(\"highp vec4 encode(highp float f) {\\n        return vec4(f, 0.0, 0.0, 0.0);\\n      }\\n        \")\n            };\n          }\n          decodeFloat32() {\n            return {\n              decode: new r.GlslLibRoutine(\"highp float decode(highp vec4 rgba) {\\n        return rgba.r;\\n      }\\n        \")\n            };\n          }\n          encodeUint8() {\n            const e = o.isLittleEndian() ? \"rgba.rgba=rgba.abgr;\" : \"\";\n            return {\n              encode: new r.GlslLibRoutine(`\\n      highp vec4 encode(highp float f) {\\n        highp float F = abs(f);\\n        highp float Sign = step(0.0,-f);\\n        highp float Exponent = floor(log2(F));\\n        highp float Mantissa = (exp2(- Exponent) * F);\\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\\n        highp vec4 rgba;\\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\\n        ${e}\\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\\n        return rgba;\\n    }\\n        `)\n            };\n          }\n          decodeUint8() {\n            const e = o.isLittleEndian() ? \"rgba.rgba=rgba.abgr;\" : \"\";\n            return {\n              decode: new r.GlslLibRoutine(`\\n        highp float decode(highp vec4 rgba) {\\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\\n          ${e}\\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\\n          return Result;\\n      }\\n        `)\n            };\n          }\n          static isLittleEndian() {\n            const e = new ArrayBuffer(4),\n              t = new Uint32Array(e),\n              n = new Uint8Array(e);\n            if (t[0] = 3735928559, 239 === n[0]) return !0;\n            if (222 === n[0]) return !1;\n            throw new Error(\"unknown endianness\");\n          }\n        }\n        t.EncodingGlslLib = o;\n      },\n      2691: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.FragColorGlslLib = void 0;\n        const r = n(1997),\n          o = n(6757);\n        class i extends r.GlslLib {\n          constructor(e) {\n            super(e);\n          }\n          getFunctions() {\n            return Object.assign(Object.assign({}, this.setFragColor()), this.getColorAsFloat());\n          }\n          getCustomTypes() {\n            return {};\n          }\n          setFragColor() {\n            const e = (0, o.getGlsl)(this.context.glContext.version);\n            return {\n              setFragColor: new r.GlslLibRoutine(`\\n        void setFragColor(float value) {\\n            ${e.output} = encode(value);\\n        }\\n        `, [\"encoding.encode\"])\n            };\n          }\n          getColorAsFloat() {\n            return {\n              getColorAsFloat: new r.GlslLibRoutine(\"\\n        float getColorAsFloat(vec4 color) {\\n            return decode(color);\\n        }\\n        \", [\"encoding.decode\"])\n            };\n          }\n        }\n        t.FragColorGlslLib = i;\n      },\n      3878: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.replaceInlines = void 0;\n        const n = /@inline[\\s\\n\\r]+(\\w+)[\\s\\n\\r]+([0-9a-zA-Z_]+)\\s*\\(([^)]*)\\)\\s*{(([^}]|[\\n\\r])*)}/gm;\n        t.replaceInlines = function (e) {\n          const t = {};\n          let r;\n          for (; null !== (r = n.exec(e));) {\n            const e = r[3].split(\",\").map(e => {\n              const t = e.trim().split(\" \");\n              return t && 2 === t.length ? {\n                type: t[0],\n                name: t[1]\n              } : null;\n            }).filter(e => null !== e);\n            t[r[2]] = {\n              params: e,\n              body: r[4]\n            };\n          }\n          for (const n in t) {\n            const o = \"(\\\\w+)?\\\\s+([_0-9a-zA-Z]+)\\\\s+=\\\\s+__FUNC__\\\\((.*)\\\\)\\\\s*;\".replace(\"__FUNC__\", n),\n              i = new RegExp(o, \"gm\");\n            for (; null !== (r = i.exec(e));) {\n              const o = r[1],\n                i = r[2],\n                a = r[3].split(\",\"),\n                s = o ? `${o} ${i};` : \"\";\n              let u = t[n].body,\n                l = \"\";\n              t[n].params.forEach((e, t) => {\n                e && (l += `${e.type} ${e.name} = ${a[t]};\\n`);\n              }), u = `${l}\\n ${u}`, u = u.replace(\"return\", `${i} = `);\n              const c = `\\n      ${s}\\n      {\\n        ${u}\\n      }\\n      `;\n              e = e.replace(r[0], c);\n            }\n          }\n          return e.replace(n, \"\");\n        };\n      },\n      8897: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.GlslPreprocessor = void 0;\n        const r = n(1997),\n          o = n(3878),\n          i = n(1248),\n          a = n(6757);\n        t.GlslPreprocessor = class {\n          constructor(e, t, n, o) {\n            this.libs = {}, this.glslLibRoutineDependencyGraph = {}, this.context = new r.GlslContext(e, t, n, o), Object.keys(i.glslRegistry).forEach(e => {\n              const t = new i.glslRegistry[e](this.context);\n              this.libs[e] = t;\n            });\n            const a = this.glslLibRoutineDependencyGraph;\n            for (const e in this.libs) {\n              const t = this.libs[e].getFunctions();\n              for (const n in t) {\n                const o = e + \".\" + n;\n                let i;\n                a[o] ? (i = a[o], i.routineBody = t[n].routineBody) : (i = new r.GlslLibRoutineNode(o, t[n].routineBody), a[o] = i);\n                const s = t[n].dependencies;\n                if (s) for (let e = 0; e < s.length; ++e) if (a[s[e]]) i.addDependency(a[s[e]]);else {\n                  const t = new r.GlslLibRoutineNode(s[e]);\n                  a[s[e]] = t, i.addDependency(t);\n                }\n              }\n            }\n          }\n          preprocess() {\n            const e = this.context.programInfo;\n            let t = e.shaderSource;\n            return this.context.programInfo.hasMain || (t = `${t}\\n      ${(0, a.getDefaultFragShaderMain)(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`), t = (0, o.replaceInlines)(t), `${(0, a.getFragShaderPreamble)(this.context.glContext.version)}\\n    ${this.getUniforms(e.inputNames, e.variables)}\\n    ${this.getImports(t)}\\n    ${t}`;\n          }\n          getImports(e) {\n            const t = this.selectGlslLibRoutinesToBeIncluded(e);\n            if (0 === t.length) return \"\";\n            let n = \"\";\n            for (let e = 0; e < t.length; ++e) {\n              if (!t[e].routineBody) throw new Error(`Missing body for the Glsl Library routine: ${t[e].name}`);\n              n += t[e].routineBody + \"\\n\";\n            }\n            return n;\n          }\n          selectGlslLibRoutinesToBeIncluded(e) {\n            const t = [];\n            return Object.keys(this.glslLibRoutineDependencyGraph).forEach(n => {\n              const r = n.split(\".\")[1];\n              -1 !== e.indexOf(r) && t.push(this.glslLibRoutineDependencyGraph[n]);\n            }), r.TopologicalSortGlslRoutines.returnOrderedNodes(t);\n          }\n          getUniforms(e, t) {\n            const n = [];\n            if (e) for (const t of e) n.push(`uniform sampler2D ${t};`);\n            if (t) for (const e of t) n.push(`uniform ${e.type} ${e.name}${e.arrayLength ? `[${e.arrayLength}]` : \"\"};`);\n            return n.join(\"\\n\");\n          }\n        };\n      },\n      1248: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.glslRegistry = void 0;\n        const r = n(6859),\n          o = n(1371),\n          i = n(2691),\n          a = n(9183),\n          s = n(9314);\n        t.glslRegistry = {\n          encoding: o.EncodingGlslLib,\n          fragcolor: i.FragColorGlslLib,\n          vec: s.VecGlslLib,\n          shapeUtils: a.ShapeUtilsGlslLib,\n          coordinates: r.CoordsGlslLib\n        };\n      },\n      9183: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ShapeUtilsGlslLib = void 0;\n        const r = n(1997);\n        class o extends r.GlslLib {\n          constructor(e) {\n            super(e);\n          }\n          getFunctions() {\n            return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.bcastIndex()), this.bcastMatmulIndex()), this.offsetToIndices()), this.indicesToOffset()), this.incrementIndices());\n          }\n          getCustomTypes() {\n            return {};\n          }\n          bcastIndex() {\n            const e = this.context.outputTextureLayout.shape.length,\n              t = {};\n            return this.context.programInfo.inputNames.forEach((n, o) => {\n              const i = this.context.inputTextureLayouts[o].unpackedShape;\n              if (i.length <= e) {\n                const o = i.length,\n                  a = e - o,\n                  s = `bcastIndices_${n}`;\n                let u = \"\";\n                for (let e = 0; e < o; ++e) u += `\\n          realIndices[${e}] = int( mod(float(bcastedIndices[${a + e}]), ${i[e]}.0) );\\n          `;\n                const l = `\\n        void ${s} (int bcastedIndices[${e}], out int realIndices[${o}]) {\\n          ${u}\\n        }\\n        `;\n                t[s] = new r.GlslLibRoutine(l);\n              }\n            }), t;\n          }\n          bcastMatmulIndex() {\n            const e = this.context.outputTextureLayout.shape.length,\n              t = {};\n            return this.context.programInfo.inputNames.forEach((n, o) => {\n              const i = this.context.inputTextureLayouts[o].shape;\n              if (!(i.length < 2 || i.length > e)) {\n                const o = i.length,\n                  a = e - o,\n                  s = `bcastMatmulIndices_${n}`;\n                let u = \"\";\n                for (let e = 0; e < o - 2; ++e) u += `\\n          realIndices[${e}] = int( mod(float(bcastedIndices[${a + e}]), ${i[e]}.0) );\\n          `;\n                const l = `\\n        void ${s}(int bcastedIndices[${e}], out int realIndices[${o}]) {\\n          ${u}\\n          realIndices[${o - 1}] = bcastedIndices[${e - 1}];\\n          realIndices[${o - 2}] = bcastedIndices[${e - 2}];\\n        }\\n        `;\n                t[s] = new r.GlslLibRoutine(l);\n              }\n            }), t;\n          }\n          indicesToOffset() {\n            const e = {};\n            return this.context.programInfo.inputNames.forEach((t, n) => {\n              const i = this.context.inputTextureLayouts[n].shape,\n                a = this.context.inputTextureLayouts[n].strides,\n                s = i.length;\n              let u = `indicesToOffset_${t}`;\n              e[u] = new r.GlslLibRoutine(o.indexToOffsetSingle(u, s, a)), u = `indicesToOffset_${t}_T`, e[u] = new r.GlslLibRoutine(o.indexToOffsetSingle(u, s, a.slice().reverse()));\n            }), e;\n          }\n          static indexToOffsetSingle(e, t, n) {\n            let r = \"\";\n            for (let e = t - 1; e >= 0; --e) r += `\\n        offset += indices[${e}] * ${n[e]};\\n        `;\n            return `\\n      int ${e}(int indices[${t}]) {\\n        int offset = 0;\\n        ${r}\\n        return offset;\\n      }\\n      `;\n          }\n          offsetToIndices() {\n            const e = {};\n            return this.context.programInfo.inputNames.forEach((t, n) => {\n              const i = this.context.inputTextureLayouts[n].shape,\n                a = this.context.inputTextureLayouts[n].strides,\n                s = i.length;\n              let u = `offsetToIndices_${t}`;\n              e[u] = new r.GlslLibRoutine(o.offsetToIndicesSingle(u, s, a)), u = `offsetToIndices_${t}_T`, e[u] = new r.GlslLibRoutine(o.offsetToIndicesSingle(u, s, a.slice().reverse()));\n            }), e;\n          }\n          static offsetToIndicesSingle(e, t, n) {\n            const r = [];\n            for (let e = 0; e < t - 1; ++e) r.push(`\\n      indices[${e}] = offset / ${n[e]};`), r.push(`\\n        offset -= indices[${e}] * ${n[e]};`);\n            return r.push(`\\n      indices[${t - 1}] = offset;`), `\\n      void ${e}(int offset, out int indices[${t}]) {\\n        ${r.join(\"\")}\\n      }\\n      `;\n          }\n          incrementIndices() {\n            const e = {};\n            return this.context.programInfo.inputNames.forEach((t, n) => {\n              const o = this.context.inputTextureLayouts[n].shape,\n                i = o.length,\n                a = `incrementIndices_${t}`;\n              let s = \"\";\n              for (let e = 0; e < i; ++e) s += `\\n        shape[${e}] = ${o[e]};`;\n              const u = `\\n        void ${a}(int axis, out int indices[${i}]) {\\n          int shape[${i}];\\n          ${s};\\n          for(int i = ${i} -1 ; i >= 0; --i) {\\n            if(i > axis) continue;\\n            indices[i] += 1;\\n            if(indices[i] < shape[i]) {\\n              break;\\n            }\\n            indices[i] = 0;\\n          }\\n        }\\n        `;\n              e[a] = new r.GlslLibRoutine(u);\n            }), e;\n          }\n        }\n        t.ShapeUtilsGlslLib = o;\n      },\n      6757: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getDefaultFragShaderMain = t.getFragShaderPreamble = t.getVertexShaderSource = t.getGlsl = void 0;\n        const n = {\n            version: \"\",\n            attribute: \"attribute\",\n            varyingVertex: \"varying\",\n            varyingFrag: \"varying\",\n            texture2D: \"texture2D\",\n            output: \"gl_FragColor\",\n            outputDeclaration: \"\"\n          },\n          r = {\n            version: \"#version 300 es\",\n            attribute: \"in\",\n            varyingVertex: \"out\",\n            varyingFrag: \"in\",\n            texture2D: \"texture\",\n            output: \"outputColor\",\n            outputDeclaration: \"out vec4 outputColor;\"\n          };\n        function o(e) {\n          return 1 === e ? n : r;\n        }\n        t.getGlsl = o, t.getVertexShaderSource = function (e) {\n          const t = o(e);\n          return `${t.version}\\n      precision highp float;\\n      ${t.attribute} vec3 position;\\n      ${t.attribute} vec2 textureCoord;\\n\\n      ${t.varyingVertex} vec2 TexCoords;\\n\\n      void main()\\n      {\\n          gl_Position = vec4(position, 1.0);\\n          TexCoords = textureCoord;\\n      }`;\n        }, t.getFragShaderPreamble = function (e) {\n          const t = o(e);\n          return `${t.version}\\n    precision highp float;\\n    precision highp int;\\n    precision highp sampler2D;\\n    ${t.varyingFrag} vec2 TexCoords;\\n    ${t.outputDeclaration}\\n    const vec2 halfCR = vec2(0.5, 0.5);\\n\\n    // Custom vector types to handle higher dimenalities.\\n    struct ivec5\\n    {\\n      int x;\\n      int y;\\n      int z;\\n      int w;\\n      int u;\\n    };\\n\\n    struct ivec6\\n    {\\n      int x;\\n      int y;\\n      int z;\\n      int w;\\n      int u;\\n      int v;\\n    };\\n\\n    int imod(int x, int y) {\\n      return x - y * (x / y);\\n    }\\n\\n    `;\n        }, t.getDefaultFragShaderMain = function (e, t) {\n          return `\\n  void main() {\\n    int indices[${t}];\\n    toVec(TexCoords, indices);\\n    vec4 result = vec4(process(indices));\\n    ${o(e).output} = result;\\n  }\\n  `;\n        };\n      },\n      9314: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.VecGlslLib = void 0;\n        const r = n(1997);\n        class o extends r.GlslLib {\n          constructor(e) {\n            super(e);\n          }\n          getCustomTypes() {\n            return {};\n          }\n          getFunctions() {\n            return Object.assign(Object.assign(Object.assign(Object.assign({}, this.binaryVecFunctions()), this.copyVec()), this.setVecItem()), this.getVecItem());\n          }\n          binaryVecFunctions() {\n            const e = this.context.outputTextureLayout.shape.length,\n              t = {\n                add: \"+=\",\n                sub: \"-=\",\n                mul: \"*=\",\n                div: \"/=\"\n              },\n              n = {};\n            for (const o in t) {\n              const i = `${o}Vec`;\n              let a = \"\";\n              for (let n = 0; n < e; ++n) a += `\\n          dest[${n}] ${t[o]} src[${n}];\\n          `;\n              const s = `\\n        void ${i}(int src[${e}], out int dest[${e}]) {\\n          ${a}\\n        }\\n        `;\n              n[i] = new r.GlslLibRoutine(s);\n            }\n            return n;\n          }\n          copyVec() {\n            const e = this.context.outputTextureLayout.shape.length;\n            let t = \"\";\n            for (let n = 0; n < e; ++n) t += `\\n        dest[${n}] = src[${n}];\\n        `;\n            const n = `\\n      void copyVec(int src[${e}], out int dest[${e}]) {\\n        ${t}\\n      }\\n      `;\n            return {\n              copyVec: new r.GlslLibRoutine(n)\n            };\n          }\n          setVecItem() {\n            const e = this.context.outputTextureLayout.shape.length;\n            let t = `\\n        if(index < 0)\\n            index =${e} + index;\\n        if (index == 0)\\n            m[0] = value;\\n        `;\n            for (let n = 1; n < e - 1; ++n) t += `\\n        else if (index == ${n})\\n            m[${n}] = value;\\n            `;\n            t += `\\n        else\\n            m[${e - 1}] = value;\\n        `;\n            const n = `\\n      void setVecItem(out int m[${e}], int index, int value) {\\n        ${t}\\n      }\\n        `;\n            return {\n              setVecItem: new r.GlslLibRoutine(n)\n            };\n          }\n          getVecItem() {\n            const e = this.context.outputTextureLayout.shape.length;\n            let t = `\\n        if(index < 0)\\n            index = ${e} + index;\\n        if (index == 0)\\n            return m[0];\\n      `;\n            for (let n = 1; n < e - 1; ++n) t += `\\n        else if (index == ${n})\\n            return m[${n}];\\n      `;\n            t += `\\n        else\\n            return m[${e - 1}];\\n        `;\n            const n = `\\n      int getVecItem(int m[${e}], int index) {\\n        ${t}\\n      }\\n    `;\n            return {\n              getVecItem: new r.GlslLibRoutine(n)\n            };\n          }\n        }\n        t.VecGlslLib = o;\n      },\n      7860: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.WebGLInferenceHandler = void 0;\n        const r = n(1315),\n          o = n(9240),\n          i = n(7273),\n          a = n(9),\n          s = n(7379),\n          u = n(2488),\n          l = n(540),\n          c = n(3314),\n          p = n(5639);\n        t.WebGLInferenceHandler = class {\n          constructor(e) {\n            this.session = e, this.packedTextureDataCache = new Map(), this.unpackedTextureDataCache = new Map();\n          }\n          calculateTextureWidthAndHeight(e, t) {\n            return (0, c.calculateTextureWidthAndHeight)(this.session.layoutStrategy, e, t);\n          }\n          executeProgram(e, t) {\n            if (t.length < e.inputNames.length) throw new Error(`Input size mustn't be less than ${e.inputNames.length}.`);\n            if (e.inputNames.length !== e.inputTypes.length) throw new Error(\"input names size does not match input types\");\n            const n = [];\n            for (let r = 0; r < e.inputNames.length; ++r) n[r] = this.getOrCreateTextureData(t[r], e.inputTypes[r]);\n            const r = ((e, t) => {\n              const n = t.map(e => `${e.unpackedShape.join(\",\")};${e.width}x${e.height}`).join(\"_\");\n              let r = e.name;\n              return e.cacheHint && (r += \"[\" + e.cacheHint + \"]\"), r += \":\" + n, r;\n            })(e, n);\n            let o = this.session.programManager.getArtifact(r);\n            const i = o ? o.programInfo : \"function\" == typeof e.get ? e.get() : e,\n              a = (0, c.createTextureLayoutFromTextureType)(this.session.layoutStrategy, i.output.dims, i.output.textureType),\n              s = this.createTextureData(a, i.output.type);\n            return o || (o = this.session.programManager.build(i, n, s), this.session.programManager.setArtifact(r, o)), this.runProgram(o, n, s), s;\n          }\n          run(e, t) {\n            return this.executeProgram(e, t).tensor;\n          }\n          runProgram(e, t, n) {\n            for (let n = 0; n < t.length; ++n) if (!!t[n].isPacked != (e.programInfo.inputTypes[n] === p.TextureType.packed)) throw new Error(`input[${n}] property packed inconsistent`);\n            if (!!n.isPacked != (e.programInfo.output.textureType === p.TextureType.packed)) throw new Error(\"output property packed inconsistent\");\n            this.session.programManager.run(e, t, n);\n          }\n          getOrCreateTextureData(e, t) {\n            let n = this.getTextureData(e.dataId, t === p.TextureType.packed);\n            if (!n && (n = this.getTextureData(e.dataId, t !== p.TextureType.packed), n)) return t === p.TextureType.packed ? this.pack(n) : this.unpack(n);\n            if (!n) {\n              const r = (0, c.createTextureLayoutFromTextureType)(this.session.layoutStrategy, e.dims, t);\n              if (t === p.TextureType.packedLastDimension) {\n                const n = 1,\n                  r = 4,\n                  o = e.dims;\n                if (4 === o.length) {\n                  const i = [o[0], Math.ceil(o[1] * o[2] * o[3] / r)],\n                    a = (0, c.createTextureLayoutFromTextureType)(this.session.layoutStrategy, i, t);\n                  let s = e.numberData;\n                  if (o[1] * o[2] * o[3] % r != 0) {\n                    const t = o[0],\n                      i = o[1] * o[2] * o[3],\n                      a = Math.ceil(i * n / r) * r;\n                    s = new Float32Array(t * a);\n                    for (let r = 0; r < t; ++r) {\n                      const t = r * i,\n                        o = r * a + r % n * i;\n                      s.set(e.numberData.subarray(t, t + i), o);\n                    }\n                  }\n                  return this.createTextureData(a, e.type, s, e, 1);\n                }\n              }\n              if (t === p.TextureType.packed) {\n                const t = (0, c.createTextureLayoutFromShape)(this.session.layoutStrategy, e.dims, 1, [], {\n                    reverseWH: !0\n                  }),\n                  r = this.createTextureData(t, e.type, e.numberData, e, 1);\n                n = this.pack(r);\n              } else n = this.createTextureData(r, e.type, e.numberData, e, 1);\n            }\n            return n;\n          }\n          createTextureDataFromLayoutBindTensor(e, t, n, r) {\n            return this.createTextureData(e, t, n, r, 1);\n          }\n          createTextureData(e, t, n, o, i) {\n            r.Logger.verbose(\"InferenceHandler\", `Creating TextureData: layout:[${JSON.stringify(e)}]`);\n            const a = this.session.textureManager.createTextureFromLayout(t, e, n, i);\n            return this.createTextureDataFromTexture(e, t, a, o);\n          }\n          reshapeUnpacked(e, t) {\n            const n = this.getOrCreateTextureData(e, p.TextureType.unpacked),\n              r = {\n                channels: n.channels,\n                height: n.height,\n                width: n.width,\n                shape: 0 !== t.length ? t : [1],\n                strides: i.ShapeUtil.computeStrides(t),\n                unpackedShape: t\n              };\n            return this.createTextureDataFromTexture(r, e.type, n.texture).tensor;\n          }\n          reshapePacked(e, t) {\n            const n = this.getOrCreateTextureData(e, p.TextureType.packed);\n            if ((0, s.isReshapeCheap)(e.dims, t)) {\n              const r = {\n                channels: n.channels,\n                height: n.height,\n                width: n.width,\n                shape: 0 !== t.length ? t : [1],\n                strides: i.ShapeUtil.computeStrides(t),\n                unpackedShape: t,\n                isPacked: !0\n              };\n              return this.createTextureDataFromTexture(r, e.type, n.texture).tensor;\n            }\n            const r = (0, s.processDims3D)(e.dims),\n              o = (0, s.processDims3D)(t),\n              a = this.reshapePacked(e, r),\n              u = this.run((0, s.createPackedReshape3DProgramInfoLoader)(this, a, o), [a]);\n            return this.reshapePacked(u, t);\n          }\n          cast(e, t) {\n            const n = this.getOrCreateTextureData(e, p.TextureType.unpacked);\n            return this.createTextureDataFromTexture(n, t, n.texture).tensor;\n          }\n          createTextureDataFromTexture(e, t, n, r, i) {\n            const a = Object.assign(Object.assign({}, e), {\n              tensor: r || new o.Tensor(e.unpackedShape, t, e => this.readTexture(a), async e => this.readTextureAsync(a), void 0, i),\n              texture: n\n            });\n            return this.setTextureData(a.tensor.dataId, a, e.isPacked), a;\n          }\n          getTextureData(e, t = !1) {\n            return this.session.isInitializer(e) ? this.session.getTextureData(e, t) : t ? this.packedTextureDataCache.get(e) : this.unpackedTextureDataCache.get(e);\n          }\n          setTextureData(e, t, n = !1) {\n            this.session.isInitializer(e) ? this.session.setTextureData(e, t, n) : (n ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(e, t);\n          }\n          isTextureLayoutCached(e, t = !1) {\n            return !!this.getTextureData(e.dataId, t);\n          }\n          dispose() {\n            this.session.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach(e => this.session.textureManager.releaseTexture(e)), this.packedTextureDataCache = new Map(), this.unpackedTextureDataCache.forEach(e => this.session.textureManager.releaseTexture(e)), this.unpackedTextureDataCache = new Map();\n          }\n          readTexture(e) {\n            return e.isPacked ? this.readTexture(this.unpack(e)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTexture(e, e.tensor.type, e.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u.encodeAsUint8)(this, e));\n          }\n          async readTextureAsync(e) {\n            return e.isPacked ? this.readTextureAsync(this.unpack(e)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTextureAsync(e, e.tensor.type, e.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u.encodeAsUint8)(this, e));\n          }\n          pack(e) {\n            return this.executeProgram((0, a.createPackProgramInfoLoader)(this, e.tensor), [e.tensor]);\n          }\n          unpack(e) {\n            return this.executeProgram((0, l.createUnpackProgramInfoLoader)(this, e.tensor), [e.tensor]);\n          }\n        };\n      },\n      4110: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__createBinding || (Object.create ? function (e, t, n, r) {\n            void 0 === r && (r = n);\n            var o = Object.getOwnPropertyDescriptor(t, n);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[n];\n              }\n            }), Object.defineProperty(e, r, o);\n          } : function (e, t, n, r) {\n            void 0 === r && (r = n), e[r] = t[n];\n          }),\n          o = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          i = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var n in e) \"default\" !== n && Object.prototype.hasOwnProperty.call(e, n) && r(t, e, n);\n            return o(t, e), t;\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.WEBGL_OP_RESOLVE_RULES = void 0;\n        const a = n(8817),\n          s = i(n(5194)),\n          u = n(4752),\n          l = n(6668),\n          c = n(9754),\n          p = n(5042),\n          d = n(6742),\n          f = n(4125),\n          h = n(6149),\n          g = n(5378),\n          b = n(6981),\n          m = n(7413),\n          y = n(7006),\n          v = n(8276),\n          _ = n(5565),\n          w = n(2834),\n          T = n(1010),\n          x = n(8126),\n          O = n(2801),\n          S = n(565),\n          A = n(2444),\n          P = n(815),\n          I = n(564),\n          E = n(5416),\n          D = n(1240),\n          $ = n(5944),\n          k = n(5707),\n          F = i(n(9087)),\n          N = n(7862),\n          R = n(3980);\n        t.WEBGL_OP_RESOLVE_RULES = [[\"Abs\", \"\", \"6+\", F.abs], [\"Acos\", \"\", \"7+\", F.acos], [\"Add\", \"\", \"7+\", s.add], [\"And\", \"\", \"7+\", s.and], [\"Asin\", \"\", \"7+\", F.asin], [\"Atan\", \"\", \"7+\", F.atan], [\"AveragePool\", \"\", \"7+\", w.averagePool, w.parseAveragePoolAttributes], [\"BatchNormalization\", \"\", \"7+\", a.batchNormalization, a.parseBatchNormalizationAttributes], [\"Cast\", \"\", \"6+\", u.cast, u.parseCastAttributes], [\"Ceil\", \"\", \"6+\", F.ceil], [\"Clip\", \"\", \"6-10\", F.clip, F.parseClipAttributes], [\"Clip\", \"\", \"11+\", F.clipV11], [\"Concat\", \"\", \"4+\", l.concat, l.parseConcatAttributes], [\"Conv\", \"\", \"1+\", c.conv, c.parseConvAttributes], [\"ConvTranspose\", \"\", \"1+\", p.convTranspose, p.parseConvTransposeAttributes], [\"Cos\", \"\", \"7+\", F.cos], [\"Div\", \"\", \"7+\", s.div], [\"Dropout\", \"\", \"7+\", F.identity], [\"DepthToSpace\", \"\", \"1+\", d.depthToSpace, d.parseDepthToSpaceAttributes], [\"Equal\", \"\", \"7+\", s.equal], [\"Elu\", \"\", \"6+\", F.elu, F.parseEluAttributes], [\"Exp\", \"\", \"6+\", F.exp], [\"Flatten\", \"\", \"1+\", f.flatten, f.parseFlattenAttributes], [\"Floor\", \"\", \"6+\", F.floor], [\"FusedConv\", \"com.microsoft\", \"1+\", c.conv, c.parseConvAttributes], [\"Gather\", \"\", \"1+\", h.gather, h.parseGatherAttributes], [\"Gemm\", \"\", \"7-10\", g.gemm, g.parseGemmAttributesV7], [\"Gemm\", \"\", \"11+\", g.gemm, g.parseGemmAttributesV11], [\"GlobalAveragePool\", \"\", \"1+\", w.globalAveragePool, w.parseGlobalAveragePoolAttributes], [\"GlobalMaxPool\", \"\", \"1+\", w.globalMaxPool], [\"Greater\", \"\", \"7+\", s.greater], [\"Identity\", \"\", \"1+\", F.identity], [\"ImageScaler\", \"\", \"1+\", b.imageScaler, b.parseImageScalerAttributes], [\"InstanceNormalization\", \"\", \"6+\", m.instanceNormalization, m.parseInstanceNormalizationAttributes], [\"LeakyRelu\", \"\", \"6+\", F.leakyRelu, F.parseLeakyReluAttributes], [\"Less\", \"\", \"7+\", s.less], [\"LRN\", \"\", \"1+\", y.lrn, y.parseLrnAttributes], [\"Log\", \"\", \"6+\", F.log], [\"MatMul\", \"\", \"1+\", v.matMul, v.parseMatMulAttributes], [\"MaxPool\", \"\", \"1+\", w.maxPool, w.parseMaxPoolAttributes], [\"Mul\", \"\", \"7+\", s.mul], [\"Neg\", \"\", \"6+\", F.neg], [\"Not\", \"\", \"1+\", F.not], [\"Or\", \"\", \"7+\", s.or], [\"Pad\", \"\", \"2-10\", _.padV2, _.parsePadAttributesV2], [\"Pad\", \"\", \"11+\", _.padV11, _.parsePadAttributesV11], [\"Pow\", \"\", \"7+\", s.pow], [\"PRelu\", \"\", \"7+\", s.pRelu], [\"ReduceLogSum\", \"\", \"1+\", T.reduceLogSum, T.parseReduceAttributes], [\"ReduceMax\", \"\", \"1+\", T.reduceMax, T.parseReduceAttributes], [\"ReduceMean\", \"\", \"1+\", T.reduceMean, T.parseReduceAttributes], [\"ReduceMin\", \"\", \"1+\", T.reduceMin, T.parseReduceAttributes], [\"ReduceProd\", \"\", \"1+\", T.reduceProd, T.parseReduceAttributes], [\"ReduceSum\", \"\", \"1-12\", T.reduceSum, T.parseReduceAttributes], [\"ReduceSumSquare\", \"\", \"1+\", T.reduceLogSumSquare, T.parseReduceAttributes], [\"Relu\", \"\", \"6+\", F.relu], [\"Reshape\", \"\", \"5+\", x.reshape], [\"Resize\", \"\", \"10\", O.resize, O.parseResizeAttributesV10], [\"Resize\", \"\", \"11+\", O.resize, O.parseResizeAttributesV11], [\"Shape\", \"\", \"1+\", S.shape], [\"Sigmoid\", \"\", \"6+\", F.sigmoid], [\"Sin\", \"\", \"7+\", F.sin], [\"Slice\", \"\", \"10+\", A.sliceV10], [\"Slice\", \"\", \"1-9\", A.slice, A.parseSliceAttributes], [\"Softmax\", \"\", \"1-12\", P.softmax, P.parseSoftmaxAttributes], [\"Softmax\", \"\", \"13+\", P.softmaxV13, P.parseSoftmaxAttributesV13], [\"Split\", \"\", \"2-12\", I.split, I.parseSplitAttributes], [\"Sqrt\", \"\", \"6+\", F.sqrt], [\"Squeeze\", \"\", \"1-12\", E.squeeze, E.parseSqueezeAttributes], [\"Squeeze\", \"\", \"13+\", E.squeezeV13], [\"Sub\", \"\", \"7+\", s.sub], [\"Sum\", \"\", \"6+\", D.sum], [\"Tan\", \"\", \"7+\", F.tan], [\"Tanh\", \"\", \"6+\", F.tanh], [\"Tile\", \"\", \"6+\", $.tile], [\"Transpose\", \"\", \"1+\", k.transpose, k.parseTransposeAttributes], [\"Upsample\", \"\", \"7-8\", R.upsample, R.parseUpsampleAttributesV7], [\"Upsample\", \"\", \"9\", R.upsample, R.parseUpsampleAttributesV9], [\"Unsqueeze\", \"\", \"1-12\", N.unsqueeze, N.parseUnsqueezeAttributes], [\"Unsqueeze\", \"\", \"13+\", N.unsqueezeV13], [\"Xor\", \"\", \"7+\", s.xor]];\n      },\n      8817: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.parseBatchNormalizationAttributes = t.batchNormalization = void 0;\n        const r = n(4910),\n          o = n(6757),\n          i = n(5639),\n          a = {\n            name: \"BatchNormalization\",\n            inputNames: [\"A\", \"Scale\", \"B\", \"Mean\", \"Variance\"],\n            inputTypes: [i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked]\n          };\n        t.batchNormalization = (e, t, n) => (u(t), [e.run(Object.assign(Object.assign({}, a), {\n          cacheHint: n.cacheKey,\n          get: () => s(e, t, n)\n        }), t)]), t.parseBatchNormalizationAttributes = e => {\n          const t = e.attributes.getFloat(\"epsilon\", 1e-5),\n            n = e.attributes.getFloat(\"momentum\", .9),\n            o = e.attributes.getInt(\"spatial\", 1);\n          return (0, r.createAttributeWithCacheKey)({\n            epsilon: t,\n            momentum: n,\n            spatial: o\n          });\n        };\n        const s = (e, t, n) => {\n            const r = (0, o.getGlsl)(e.session.backend.glContext.version),\n              s = t[0].dims.length,\n              [u, l] = e.calculateTextureWidthAndHeight(t[1].dims, i.TextureType.unpacked),\n              c = `\\n  float process(int[${s}] indices) {\\n    vec2 position = offsetToCoords(indices[1], ${u}, ${l});\\n    float scale = getColorAsFloat(${r.texture2D}(Scale, position));\\n    float mean = getColorAsFloat(${r.texture2D}(Mean, position));\\n    float variance = getColorAsFloat(${r.texture2D}(Variance, position));\\n    float b = getColorAsFloat(${r.texture2D}(B, position));\\n\\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n.epsilon})) ) + b;\\n  }`;\n            return Object.assign(Object.assign({}, a), {\n              output: {\n                dims: t[0].dims,\n                type: t[0].type,\n                textureType: i.TextureType.unpacked\n              },\n              shaderSource: c\n            });\n          },\n          u = e => {\n            if (!e || 5 !== e.length) throw new Error(\"BatchNormalization requires 5 inputs.\");\n            const t = e[0],\n              n = e[1],\n              r = e[2],\n              o = e[3],\n              i = e[4];\n            if (t.dims.length < 3 || 1 !== n.dims.length || 1 !== r.dims.length || 1 !== o.dims.length || 1 !== i.dims.length) throw new Error(\"invalid input shape.\");\n            if (n.dims[0] !== t.dims[1] || r.dims[0] !== t.dims[1] || o.dims[0] !== t.dims[1] || i.dims[0] !== t.dims[1]) throw new Error(\"invalid input shape.\");\n            if (\"float32\" !== t.type && \"float64\" !== t.type || \"float32\" !== n.type && \"float64\" !== n.type || \"float32\" !== r.type && \"float64\" !== r.type || \"float32\" !== o.type && \"float64\" !== o.type || \"float32\" !== i.type && \"float64\" !== i.type) throw new Error(\"invalid input tensor types.\");\n          };\n      },\n      5194: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.xor = t.sub = t.pRelu = t.pow = t.or = t.mul = t.less = t.greater = t.equal = t.div = t.and = t.add = t.glslPRelu = t.glslPow = t.glslXor = t.glslOr = t.glslAnd = t.glslLess = t.glslGreater = t.glslEqual = t.glslSub = t.glslMul = t.glslDiv = t.glslAdd = void 0;\n        const r = n(7273),\n          o = n(1997),\n          i = n(6757),\n          a = n(5639);\n        function s() {\n          const e = \"add_\";\n          return {\n            body: `\\n  float ${e}(float a, float b) {\\n    return a + b;\\n  }\\n  vec4 ${e}(vec4 v1, vec4 v2) {\\n    return v1 + v2;\\n  }\\n  `,\n            name: e,\n            type: o.FunctionType.ValueBased\n          };\n        }\n        function u() {\n          const e = \"div_\";\n          return {\n            body: `\\n  float ${e}(float a, float b) {\\n    return a / b;\\n  }\\n  vec4 ${e}(vec4 v1, vec4 v2) {\\n    return v1 / v2;\\n  }\\n  `,\n            name: e,\n            type: o.FunctionType.ValueBased\n          };\n        }\n        function l() {\n          const e = \"mul_\";\n          return {\n            body: `\\n  float ${e}(float a, float b) {\\n    return a * b;\\n  }\\n  vec4 ${e}(vec4 v1, vec4 v2) {\\n    return v1 * v2;\\n  }\\n  `,\n            name: e,\n            type: o.FunctionType.ValueBased\n          };\n        }\n        function c() {\n          const e = \"sub_\";\n          return {\n            body: `\\n  float ${e}(float a, float b) {\\n    return a - b;\\n  }\\n  vec4 ${e}(vec4 v1, vec4 v2) {\\n    return v1 - v2;\\n  }\\n  `,\n            name: e,\n            type: o.FunctionType.ValueBased\n          };\n        }\n        function p() {\n          const e = \"equal_\";\n          return {\n            body: `\\n  float ${e}(float a, float b) {\\n    return float(a == b);\\n  }\\n  vec4 ${e}(vec4 v1, vec4 v2) {\\n    return vec4(equal(v1, v2));\\n  }\\n  `,\n            name: e,\n            type: o.FunctionType.ValueBased\n          };\n        }\n        function d() {\n          const e = \"greater_\";\n          return {\n            body: `\\n  float ${e}(float a, float b) {\\n    return float(a > b);\\n  }\\n  vec4 ${e}(vec4 v1, vec4 v2) {\\n    return vec4( v1.r > v2.r ,\\n      v1.g > v2.g,\\n      v1.b > v2.b,\\n      v1.a > v2.a );\\n  }\\n  `,\n            name: e,\n            type: o.FunctionType.ValueBased\n          };\n        }\n        function f() {\n          const e = \"less_\";\n          return {\n            body: `\\n  float ${e}(float a, float b) {\\n    return float(a < b);\\n  }\\n  vec4 ${e}(vec4 v1, vec4 v2) {\\n    return vec4( v1.r < v2.r ,\\n                v1.g < v2.g,\\n                v1.b < v2.b,\\n                v1.a < v2.a );\\n  }\\n  `,\n            name: e,\n            type: o.FunctionType.ValueBased\n          };\n        }\n        function h() {\n          const e = \"and_\";\n          return {\n            body: `\\n  float ${e}(float a, float b) {\\n    return float( bool(a) && bool(b) );\\n  }\\n  vec4 ${e}(vec4 v1, vec4 v2) {\\n    bvec4 b1 = bvec4(v1);\\n    bvec4 b2 = bvec4(v2);\\n    return vec4( b1.r && b2.r ,\\n                b1.g && b2.g,\\n                b1.b && b2.b,\\n                b1.a && b2.a );\\n  }\\n  `,\n            name: e,\n            type: o.FunctionType.ValueBased\n          };\n        }\n        function g() {\n          const e = \"or_\";\n          return {\n            body: `\\n  float ${e}(float a, float b) {\\n    return float( bool(a) || bool(b) );\\n  }\\n  vec4 ${e}(vec4 v1, vec4 v2) {\\n    bvec4 b1 = bvec4(v1);\\n    bvec4 b2 = bvec4(v2);\\n    return vec4( b1.r || b2.r ,\\n                b1.g || b2.g,\\n                b1.b || b2.b,\\n                b1.a || b2.a );\\n  }\\n  `,\n            name: e,\n            type: o.FunctionType.ValueBased\n          };\n        }\n        function b() {\n          const e = \"xor_\";\n          return {\n            body: `\\n  float ${e}(float a, float b) {\\n    return float( bool(a) ^^ bool(b) );\\n  }\\n  vec4 ${e}(vec4 v1, vec4 v2) {\\n    bvec4 b1 = bvec4(v1);\\n    bvec4 b2 = bvec4(v2);\\n    return vec4( b1.r ^^ b2.r ,\\n                b1.g ^^ b2.g,\\n                b1.b ^^ b2.b,\\n                b1.a ^^ b2.a );\\n  }\\n  `,\n            name: e,\n            type: o.FunctionType.ValueBased\n          };\n        }\n        function m() {\n          return function (e) {\n            const t = `${e}_`;\n            return {\n              body: `\\n  float ${t}(float a, float b) {\\n    return ${e}(a, b);\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return ${e}(v1, v2);\\n  }\\n  `,\n              name: t,\n              type: o.FunctionType.ValueBased\n            };\n          }(\"pow\");\n        }\n        function y() {\n          const e = \"prelu_\";\n          return {\n            body: `\\n  float ${e}(float a, float b) {\\n    return a < 0.0 ? a * b: a;\\n  }\\n  vec4 ${e}(vec4 v1, vec4 v2) {\\n    return vec4(\\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\\n      );\\n  }\\n  `,\n            name: e,\n            type: o.FunctionType.ValueBased\n          };\n        }\n        t.glslAdd = s, t.glslDiv = u, t.glslMul = l, t.glslSub = c, t.glslEqual = p, t.glslGreater = d, t.glslLess = f, t.glslAnd = h, t.glslOr = g, t.glslXor = b, t.glslPow = m, t.glslPRelu = y;\n        const v = (e, t, n, r = t[0].type, o) => {\n            const i = e.session.pack ? a.TextureType.packed : a.TextureType.unpacked;\n            return {\n              name: n.name,\n              inputNames: [\"A\", \"B\"],\n              inputTypes: [i, i],\n              cacheHint: o,\n              get: () => _(e, t, n, r)\n            };\n          },\n          _ = (e, t, n, o = t[0].type) => {\n            const s = e.session.pack ? a.TextureType.packed : a.TextureType.unpacked,\n              u = !r.ShapeUtil.areEqual(t[0].dims, t[1].dims);\n            let l = t[0].dims;\n            const c = e.session.pack;\n            if (u) {\n              const a = r.BroadcastUtil.calcShape(t[0].dims, t[1].dims, !1);\n              if (!a) throw new Error(\"Can't perform binary op on the given tensors\");\n              l = a;\n              const u = l.length,\n                p = 0 !== t[0].dims.length ? t[0].dims.length : 1,\n                d = 0 !== t[1].dims.length ? t[1].dims.length : 1,\n                f = 0 !== t[0].dims.length ? \"bcastIndices_A(indices, aindices);\" : \"aindices[0] = 0;\",\n                h = 0 !== t[1].dims.length ? \"bcastIndices_B(indices, bindices);\" : \"bindices[0] = 0;\",\n                g = (0, i.getGlsl)(e.session.backend.glContext.version),\n                b = c ? `\\n      ${n.body}\\n      void main() {\\n        vec4 a = getAAtOutCoords();\\n        vec4 b = getBAtOutCoords();\\n        vec4 result = ${n.name}(a, b);\\n        ${g.output} = result;\\n      }` : `\\n      ${n.body}\\n      float process(int indices[${u}]) {\\n        int aindices[${p}];\\n        int bindices[${d}];\\n        ${f}\\n        ${h}\\n        return ${n.name}(_A(aindices), _B(bindices));\\n      }`;\n              return {\n                name: n.name,\n                inputNames: [\"A\", \"B\"],\n                inputTypes: [s, s],\n                output: {\n                  dims: l,\n                  type: o,\n                  textureType: s\n                },\n                shaderSource: b,\n                hasMain: c\n              };\n            }\n            const p = (0, i.getGlsl)(e.session.backend.glContext.version),\n              d = `\\n    ${n.body}\\n    void main() {\\n      vec4 v1 = ${p.texture2D}(A, TexCoords);\\n      vec4 v2 = ${p.texture2D}(B, TexCoords);\\n      vec4 result = ${n.name}(v1, v2);\\n      ${p.output} = result;\\n    }\\n    `;\n            return {\n              name: n.name,\n              inputNames: [\"A\", \"B\"],\n              inputTypes: [s, s],\n              output: {\n                dims: t[0].dims,\n                type: o,\n                textureType: s\n              },\n              shaderSource: d,\n              hasMain: !0\n            };\n          };\n        t.add = (e, t) => [e.run(v(e, t, s()), t)], t.and = (e, t) => [e.run(v(e, t, h(), \"bool\"), t)], t.div = (e, t) => [e.run(v(e, t, u()), t)], t.equal = (e, t) => [e.run(v(e, t, p(), \"bool\"), t)], t.greater = (e, t) => [e.run(v(e, t, d(), \"bool\"), t)], t.less = (e, t) => [e.run(v(e, t, f(), \"bool\"), t)], t.mul = (e, t) => [e.run(v(e, t, l()), t)], t.or = (e, t) => [e.run(v(e, t, g(), \"bool\"), t)], t.pow = (e, t) => [e.run(v(e, t, m()), t)], t.pRelu = (e, t) => [e.run(v(e, t, y()), t)], t.sub = (e, t) => [e.run(v(e, t, c()), t)], t.xor = (e, t) => [e.run(v(e, t, b(), \"bool\"), t)];\n      },\n      4752: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.parseCastAttributes = t.cast = void 0;\n        const r = n(7273);\n        t.cast = (e, t, n) => (o(t), [e.cast(t[0], n)]), t.parseCastAttributes = e => r.ProtoUtil.tensorDataTypeFromProto(e.attributes.getInt(\"to\"));\n        const o = e => {\n          if (!e || 1 !== e.length) throw new Error(\"Cast requires 1 input.\");\n          if (\"string\" === e[0].type) throw new Error(\"Invalid input type.\");\n        };\n      },\n      4595: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.createPackedConcatProgramInfoLoader = void 0;\n        const r = n(6757),\n          o = n(5639),\n          i = n(432),\n          a = n(5614);\n        t.createPackedConcatProgramInfoLoader = (e, t, n) => {\n          const u = (l = t.length, c = n.cacheKey, {\n            name: \"Concat (packed)\",\n            inputNames: Array.from({\n              length: l\n            }, (e, t) => `X${t}`),\n            inputTypes: Array(l).fill(o.TextureType.packed),\n            cacheHint: c\n          });\n          var l, c;\n          return Object.assign(Object.assign({}, u), {\n            get: () => ((e, t, n, u) => {\n              const l = n[0].dims.slice();\n              if (u >= l.length || u < -1 * l.length) throw new Error(\"axis specified for concat doesn't match input dimensionality\");\n              u < 0 && (u = l.length + u);\n              const c = l.slice(0);\n              for (let e = 1; e < n.length; e++) {\n                const t = n[e].dims.slice();\n                for (let e = 0; e < l.length; e++) if (e === u) c[u] += t[e];else if (l[e] !== t[e]) throw new Error(\"non concat dimensions must match\");\n              }\n              const p = c.length,\n                d = (0, a.getChannels)(\"coords\", p),\n                f = (0, i.getCoordsDataType)(p),\n                h = (0, a.unpackFromChannel)(),\n                g = n.map(e => e.dims),\n                b = (0, i.getGlChannels)(p),\n                m = new Array(g.length - 1);\n              m[0] = g[0][u];\n              for (let e = 1; e < m.length; e++) m[e] = m[e - 1] + g[e][u];\n              const y = b[u],\n                v = b.slice(-2),\n                _ = b.join();\n              let w = `if (${y} < ${m[0]}) {\\n        return getChannel(\\n            getX0(${_}), vec2(${v.join()}));\\n        }`;\n              for (let e = 1; e < m.length; e++) {\n                const t = m[e - 1];\n                w += `\\n            if (${y} < ${m[e]}  && ${y} >= ${m[e - 1]}) {\\n              return getChannel(\\n                getX${e}(${s(b, y, t)}),\\n                vec2(${s(v, y, t)}));\\n            }`;\n              }\n              const T = m.length,\n                x = m[m.length - 1];\n              w += `\\n            return getChannel(\\n              getX${T}(${s(b, y, x)}),\\n              vec2(${s(v, y, x)}));`;\n              const O = (0, r.getGlsl)(e.session.backend.glContext.version),\n                S = `\\n          ${h}\\n          float getValue(${b.map(e => \"int \" + e)}) {\\n            ${w}\\n          }\\n\\n          void main() {\\n            ${f} coords = getOutputCoords();\\n            int lastDim = coords.${b[p - 1]};\\n            coords.${b[p - 1]} = coords.${b[p - 2]};\\n            coords.${b[p - 2]} = lastDim;\\n\\n            vec4 result = vec4(getValue(${d}), 0., 0., 0.);\\n\\n            ${d[p - 1]} = ${d[p - 1]} + 1;\\n            if (${d[p - 1]} < ${c[p - 1]}) {\\n              result.g = getValue(${d});\\n            }\\n\\n            ${d[p - 2]} = ${d[p - 2]} + 1;\\n            if (${d[p - 2]} < ${c[p - 2]}) {\\n              result.a = getValue(${d});\\n            }\\n\\n            ${d[p - 1]} = ${d[p - 1]} - 1;\\n            if (${d[p - 2]} < ${c[p - 2]} &&\\n                ${d[p - 1]} < ${c[p - 1]}) {\\n              result.b = getValue(${d});\\n            }\\n            ${O.output} = result;\\n          }\\n        `;\n              return Object.assign(Object.assign({}, t), {\n                output: {\n                  dims: c,\n                  type: n[0].type,\n                  textureType: o.TextureType.packed\n                },\n                shaderSource: S,\n                hasMain: !0\n              });\n            })(e, u, t, n.axis)\n          });\n        };\n        const s = (e, t, n) => {\n          const r = e.indexOf(t);\n          return e.map((e, t) => t === r ? `${e} - ${n}` : e).join();\n        };\n      },\n      6668: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.parseConcatAttributes = t.concat = void 0;\n        const r = n(4910),\n          o = n(5639),\n          i = n(4595);\n        t.concat = (e, t, n) => (p(t), e.session.pack && t[0].dims.length > 1 ? [e.run((0, i.createPackedConcatProgramInfoLoader)(e, t, n), t)] : [e.run(a(e, t, n), t)]);\n        const a = (e, t, n) => {\n            const r = (i = t.length, a = n.cacheKey, {\n              name: \"Concat\",\n              inputNames: Array.from({\n                length: i\n              }, (e, t) => `X${t}`),\n              inputTypes: Array(i).fill(o.TextureType.unpacked),\n              cacheHint: a\n            });\n            var i, a;\n            return Object.assign(Object.assign({}, r), {\n              get: () => ((e, t, n, r) => {\n                const i = n[0].dims.slice();\n                if (r >= i.length || r < -1 * i.length) throw new Error(\"axis specified for concat doesn't match input dimensionality\");\n                r < 0 && (r = i.length + r);\n                const a = i.slice(0);\n                for (let e = 1; e < n.length; e++) {\n                  const t = n[e].dims.slice();\n                  for (let e = 0; e < i.length; e++) if (e === r) a[r] += t[e];else if (i[e] !== t[e]) throw new Error(\"non concat dimensions must match\");\n                }\n                const p = a.length,\n                  d = new Array(n.length);\n                let f = 0;\n                for (let e = 0; e < d.length; ++e) f += n[e].dims[r], d[e] = f;\n                let h = \"\";\n                h = n.length < 5 ? s(d) : u(d);\n                const g = `\\n        ${l(n.length, p)}\\n        ${c(d)}\\n        ${h}\\n        float process(int indices[${p}]) {\\n          int textureIndex = getTextureWhereDataResides (indices[${r}]);\\n\\n          if(textureIndex != 0) {\\n            indices[${r}] = indices[${r}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\\n          }\\n\\n          return fetchDataFromCorrectTexture(textureIndex, indices);\\n        }`;\n                return Object.assign(Object.assign({}, t), {\n                  output: {\n                    dims: a,\n                    type: n[0].type,\n                    textureType: o.TextureType.unpacked\n                  },\n                  shaderSource: g\n                });\n              })(0, r, t, n.axis)\n            });\n          },\n          s = e => `int getTextureWhereDataResides(int index) {\\n      ${e.map((e, t) => `if(index<${e}) {return ${t};}\\n`).join(\"\")}\\n    }`,\n          u = e => s(e),\n          l = (e, t) => {\n            const n = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${t}]) {`];\n            for (let t = 0; t < e; ++t) 0 === t ? n.push(`\\tif (textureIndex == ${t}) { return _X${t}(indices); }`) : t === e - 1 ? n.push(`\\telse { return _X${t}(indices); }`) : n.push(`\\telse if (textureIndex == ${t}) { return _X${t}(indices); }`);\n            return n.push(\"\\t}\"), n.join(\"\\n\");\n          },\n          c = e => {\n            const t = [\"int getSizeInConcatAxisValueFromIndex(int index) {\"];\n            for (let n = 0; n < e.length; ++n) 0 === n ? t.push(`\\tif (index == ${n}) { return ${e[n]}; }`) : n === e.length - 1 ? t.push(`\\telse { return ${e[n]}; }`) : t.push(`\\telse if (index == ${n}) { return ${e[n]}; }`);\n            return t.push(\"\\t}\"), t.join(\"\\n\");\n          };\n        t.parseConcatAttributes = e => (0, r.createAttributeWithCacheKey)({\n          axis: e.attributes.getInt(\"axis\")\n        });\n        const p = e => {\n          if (!e || e.length < 1) throw new Error(\"too few inputs\");\n          const t = e[0].type,\n            n = e[0].dims.length;\n          if (\"string\" === t) throw new Error(\"string tensor is not supported yet\");\n          for (const r of e) {\n            if (r.type !== t) throw new Error(\"input tensors should be one type\");\n            if (r.dims.length !== n) throw new Error(\"input tensors should have the same shape\");\n          }\n        };\n      },\n      7825: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.createUnpackedGroupedConvProgramInfoLoader = void 0;\n        const r = n(1315),\n          o = n(6757),\n          i = n(5639),\n          a = n(9754),\n          s = n(2150);\n        t.createUnpackedGroupedConvProgramInfoLoader = (e, t, n) => {\n          const u = (l = t.length > 2, c = n.cacheKey, {\n            name: \"GroupedConv\",\n            inputNames: l ? [\"X\", \"W\", \"Bias\"] : [\"X\", \"W\"],\n            inputTypes: l ? [i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked] : [i.TextureType.unpacked, i.TextureType.unpacked],\n            cacheHint: c\n          });\n          var l, c;\n          return Object.assign(Object.assign({}, u), {\n            get: () => ((e, t, n, u) => {\n              const l = t.length > 2 ? \"value += getBias(output_channel);\" : \"\",\n                c = t[0].dims.slice(),\n                p = t[1].dims.slice(),\n                d = p[0] / u.group;\n              r.Logger.verbose(\"GroupedConv\", `autpPad:${u.autoPad}, dilations:${u.dilations}, group:${u.group}, kernelShape:${u.kernelShape}, pads:${u.pads}, strides:${u.strides}`);\n              const f = (0, a.calculateOutputShape)(c, p, u.dilations, u.pads, u.strides),\n                h = (0, o.getGlsl)(e.session.backend.glContext.version),\n                {\n                  activationFunction: g,\n                  applyActivation: b\n                } = (0, s.getActivationSnippet)(u),\n                m = `\\n  const ivec2 strides = ivec2(${u.strides[0]}, ${u.strides[1]});\\n  const ivec2 pads = ivec2(${u.pads[0]}, ${u.pads[1]});\\n  ${g}\\n  void main() {\\n    ivec4 coords = getOutputCoords();\\n    int batch = coords.x;\\n    int output_channel = coords.y;\\n    ivec2 xRCCorner = coords.zw * strides - pads;\\n    int group_id = output_channel / ${d};\\n\\n    float value = 0.0;\\n    for (int wInChannel = 0; wInChannel < ${p[1]}; wInChannel++) {\\n      int input_channel = group_id * ${p[1]} + wInChannel;\\n      for (int wHeight = 0; wHeight < ${p[2]}; wHeight++) {\\n        int xHeight = xRCCorner.x + wHeight * ${u.dilations[0]};\\n\\n        if (xHeight < 0 || xHeight >= ${c[2]}) {\\n          continue;\\n        }\\n\\n        for (int wWidth = 0; wWidth < ${p[3]}; wWidth++) {\\n          int xWidth = xRCCorner.y + wWidth * ${u.dilations[1]};\\n          if (xWidth < 0 || xWidth >= ${c[3]}) {\\n            continue;\\n          }\\n\\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\\n          value += xVal*wVal;\\n        }\\n      }\\n    }\\n    ${l}\\n    ${b}\\n    ${h.output} = vec4(value, .0, .0, .0);\\n  }\\n`;\n              return Object.assign(Object.assign({}, n), {\n                output: {\n                  dims: f,\n                  type: t[0].type,\n                  textureType: i.TextureType.unpacked\n                },\n                shaderSource: m,\n                hasMain: !0\n              });\n            })(e, t, u, n)\n          });\n        };\n      },\n      7708: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.conv2DPacked = t.conv2DPackedPointwise = void 0;\n        const r = n(9754),\n          o = n(5950),\n          i = n(5632);\n        t.conv2DPackedPointwise = (e, t, n) => {\n          const o = t[0].dims,\n            a = t[1].dims,\n            s = (0, r.calculateOutputShape)(o, a, n.dilations, n.pads, n.strides),\n            u = e.reshapePacked(t[0], [o[1], o[2] * o[3]]),\n            l = e.reshapePacked(t[1], [a[0], a[1]]),\n            c = t.length > 2 ? [l, u, t[2]] : [l, u],\n            p = e.run((0, i.createPackedMatmulProgramInfoLoader)(e, c, n), c);\n          return e.reshapePacked(p, s);\n        }, t.conv2DPacked = (e, t, n) => {\n          const a = t[0].dims,\n            s = t[1].dims,\n            u = (0, r.calculateOutputShape)(a, s, n.dilations, n.pads, n.strides),\n            l = e.run((0, o.createPackedIm2ColProgramInfoLoader)(e, t[0], t[1], u, n), [t[0]]),\n            c = e.reshapePacked(t[1], [s[0], s[1] * s[2] * s[3]]),\n            p = 3 === t.length ? [c, l, t[2]] : [c, l],\n            d = e.run((0, i.createPackedMatmulProgramInfoLoader)(e, p, n), p);\n          return e.reshapePacked(d, u);\n        };\n      },\n      5042: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.parseConvTransposeAttributes = t.convTranspose = void 0;\n        const r = n(4910),\n          o = n(6757),\n          i = n(5639),\n          a = n(2150),\n          s = (e, t, n, r, o, i) => (e - 1) * t + n + (r - 1) * o + 1 - i,\n          u = (e, t, n, r, o) => {\n            const i = Math.floor(e / 2);\n            \"SAME_UPPER\" === t ? (n[r] = i, n[o] = e - i) : \"SAME_LOWER\" === t && (n[r] = e - i, n[o] = i);\n          };\n        t.convTranspose = (e, t, n) => (d(t, n), l(e, t, n));\n        const l = (e, t, n) => {\n            const r = p(n, t);\n            return [c(e, t, r)];\n          },\n          c = (e, t, n) => e.run(((e, t, n) => {\n            const r = (s = t.length > 2, u = n.cacheKey, {\n              name: \"ConvTranspose\",\n              inputNames: s ? [\"X\", \"W\", \"B\"] : [\"X\", \"W\"],\n              inputTypes: s ? [i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked] : [i.TextureType.unpacked, i.TextureType.unpacked],\n              cacheHint: u\n            });\n            var s, u;\n            return Object.assign(Object.assign({}, r), {\n              get: () => ((e, t, n, r) => {\n                const s = t.length > 2 ? \"getB(output_channel)\" : \"0.0\",\n                  u = t[0].dims,\n                  l = t[1].dims,\n                  c = l[1],\n                  p = l[0] / r.group,\n                  d = [t[0].dims[0], t[1].dims[1] * r.group, ...r.outputShape],\n                  f = (0, o.getGlsl)(e.session.backend.glContext.version),\n                  {\n                    activationFunction: h,\n                    applyActivation: g\n                  } = (0, a.getActivationSnippet)(r),\n                  b = `\\n  const ivec2 strides = ivec2(${r.strides[0]}, ${r.strides[1]});\\n  const ivec2 pads = ivec2(${r.pads[0]}, ${r.pads[1]});\\n  ${h}\\n  void main() {\\n    ivec4 coords = getOutputCoords();\\n    int batch = coords.x;\\n    int output_channel = coords.y;\\n\\n    ivec2 loc = coords.zw + pads;\\n\\n    int group_id = output_channel / ${c};\\n    int wOutChannel = output_channel - group_id * ${c};\\n\\n    float value = ${s};\\n    for (int inChannelOffset = 0; inChannelOffset < ${p}; inChannelOffset++) {\\n      int input_channel = group_id * ${p} + inChannelOffset;\\n      for (int wWOff = 0; wWOff < ${l[2]}; wWOff++) {\\n        for (int wHOff = 0; wHOff < ${l[3]}; wHOff++) {\\n          ivec2 wOff = ivec2(wWOff * ${r.dilations[0]}, wHOff * ${r.dilations[1]});\\n          ivec2 wLoc = loc - wOff;\\n          ivec2 wLocIn = wLoc / strides;\\n          if (\\n            wLocIn * strides == wLoc &&\\n            wLocIn.x >= 0 && wLocIn.x < ${u[2]} &&\\n            wLocIn.y >= 0 && wLocIn.y < ${u[3]}\\n          ) {\\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\\n            value += xVal * wVal;\\n          }\\n        }\\n      }\\n    }\\n    ${g}\\n    ${f.output} = vec4(value, .0, .0, .0);\\n  }\\n`;\n                return Object.assign(Object.assign({}, n), {\n                  output: {\n                    dims: d,\n                    type: t[0].type,\n                    textureType: i.TextureType.unpacked\n                  },\n                  shaderSource: b,\n                  hasMain: !0\n                });\n              })(e, t, r, n)\n            });\n          })(e, t, n), t),\n          p = (e, t) => {\n            const n = e.kernelShape.slice();\n            if (0 === e.kernelShape.length) for (let e = 2; e < t[1].dims.length; ++e) n.push(t[1].dims[e]);\n            const r = e.pads.slice(),\n              o = e.outputShape.slice();\n            ((e, t, n, r, o, i, a, l) => {\n              const c = e.length - 2,\n                p = 0 === l.length;\n              for (let d = 0; d < c; ++d) {\n                const f = p ? e[d + 2] * i[d] : l[d],\n                  h = s(e[d + 2], i[d], o[d], t[d], n[d], f);\n                u(h, r, o, d, d + c), p && l.push(i[d] * (e[d + 2] - 1) + a[d] + (t[d] - 1) * n[d] + 1 - o[d] - o[d + c]);\n              }\n            })(t[0].dims, n, e.dilations, e.autoPad, r, e.strides, e.outputPadding, o);\n            const i = Object.assign({}, e);\n            return Object.assign(i, {\n              kernelShape: n,\n              pads: r,\n              outputShape: o,\n              cacheKey: e.cacheKey\n            }), i;\n          };\n        t.parseConvTransposeAttributes = e => {\n          const t = e.attributes,\n            n = (0, a.parseInternalActivationAttributes)(t),\n            o = t.getString(\"auto_pad\", \"NOTSET\"),\n            i = t.getInts(\"dilations\", [1, 1]),\n            s = t.getInt(\"group\", 1),\n            u = t.getInts(\"kernel_shape\", []),\n            l = t.getInts(\"output_padding\", [0, 0]),\n            c = t.getInts(\"output_shape\", []),\n            p = t.getInts(\"pads\", [0, 0, 0, 0]),\n            d = t.getInts(\"strides\", [1, 1]);\n          return (0, r.createAttributeWithCacheKey)(Object.assign({\n            autoPad: o,\n            dilations: i,\n            group: s,\n            kernelShape: u,\n            outputPadding: l,\n            outputShape: c,\n            pads: p,\n            strides: d\n          }, n));\n        };\n        const d = (e, t) => {\n          if (!e || 2 !== e.length && 3 !== e.length) throw new Error(\"Conv requires 2 or 3 inputs\");\n          if (4 !== e[0].dims.length || 4 !== e[1].dims.length) throw new Error(\"currently only support 2-dimensional conv\");\n          if (e[0].dims[1] !== e[1].dims[0]) throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");\n          const n = e[1].dims[1] * t.group;\n          if (3 === e.length && (1 !== e[2].dims.length || e[2].dims[0] !== n)) throw new Error(\"invalid bias\");\n          const r = e[0].dims.length - 2;\n          if (t.dilations.length !== r) throw new Error(`dilations should be ${r}D`);\n          if (t.strides.length !== r) throw new Error(`strides should be ${r}D`);\n          if (t.pads.length !== 2 * r) throw new Error(`pads should be ${2 * r}D`);\n          if (t.outputPadding.length !== r) throw new Error(`output_padding should be ${r}D`);\n          if (0 !== t.kernelShape.length && t.kernelShape.length !== e[1].dims.length - 2) throw new Error(\"invalid kernel shape\");\n          if (0 !== t.outputShape.length && t.outputShape.length !== e[0].dims.length - 2) throw new Error(\"invalid output shape\");\n          if (\"float32\" !== e[0].type || \"float32\" !== e[1].type) throw new Error(\"ConvTranspose input(X,W) should be float tensor\");\n          if (3 === e.length && \"float32\" !== e[2].type) throw new Error(\"ConvTranspose input(bias) should be float tensor\");\n        };\n      },\n      9754: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.parseConvAttributes = t.conv = t.calculateOutputShape = void 0;\n        const r = n(4910),\n          o = n(7273),\n          i = n(7825),\n          a = n(7708),\n          s = n(3281),\n          u = n(2150),\n          l = n(1625),\n          c = n(8276);\n        t.calculateOutputShape = (e, t, n, r, o) => {\n          const i = e[0],\n            a = e.slice(2),\n            s = a.length,\n            u = t[0],\n            l = t.slice(2).map((e, t) => e + (e - 1) * (n[t] - 1)),\n            c = a.map((e, t) => e + r[t] + r[t + s]).map((e, t) => Math.floor((e - l[t] + o[t]) / o[t]));\n          return [i, u].concat(...c);\n        }, t.conv = (e, t, n) => (g(t, n), p(e, t, n));\n        const p = (e, t, n) => {\n            const r = h(n, t),\n              o = e.session.pack,\n              s = 1 === r.kernelShape[0] && 1 === r.kernelShape[1];\n            return r.group > 1 ? [e.run((0, i.createUnpackedGroupedConvProgramInfoLoader)(e, t, r), t)] : s && o ? [d(e, t, r)] : o && 4 === t[0].dims.length && 1 === t[0].dims[0] && !s ? [(0, a.conv2DPacked)(e, t, r)] : [f(e, t, r)];\n          },\n          d = (e, n, r) => {\n            const o = n[0].dims,\n              i = n[1].dims,\n              a = (0, t.calculateOutputShape)(o, i, r.dilations, r.pads, r.strides),\n              s = e.reshapeUnpacked(n[0], [o[1], o[2] * o[3]]),\n              u = e.reshapeUnpacked(n[1], [i[0], i[1]]),\n              l = n.length > 2 ? [u, s, n[2]] : [u, s],\n              p = e.run((0, c.createMatmulProgramInfoLoader)(l, r), l);\n            return e.reshapeUnpacked(p, a);\n          },\n          f = (e, n, r) => {\n            const o = n[0].dims,\n              i = n[1].dims,\n              a = (0, t.calculateOutputShape)(o, i, r.dilations, r.pads, r.strides),\n              u = e.run((0, l.createIm2ColProgramInfoLoader)(e, n[0], n[1], a, r), [n[0]]),\n              c = 3 === n.length ? [u, n[1], n[2]] : [u, n[1]];\n            return e.run((0, s.createDotProductProgramInfoLoader)(e, n, a, r), c);\n          },\n          h = (e, t) => {\n            const n = e.kernelShape.slice();\n            if (0 === e.kernelShape.length) for (let e = 2; e < t[1].dims.length; ++e) n.push(t[1].dims[e]);\n            const r = e.pads.slice();\n            o.PoolConvUtil.adjustPadsBasedOnAutoPad(t[0].dims, e.strides, e.dilations, n, r, e.autoPad);\n            const i = Object.assign({}, e);\n            return Object.assign(i, {\n              kernelShape: n,\n              pads: r,\n              cacheKey: e.cacheKey\n            }), i;\n          };\n        t.parseConvAttributes = e => {\n          const t = e.attributes,\n            n = (0, u.parseInternalActivationAttributes)(t),\n            o = t.getString(\"auto_pad\", \"NOTSET\"),\n            i = t.getInts(\"dilations\", [1, 1]),\n            a = t.getInt(\"group\", 1),\n            s = t.getInts(\"kernel_shape\", []),\n            l = t.getInts(\"pads\", [0, 0, 0, 0]),\n            c = t.getInts(\"strides\", [1, 1]);\n          return (0, r.createAttributeWithCacheKey)(Object.assign({\n            autoPad: o,\n            dilations: i,\n            group: a,\n            kernelShape: s,\n            pads: l,\n            strides: c\n          }, n));\n        };\n        const g = (e, t) => {\n          if (!e || 2 !== e.length && 3 !== e.length) throw new Error(\"Conv requires 2 or 3 inputs\");\n          if (4 !== e[0].dims.length || 4 !== e[1].dims.length) throw new Error(\"currently only support 2-dimensional conv\");\n          if (e[0].dims[1] !== e[1].dims[1] * t.group) throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");\n          if (3 === e.length && (1 !== e[2].dims.length || e[1].dims[0] !== e[2].dims[0])) throw new Error(\"invalid bias\");\n          const n = e[0].dims.length - 2;\n          if (t.dilations.length !== n) throw new Error(`dilations should be ${n}D`);\n          if (t.strides.length !== n) throw new Error(`strides should be ${n}D`);\n          if (t.pads.length !== 2 * n) throw new Error(`pads should be ${2 * n}D`);\n          if (0 !== t.kernelShape.length && t.kernelShape.length !== e[1].dims.length - 2) throw new Error(\"invalid kernel shape\");\n          if (\"float32\" !== e[0].type || \"float32\" !== e[1].type) throw new Error(\"Conv input(X,W) should be float tensor\");\n          if (3 === e.length && \"float32\" !== e[2].type) throw new Error(\"Conv input(bias) should be float tensor\");\n        };\n      },\n      6742: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.parseDepthToSpaceAttributes = t.depthToSpace = void 0;\n        const r = n(5707);\n        t.depthToSpace = (e, t, n) => {\n          o(t);\n          const i = n.blocksize,\n            a = i * i,\n            s = \"DCR\" === n.mode ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3],\n            u = \"DCR\" === n.mode ? [t[0].dims[0], i, i, t[0].dims[1] / a, t[0].dims[2], t[0].dims[3]] : [t[0].dims[0], t[0].dims[1] / a, i, i, t[0].dims[2], t[0].dims[3]],\n            l = e.reshapeUnpacked(t[0], u),\n            c = {\n              perm: s,\n              cacheKey: `${s}`\n            },\n            [p] = (0, r.transpose)(e, [l], c),\n            d = [t[0].dims[0], t[0].dims[1] / a, t[0].dims[2] * i, t[0].dims[3] * i];\n          return [e.reshapeUnpacked(p, d)];\n        }, t.parseDepthToSpaceAttributes = e => {\n          const t = e.attributes.getInt(\"blocksize\");\n          if (t < 1) throw new Error(`blocksize must be >= 1, but got : ${t} for DepthToSpace`);\n          const n = e.attributes.getString(\"mode\", \"DCR\");\n          if (\"DCR\" !== n && \"CRD\" !== n) throw new Error(`unrecognized mode: ${n} for DepthToSpace`);\n          return {\n            mode: n,\n            blocksize: t\n          };\n        };\n        const o = e => {\n          if (1 !== e.length) throw new Error(`DepthToSpace expect 1 inputs, but got ${e.length}`);\n          if (\"string\" === e[0].type || 4 !== e[0].dims.length) throw new TypeError(\"DepthToSpace input should be a 4-D numeric tensor\");\n        };\n      },\n      3281: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.createDotProductProgramInfoLoader = void 0;\n        const r = n(7273),\n          o = n(6757),\n          i = n(5639),\n          a = n(2150),\n          s = n(1625);\n        t.createDotProductProgramInfoLoader = (e, t, n, u) => {\n          const l = ((e, t) => ({\n            name: \"ConvDotProduct\",\n            inputNames: e ? [\"Im2Col\", \"K\", \"B\"] : [\"Im2Col\", \"K\"],\n            inputTypes: e ? [i.TextureType.unpacked, i.TextureType.packedLastDimension, i.TextureType.unpacked] : [i.TextureType.unpacked, i.TextureType.packedLastDimension],\n            cacheKey: t.activationCacheKey\n          }))(t.length > 2, u);\n          return Object.assign(Object.assign({}, l), {\n            get: () => ((e, t, n, u, l) => {\n              const c = n[0].dims,\n                p = n[1].dims,\n                d = [p[0], Math.ceil(c[1] * p[2] * p[3] / 4)],\n                f = (0, s.calculateIm2ColDims)(c, p, u),\n                [h, g] = e.calculateTextureWidthAndHeight(d, i.TextureType.packedLastDimension),\n                b = r.ShapeUtil.computeStrides(f),\n                [m, y] = e.calculateTextureWidthAndHeight(f, i.TextureType.packedLastDimension),\n                v = u.length,\n                _ = n.length < 3 ? \"0.0\" : \"_B(b)\",\n                w = Math.ceil(c[1] * p[2] * p[3] / 4),\n                {\n                  activationFunction: T,\n                  applyActivation: x\n                } = (0, a.getActivationSnippet)(l),\n                O = (0, o.getGlsl)(e.session.backend.glContext.version),\n                S = `\\n${T}\\nfloat process(int indices[${v}]) {\\n  int b[1];\\n  b[0] = indices[1];\\n  int im2col[4];\\n  im2col[0] = indices[0];\\n  im2col[1] = indices[2];\\n  im2col[2] = indices[3];\\n  int im2colOffset = im2col[0] * ${b[0]} + im2col[1] * ${b[1]} + im2col[2] * ${b[2]};\\n  int kernelOffset = indices[1] * ${d[1]};\\n  float value = ${_};\\n  for (int i = 0; i < ${w}; ++i) {\\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${m}, ${y});\\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${h}, ${g});\\n    value += dot(${O.texture2D}(Im2Col, im2colCoords), ${O.texture2D}(K, kernelCoords));\\n    ++im2colOffset;\\n    ++kernelOffset;\\n  }\\n  ${x}\\n  return value;\\n}`;\n              return Object.assign(Object.assign({}, t), {\n                output: {\n                  dims: u,\n                  type: n[0].type,\n                  textureType: i.TextureType.unpacked\n                },\n                shaderSource: S\n              });\n            })(e, l, t, n, u)\n          });\n        };\n      },\n      4125: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.parseFlattenAttributes = t.flatten = void 0;\n        const r = n(7273);\n        t.flatten = (e, t, n) => {\n          o(t, n);\n          const i = r.ShapeUtil.flattenShape(t[0].dims, n);\n          return [e.reshapeUnpacked(t[0], i)];\n        }, t.parseFlattenAttributes = e => e.attributes.getInt(\"axis\", 1);\n        const o = (e, t) => {\n          if (!e || 1 !== e.length) throw new Error(\"Flatten requires 1 input.\");\n          const n = e[0].dims.length;\n          if (0 === n) throw new Error(\"scalar tensor is not supported.\");\n          if (t < -n || t > n) throw new Error(\"Invalid axis\");\n          if (\"string\" === e[0].type) throw new Error(\"string tensor is not supported.\");\n        };\n      },\n      2150: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.parseInternalActivationAttributes = t.getActivationSnippet = void 0;\n        const r = n(7273),\n          o = n(9087);\n        t.getActivationSnippet = function (e) {\n          let t;\n          switch (e.activation) {\n            case \"Relu\":\n              t = (0, o.glslRelu)();\n              break;\n            case \"Sigmoid\":\n              t = (0, o.glslSigmoid)();\n              break;\n            case \"Clip\":\n              t = (0, o.glslClip)(e.clipMin, e.clipMax);\n              break;\n            default:\n              return {\n                activationFunction: \"\",\n                applyActivation: \"\"\n              };\n          }\n          const n = t.name;\n          return {\n            activationFunction: t.body,\n            applyActivation: `value = ${n}_(value);`\n          };\n        }, t.parseInternalActivationAttributes = e => {\n          const t = e.getString(\"activation\", \"\");\n          if (\"Clip\" === t) {\n            const [n, o] = e.getFloats(\"activation_params\", [r.MIN_CLIP, r.MAX_CLIP]);\n            return {\n              activation: t,\n              clipMax: o,\n              clipMin: n,\n              activationCacheKey: `${t}:${n},${o}`\n            };\n          }\n          return {\n            activation: t,\n            activationCacheKey: t\n          };\n        };\n      },\n      6149: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.parseGatherAttributes = t.gather = void 0;\n        const r = n(4910),\n          o = n(6145),\n          i = n(7273),\n          a = n(5639);\n        t.gather = (e, t, n) => (l(t, n.axis), [e.run(u(e, t, n), t)]), t.parseGatherAttributes = e => (0, r.createAttributeWithCacheKey)({\n          axis: e.attributes.getInt(\"axis\", 0)\n        });\n        const s = {\n            name: \"Gather\",\n            inputNames: [\"A\", \"B\"],\n            inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked]\n          },\n          u = (e, t, n) => {\n            const r = Object.assign(Object.assign({}, s), {\n              cacheHint: n.cacheKey\n            });\n            return Object.assign(Object.assign({}, r), {\n              get: () => ((e, t, n, r) => {\n                const o = n[0].dims.slice(),\n                  s = n[1].dims.slice(),\n                  u = new Array(o.length + s.length - 1);\n                r = i.ShapeUtil.normalizeAxis(r, o.length);\n                const l = [];\n                for (let e = 0; e < u.length; e++) e < r ? (u[e] = o[e], l.push(`inputIdx[${e}] = outputIdx[${e}];`)) : e < r + s.length ? (u[e] = s[e - r], l.push(`indexDataIdx[${e - r}] = outputIdx[${e}];`)) : (u[e] = o[e - s.length + 1], l.push(`inputIdx[${e - s.length + 1}] = outputIdx[${e}];`));\n                const c = `\\n      float process(int outputIdx[${u.length || 1}]) {\\n        int inputIdx[${o.length}];\\n        int indexDataIdx[${s.length || 1}];\\n        indexDataIdx[0] = 0;\\n        ${l.join(\"\\n        \")}\\n        int idx = int(_B(indexDataIdx));\\n        inputIdx[${r}] = idx < 0 ? idx + ${o[r]} : idx;\\n        return _A(inputIdx);\\n      }`;\n                return Object.assign(Object.assign({}, t), {\n                  output: {\n                    dims: u,\n                    type: n[0].type,\n                    textureType: a.TextureType.unpacked\n                  },\n                  shaderSource: c\n                });\n              })(0, r, t, n.axis)\n            });\n          },\n          l = (e, t) => {\n            if (!e || 2 !== e.length) throw new Error(\"Gather requires 2 inputs.\");\n            const n = e[0].dims.length;\n            if (n < 1) throw new Error(\"Invalid input shape.\");\n            if (t < -n || t > n - 1) throw new Error(\"Invalid axis.\");\n            if (-1 === o.NUMBER_TYPES.indexOf(e[0].type)) throw new Error(\"Invaid input type.\");\n            if (\"int32\" !== e[1].type && \"int16\" !== e[1].type) throw new Error(\"Invaid input type.\");\n          };\n      },\n      5378: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.parseGemmAttributesV11 = t.parseGemmAttributesV7 = t.gemm = void 0;\n        const r = n(4910),\n          o = n(7273),\n          i = n(5639);\n        t.gemm = (e, t, n) => (l(t, n), [e.run(s(t, n), t)]);\n        const a = (e, t) => {\n          const n = 0 !== e.attributes.getInt(\"transA\", 0),\n            o = 0 !== e.attributes.getInt(\"transB\", 0),\n            i = e.attributes.getFloat(\"alpha\", 1),\n            a = e.attributes.getFloat(\"beta\", 1);\n          return (0, r.createAttributeWithCacheKey)({\n            transA: n,\n            transB: o,\n            alpha: i,\n            beta: a,\n            isOptionalC: t\n          });\n        };\n        t.parseGemmAttributesV7 = e => a(e, !1), t.parseGemmAttributesV11 = e => a(e, !0);\n        const s = (e, t) => {\n            const n = {\n              name: \"Gemm\",\n              inputNames: 3 === e.length ? [\"A\", \"B\", \"C\"] : [\"A\", \"B\"],\n              inputTypes: 3 === e.length ? [i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked] : [i.TextureType.unpacked, i.TextureType.unpacked],\n              key: t.cacheKey\n            };\n            return Object.assign(Object.assign({}, n), {\n              get: () => u(n, e, t)\n            });\n          },\n          u = (e, t, n) => {\n            const r = t[0].dims.slice(),\n              a = t[1].dims.slice(),\n              [s, u] = o.GemmUtil.getShapeOfGemmResult(r, n.transA, a, n.transB, 3 === t.length ? t[2].dims : void 0),\n              l = [s, u];\n            if (!l) throw new Error(\"Can't use gemm on the given tensors\");\n            let c = r[r.length - 1],\n              p = \"\";\n            n.transA && (c = r[0]), n.transA && n.transB ? p = \"value += _A_T(a) * _B_T(b);\" : n.transA && !n.transB ? p = \"value += _A_T(a) * _B(b);\" : !n.transA && n.transB ? p = \"value += _A(a) * _B_T(b);\" : n.transA || n.transB || (p = \"value += _A(a) * _B(b);\");\n            const d = l.length,\n              f = `\\n      float process(int indices[${d}]) {\\n          int a[${d}];\\n          int b[${d}];\\n          ${3 === t.length ? `int c[${t[2].dims.length}];` : \"\"}\\n\\n          copyVec(indices, a);\\n          copyVec(indices, b);\\n          ${3 === t.length ? \"bcastIndices_C(indices, c);\" : \"\"}\\n\\n          float value = 0.0;\\n          for (int k=0; k<${c}; ++k) {\\n              a[${d - 1}] = k;\\n              b[${d - 2}] = k;\\n              ${p}\\n          }\\n\\n          value = value * alpha;\\n          ${3 === t.length ? \"value += beta * _C(c);\" : \"\"}\\n          return value;\\n      }`;\n            return Object.assign(Object.assign({}, e), {\n              output: {\n                dims: l,\n                type: t[0].type,\n                textureType: i.TextureType.unpacked\n              },\n              variables: [{\n                name: \"alpha\",\n                type: \"float\",\n                data: n.alpha\n              }, {\n                name: \"beta\",\n                type: \"float\",\n                data: n.beta\n              }],\n              shaderSource: f\n            });\n          },\n          l = (e, t) => {\n            if (!e) throw new Error(\"Input is missing\");\n            if (t.isOptionalC && (e.length < 2 || e.length > 3)) throw new Error(\"Invaid input shape.\");\n            if (!t.isOptionalC && 3 !== e.length) throw new Error(\"Gemm requires 3 inputs\");\n            if (3 === e.length && 1 !== e[2].dims.length && 2 !== e[2].dims.length) throw new Error(\"Invalid input shape of C\");\n            if (\"float32\" !== e[0].type && \"float64\" !== e[0].type || \"float32\" !== e[1].type && \"float64\" !== e[1].type || 3 === e.length && \"float32\" !== e[2].type && \"float64\" !== e[2].type) throw new Error(\"Invalid input type.\");\n            if (e[0].type !== e[1].type || 3 === e.length && e[0].type !== e[2].type) throw new Error(\"Input types are mismatched\");\n          };\n      },\n      5950: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.createPackedIm2ColProgramInfoLoader = void 0;\n        const r = n(6757),\n          o = n(5639),\n          i = n(5614);\n        t.createPackedIm2ColProgramInfoLoader = (e, t, n, a, s) => {\n          const u = (l = s.cacheKey, {\n            name: \"Im2Col (packed)\",\n            inputNames: [\"A\"],\n            inputTypes: [o.TextureType.packed],\n            cacheHint: l\n          });\n          var l;\n          return Object.assign(Object.assign({}, u), {\n            get: () => ((e, t, n, a, s, u) => {\n              const l = n.dims,\n                c = a.dims,\n                p = s.length,\n                d = [c[1] * c[2] * c[3], s[2] * s[3]],\n                f = c[2] * c[3],\n                h = (0, i.unpackFromChannel)(),\n                g = (0, r.getGlsl)(e.session.backend.glContext.version);\n              let b = \"\";\n              for (let e = 0; e <= 1; e++) for (let t = 0; t <= 1; t++) b += `\\n            blockIndex = rc.x + ${t};\\n            pos = rc.y + ${e};\\n\\n            if(blockIndex < ${d[1]} && pos < ${d[0]}) {\\n              offsetY = int(blockIndex / (${s[p - 1]})) * ${u.strides[0]} -\\n                ${u.pads[0]};\\n              d0 = offsetY + ${u.dilations[0]} * (imod(pos, ${f}) / ${c[2]});\\n\\n              if(d0 < ${l[2]} && d0 >= 0) {\\n                offsetX = imod(blockIndex, ${s[p - 1]}) * ${u.strides[1]} -\\n                  ${u.pads[1]};\\n                d1 = offsetX + ${u.dilations[1]} * imod(imod(pos, ${f}), ${c[2]});\\n\\n                if(d1 < ${l[3]} && d1 >= 0) {\\n\\n                  ch = int(float(pos)/ ${f}.);\\n                    innerDims = vec2(d0, d1);\\n                    result[${2 * e + t}] = getChannel(\\n                      getA(0, ch, int(innerDims.x),\\n                      int(innerDims.y)), innerDims);\\n                }\\n              }\\n            }\\n\\n          `;\n              const m = `\\n      ${h}\\n\\n      void main() {\\n        ivec2 rc = getOutputCoords();\\n          vec4 result = vec4(0.0);\\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\\n          vec2 innerDims;\\n          ${b}\\n          ${g.output} = result;\\n      }\\n            `;\n              return Object.assign(Object.assign({}, t), {\n                output: {\n                  dims: d,\n                  type: n.type,\n                  textureType: o.TextureType.packed\n                },\n                shaderSource: m,\n                hasMain: !0\n              });\n            })(e, u, t, n, a, s)\n          });\n        };\n      },\n      1625: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.calculateIm2ColDims = t.createIm2ColProgramInfoLoader = void 0;\n        const r = n(5639);\n        t.createIm2ColProgramInfoLoader = (e, n, o, i, a) => {\n          const s = (u = a.cacheKey, {\n            name: \"Im2Col\",\n            inputNames: [\"X\"],\n            inputTypes: [r.TextureType.unpacked],\n            cacheHint: u\n          });\n          var u;\n          return Object.assign(Object.assign({}, s), {\n            get: () => ((e, n, o, i, a, s) => {\n              const u = o.dims,\n                l = i.dims,\n                c = a.length,\n                p = (0, t.calculateIm2ColDims)(u, l, a, 4),\n                d = `\\n        const int XC = ${u[1]};\\n        const int XH = ${u[2]};\\n        const int XW = ${u[3]};\\n        const int KH = ${s.kernelShape[0]};\\n        const int KW = ${s.kernelShape[1]};\\n        const int dilationH = ${s.dilations[0]};\\n        const int dilationW = ${s.dilations[1]};\\n        const int strideH = ${s.strides[0]};\\n        const int strideW = ${s.strides[1]};\\n        const int padH = ${s.pads[0]};\\n        const int padW = ${s.pads[1]};\\n        const int KHKW = KH*KW;\\n        const int XCKHKW = XC * KHKW;\\n        const int outputChannels = 4;\\n        vec4 process(int indices[${c}]) {\\n          int b  = indices[0]; // batch size\\n          int oh = indices[1] * strideH - padH; //output height\\n          int ow = indices[2] * strideW - padW; //output width\\n          int p = indices[3] * outputChannels; //patch\\n          vec4 value = vec4(0.0);\\n          for(int i=0; i < outputChannels; ++i) {\\n            if(p < XCKHKW) {\\n              int patchC = p / KHKW;\\n              int patchH = (p - patchC*KHKW) / KW;\\n              int patchW = (p - patchC*KHKW) - patchH * KW;\\n              int xh2 = oh + patchH * dilationH;\\n              int xw2 = ow + patchW * dilationW;\\n              int x[${u.length}];\\n              x[0] = b;\\n              x[1] = patchC;\\n              x[2] = xh2;\\n              x[3] = xw2;\\n              if(xh2 >= 0 &&\\n                  xh2 < XH &&\\n                  xw2 >= 0 &&\\n                  xw2 < XW) {\\n                value[i] = _X(x);\\n              }\\n            }\\n            ++p;\\n          }\\n          return value;\\n        }\\n        `;\n              return Object.assign(Object.assign({}, n), {\n                output: {\n                  dims: p,\n                  type: o.type,\n                  textureType: r.TextureType.packedLastDimension\n                },\n                shaderSource: d\n              });\n            })(0, s, n, o, i, a)\n          });\n        }, t.calculateIm2ColDims = (e, t, n, r = 4) => [n[0], n[2], n[3], Math.ceil(e[1] * t[2] * t[3] / r)];\n      },\n      6981: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.parseImageScalerAttributes = t.imageScaler = void 0;\n        const r = n(4910),\n          o = n(5639);\n        t.imageScaler = (e, t, n) => (u(t), [e.run(a(e, t, n), t)]), t.parseImageScalerAttributes = e => {\n          const t = e.attributes.getFloat(\"scale\"),\n            n = e.attributes.getFloats(\"bias\");\n          return (0, r.createAttributeWithCacheKey)({\n            scale: t,\n            bias: n\n          });\n        };\n        const i = {\n            name: \"ImageScaler\",\n            inputNames: [\"X\"],\n            inputTypes: [o.TextureType.unpacked]\n          },\n          a = (e, t, n) => {\n            const r = Object.assign(Object.assign({}, i), {\n              cacheHint: n.cacheKey\n            });\n            return Object.assign(Object.assign({}, r), {\n              get: () => ((e, t, n, r) => {\n                const i = n[0].dims.slice(),\n                  a = i.length,\n                  u = `\\n      ${s(r.bias.length)}\\n      float process(int indices[${a}]) {\\n        return _X(indices) * scale + getBias(bias, indices[1]);\\n      }`;\n                return Object.assign(Object.assign({}, t), {\n                  output: {\n                    dims: i,\n                    type: n[0].type,\n                    textureType: o.TextureType.unpacked\n                  },\n                  variables: [{\n                    name: \"bias\",\n                    type: \"float\",\n                    arrayLength: r.bias.length,\n                    data: r.bias\n                  }, {\n                    name: \"scale\",\n                    type: \"float\",\n                    data: r.scale\n                  }],\n                  shaderSource: u\n                });\n              })(0, r, t, n)\n            });\n          },\n          s = e => {\n            const t = [`float getBias(float bias[${e}], int channel) {`];\n            for (let n = 0; n < e; ++n) 0 === n ? t.push(`\\tif (channel == ${n}) { return bias[${n}]; }`) : n === e - 1 ? t.push(`\\telse { return bias[${n}]; }`) : t.push(`\\telse if (channel == ${n}) { return bias[${n}]; }`);\n            return t.push(\"\\t}\"), t.join(\"\\n\");\n          },\n          u = e => {\n            if (!e || 1 !== e.length) throw new Error(\"ImageScaler requires 1 input.\");\n            if (4 !== e[0].dims.length) throw new Error(\"Invalid input shape.\");\n            if (\"float32\" !== e[0].type && \"float64\" !== e[0].type) throw new Error(\"Invalid input type.\");\n          };\n      },\n      7413: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.parseInstanceNormalizationAttributes = t.instanceNormalization = void 0;\n        const r = n(6757),\n          o = n(5639);\n        t.instanceNormalization = (e, t, n) => {\n          l(t);\n          const r = e.run(a(t[0]), t);\n          return [e.run(u(e, t[0], n, r.dims), [t[0], r, t[1], t[2]])];\n        }, t.parseInstanceNormalizationAttributes = e => e.attributes.getFloat(\"epsilon\", 1e-5);\n        const i = {\n            name: \"InstanceNormalization_MeanAndVariance\",\n            inputNames: [\"X\"],\n            inputTypes: [o.TextureType.unpacked]\n          },\n          a = e => Object.assign(Object.assign({}, i), {\n            get: () => ((e, t) => {\n              const n = t.dims.slice(),\n                r = n[1],\n                i = n[2] * n[3],\n                a = [n[0], r],\n                s = `\\n      vec4 process(int[2] indices) {\\n        vec4 v = vec4(0.0);\\n        int a[4];\\n        a[0] = indices[0];\\n        a[1] = indices[1];\\n        float temp = 0.0;\\n        for(int a2=0; a2<${n[2]}; a2++) {\\n          a[2] = a2;\\n          for(int a3=0; a3<${n[3]}; a3++) {\\n            a[3] = a3;\\n            float x = _X(a);\\n            temp += x;\\n          }\\n        }\\n        float mean = temp / float(${i});\\n        temp = 0.0;\\n        for(int a2=0; a2<${n[2]}; a2++) {\\n          a[2] = a2;\\n          for(int a3=0; a3<${n[3]}; a3++) {\\n            a[3] = a3;\\n            float x = _X(a);\\n            temp += (x - mean) * (x - mean);\\n          }\\n        }\\n        v.r = mean;\\n        v.g = temp / float(${i});\\n\\n        return v;\\n      }`;\n              return Object.assign(Object.assign({}, e), {\n                output: {\n                  dims: a,\n                  type: t.type,\n                  textureType: o.TextureType.packedLastDimension\n                },\n                shaderSource: s\n              });\n            })(i, e)\n          }),\n          s = {\n            name: \"InstanceNormalization_ComputeOutput\",\n            inputNames: [\"X\", \"MeanAndVariance\", \"Scale\", \"B\"],\n            inputTypes: [o.TextureType.unpacked, o.TextureType.packedLastDimension, o.TextureType.unpacked, o.TextureType.unpacked]\n          },\n          u = (e, t, n, i) => {\n            const a = Object.assign(Object.assign({}, s), {\n              cacheHint: `${n}`\n            });\n            return Object.assign(Object.assign({}, a), {\n              get: () => ((e, t, n, i, a) => {\n                const s = (0, r.getGlsl)(e.session.backend.glContext.version),\n                  [u, l] = e.calculateTextureWidthAndHeight(a, o.TextureType.packedLastDimension),\n                  [c, p] = [u / 4, l],\n                  d = `\\n      vec4 get_MeanAndVariance(int[2] mv) {\\n        int offset = indicesToOffset_MeanAndVariance(mv);\\n        vec2 coords = offsetToCoords(offset, ${c}, ${p});\\n        return ${s.texture2D}(MeanAndVariance, coords);\\n      }\\n\\n      float process(int[4] indices) {\\n        int mv[2];\\n        mv[0] = indices[0];\\n        mv[1] = indices[1];\\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\\n        float mean = mean_and_variance.r;\\n        float variance = mean_and_variance.g;\\n\\n        int sb[1];\\n        sb[0] = indices[1];\\n        float scale = _Scale(sb);\\n        float b = _B(sb);\\n\\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\\n      }`;\n                return Object.assign(Object.assign({}, t), {\n                  output: {\n                    dims: n.dims,\n                    type: n.type,\n                    textureType: o.TextureType.unpacked\n                  },\n                  variables: [{\n                    name: \"epsilon\",\n                    type: \"float\",\n                    data: i\n                  }],\n                  shaderSource: d\n                });\n              })(e, a, t, n, i)\n            });\n          },\n          l = e => {\n            if (!e || 3 !== e.length) throw new Error(\"InstanceNormalization requires 3 inputs.\");\n            const t = e[0],\n              n = e[1],\n              r = e[2];\n            if (t.dims.length < 3 || 1 !== n.dims.length || 1 !== r.dims.length) throw new Error(\"Invalid input shape.\");\n            if (n.dims[0] !== t.dims[1] || r.dims[0] !== t.dims[1]) throw new Error(\"Input shapes are mismatched.\");\n            if (\"float32\" !== t.type && \"float64\" !== t.type || \"float32\" !== n.type && \"float64\" !== n.type || \"float32\" !== r.type && \"float64\" !== r.type) throw new Error(\"Invalid input type.\");\n            if (4 !== e[0].dims.length) throw new Error(\"Only support 4-D input shape.\");\n          };\n      },\n      7006: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.createLrnProgramInfoLoader = t.parseLrnAttributes = t.lrn = void 0;\n        const r = n(4910),\n          o = n(5639);\n        t.lrn = (e, t, n) => (s(t), [e.run(a(t, n), t)]), t.parseLrnAttributes = e => {\n          const t = e.attributes.getFloat(\"alpha\", 1e-4),\n            n = e.attributes.getFloat(\"beta\", .75),\n            o = e.attributes.getFloat(\"bias\", 1),\n            i = e.attributes.getInt(\"size\");\n          return (0, r.createAttributeWithCacheKey)({\n            alpha: t,\n            beta: n,\n            bias: o,\n            size: i\n          });\n        };\n        const i = {\n          name: \"LRN\",\n          inputNames: [\"X\"],\n          inputTypes: [o.TextureType.unpacked]\n        };\n        function a(e, t) {\n          return Object.assign(Object.assign({}, i), {\n            cacheHint: t.cacheKey,\n            get: () => function (e, t) {\n              const n = e[0].dims[1],\n                r = e[0].dims.length,\n                a = -Math.floor((t.size - 1) / 2),\n                s = Math.ceil((t.size - 1) / 2),\n                u = `float(${t.alpha}) / float(${t.size})`,\n                l = `\\n    float process(int indices[${r}]) {\\n        int c = indices[1];\\n        float x = _X(indices);\\n        float square_sum = 0.0;\\n\\n        for (int i = ${a}; i <= ${s}; i++) {\\n          int idx = c + i;\\n          if (c >= 0 && c < ${n}) {\\n            indices[1] = idx;\\n            float j = _X(indices);\\n            square_sum += j * j;\\n          }\\n        }\\n        return x / pow(float(${t.bias}) + ${u} * square_sum, float(${t.beta}));\\n    }`;\n              return Object.assign(Object.assign({}, i), {\n                cacheHint: t.cacheKey,\n                output: {\n                  dims: e[0].dims,\n                  type: e[0].type,\n                  textureType: o.TextureType.unpacked\n                },\n                shaderSource: l\n              });\n            }(e, t)\n          });\n        }\n        t.createLrnProgramInfoLoader = a;\n        const s = e => {\n          if (!e || 1 !== e.length) throw new Error(\"LRN requires 1 input.\");\n          if (4 !== e[0].dims.length) throw new Error('currently only support LRN for input with \"NCHW\" format');\n          if (\"float32\" !== e[0].type) throw new Error(\"input should be float type\");\n        };\n      },\n      5632: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.createPackedMatmulProgramInfoLoader = void 0;\n        const r = n(7273),\n          o = n(6757),\n          i = n(5639),\n          a = n(432),\n          s = n(2150),\n          u = n(8276);\n        t.createPackedMatmulProgramInfoLoader = (e, t, n) => {\n          const l = (c = t.length > 2, p = n.activationCacheKey, {\n            name: \"MatMul (packed)\",\n            inputNames: c ? [\"A\", \"B\", \"Bias\"] : [\"A\", \"B\"],\n            inputTypes: c ? [i.TextureType.packed, i.TextureType.packed, i.TextureType.packed] : [i.TextureType.packed, i.TextureType.packed],\n            cacheHint: p\n          });\n          var c, p;\n          return Object.assign(Object.assign({}, l), {\n            get: () => ((e, t, n, l) => {\n              const c = n.length > 2,\n                p = c ? \"value += getBiasForMatmul();\" : \"\",\n                d = n[0].dims,\n                f = n[1].dims,\n                h = r.BroadcastUtil.calcShape(d, f, !0),\n                g = !r.ShapeUtil.areEqual(n[0].dims, n[1].dims);\n              if (!h) throw new Error(\"Can't use matmul on the given tensors\");\n              const b = d[d.length - 1],\n                m = Math.ceil(b / 2),\n                y = d.length,\n                v = f.length,\n                _ = (0, o.getGlsl)(e.session.backend.glContext.version),\n                w = (0, a.getCoordsDataType)(h.length),\n                T = h.length,\n                x = (0, a.getGlChannels)(),\n                {\n                  activationFunction: O,\n                  applyActivation: S\n                } = (0, s.getActivationSnippet)(l),\n                A = c ? `${(0, u.getBiasForMatmul)(w, x, n[2].dims, h, !0)}` : \"\",\n                P = g ? `${function (e, t, n, o) {\n                  let i = [],\n                    a = [];\n                  const s = n[0].dims,\n                    u = n[1].dims,\n                    l = s.length,\n                    c = u.length,\n                    p = o.length,\n                    d = p - l,\n                    f = p - c;\n                  i = s.map((e, n) => `coords.${t[n + d]}`), i[l - 1] = \"i*2\", i.join(\", \"), a = u.map((e, n) => `coords.${t[n + f]}`), a[c - 2] = \"i*2\", a.join(\", \");\n                  const h = r.BroadcastUtil.getBroadcastDims(s, o),\n                    g = r.BroadcastUtil.getBroadcastDims(u, o),\n                    b = h.map(e => `coords.${t[e + d]} = 0;`).join(\"\\n\"),\n                    m = g.map(e => `coords.${t[e + f]} = 0;`).join(\"\\n\"),\n                    y = `int lastDim = coords.${t[p - 1]};\\n  coords.${t[p - 1]} = coords.${t[p - 2]};\\n  coords.${t[p - 2]} = lastDim;`;\n                  return `\\nvec4 getAAtOutCoordsMatmul(int i) {\\n  ${e} coords = getOutputCoords();\\n  ${y}\\n  ${b}\\n  vec4 outputValue = getA(${i});\\n  return outputValue;\\n}\\n\\nvec4 getBAtOutCoordsMatmul(int i) {\\n  ${e} coords = getOutputCoords();\\n  ${y}\\n  ${m}\\n  vec4 outputValue = getB(${a});\\n  return outputValue;\\n}`;\n                }(w, x, n, h)}` : \"\",\n                I = g ? \"getAAtOutCoordsMatmul(i)\" : `getA(${function (e, t) {\n                  let n = \"\";\n                  for (let r = 0; r < t - 2; r++) n += `rc.${e[r]}, `;\n                  return n += `rc.${e[t - 2]}, i*2`, n;\n                }(x, y)})`,\n                E = g ? \"getBAtOutCoordsMatmul(i)\" : `getB(${function (e, t) {\n                  let n = \"\";\n                  for (let r = 0; r < t - 2; r++) n += `rc.${e[r]}, `;\n                  return n += `i*2, rc.${e[t - 1]}`, n;\n                }(x, v)})`,\n                D = `\\n            ${P}\\n            ${A}\\n            ${O}\\n            void main() {\\n              ${g ? \"\" : `${w} rc =\\n          getOutputCoords(); int lastDim = rc.${x[T - 1]}; rc.${x[T - 1]} =\\n          rc.${x[T - 2]}; rc.${x[T - 2]} = lastDim;\\n      `}\\n\\n              vec4 value = vec4(0);\\n              for (int i = 0; i < ${m}; i++) {\\n                vec4 a = ${I};\\n                vec4 b = ${E};\\n\\n                value += (a.rrbb * b.rgrg);\\n                value += (a.ggaa * b.baba);\\n              }\\n              ${p}\\n              ${S}\\n              ${_.output} = value;\\n            }`;\n              return Object.assign(Object.assign({}, t), {\n                output: {\n                  dims: h,\n                  type: n[0].type,\n                  textureType: i.TextureType.packed\n                },\n                shaderSource: D,\n                hasMain: !0\n              });\n            })(e, l, t, n)\n          });\n        };\n      },\n      8276: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getBiasForMatmul = t.createMatmulProgramInfoLoader = t.parseMatMulAttributes = t.matMul = void 0;\n        const r = n(7273),\n          o = n(5639),\n          i = n(432),\n          a = n(2150),\n          s = n(5632);\n        t.matMul = (e, t, n) => (c(t), e.session.pack ? [e.run((0, s.createPackedMatmulProgramInfoLoader)(e, t, n), t)] : [e.run(l(t, n), t)]), t.parseMatMulAttributes = e => (0, a.parseInternalActivationAttributes)(e.attributes);\n        const u = (e, t) => ({\n          name: \"MatMul\",\n          inputNames: e ? [\"A\", \"B\", \"Bias\"] : [\"A\", \"B\"],\n          inputTypes: e ? [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.unpacked],\n          cacheHint: t\n        });\n        function l(e, t) {\n          const n = u(e.length > 2, t.activationCacheKey);\n          return Object.assign(Object.assign({}, n), {\n            get: () => function (e, t, n) {\n              const s = t[0].dims,\n                u = t[1].dims,\n                l = r.BroadcastUtil.calcShape(s, u, !0);\n              if (!l) throw new Error(\"Can't use matmul on the given tensors\");\n              const c = (0, i.getCoordsDataType)(l.length),\n                d = (0, i.getGlChannels)(),\n                {\n                  activationFunction: f,\n                  applyActivation: h\n                } = (0, a.getActivationSnippet)(n),\n                g = t.length > 2,\n                b = g ? \"value += getBiasForMatmul();\" : \"\",\n                m = g ? `${p(c, d, t[2].dims, l, !1)}` : \"\",\n                y = l.length,\n                v = s.length,\n                _ = u.length,\n                w = `\\n    ${f}\\n    ${m}\\n    float process(int indices[${y}]) {\\n        int a[${v}];\\n        int b[${_}];\\n        bcastMatmulIndices_A(indices, a);\\n        bcastMatmulIndices_B(indices, b);\\n\\n        float value;\\n        for (int k=0; k<${s[s.length - 1]}; ++k) {\\n            a[${v - 1}] = k;\\n            b[${_ - 2}] = k;\\n            value += _A(a) * _B(b);\\n        }\\n        ${b}\\n        ${h}\\n        return value;\\n    }`;\n              return Object.assign(Object.assign({}, e), {\n                output: {\n                  dims: l,\n                  type: t[0].type,\n                  textureType: o.TextureType.unpacked\n                },\n                shaderSource: w\n              });\n            }(n, e, t)\n          });\n        }\n        t.createMatmulProgramInfoLoader = l;\n        const c = e => {\n          if (!e || 2 !== e.length) throw new Error(\"MatMul requires 2 inputs.\");\n          if (e[0].dims[e[0].dims.length - 1] !== e[1].dims[e[1].dims.length - 2]) throw new Error(\"shared dimension does not match.\");\n          if (\"float32\" !== e[0].type && \"float64\" !== e[0].type || \"float32\" !== e[1].type && \"float64\" !== e[1].type) throw new Error(\"inputs should be float type\");\n          if (e[0].type !== e[1].type) throw new Error(\"inputs types should match\");\n        };\n        function p(e, t, n, o, i) {\n          let a = \"\";\n          const s = n.length,\n            u = o.length,\n            l = u - s;\n          a = u < 2 && s > 0 ? \"coords\" : n.map((e, n) => `coords.${t[n + l]}`).join(\", \");\n          const c = r.BroadcastUtil.getBroadcastDims(n, o).map(e => `coords.${t[e + l]} = 0;`).join(\"\\n\");\n          let p = \"vec4(outputValue.xx, outputValue.yy)\";\n          return 1 === r.ShapeUtil.size(n) && (p = \"vec4(outputValue.x)\"), i ? `\\nvec4 getBiasForMatmul() {\\n  ${e} coords = getOutputCoords();\\n  ${c}\\n  vec4 outputValue = getBias(${a});\\n  return ${p};\\n}` : `\\nfloat getBiasForMatmul() {\\n  ${e} coords = getOutputCoords();\\n  ${c}\\n  return getBias(coords.x);\\n}`;\n        }\n        t.getBiasForMatmul = p;\n      },\n      9: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.createPackProgramInfoLoader = void 0;\n        const r = n(6757),\n          o = n(5639),\n          i = n(432),\n          a = n(5614),\n          s = {\n            name: \"pack\",\n            inputNames: [\"A\"],\n            inputTypes: [o.TextureType.unpackedReversed]\n          };\n        t.createPackProgramInfoLoader = (e, t) => Object.assign(Object.assign({}, s), {\n          get: () => ((e, t) => {\n            const n = (0, r.getGlsl)(e.session.backend.glContext.version),\n              u = t.dims,\n              l = u.length,\n              c = t.dims.length,\n              p = (0, i.getCoordsDataType)(c),\n              d = (0, a.getChannels)(\"rc\", c),\n              f = (h = c, g = d, b = u[u.length - 2], m = u[u.length - 1], 0 === h || 1 === h ? \"\" : `\\n    int r = ${g[h - 2]};\\n    int c = ${g[h - 1]};\\n    int rp1 = ${g[h - 2]} + 1;\\n    int cp1 = ${g[h - 1]} + 1;\\n    bool rEdge = rp1 >= ${m};\\n    bool cEdge = cp1 >= ${b};\\n    `);\n            var h, g, b, m;\n            let y;\n            y = 0 === l ? [1, 1] : 1 === l ? [u[0], 1] : [u[c - 1], u[c - 2]];\n            const v = function (e, t, n) {\n                if (0 === e) return \"false\";\n                if (1 === e) return `rc > ${t[0]}`;\n                let r = \"\";\n                for (let o = e - 2; o < e; o++) r += `${n[o]} >= ${t[o - e + 2]}`, o < e - 1 && (r += \"||\");\n                return r;\n              }(c, y, d),\n              _ = function (e, t) {\n                const n = e.length;\n                if (0 === n) return \"getA(), 0, 0, 0\";\n                if (1 === n) return `getA(rc),\\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\\n            0, 0`;\n                let r = \"\";\n                if (n > 2) for (let e = 0; e < n - 2; ++e) r += `${t[e]},`;\n                return `getA(${r}r, c),\\n          rEdge ? 0. : getA(${r}rp1, c),\\n          cEdge ? 0. : getA(${r}r, cp1),\\n          rEdge || cEdge ? 0. : getA(${r}rp1, cp1)`;\n              }(u, d),\n              w = `\\n        void main() {\\n          ${p} rc = getOutputCoords();\\n\\n          if(${v}) {\\n            ${n.output} = vec4(0);\\n          } else {\\n            ${f}\\n\\n            ${n.output} = vec4(${_});\\n          }\\n        }\\n      `;\n            return Object.assign(Object.assign({}, s), {\n              hasMain: !0,\n              output: {\n                dims: t.dims,\n                type: t.type,\n                textureType: o.TextureType.packed\n              },\n              shaderSource: w\n            });\n          })(e, t)\n        });\n      },\n      5614: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.unpackFromChannel = t.getChannels = t.getVecChannels = void 0;\n        const r = n(432);\n        function o(e, t) {\n          return (0, r.getGlChannels)(t).map(t => `${e}.${t}`);\n        }\n        t.getVecChannels = o, t.getChannels = function (e, t) {\n          return 1 === t ? [e] : o(e, t);\n        }, t.unpackFromChannel = function () {\n          return \"\\n    float getChannel(vec4 frag, int dim) {\\n      int modCoord = imod(dim, 2);\\n      return modCoord == 0 ? frag.r : frag.g;\\n    }\\n\\n    float getChannel(vec4 frag, vec2 innerDims) {\\n      vec2 modCoord = mod(innerDims, 2.);\\n      return modCoord.x == 0. ?\\n        (modCoord.y == 0. ? frag.r : frag.g) :\\n        (modCoord.y == 0. ? frag.b : frag.a);\\n    }\\n  \";\n        };\n      },\n      5565: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.parsePadAttributesV11 = t.padV11 = t.parsePadAttributesV2 = t.padV2 = void 0;\n        const r = n(4910),\n          o = n(7273),\n          i = n(6757),\n          a = n(5639),\n          s = {\n            name: \"Pad\",\n            inputNames: [\"A\"],\n            inputTypes: [a.TextureType.unpacked]\n          };\n        t.padV2 = (e, t, n) => (c(t), [e.run(Object.assign(Object.assign({}, s), {\n          cacheHint: n.cacheKey,\n          get: () => l(e, t[0], n)\n        }), t)]), t.parsePadAttributesV2 = e => {\n          const t = e.attributes.getString(\"mode\", \"constant\"),\n            n = e.attributes.getFloat(\"value\", 0),\n            o = e.attributes.getInts(\"pads\");\n          return (0, r.createAttributeWithCacheKey)({\n            mode: t,\n            value: n,\n            pads: o\n          });\n        }, t.padV11 = (e, n, r) => {\n          p(n);\n          const o = u(e, n, r);\n          return (0, t.padV2)(e, [n[0]], o);\n        }, t.parsePadAttributesV11 = e => e.attributes.getString(\"mode\", \"constant\");\n        const u = (e, t, n) => {\n            if (!e.session.isInitializer(t[1].dataId) || t.length >= 3 && !e.session.isInitializer(t[2].dataId)) throw new Error(\"dynamic pad attributes are not allowed\");\n            const o = Array.from(t[1].integerData),\n              i = t.length >= 3 ? t[2].floatData[0] : 0;\n            return (0, r.createAttributeWithCacheKey)({\n              mode: n,\n              pads: o,\n              value: i\n            });\n          },\n          l = (e, t, n) => {\n            const r = o.ShapeUtil.padShape(t.dims.slice(), n.pads),\n              i = r.length,\n              s = `\\n      ${d(e, t, n)}\\n      float process(int[${i}] indices) {\\n          return padA(indices);\\n      }`;\n            return {\n              name: \"Pad\",\n              inputNames: [\"A\"],\n              inputTypes: [a.TextureType.unpacked],\n              output: {\n                dims: r,\n                type: t.type,\n                textureType: a.TextureType.unpacked\n              },\n              shaderSource: s\n            };\n          },\n          c = e => {\n            if (!e || 1 !== e.length) throw new Error(\"Pad requires 1 input\");\n            if (\"float32\" !== e[0].type && \"float64\" !== e[0].type) throw new Error(\"Invalid input type.\");\n          },\n          p = e => {\n            if (!e || 2 !== e.length && 3 !== e.length) throw new Error(\"Pad requires 2 or 3 inputs\");\n            if (\"int32\" !== e[1].type) throw new Error(\"Invalid input type.\");\n            if (e.length >= 3 && \"string\" === e[2].type) throw new Error(\"Invalid input type.\");\n          },\n          d = (e, t, n) => {\n            const r = (0, i.getGlsl)(e.session.backend.glContext.version),\n              [s, u] = e.calculateTextureWidthAndHeight(t.dims, a.TextureType.unpacked),\n              l = o.ShapeUtil.computeStrides(t.dims);\n            switch (n.mode) {\n              case \"constant\":\n                return f(r, t.dims, l, s, u, n.pads, n.value);\n              case \"reflect\":\n                return h(r, t.dims, l, s, u, n.pads);\n              case \"edge\":\n                return g(r, t.dims, l, s, u, n.pads);\n              default:\n                throw new Error(\"Invalid mode\");\n            }\n          },\n          f = (e, t, n, r, o, i, a) => {\n            const s = t.length;\n            let u = \"\";\n            for (let e = s - 1; e >= 0; --e) u += `\\n        k = m[${e}] - ${i[e]};\\n        if (k < 0)  return constant;\\n        if (k >= ${t[e]}) return constant;\\n        offset += k * ${n[e]};\\n        `;\n            return `\\n      float padA(int m[${s}]) {\\n        const float constant = float(${a});\\n        int offset = 0;\\n        int k = 0;\\n        ${u}\\n        vec2 coords = offsetToCoords(offset, ${r}, ${o});\\n        float value = getColorAsFloat(${e.texture2D}(A, coords));\\n        return value;\\n      }\\n      `;\n          },\n          h = (e, t, n, r, o, i) => {\n            const a = t.length;\n            let s = \"\";\n            for (let e = a - 1; e >= 0; --e) s += `\\n        k = m[${e}] - ${i[e]};\\n        if (k < 0) { k = -k; }\\n        {\\n          const int _2n_1 = ${2 * (t[e] - 1)};\\n          k = int( mod( float(k), float(_2n_1) ) ) ;\\n          if(k >= ${t[e]}) { k = _2n_1 - k; }\\n        }\\n        offset += k * ${n[e]};\\n        `;\n            return `\\n      float padA(int m[${a}]) {\\n        int offset = 0;\\n        int k = 0;\\n        ${s}\\n        vec2 coords = offsetToCoords(offset, ${r}, ${o});\\n        float value = getColorAsFloat(${e.texture2D}(A, coords));\\n        return value;\\n      }\\n      `;\n          },\n          g = (e, t, n, r, o, i) => {\n            const a = t.length;\n            let s = \"\";\n            for (let e = a - 1; e >= 0; --e) s += `\\n        k = m[${e}] - ${i[e]};\\n        if (k < 0)  k = 0;\\n        if (k >= ${t[e]}) k = ${t[e] - 1};\\n        offset += k * ${n[e]};\\n      `;\n            return `\\n      float padA(int m[${a}]) {\\n        int offset = 0;\\n        int k = 0;\\n        ${s}\\n        vec2 coords = offsetToCoords(offset, ${r}, ${o});\\n        float value = getColorAsFloat(${e.texture2D}(A, coords));\\n        return value;\\n      }\\n      `;\n          };\n      },\n      2834: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.globalMaxPool = t.parseMaxPoolAttributes = t.maxPool = t.parseGlobalAveragePoolAttributes = t.globalAveragePool = t.parseAveragePoolAttributes = t.averagePool = void 0;\n        const r = n(4910),\n          o = n(7273),\n          i = n(5639);\n        t.averagePool = (e, t, n) => {\n          p(t);\n          const r = {\n            name: \"AveragePool\",\n            inputNames: [\"X\"],\n            inputTypes: [i.TextureType.unpacked],\n            cacheHint: n.cacheKey\n          };\n          return [e.run(Object.assign(Object.assign({}, r), {\n            get: () => a(t, r, !1, n)\n          }), t)];\n        }, t.parseAveragePoolAttributes = e => {\n          const t = e.attributes.getString(\"auto_pad\", \"NOTSET\"),\n            n = e.attributes.getInt(\"ceil_mode\", 0),\n            o = 0 !== e.attributes.getInt(\"count_include_pad\", 0),\n            i = e.attributes.getInts(\"kernel_shape\"),\n            a = e.attributes.getInts(\"strides\", []),\n            s = e.attributes.getInts(\"pads\", []);\n          if (0 !== n) throw new Error(\"using ceil() in shape computation is not yet supported for AveragePool\");\n          return (0, r.createAttributeWithCacheKey)({\n            autoPad: t,\n            ceilMode: n,\n            countIncludePad: o,\n            kernelShape: i,\n            strides: a,\n            pads: s\n          });\n        };\n        const a = (e, t, n, r) => {\n          const [a, s] = u(e, r, n),\n            l = o.ShapeUtil.size(a.kernelShape);\n          let c = \"\";\n          a.countIncludePad ? c += `value /= float(${l});` : c += `value /= float(${l} - pad);`;\n          const p = `\\n        ${d(e[0].dims, a, \"value += _X(x);\", c, \"0.0\")}\\n      `;\n          return Object.assign(Object.assign({}, t), {\n            output: {\n              dims: s,\n              type: e[0].type,\n              textureType: i.TextureType.unpacked\n            },\n            shaderSource: p\n          });\n        };\n        t.globalAveragePool = (e, t, n) => {\n          p(t);\n          const r = {\n            name: \"GlobalAveragePool\",\n            inputNames: [\"X\"],\n            inputTypes: [i.TextureType.unpacked],\n            cacheHint: `${n.countIncludePad}`\n          };\n          return [e.run(Object.assign(Object.assign({}, r), {\n            get: () => a(t, r, !0, n)\n          }), t)];\n        }, t.parseGlobalAveragePoolAttributes = e => {\n          const t = 0 !== e.attributes.getInt(\"count_include_pad\", 0);\n          return (0, r.createAttributeWithCacheKey)({\n            autoPad: \"\",\n            ceilMode: 0,\n            countIncludePad: t,\n            kernelShape: [],\n            strides: [],\n            pads: []\n          });\n        }, t.maxPool = (e, t, n) => {\n          p(t);\n          const r = {\n            name: \"MaxPool\",\n            inputNames: [\"X\"],\n            inputTypes: [i.TextureType.unpacked],\n            cacheHint: n.cacheKey\n          };\n          return [e.run(Object.assign(Object.assign({}, r), {\n            get: () => s(t, r, !1, n)\n          }), t)];\n        }, t.parseMaxPoolAttributes = e => {\n          const t = e.attributes.getString(\"auto_pad\", \"NOTSET\"),\n            n = e.attributes.getInt(\"ceil_mode\", 0),\n            o = e.attributes.getInts(\"kernel_shape\"),\n            i = e.attributes.getInts(\"strides\", []),\n            a = e.attributes.getInts(\"pads\", []),\n            s = e.attributes.getInt(\"storage_order\", 0),\n            u = e.attributes.getInts(\"dilations\", []);\n          if (0 !== s) throw new Error(\"column major storage order is not yet supported for MaxPool\");\n          if (0 !== n) throw new Error(\"using ceil() in shape computation is not yet supported for MaxPool\");\n          return (0, r.createAttributeWithCacheKey)({\n            autoPad: t,\n            ceilMode: n,\n            countIncludePad: !1,\n            kernelShape: o,\n            strides: i,\n            pads: a,\n            storageOrder: s,\n            dilations: u\n          });\n        };\n        const s = (e, t, n, r) => {\n            const [o, a] = u(e, r, n),\n              s = `\\n      ${d(e[0].dims, o, \"\\n      value = max(_X(x), value);\\n    \", \"\", \"-1e5\")}\\n    `;\n            return Object.assign(Object.assign({}, t), {\n              output: {\n                dims: a,\n                type: e[0].type,\n                textureType: i.TextureType.unpacked\n              },\n              shaderSource: s\n            });\n          },\n          u = (e, t, n) => {\n            const r = e[0].dims.slice(),\n              i = Object.hasOwnProperty.call(t, \"dilations\"),\n              a = t.kernelShape.slice(),\n              s = t.strides.slice(),\n              u = i ? t.dilations.slice() : [],\n              l = t.pads.slice();\n            o.PoolConvUtil.adjustPoolAttributes(n, r, a, s, u, l);\n            const c = o.PoolConvUtil.computePoolOutputShape(n, r, s, u, a, l, t.autoPad),\n              p = Object.assign({}, t);\n            return i ? Object.assign(p, {\n              kernelShape: a,\n              strides: s,\n              pads: l,\n              dilations: u,\n              cacheKey: t.cacheKey\n            }) : Object.assign(p, {\n              kernelShape: a,\n              strides: s,\n              pads: l,\n              cacheKey: t.cacheKey\n            }), [p, c];\n          },\n          l = {\n            autoPad: \"\",\n            ceilMode: 0,\n            countIncludePad: !1,\n            kernelShape: [],\n            strides: [],\n            pads: [],\n            storageOrder: 0,\n            dilations: [],\n            cacheKey: \"\"\n          },\n          c = {\n            name: \"GlobalMaxPool\",\n            inputNames: [\"X\"],\n            inputTypes: [i.TextureType.unpacked]\n          };\n        t.globalMaxPool = (e, t) => (p(t), [e.run(Object.assign(Object.assign({}, c), {\n          get: () => s(t, c, !0, l)\n        }), t)]);\n        const p = e => {\n            if (!e || 1 !== e.length) throw new Error(\"Pool ops requires 1 input.\");\n            if (\"float32\" !== e[0].type && \"float64\" !== e[0].type) throw new Error(\"Invalid input type.\");\n          },\n          d = (e, t, n, r, i) => {\n            const a = e.length;\n            if (t.kernelShape.length <= 2) {\n              const o = t.kernelShape[t.kernelShape.length - 1],\n                s = t.strides[t.strides.length - 1],\n                u = t.pads[t.pads.length / 2 - 1],\n                l = t.pads[t.pads.length - 1],\n                c = e[a - 1];\n              let p = \"\",\n                d = \"\",\n                f = \"\";\n              if (p = u + l !== 0 ? `\\n          for (int i = 0; i < ${o}; i++) {\\n            x[${a} - 1] = indices[${a} - 1] * ${s} - ${u} + i;\\n            if (x[${a} - 1] < 0 || x[${a} - 1] >= ${c}) {\\n              pad++;\\n              continue;\\n            }\\n            ${n}\\n          }` : `\\n          for (int i = 0; i < ${o}; i++) {\\n            x[${a} - 1] = indices[${a} - 1] * ${s} - ${u} + i;\\n            ${n}\\n          }`, 2 === t.kernelShape.length) {\n                const n = t.kernelShape[t.kernelShape.length - 2],\n                  r = t.strides[t.strides.length - 2],\n                  i = t.pads[t.pads.length / 2 - 2],\n                  s = t.pads[t.pads.length - 2],\n                  u = e[a - 2];\n                d = i + s !== 0 ? `\\n            for (int j = 0; j < ${n}; j++) {\\n              x[${a} - 2] = indices[${a} - 2] * ${r} - ${i} + j;\\n              if (x[${a} - 2] < 0 || x[${a} - 2] >= ${u}) {\\n                pad+= ${o};\\n                continue;\\n              }\\n          ` : `\\n            for (int j = 0; j < ${n}; j++) {\\n              x[${a} - 2] = indices[${a} - 2] * ${r} - ${i} + j;\\n            `, f = \"\\n          }\\n        \";\n              }\n              return `\\n        float process(int indices[${a}]) {\\n          int x[${a}];\\n          copyVec(indices, x);\\n\\n          float value = ${i};\\n          int pad = 0;\\n          ${d}\\n          ${p}\\n          ${f}\\n          ${r}\\n          return value;\\n        }\\n      `;\n            }\n            {\n              const s = o.ShapeUtil.size(t.kernelShape),\n                u = o.ShapeUtil.computeStrides(t.kernelShape),\n                l = u.length,\n                c = t.pads.length,\n                p = h(l),\n                d = f(e, \"inputDims\"),\n                g = f(t.pads, \"pads\"),\n                b = f(u, \"kernelStrides\"),\n                m = f(t.strides, \"strides\");\n              let y = \"\";\n              return y = t.pads.reduce((e, t) => e + t) ? `\\n            if (x[j] >= inputDims[j] || x[j] < 0) {\\n              pad++;\\n              isPad = true;\\n              break;\\n            }\\n          }\\n          if (!isPad) {\\n            ${n}\\n          }` : `\\n          }\\n          ${n}\\n        `, `\\n        ${p}\\n        float process(int indices[${a}]) {\\n          int x[${a}];\\n          copyVec(indices, x);\\n          int offset[${l}];\\n          int pads[${c}];\\n          int inputDims[${a}];\\n          int kernelStrides[${l}];\\n          int strides[${l}];\\n          ${g}\\n          ${d}\\n          ${m}\\n          ${b}\\n\\n          float value = ${i};\\n          int pad = 0;\\n          bool isPad = false;\\n          for (int i = 0; i < ${s}; i++) {\\n            offsetToIndices(i, kernelStrides, offset);\\n            isPad = false;\\n            for (int j = ${a} - ${l}; j < ${a}; j++) {\\n              x[j] = indices[j] * strides[j - ${a} + ${l}]\\n                + offset[j - ${a} + ${l}] - pads[j - 2];\\n              ${y}\\n          }\\n          ${r}\\n\\n          return value;\\n        }\\n      `;\n            }\n          },\n          f = (e, t) => {\n            let n = \"\";\n            for (let r = 0; r < e.length; r++) n += `\\n      ${t}[${r}] = ${e[r]};\\n    `;\n            return n;\n          },\n          h = e => `\\n  void offsetToIndices(int offset, int[${e}] strides, out int[${e}] indices) {\\n    if (${e} == 0) {\\n      return;\\n    }\\n    for (int i = 0; i < ${e} - 1; ++i) {\\n      indices[i] = offset / strides[i];\\n      offset -= indices[i] * strides[i];\\n    }\\n    indices[${e} - 1] = offset;\\n  }`;\n      },\n      1010: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.reduceLogSumSquare = t.reduceLogSum = t.reduceProd = t.reduceMin = t.reduceMax = t.reduceMean = t.reduceSum = t.parseReduceAttributes = void 0;\n        const r = n(4910),\n          o = n(6145),\n          i = n(7273),\n          a = n(5639),\n          s = (e, t, n, r, o) => {\n            l(t);\n            const i = {\n              name: r,\n              inputNames: [\"A\"],\n              inputTypes: [a.TextureType.unpacked]\n            };\n            return [e.run(Object.assign(Object.assign({}, i), {\n              cacheHint: n.cacheKey,\n              get: () => u(e, t, n, r, o, i)\n            }), t)];\n          };\n        t.parseReduceAttributes = e => {\n          const t = e.attributes.getInts(\"axes\", []),\n            n = 1 === e.attributes.getInt(\"keepdims\", 1);\n          return (0, r.createAttributeWithCacheKey)({\n            axes: t,\n            keepDims: n\n          });\n        };\n        const u = (e, t, n, r, o, s) => {\n            const u = [],\n              l = t[0].dims.length || 1,\n              c = [],\n              p = i.ShapeUtil.normalizeAxes(n.axes, t[0].dims.length),\n              d = o(t, p);\n            let f = d[1];\n            for (let e = 0; e < t[0].dims.length; e++) p.indexOf(e) >= 0 || 0 === p.length ? (n.keepDims && u.push(1), f = `\\n          for(int j${e} = 0; j${e} < ${t[0].dims[e]}; j${e}++) {\\n            inputIdx[${e}] = j${e};\\n            ${f}\\n          }`) : (c.push(`inputIdx[${e}] = outputIdx[${u.length}];`), u.push(t[0].dims[e]));\n            const h = `\\n      float process(int outputIdx[${u.length || 1}]) {\\n        float value;                 // final result\\n        int inputIdx[${l}];      // addressing input data\\n        ${c.join(\"\\n\")}\\n        ${d[0]}       // init ops for reduce max/min\\n        ${f}\\n        ${d[2]}       // final computation for reduce mean\\n        return value;\\n      }`;\n            return Object.assign(Object.assign({}, s), {\n              output: {\n                dims: u,\n                type: t[0].type,\n                textureType: a.TextureType.unpacked\n              },\n              shaderSource: h\n            });\n          },\n          l = e => {\n            if (!e || 1 !== e.length) throw new Error(\"Reduce op requires 1 input.\");\n            if (-1 === o.NUMBER_TYPES.indexOf(e[0].type)) throw new Error(\"Invalid input type.\");\n          };\n        t.reduceSum = (e, t, n) => s(e, t, n, \"ReduceSum\", () => [\"value = 0.0;\", \"value += _A(inputIdx);\", \"\"]), t.reduceMean = (e, t, n) => s(e, t, n, \"ReduceMean\", (e, t) => {\n          let n = 1;\n          for (let r = 0; r < e[0].dims.length; r++) (t.indexOf(r) >= 0 || 0 === t.length) && (n *= e[0].dims[r]);\n          return [\"value = 0.0;\", \"value += _A(inputIdx);\", `value /= ${n}.;`];\n        }), t.reduceMax = (e, t, n) => s(e, t, n, \"ReduceMax\", (e, t) => {\n          const n = [];\n          for (let r = 0; r < e[0].dims.length; r++) (t.indexOf(r) >= 0 || 0 === t.length) && n.push(`inputIdx[${r}] = 0;`);\n          return [`${n.join(\"\\n\")}\\nvalue = _A(inputIdx);`, \"value = max(value, _A(inputIdx));\", \"\"];\n        }), t.reduceMin = (e, t, n) => s(e, t, n, \"ReduceMin\", (e, t) => {\n          const n = [];\n          for (let r = 0; r < e[0].dims.length; r++) (t.indexOf(r) >= 0 || 0 === t.length) && n.push(`inputIdx[${r}] = 0;`);\n          return [`${n.join(\"\\n\")}\\nvalue = _A(inputIdx);`, \"value = min(value, _A(inputIdx));\", \"\"];\n        }), t.reduceProd = (e, t, n) => s(e, t, n, \"ReduceProd\", () => [\"value = 1.0;\", \"value *= _A(inputIdx);\", \"\"]), t.reduceLogSum = (e, t, n) => s(e, t, n, \"ReduceLogSum\", () => [\"value = 0.0;\", \"value += _A(inputIdx);\", \"value = log(value);\"]), t.reduceLogSumSquare = (e, t, n) => s(e, t, n, \"ReduceLogSumSquare\", () => [\"float t; value = 0.0;\", \"t = _A(inputIdx); value += t * t;\", \"\"]);\n      },\n      7379: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.isReshapeCheap = t.processDims3D = t.createPackedReshape3DProgramInfoLoader = void 0;\n        const r = n(7273),\n          o = n(6757),\n          i = n(5639),\n          a = n(5614);\n        t.createPackedReshape3DProgramInfoLoader = (e, t, n) => {\n          const s = (e => ({\n            name: \"Reshape (packed)\",\n            inputTypes: [i.TextureType.packed],\n            inputNames: [\"A\"],\n            cacheHint: `${e}`\n          }))(n);\n          return Object.assign(Object.assign({}, s), {\n            get: () => ((e, t, n, s) => {\n              const u = t.dims,\n                l = s;\n              let c = \"\";\n              for (let e = 0; e < 4; e++) {\n                let t = \"\";\n                switch (e) {\n                  case 0:\n                    t = \"outputCoords = rc;\";\n                    break;\n                  case 1:\n                    t = \"outputCoords = ivec3(rc.x, rc.y+1, rc.z);\";\n                    break;\n                  case 2:\n                    t = \"outputCoords = ivec3(rc.x, rc.y, rc.z+1);\";\n                    break;\n                  case 3:\n                    t = \"outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);\";\n                    break;\n                  default:\n                    throw new Error();\n                }\n                c += `\\n        ${t}\\n        ${e > 0 ? \"if(outputCoords.y < rows && outputCoords.z < cols){\" : \"\"}\\n          int flattenedIndex = getFlattenedIndex(outputCoords);\\n\\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\\n\\n          result[${e}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\\n\\n        ${e > 0 ? \"}\" : \"\"}\\n      `;\n              }\n              const p = (0, o.getGlsl)(e.session.backend.glContext.version),\n                d = `\\n      ${function (e) {\n                  const t = r.ShapeUtil.computeStrides(e),\n                    n = [\"b\", \"r\", \"c\"],\n                    o = \"index\";\n                  return `\\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\\n      ${t.map((e, r) => `int ${n[r]} = ${o} / ${e}; ${r === t.length - 1 ? `int ${n[r + 1]} = ${o} - ${n[r]} * ${e}` : `index -= ${n[r]} * ${e}`};`).join(\"\")}\\n      return ivec3(b, r, c);\\n    }\\n  `;\n                }(u)}\\n      ${function (e) {\n                  const t = r.ShapeUtil.computeStrides(e);\n                  return `\\n  int getFlattenedIndex(ivec3 coords) {\\n    // reverse y, z order\\n    return coords.x * ${t[0]} + coords.z * ${t[1]} + coords.y;\\n  }\\n`;\n                }(l)}\\n      ${(0, a.unpackFromChannel)()}\\n\\n      void main() {\\n        ivec3 rc = getOutputCoords();\\n\\n        vec4 result = vec4(0.0);\\n\\n        ivec3 outputCoords;\\n        int rows = ${l[2]};\\n        int cols = ${l[1]};\\n\\n        ${c}\\n        ${p.output} = result;\\n      }\\n    `;\n              return Object.assign(Object.assign({}, n), {\n                output: {\n                  dims: l,\n                  type: t.type,\n                  textureType: i.TextureType.packed\n                },\n                shaderSource: d,\n                hasMain: !0\n              });\n            })(e, t, s, n)\n          });\n        }, t.processDims3D = function (e) {\n          if (0 === e.length) return [1, 1, 1];\n          let t = 1;\n          for (let n = 0; n < e.length - 2; ++n) t *= e[n];\n          return [t, e.length > 1 ? e[e.length - 2] : 1, e[e.length - 1]];\n        }, t.isReshapeCheap = function (e, t) {\n          let n = !1;\n          return n = 0 === e.length || 0 === t.length || (e.length < 2 || t.length < 2 ? e[e.length - 1] === t[t.length - 1] : e[e.length - 1] === t[t.length - 1] && e[e.length - 2] === t[t.length - 2]), n;\n        };\n      },\n      8126: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.reshape = void 0;\n        const r = n(7273);\n        t.reshape = (e, t) => {\n          const n = r.ShapeUtil.calculateReshapedDims(t[0].dims, t[1].integerData);\n          return e.session.pack ? [e.reshapePacked(t[0], n)] : [e.reshapeUnpacked(t[0], n)];\n        };\n      },\n      2801: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.parseResizeAttributesV11 = t.parseResizeAttributesV10 = t.resize = void 0;\n        const r = n(6757),\n          o = n(5639),\n          i = n(432),\n          a = n(5614),\n          s = n(3980),\n          u = {\n            name: \"Resize\",\n            inputNames: [\"A\"],\n            inputTypes: [o.TextureType.packed]\n          };\n        t.resize = (e, t, n) => ((0, s.validateInputs)(t, n), [e.run(Object.assign(Object.assign({}, u), {\n          cacheHint: n.cacheKey,\n          get: () => l(e, t, n)\n        }), t)]), t.parseResizeAttributesV10 = e => (0, s.parseUpsampleAttributes)(e, 10), t.parseResizeAttributesV11 = e => (0, s.parseUpsampleAttributes)(e, 11);\n        const l = (e, t, n) => {\n            const s = (0, r.getGlsl)(e.session.backend.glContext.version),\n              [l, p] = c(t, n);\n            if (l.every(e => 1 === e) && \"tf_crop_and_resize\" !== n.coordinateTransformMode) return Object.assign(Object.assign({}, u), {\n              output: {\n                dims: p,\n                type: t[0].type,\n                textureType: o.TextureType.packed\n              },\n              hasMain: !0,\n              shaderSource: `void main() {\\n                    vec4 v = ${s.texture2D}(X, TexCoords);\\n                    ${s.output} = v;\\n                }`\n            });\n            const d = p.length;\n            if (d < 2) throw new Error(`output dimension should be at least 2, but got ${d}`);\n            const f = p[d - 2],\n              h = p[d - 1],\n              g = t[0].dims;\n            if (d !== g.length) throw new Error(`output dimension should match input ${g.length}, but got ${d}`);\n            const b = g[d - 2],\n              m = g[d - 1],\n              y = l[d - 2],\n              v = l[d - 1];\n            let _ = \"\";\n            if (\"linear\" !== n.mode) throw new Error(`resize (packed) does not support mode: '${n.mode}'`);\n            switch (n.coordinateTransformMode) {\n              case \"asymmetric\":\n                _ = \"\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        return vec4(coords) / scaleWHWH;\\n                    }\\n                \";\n                break;\n              case \"half_pixel\":\n                _ = \"\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\\n                    }\\n                \";\n                break;\n              case \"pytorch_half_pixel\":\n                _ = `\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        vec4 fcoords = vec4(coords);\\n                        return vec4(\\n                            ${h}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\\n                            ${f}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\\n                            ${h}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\\n                            ${f}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\\n                          );\\n                    }\\n                `;\n                break;\n              case \"align_corners\":\n                _ = `\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        vec4 resized = vec4(${h}.0 - 1.0, ${f}.0 - 1.0, ${h}.0 - 1.0,\\n                            ${f}.0 - 1.0);\\n                        vec4 original = vec4(${m}.0 - 1.0, ${b}.0 - 1.0, ${m}.0 - 1.0,\\n                            ${b}.0 - 1.0);\\n                        vec4 new_scale = original / resized;\\n                        return vec4(coords) * new_scale;\\n                    }\\n                `;\n                break;\n              default:\n                throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n.coordinateTransformMode}'`);\n            }\n            const w = (0, i.getCoordsDataType)(d),\n              T = `\\n            const vec2 inputWH = vec2(${b}.0, ${m}.0);\\n            const vec4 scaleWHWH = vec4(float(${y}), float(${v}), float(${y}), float(${v}));\\n            ${(0, a.unpackFromChannel)()}\\n            ${_}\\n            float getAValue(int x10, int r, int c, int d) {\\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\\n            }\\n            void main() {\\n                ${w} rc = getOutputCoords();\\n\\n                int batch = rc[0];\\n                int depth = rc[1];\\n\\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\\n\\n                // calculate the source index in fraction\\n                vec4 sourceFrac = getSourceFracIndex(coords);\\n\\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\\n\\n                bool hasNextRow = rc.w < ${f - 1};\\n                bool hasNextCol = rc.z < ${h - 1};\\n\\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\\n                vec4 topLeft = vec4(\\n                    getAValue(batch, depth, x00.x, x00.y),\\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\\n\\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\\n                vec4 topRight = vec4(\\n                    getAValue(batch, depth, x00.x, x00.w),\\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\\n\\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\\n                vec4 bottomLeft = vec4(\\n                    getAValue(batch, depth, x00.z, x00.y),\\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\\n\\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\\n                vec4 bottomRight = vec4(\\n                    getAValue(batch, depth, x00.z, x00.w),\\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\\n\\n                // calculate the interpolation fraction on u and v direction\\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\\n\\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\\n\\n                ${s.output} = vec4(newValue);\\n            }\\n        `;\n            return Object.assign(Object.assign({}, u), {\n              output: {\n                dims: p,\n                type: t[0].type,\n                textureType: o.TextureType.packed\n              },\n              hasMain: !0,\n              shaderSource: T\n            });\n          },\n          c = (e, t) => {\n            const n = e[0].dims;\n            let r,\n              o = t.scales;\n            if (0 === o.length) {\n              const i = e[t.scalesInputIdx];\n              if (i && 0 !== i.size) {\n                if (e[t.sizesInputIdx]) throw new Error(\"Only one of scales or sizes must be provided as input.\");\n                o = p(i, t.mode, t.isResize);\n              } else {\n                const i = e[t.sizesInputIdx];\n                if (!i || 0 === i.size) throw new Error(\"Either scales or sizes MUST be provided as input.\");\n                r = Array.from(i.integerData), o = d(r, n, t.mode, t.isResize);\n              }\n            } else if (e[t.sizesInputIdx]) throw new Error(\"Only one of scales or sizes must be provided as input.\");\n            const i = r || n.map((e, t) => Math.floor(e * o[t]));\n            return [o, i];\n          },\n          p = (e, t, n) => {\n            const r = Array.from(e.floatData);\n            return (0, s.scalesValidation)(r, t, n), r;\n          },\n          d = (e, t, n, r) => {\n            const o = t.length,\n              i = new Array(o);\n            for (let n = 0, r = o; n < r; n++) if (0 === t[n]) {\n              if (0 !== e[n]) throw new Error(\"Input dim is zero but required output dim is non-zero.\");\n              i[n] = 1;\n            } else i[n] = e[n] / t[n];\n            return (0, s.scalesValidation)(i, n, r), i;\n          };\n      },\n      565: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.shape = void 0;\n        const r = n(9240);\n        t.shape = (e, t) => (o(t), [new r.Tensor([t[0].dims.length], \"int32\", void 0, void 0, new Int32Array(t[0].dims))]);\n        const o = e => {\n          if (!e || 1 !== e.length) throw new Error(\"Shape requires 1 input.\");\n        };\n      },\n      2444: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.sliceV10 = t.parseSliceAttributes = t.slice = void 0;\n        const r = n(4910),\n          o = n(6145),\n          i = n(7273),\n          a = n(5639),\n          s = {\n            name: \"Slice\",\n            inputNames: [\"A\"],\n            inputTypes: [a.TextureType.unpacked]\n          };\n        t.slice = (e, t, n) => (l(t), [e.run(Object.assign(Object.assign({}, s), {\n          cacheHint: n.cacheKey,\n          get: () => u(e, t[0], n)\n        }), t)]), t.parseSliceAttributes = e => {\n          const t = e.attributes.getInts(\"starts\"),\n            n = e.attributes.getInts(\"ends\"),\n            o = e.attributes.getInts(\"axes\", []);\n          return (0, r.createAttributeWithCacheKey)({\n            starts: t,\n            ends: n,\n            axes: o\n          });\n        };\n        const u = (e, t, n) => {\n            const r = 0 === n.axes.length ? t.dims.slice(0).map((e, t) => t) : n.axes,\n              o = i.ShapeUtil.normalizeAxes(r, t.dims.length),\n              u = n.starts.map((e, n) => e > t.dims[o[n]] - 1 ? t.dims[o[n]] : i.ShapeUtil.normalizeAxis(e, t.dims[o[n]])),\n              l = n.ends.map((e, n) => e > t.dims[o[n]] - 1 ? t.dims[o[n]] : i.ShapeUtil.normalizeAxis(e, t.dims[o[n]])),\n              c = t.dims.slice(),\n              p = [];\n            for (let e = 0; e < o.length; e++) c[o[e]] = l[e] - u[e], u[e] > 0 && p.push(`outputIdx[${o[e]}] += ${u[e]};`);\n            const d = `\\n      float process(int outputIdx[${c.length}]) {\\n        ${p.join(\"\\n      \")}\\n        return _A(outputIdx);\\n      }`;\n            return Object.assign(Object.assign({}, s), {\n              output: {\n                dims: c,\n                type: t.type,\n                textureType: a.TextureType.unpacked\n              },\n              shaderSource: d\n            });\n          },\n          l = e => {\n            if (!e || 1 !== e.length) throw new Error(\"Slice requires 1 input.\");\n            if (-1 === o.NUMBER_TYPES.indexOf(e[0].type)) throw new Error(\"Invalid input type.\");\n          };\n        t.sliceV10 = (e, t) => {\n          p(t);\n          const n = c(e, t);\n          return [e.run(Object.assign(Object.assign({}, s), {\n            cacheHint: n.cacheKey,\n            get: () => u(e, t[0], n)\n          }), [t[0]])];\n        };\n        const c = (e, t) => {\n            if (!e.session.isInitializer(t[1].dataId) || !e.session.isInitializer(t[2].dataId) || t.length >= 4 && !e.session.isInitializer(t[3].dataId) || t.length >= 5 && !e.session.isInitializer(t[4].dataId)) throw new Error(\"dynamic slice attributes are not allowed\");\n            if (t.length >= 5 && t[4].integerData.some(e => 1 !== e)) throw new Error(\"currently non-1 steps is not supported for Slice\");\n            const n = Array.from(t[1].integerData),\n              r = Array.from(t[2].integerData),\n              o = t.length >= 4 ? Array.from(t[3].integerData) : [];\n            return {\n              starts: n,\n              ends: r,\n              axes: o,\n              cacheKey: `${o};${n};${r}`\n            };\n          },\n          p = e => {\n            if (!e || e.length < 3 || e.length > 5) throw new Error(\"Invalid input number.\");\n            if (\"int32\" !== e[1].type || 1 !== e[1].dims.length) throw new Error(\"Invalid input type.\");\n            if (\"int32\" !== e[2].type || 1 !== e[2].dims.length) throw new Error(\"Invalid input type.\");\n            if (e.length >= 4 && (\"int32\" !== e[3].type || 1 !== e[3].dims.length)) throw new Error(\"Invalid input type.\");\n            if (e.length >= 5 && (\"int32\" !== e[4].type || 1 !== e[4].dims.length)) throw new Error(\"Invalid input type.\");\n          };\n      },\n      815: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.softmaxV13 = t.parseSoftmaxAttributesV13 = t.parseSoftmaxAttributes = t.softmax = void 0;\n        const r = n(4910),\n          o = n(7273),\n          i = n(6757),\n          a = n(5639),\n          s = n(5707),\n          u = {\n            name: \"SoftmaxComputeMax\",\n            inputNames: [\"A\"],\n            inputTypes: [a.TextureType.unpacked]\n          },\n          l = {\n            name: \"SoftmaxComputeScale\",\n            inputNames: [\"A\", \"Max\"],\n            inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked]\n          },\n          c = {\n            name: \"SoftMax\",\n            inputNames: [\"A\", \"Max\", \"Norm\"],\n            inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked, a.TextureType.unpacked]\n          };\n        t.softmax = (e, t, n) => {\n          g(t);\n          const r = t[0].dims.slice(),\n            i = o.ShapeUtil.normalizeAxis(n.axis, r.length),\n            a = o.ShapeUtil.sizeToDimension(r, i),\n            s = o.ShapeUtil.sizeFromDimension(r, i);\n          return p(e, t, n, a, s);\n        }, t.parseSoftmaxAttributes = e => (0, r.createAttributeWithCacheKey)({\n          axis: e.attributes.getInt(\"axis\", 1)\n        }), t.parseSoftmaxAttributesV13 = e => (0, r.createAttributeWithCacheKey)({\n          axis: e.attributes.getInt(\"axis\", -1)\n        }), t.softmaxV13 = (e, t, n) => {\n          g(t);\n          const i = t[0].dims.slice(),\n            a = o.ShapeUtil.normalizeAxis(n.axis, i.length),\n            u = i.length,\n            l = a !== u - 1,\n            c = [];\n          let d,\n            f = [],\n            h = [];\n          l && (f = Array.from({\n            length: u\n          }).map((e, t) => t), f[a] = u - 1, f[u - 1] = a, f.map(e => c.push(i[e])), d = (0, r.createAttributeWithCacheKey)({\n            perm: f\n          }), h = (0, s.transpose)(e, t, d));\n          const b = l ? o.ShapeUtil.sizeToDimension(c, u - 1) : o.ShapeUtil.sizeToDimension(i, u - 1),\n            m = l ? o.ShapeUtil.sizeFromDimension(c, u - 1) : o.ShapeUtil.sizeFromDimension(i, u - 1),\n            y = p(e, l ? h : t, n, b, m);\n          return l ? (0, s.transpose)(e, y, d) : y;\n        };\n        const p = (e, t, n, r, o) => {\n            const i = d(e, t[0], r, o, [r]),\n              a = e.run(Object.assign(Object.assign({}, u), {\n                cacheHint: n.cacheKey,\n                get: () => i\n              }), t),\n              s = f(e, t[0], r, o, i.output.dims, [r]),\n              p = e.run(Object.assign(Object.assign({}, l), {\n                cacheHint: n.cacheKey,\n                get: () => s\n              }), [t[0], a]),\n              g = h(e, t[0], r, o, i.output.dims, s.output.dims);\n            return [e.run(Object.assign(Object.assign({}, c), {\n              cacheHint: n.cacheKey,\n              get: () => g\n            }), [t[0], a, p])];\n          },\n          d = (e, t, n, r, o) => {\n            const [s, l] = e.calculateTextureWidthAndHeight(t.dims, a.TextureType.unpacked),\n              c = o.length;\n            if (n < 1 || r < 1) throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");\n            if (1 !== o.length) throw new Error(\"Dimensionality of the output should be 1\");\n            if (o[0] !== n) throw new Error(\"Shape of the output should be equal to logical row count\");\n            const p = (0, i.getGlsl)(e.session.backend.glContext.version),\n              d = `\\n      float process(int[${c}] indices) {\\n        int logical_row_start_offset = indices[0] * ${r};\\n\\n        float max = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset, ${s},\\n        ${l} )));\\n        for(int i=1; i<${r}; ++i)\\n        {\\n          float current = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\\n            ${s}, ${l})));\\n          if(current > max)\\n          max = current;\\n        }\\n\\n        return max;\\n      }`;\n            return Object.assign(Object.assign({}, u), {\n              output: {\n                dims: o,\n                type: t.type,\n                textureType: a.TextureType.unpacked\n              },\n              shaderSource: d\n            });\n          },\n          f = (e, t, n, r, o, s) => {\n            const [u, c] = e.calculateTextureWidthAndHeight(t.dims, a.TextureType.unpacked),\n              p = s.length;\n            if (n < 1 || r < 1) throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");\n            if (1 !== s.length) throw new Error(\"Dimensionality of the output should be 1\");\n            if (s[0] !== n) throw new Error(\"Shape of the output should be equal to logical row count\");\n            if (1 !== o.length) throw new Error(\"Dimensionality of the intermediate results should be 1\");\n            if (o[0] !== n) throw new Error(\"Shape of the intermediate results should be equal to logical row count\");\n            const d = `\\n      float process(int[${p}] indices) {\\n        int logical_row_start_offset = indices[0] * ${r};\\n\\n        float norm_factor = 0.0;\\n        float max = _Max(indices);\\n        for(int i=0; i<${r}; ++i)\\n        {\\n          norm_factor += exp(getColorAsFloat(${(0, i.getGlsl)(e.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,\\n            ${u}, ${c}))) - max);\\n        }\\n\\n        return norm_factor;\\n      }`;\n            return Object.assign(Object.assign({}, l), {\n              output: {\n                dims: s,\n                type: t.type,\n                textureType: a.TextureType.unpacked\n              },\n              shaderSource: d\n            });\n          },\n          h = (e, t, n, r, o, i) => {\n            const [s, u] = e.calculateTextureWidthAndHeight(t.dims, a.TextureType.unpacked),\n              l = t.dims.length;\n            if (n < 1 || r < 1) throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");\n            if (1 !== o.length || 1 !== i.length) throw new Error(\"Dimensionality of the intermediate results should be 1\");\n            if (o[0] !== n || i[0] !== n) throw new Error(\"Shape of the intermediate results should be equal to logical row count\");\n            const p = `\\n      float process(int[${l}] indices) {\\n\\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\\n      int offset = coordsToOffset(TexCoords, ${s}, ${u});\\n\\n      //determine the logical row for this index\\n      int logical_row_index[1];\\n      logical_row_index[0] = offset / ${r};\\n\\n      float norm_factor = _Norm(logical_row_index);\\n\\n      // avoid possible division by 0\\n      // if norm_facor is 0, all elements are zero\\n      // if so, return 0\\n      if(norm_factor == 0.0)\\n        return 0.0;\\n\\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\\n    }`;\n            return Object.assign(Object.assign({}, c), {\n              output: {\n                dims: t.dims,\n                type: t.type,\n                textureType: a.TextureType.unpacked\n              },\n              shaderSource: p\n            });\n          },\n          g = e => {\n            if (!e || 1 !== e.length) throw new Error(\"Softmax requires 1 input.\");\n            if (\"float32\" !== e[0].type && \"float64\" !== e[0].type) throw new Error(\"Invalid input type\");\n          };\n      },\n      564: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.parseSplitAttributes = t.split = void 0;\n        const r = n(4910),\n          o = n(7273),\n          i = n(5639),\n          a = {\n            name: \"Split\",\n            inputNames: [\"A\"],\n            inputTypes: [i.TextureType.unpacked]\n          };\n        t.split = (e, t, n) => {\n          l(t);\n          const r = o.ShapeUtil.normalizeAxis(n.axis, t[0].dims.length),\n            i = s(e, t, r, n),\n            c = [];\n          for (let o = 0; o < i; ++o) c.push(e.run(Object.assign(Object.assign({}, a), {\n            cacheHint: `${n.cacheKey};${o}`,\n            get: () => u(e, t[0], n, r, o)\n          }), t));\n          return c;\n        }, t.parseSplitAttributes = e => {\n          const t = e.attributes.getInt(\"axis\", 0),\n            n = e.attributes.getInts(\"split\", []),\n            o = e.outputs.length;\n          return (0, r.createAttributeWithCacheKey)({\n            axis: t,\n            split: n,\n            numOutputs: o\n          });\n        };\n        const s = (e, t, n, r) => {\n            const [, i] = o.SplitUtil.splitShape(t[0].dims, n, r.split, r.numOutputs);\n            return i.length;\n          },\n          u = (e, t, n, r, s) => {\n            const [u, l] = o.SplitUtil.splitShape(t.dims, r, n.split, n.numOutputs),\n              c = l[s],\n              p = u[s],\n              d = `\\n      float process(int indices[${p.length}]) {\\n        indices[${r}] += ${c};\\n        return _A(indices);\\n      }\\n    `;\n            return Object.assign(Object.assign({}, a), {\n              cacheHint: `${n.cacheKey}:${s}`,\n              output: {\n                dims: p,\n                type: t.type,\n                textureType: i.TextureType.unpacked\n              },\n              shaderSource: d\n            });\n          },\n          l = e => {\n            if (!e || 1 !== e.length) throw new Error(\"Split requires one input.\");\n            if (\"int8\" !== e[0].type && \"uint8\" !== e[0].type && \"int16\" !== e[0].type && \"uint16\" !== e[0].type && \"int32\" !== e[0].type && \"uint32\" !== e[0].type && \"float32\" !== e[0].type && \"float64\" !== e[0].type && \"bool\" !== e[0].type) throw new Error(\"Invalid input type.\");\n          };\n      },\n      5416: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.parseSqueezeAttributes = t.squeezeV13 = t.squeeze = void 0;\n        const r = n(7273);\n        t.squeeze = (e, t, n) => {\n          o(t);\n          const i = r.ShapeUtil.squeezeShape(t[0].dims, n);\n          return [e.reshapeUnpacked(t[0], i)];\n        }, t.squeezeV13 = (e, n) => (i(n), (0, t.squeeze)(e, [n[0]], Array.from(n[1].integerData))), t.parseSqueezeAttributes = e => e.attributes.getInts(\"axes\");\n        const o = e => {\n            if (!e || 1 !== e.length) throw new Error(\"Squeeze requires 1 input.\");\n            if (\"string\" === e[0].type) throw new Error(\"invalid input tensor types.\");\n          },\n          i = e => {\n            if (!e || 2 !== e.length) throw new Error(\"Squeeze requires 2 inputs.\");\n            if (\"int32\" !== e[1].type) throw new Error(\"Invalid input type.\");\n          };\n      },\n      1240: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.sum = void 0;\n        const r = n(6757),\n          o = n(5639);\n        t.sum = (e, t) => {\n          a(t);\n          const n = {\n            name: \"Sum\",\n            inputNames: t.map((e, t) => `X${t}`),\n            inputTypes: new Array(t.length).fill(o.TextureType.unpacked)\n          };\n          return [e.run(Object.assign(Object.assign({}, n), {\n            get: () => i(e, t, n)\n          }), t)];\n        };\n        const i = (e, t, n) => {\n            const i = (0, r.getGlsl)(e.session.backend.glContext.version),\n              a = t[0].dims.slice(),\n              s = `\\n      void main() {\\n        vec4 result = ${t.map((e, t) => `${i.texture2D}(X${t},TexCoords)`).join(\" + \")};\\n        ${i.output} = result;\\n      }\\n    `;\n            return Object.assign(Object.assign({}, n), {\n              output: {\n                dims: a,\n                type: t[0].type,\n                textureType: o.TextureType.unpacked\n              },\n              hasMain: !0,\n              shaderSource: s\n            });\n          },\n          a = e => {\n            if (!e || 0 === e.length) throw new Error(\"Sum requires inputs.\");\n            const t = e[0].dims.length;\n            for (let n = 1; n < e.length; n++) {\n              if (t !== e[n].dims.length) throw new Error(\"Input shapes are mismatched.\");\n              for (let r = 0; r < t; r++) if (e[0].dims[r] !== e[n].dims[r]) throw new Error(\"Input shapes are not matched.\");\n            }\n            if (\"float32\" !== e[0].type && \"float64\" !== e[0].type) throw new Error(\"Invalid input type.\");\n            for (let t = 1; t < e.length; t++) if (e[0].type !== e[t].type) throw new Error(\"Input types are not matched.\");\n          };\n      },\n      5944: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.tile = void 0;\n        const r = n(6145),\n          o = n(5639);\n        t.tile = (e, t) => {\n          a(t);\n          const n = {\n            name: \"Tile\",\n            inputNames: [\"A\"],\n            inputTypes: [o.TextureType.unpacked]\n          };\n          return [e.run(Object.assign(Object.assign({}, n), {\n            get: () => i(e, t, n)\n          }), t)];\n        };\n        const i = (e, t, n) => {\n            const r = t[0].dims.slice(),\n              i = new Array(r.length),\n              a = [];\n            for (let e = 0; e < r.length; e++) i[e] = r[e] * t[1].numberData[e], a.push(`inputIdx[${e}] = int(mod(float(outputIdx[${e}]), ${r[e]}.));`);\n            const s = i.length,\n              u = `\\n      float process(int outputIdx[${s}]) {\\n        int inputIdx[${s}];\\n        ${a.join(\"\\n\")}\\n        return _A(inputIdx);\\n      }\\n    `;\n            return Object.assign(Object.assign({}, n), {\n              output: {\n                dims: i,\n                type: t[0].type,\n                textureType: o.TextureType.unpacked\n              },\n              shaderSource: u\n            });\n          },\n          a = e => {\n            if (!e || 2 !== e.length) throw new Error(\"Tile requires 2 input.\");\n            if (1 !== e[1].dims.length) throw new Error(\"The second input shape must 1 dimension.\");\n            if (e[1].dims[0] !== e[0].dims.length) throw new Error(\"Invalid input shape.\");\n            if (-1 === r.NUMBER_TYPES.indexOf(e[0].type)) throw new Error(\"Invalid input type.\");\n            if (\"int32\" !== e[1].type && \"int16\" !== e[1].type) throw new Error(\"Invalid repeat type.\");\n          };\n      },\n      5707: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.parseTransposeAttributes = t.transpose = void 0;\n        const r = n(4910),\n          o = n(7273),\n          i = n(5639),\n          a = {\n            name: \"Transpose\",\n            inputNames: [\"A\"],\n            inputTypes: [i.TextureType.unpacked]\n          };\n        t.transpose = (e, t, n) => (p(t), [e.run(Object.assign(Object.assign({}, a), {\n          cacheHint: n.cacheKey,\n          get: () => s(e, t[0], n.perm)\n        }), t)]), t.parseTransposeAttributes = e => (0, r.createAttributeWithCacheKey)({\n          perm: e.attributes.getInts(\"perm\", [])\n        });\n        const s = (e, t, n) => {\n            const r = t.dims;\n            n = u(r, n);\n            const o = l(r, n),\n              s = r.length,\n              p = `\\n      ${c(\"perm\", n, s)}\\n      float process(int indices[${s}]) {\\n        int a[${s}];\\n        perm(a, indices);\\n        return _A(a);\\n      }`;\n            return Object.assign(Object.assign({}, a), {\n              output: {\n                dims: o,\n                type: t.type,\n                textureType: i.TextureType.unpacked\n              },\n              shaderSource: p\n            });\n          },\n          u = (e, t) => (t && t.length !== e.length && (t = [...e.keys()].reverse()), t),\n          l = (e, t) => (t = u(e, t), o.ShapeUtil.sortBasedOnPerm(e, t)),\n          c = (e, t, n) => {\n            const r = [];\n            r.push(`void ${e}(out int a[${n}], int src[${n}]) {`);\n            for (let e = 0; e < n; ++e) r.push(`\\ta[${t[e]}]=src[${e}];`);\n            return r.push(\"\\t}\"), r.join(\"\\n\");\n          },\n          p = e => {\n            if (!e || 1 !== e.length) throw new Error(\"Transpose requires 1 input.\");\n            if (\"float32\" !== e[0].type && \"float64\" !== e[0].type) throw new Error(\"input should be float tensor\");\n          };\n      },\n      2488: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.encodeAsUint8 = void 0;\n        const r = n(6757),\n          o = n(5639);\n        t.encodeAsUint8 = (e, t) => {\n          const n = t.shape,\n            i = (0, r.getGlsl)(e.session.backend.glContext.version),\n            a = `\\n    const float FLOAT_MAX = 1.70141184e38;\\n    const float FLOAT_MIN = 1.17549435e-38;\\n\\n    bool isNaN(float val) {\\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\\n    }\\n\\n    highp vec4 encodeAsUint8(highp float v) {\\n      if (isNaN(v)) {\\n        return vec4(255, 255, 255, 255);\\n      }\\n\\n      highp float av = abs(v);\\n\\n      if(av < FLOAT_MIN) {\\n        return vec4(0.0, 0.0, 0.0, 0.0);\\n      } else if(v > FLOAT_MAX) {\\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\\n      } else if(v < -FLOAT_MAX) {\\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\\n      }\\n\\n      highp vec4 c = vec4(0,0,0,0);\\n\\n      highp float e = floor(log2(av));\\n      highp float m = exp2(fract(log2(av))) - 1.0;\\n\\n      c[2] = floor(128.0 * m);\\n      m -= c[2] / 128.0;\\n      c[1] = floor(32768.0 * m);\\n      m -= c[1] / 32768.0;\\n      c[0] = floor(8388608.0 * m);\\n\\n      highp float ebias = e + 127.0;\\n      c[3] = floor(ebias / 2.0);\\n      ebias -= c[3] * 2.0;\\n      c[2] += floor(ebias) * 128.0;\\n\\n      c[3] += 128.0 * step(0.0, -v);\\n\\n      return c / 255.0;\\n    }\\n\\n    void main() {\\n      float value = ${i.texture2D}(X,TexCoords).r;\\n      ${i.output} = encodeAsUint8(value);\\n    }`,\n            s = {\n              name: \"Uint8Encode\",\n              inputTypes: [o.TextureType.unpacked],\n              inputNames: [\"X\"],\n              output: {\n                dims: n,\n                type: t.tensor.type,\n                textureType: o.TextureType.downloadUint8AsFloat\n              },\n              shaderSource: a,\n              hasMain: !0\n            };\n          return e.executeProgram(s, [t.tensor]);\n        };\n      },\n      9087: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.tanh = t.tan = t.sqrt = t.sin = t.sigmoid = t.relu = t.not = t.neg = t.log = t.parseLeakyReluAttributes = t.leakyRelu = t.identity = t.floor = t.exp = t.parseEluAttributes = t.elu = t.cos = t.ceil = t.clipV11 = t.parseClipAttributes = t.clip = t.atan = t.asin = t.acos = t.abs = t.glslTanh = t.glslTan = t.glslSqrt = t.glslSigmoid = t.glslRelu = t.glslSin = t.glslNot = t.glslNeg = t.glslLog = t.glslLeakyRelu = t.glslIdentity = t.glslClip = t.glslFloor = t.glslExp = t.glslElu = t.glslCos = t.glslCeil = t.glslAtan = t.glslAsin = t.glslAcos = t.glslAbs = void 0;\n        const r = n(4910),\n          o = n(7273),\n          i = n(1997),\n          a = n(6757),\n          s = n(5639);\n        function u() {\n          return E(\"abs\");\n        }\n        function l() {\n          return E(\"acos\");\n        }\n        function c() {\n          return E(\"asin\");\n        }\n        function p() {\n          return E(\"atan\");\n        }\n        function d() {\n          return E(\"ceil\");\n        }\n        function f() {\n          return E(\"cos\");\n        }\n        function h(e) {\n          const t = \"elu\";\n          return {\n            body: `\\n  const float alpha = float(${e});\\n\\n  float ${t}_(float a) {\\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return vec4(${t}_(v.x), ${t}_(v.y), ${t}_(v.z), ${t}_(v.w));\\n  }\\n  `,\n            name: t,\n            type: i.FunctionType.ValueBased\n          };\n        }\n        function g() {\n          return E(\"exp\");\n        }\n        function b() {\n          return E(\"floor\");\n        }\n        function m(e, t) {\n          const n = \"clip\";\n          return {\n            body: `\\n  const float min = float(${e});\\n  const float max = float(${t});\\n\\n  float ${n}_(float a) {\\n    return clamp(a, min, max);\\n  }\\n  vec4 ${n}_(vec4 v) {\\n    return clamp(v, min, max);\\n  }\\n  `,\n            name: n,\n            type: i.FunctionType.ValueBased\n          };\n        }\n        function y() {\n          const e = \"indentity\";\n          return {\n            body: `\\n  float ${e}_(float a) {\\n    return a;\\n  }\\n  vec4 ${e}_(vec4 v) {\\n    return v;\\n  }\\n  `,\n            name: e,\n            type: i.FunctionType.ValueBased\n          };\n        }\n        function v(e) {\n          const t = \"leakyRelu\";\n          return {\n            body: `\\n  const float alpha = float(${e});\\n\\n  float ${t}_(float a) {\\n    return a < 0.0 ? a * alpha : a;\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return vec4(${t}_(v.x), ${t}_(v.y), ${t}_(v.z), ${t}_(v.w));\\n  }\\n  `,\n            name: t,\n            type: i.FunctionType.ValueBased\n          };\n        }\n        function _() {\n          return E(\"log\");\n        }\n        function w() {\n          const e = \"neg\";\n          return {\n            body: `\\n  float ${e}_(float a) {\\n    return -a;\\n  }\\n  vec4 ${e}_(vec4 v) {\\n    return -v;\\n  }\\n  `,\n            name: e,\n            type: i.FunctionType.ValueBased\n          };\n        }\n        function T() {\n          const e = \"not\";\n          return {\n            body: `\\n  float ${e}_(float a) {\\n    return float( ! bool(a) );\\n  }\\n  bool ${e}_(bool a) {\\n    return !a;\\n  }\\n  vec4 ${e}_(vec4 v) {\\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\\n  }\\n  bvec4 ${e}_(bvec4 v) {\\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\\n  }\\n  `,\n            name: e,\n            type: i.FunctionType.ValueBased\n          };\n        }\n        function x() {\n          return E(\"sin\");\n        }\n        function O() {\n          const e = \"relu\";\n          return {\n            body: `\\n  float ${e}_(float a) {\\n    return max( a, 0.0 );\\n  }\\n  vec4 ${e}_(vec4 v) {\\n    return max( v, 0.0 );\\n  }\\n  `,\n            name: e,\n            type: i.FunctionType.ValueBased\n          };\n        }\n        function S() {\n          const e = \"sigmoid\";\n          return {\n            body: `\\n  float ${e}_(float a) {\\n    return 1.0 / (1.0 + exp(-a));\\n  }\\n  vec4 ${e}_(vec4 v) {\\n    return 1.0 / (1.0 + exp(-v));\\n  }\\n  `,\n            name: e,\n            type: i.FunctionType.ValueBased\n          };\n        }\n        function A() {\n          return E(\"sqrt\");\n        }\n        function P() {\n          return E(\"tan\");\n        }\n        function I() {\n          const e = \"tanh\";\n          return {\n            body: `\\n  float ${e}_(float a) {\\n    a = clamp(a, -10., 10.);\\n    a = exp(2.*a);\\n    return (a - 1.) / (a + 1.);\\n  }\\n  vec4 ${e}_(vec4 v) {\\n    v = clamp(v, -10., 10.);\\n    v = exp(2.*v);\\n    return (v - 1.) / (v + 1.);\\n  }\\n  `,\n            name: e,\n            type: i.FunctionType.ValueBased\n          };\n        }\n        function E(e) {\n          return {\n            body: `\\n  float ${e}_(float a) {\\n    return ${e}(a);\\n  }\\n  vec4 ${e}_(vec4 v) {\\n    return ${e}(v);\\n  }\\n  `,\n            name: e,\n            type: i.FunctionType.ValueBased\n          };\n        }\n        t.glslAbs = u, t.glslAcos = l, t.glslAsin = c, t.glslAtan = p, t.glslCeil = d, t.glslCos = f, t.glslElu = h, t.glslExp = g, t.glslFloor = b, t.glslClip = m, t.glslIdentity = y, t.glslLeakyRelu = v, t.glslLog = _, t.glslNeg = w, t.glslNot = T, t.glslSin = x, t.glslRelu = O, t.glslSigmoid = S, t.glslSqrt = A, t.glslTan = P, t.glslTanh = I;\n        const D = (e, t, n, r) => {\n          const o = e.session.pack ? s.TextureType.packed : s.TextureType.unpacked,\n            i = {\n              name: n.name,\n              inputTypes: [o],\n              inputNames: [\"A\"],\n              cacheHint: r\n            };\n          return Object.assign(Object.assign({}, i), {\n            get: () => ((e, t, n, r) => {\n              const o = e.session.pack ? s.TextureType.packed : s.TextureType.unpacked,\n                i = (0, a.getGlsl)(e.session.backend.glContext.version);\n              return Object.assign(Object.assign({}, t), {\n                output: {\n                  dims: n.dims,\n                  type: n.type,\n                  textureType: o\n                },\n                shaderSource: `\\n     ${r.body}\\n     void main() {\\n       vec4 v = ${i.texture2D}(A, TexCoords);\\n       v = ${r.name}_(v);\\n       ${i.output} = v;\\n     }\\n     `,\n                hasMain: !0\n              });\n            })(e, i, t, n)\n          });\n        };\n        t.abs = (e, t) => [e.run(D(e, t[0], u()), t)], t.acos = (e, t) => [e.run(D(e, t[0], l()), t)], t.asin = (e, t) => [e.run(D(e, t[0], c()), t)], t.atan = (e, t) => [e.run(D(e, t[0], p()), t)], t.clip = (e, t, n) => [e.run(D(e, t[0], m(n.min, n.max), n.cacheKey), t)], t.parseClipAttributes = e => (0, r.createAttributeWithCacheKey)({\n          min: e.attributes.getFloat(\"min\", o.MIN_CLIP),\n          max: e.attributes.getFloat(\"max\", o.MAX_CLIP)\n        }), t.clipV11 = (e, n) => {\n          const r = $(e, n);\n          return (0, t.clip)(e, [n[0]], r);\n        };\n        const $ = (e, t) => {\n          if (t.length >= 3 && (!e.session.isInitializer(t[1].dataId) || !e.session.isInitializer(t[2].dataId))) throw new Error(\"dynamic clip attributes are not allowed\");\n          const n = t.length >= 3 ? t[1].numberData[0] : o.MIN_CLIP,\n            i = t.length >= 3 ? t[2].numberData[0] : o.MAX_CLIP;\n          return (0, r.createAttributeWithCacheKey)({\n            min: n,\n            max: i\n          });\n        };\n        t.ceil = (e, t) => [e.run(D(e, t[0], d()), t)], t.cos = (e, t) => [e.run(D(e, t[0], f()), t)], t.elu = (e, t, n) => [e.run(D(e, t[0], h(n.alpha), n.cacheKey), t)], t.parseEluAttributes = e => (0, r.createAttributeWithCacheKey)({\n          alpha: e.attributes.getFloat(\"alpha\", 1)\n        }), t.exp = (e, t) => [e.run(D(e, t[0], g()), t)], t.floor = (e, t) => [e.run(D(e, t[0], b()), t)], t.identity = (e, t) => [e.run(D(e, t[0], y()), t)], t.leakyRelu = (e, t, n) => [e.run(D(e, t[0], v(n.alpha), n.cacheKey), t)], t.parseLeakyReluAttributes = e => (0, r.createAttributeWithCacheKey)({\n          alpha: e.attributes.getFloat(\"alpha\", .01)\n        }), t.log = (e, t) => [e.run(D(e, t[0], _()), t)], t.neg = (e, t) => [e.run(D(e, t[0], w()), t)], t.not = (e, t) => [e.run(D(e, t[0], T()), t)], t.relu = (e, t) => [e.run(D(e, t[0], O()), t)], t.sigmoid = (e, t) => [e.run(D(e, t[0], S()), t)], t.sin = (e, t) => [e.run(D(e, t[0], x()), t)], t.sqrt = (e, t) => [e.run(D(e, t[0], A()), t)], t.tan = (e, t) => [e.run(D(e, t[0], P()), t)], t.tanh = (e, t) => [e.run(D(e, t[0], I()), t)];\n      },\n      540: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.createUnpackProgramInfoLoader = t.createUnpackProgramInfo = void 0;\n        const r = n(6757),\n          o = n(5639),\n          i = n(432),\n          a = n(5614),\n          s = {\n            name: \"unpack\",\n            inputNames: [\"A\"],\n            inputTypes: [o.TextureType.packed]\n          };\n        t.createUnpackProgramInfo = (e, t) => {\n          const n = t.dims.length,\n            u = (0, a.getChannels)(\"rc\", n),\n            l = u.slice(-2),\n            c = (0, i.getCoordsDataType)(n),\n            p = (0, a.unpackFromChannel)(),\n            d = 0 === t.dims.length ? \"\" : function (e, t) {\n              if (1 === e) return \"rc\";\n              let n = \"\";\n              for (let r = 0; r < e; r++) n += t[r], r < e - 1 && (n += \",\");\n              return n;\n            }(n, u),\n            f = n <= 1 ? \"rc\" : `vec2(${l.join(\",\")})`,\n            h = `\\n    ${p}\\n    void main() {\\n      ${c} rc = getOutputCoords();\\n\\n       // Sample the texture with the coords to get the rgba channel value.\\n       vec4 packedInput = getA(${d});\\n\\n       ${(0, r.getGlsl)(e.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${f}), 0, 0, 0);\\n     }\\n   `;\n          return Object.assign(Object.assign({}, s), {\n            hasMain: !0,\n            output: {\n              dims: t.dims,\n              type: t.type,\n              textureType: o.TextureType.unpacked\n            },\n            shaderSource: h\n          });\n        }, t.createUnpackProgramInfoLoader = (e, n) => Object.assign(Object.assign({}, s), {\n          get: () => (0, t.createUnpackProgramInfo)(e, n)\n        });\n      },\n      7862: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.parseUnsqueezeAttributes = t.unsqueezeV13 = t.unsqueeze = void 0;\n        const r = n(7273);\n        t.unsqueeze = (e, t, n) => {\n          o(t);\n          const i = r.ShapeUtil.unsqueezeShape(t[0].dims, n);\n          return [e.reshapeUnpacked(t[0], i)];\n        }, t.unsqueezeV13 = (e, n) => (i(n), (0, t.unsqueeze)(e, [n[0]], Array.from(n[1].integerData))), t.parseUnsqueezeAttributes = e => e.attributes.getInts(\"axes\");\n        const o = e => {\n            if (!e || 1 !== e.length) throw new Error(\"Unsqueeze requires 1 input.\");\n            if (\"string\" === e[0].type) throw new Error(\"invalid input tensor types.\");\n          },\n          i = e => {\n            if (!e || 2 !== e.length) throw new Error(\"Unsqueeze requires 2 inputs.\");\n            if (\"int32\" !== e[1].type) throw new Error(\"Invalid input type.\");\n          };\n      },\n      3980: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.scalesValidation = t.validateInputs = t.parseUpsampleAttributes = t.parseUpsampleAttributesV9 = t.parseUpsampleAttributesV7 = t.upsample = void 0;\n        const r = n(4910),\n          o = n(6757),\n          i = n(5639),\n          a = {\n            name: \"Upsample\",\n            inputNames: [\"X\"],\n            inputTypes: [i.TextureType.unpacked]\n          };\n        t.upsample = (e, n, r) => ((0, t.validateInputs)(n, r), [e.run(Object.assign(Object.assign({}, a), {\n          cacheHint: r.cacheKey,\n          get: () => s(e, n, r)\n        }), n)]), t.parseUpsampleAttributesV7 = e => (0, t.parseUpsampleAttributes)(e, 7), t.parseUpsampleAttributesV9 = e => (0, t.parseUpsampleAttributes)(e, 9), t.parseUpsampleAttributes = (e, n) => {\n          const o = n >= 10,\n            i = e.attributes.getString(\"mode\", \"nearest\");\n          if (\"nearest\" !== i && \"linear\" !== i && (n < 11 || \"cubic\" !== i)) throw new Error(`unrecognized mode: ${i}`);\n          let a = [];\n          n < 9 && (a = e.attributes.getFloats(\"scales\"), (0, t.scalesValidation)(a, i, o));\n          const s = e.attributes.getFloat(\"extrapolation_value\", 0),\n            u = n > 10 ? e.attributes.getString(\"coordinate_transformation_mode\", \"half_pixel\") : \"asymmetric\";\n          if (-1 === [\"asymmetric\", \"pytorch_half_pixel\", \"tf_half_pixel_for_nn\", \"align_corners\", \"tf_crop_and_resize\", \"half_pixel\"].indexOf(u)) throw new Error(`coordinate_transform_mode '${u}' is not supported`);\n          const l = \"tf_crop_and_resize\" === u,\n            c = l,\n            p = \"nearest\" === i && n >= 11 ? e.attributes.getString(\"nearest_mode\", \"round_prefer_floor\") : \"\";\n          if (-1 === [\"round_prefer_floor\", \"round_prefer_ceil\", \"floor\", \"ceil\", \"\"].indexOf(p)) throw new Error(`nearest_mode '${p}' is not supported`);\n          const d = e.attributes.getFloat(\"cubic_coeff_a\", -.75),\n            f = 0 !== e.attributes.getInt(\"exclude_outside\", 0);\n          if (f && \"cubic\" !== i) throw new Error(\"exclude_outside can be set to 1 only when mode is CUBIC.\");\n          const h = n < 11 || \"nearest\" === i && \"asymmetric\" === u && \"floor\" === p;\n          let g = 0,\n            b = 0,\n            m = 0;\n          return n > 10 ? e.inputs.length > 2 ? (g = 1, b = 2, m = 3) : (b = 1, m = 2) : 9 === n && (b = 1), (0, r.createAttributeWithCacheKey)({\n            opset: n,\n            isResize: o,\n            mode: i,\n            scales: a,\n            extrapolationValue: s,\n            coordinateTransformMode: u,\n            useExtrapolation: c,\n            needRoiInput: l,\n            nearestMode: p,\n            cubicCoefficientA: d,\n            excludeOutside: f,\n            useNearest2xOptimization: h,\n            roiInputIdx: g,\n            scalesInputIdx: b,\n            sizesInputIdx: m\n          });\n        };\n        const s = (e, t, n) => {\n          const r = (0, o.getGlsl)(e.session.backend.glContext.version),\n            [s, u] = e.calculateTextureWidthAndHeight(t[0].dims, i.TextureType.unpacked),\n            l = t[0].dims.map((e, t) => Math.floor(e * n.scales[t])),\n            [c, p] = e.calculateTextureWidthAndHeight(l, i.TextureType.unpacked),\n            d = l.length,\n            f = new Array(d),\n            h = new Array(d);\n          let g = `\\n      int output_pitches[${d}];\\n      int input_pitches[${d}];\\n      `;\n          for (let e = d - 1; e >= 0; e--) f[e] = e === d - 1 ? 1 : f[e + 1] * l[e + 1], h[e] = e === d - 1 ? 1 : h[e + 1] * t[0].dims[e + 1], g += `\\n        output_pitches[${e}] = ${f[e]};\\n        input_pitches[${e}] = ${h[e]};\\n        `;\n          const b = `\\n      float getInputFloat(int index) {\\n        vec2 coords = offsetToCoords(index, ${s}, ${u});\\n        float value = getColorAsFloat(${r.texture2D}(X, coords));\\n        return value;\\n      }\\n      `,\n            m = \"nearest\" === n.mode ? `\\n    ${b}\\n    float process(int indices[${d}]) {\\n      int input_index = 0;\\n      int output_index = coordsToOffset(TexCoords, ${c}, ${p});\\n\\n      ${g}\\n\\n      int d, m;\\n      for (int dim = 0; dim < ${d}; ++dim) {\\n        d = output_index / output_pitches[dim];\\n        m = output_index - d * output_pitches[dim];\\n        output_index = m;\\n\\n        if (scales[dim] != 1 && d > 0) {\\n          int d2 = d / scales[dim];\\n          m = d - d2 * scales[dim];\\n          d = d2;\\n        }\\n        input_index += input_pitches[dim] * d;\\n      }\\n\\n      return getInputFloat(input_index);\\n    }` : 4 === d ? `\\n    ${b}\\n    float process(int indices[4]) {\\n      int input_index = 0;\\n      int output_index = coordsToOffset(TexCoords, ${c}, ${p});\\n\\n      ${g}\\n\\n      int m;\\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\\n      index_of_dim0 = output_index / output_pitches[0];\\n      m = output_index - index_of_dim0 * output_pitches[0];\\n      index_of_dim1 = m / output_pitches[1];\\n      m = m - index_of_dim1 * output_pitches[1];\\n      index_of_dim2 = m / output_pitches[2];\\n      m = m - index_of_dim2 * output_pitches[2];\\n      index_of_dim3 = m;\\n\\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\\n      index_of_input_dim2 = index_of_dim2 / scales[2];\\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\\n      index_of_input_dim3 = index_of_dim3 / scales[3];\\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\\n\\n      input_index = index_of_dim0 * input_pitches[0] +\\n            index_of_dim1 * input_pitches[1] +\\n            index_of_input_dim2 * input_pitches[2] +\\n            index_of_input_dim3;\\n\\n      float x00 = getInputFloat(input_index);\\n      float x10, x01, x11;\\n\\n      bool end_of_dim2 = false;\\n      if (index_of_input_dim2 == (${t[0].dims[2]} - 1)) {\\n        // It's the end in dimension 2\\n        x01 = x00;\\n        end_of_dim2 = true;\\n      } else {\\n        x01 = getInputFloat(input_index + input_pitches[2]);\\n      }\\n\\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\\n        // It's the end in dimension 3\\n        x10 = x00;\\n        x11 = x01;\\n      }\\n      else {\\n        x10 = getInputFloat(input_index + 1);\\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\\n      }\\n\\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\\n    }` : `\\n    ${b}\\n    float process(int indices[2]) {\\n      int input_index = 0;\\n      int output_index = coordsToOffset(TexCoords, ${c}, ${p});\\n\\n      ${g}\\n\\n      int m;\\n      int index_of_dim0, index_of_dim1;\\n      index_of_dim0 = output_index / output_pitches[0];\\n      m = output_index - index_of_dim0 * output_pitches[0];\\n      index_of_dim1 = m;\\n\\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\\n      index_of_input_dim0 = index_of_dim0 / scales[0];\\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\\n      index_of_input_dim1 = index_of_dim1 / scales[1];\\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\\n\\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\\n\\n      float x00 = getInputFloat(input_index);\\n      float x10, x01, x11;\\n\\n      bool end_of_dim0 = false;\\n      if (index_of_input_dim0 == (${t[0].dims[0]} - 1)) {\\n        // It's the end in dimension 0\\n        x01 = x00;\\n        end_of_dim0 = true;\\n      } else {\\n        x01 = getInputFloat(input_index + input_pitches[0]);\\n      }\\n\\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\\n        // It's the end in dimension 1\\n        x10 = x00;\\n        x11 = x01;\\n      }\\n      else {\\n        x10 = getInputFloat(input_index + 1);\\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\\n      }\\n\\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\\n    }`;\n          return Object.assign(Object.assign({}, a), {\n            output: {\n              dims: l,\n              type: t[0].type,\n              textureType: i.TextureType.unpacked\n            },\n            shaderSource: m,\n            variables: [{\n              name: \"scales\",\n              type: \"int\",\n              arrayLength: n.scales.length,\n              data: n.scales.map(e => Math.ceil(e))\n            }]\n          });\n        };\n        t.validateInputs = (e, t) => {\n          if (!e || t.opset < 9 && 1 !== e.length || t.opset >= 9 && t.opset < 11 && 2 !== e.length || t.opset >= 11 && e.length < 2) throw new Error(\"invalid inputs.\");\n          if (t.scales.length > 0 && e[0].dims.length !== t.scales.length) throw new Error(\"Invalid input shape.\");\n          if (\"string\" === e[0].type) throw new Error(\"Invalid input tensor types.\");\n        }, t.scalesValidation = (e, t, n) => {\n          if (n) {\n            for (const t of e) if (t <= 0) throw new Error(\"Scale value should be greater than 0.\");\n          } else for (const t of e) if (t < 1) throw new Error(\"Scale value should be greater than or equal to 1.\");\n          if (!(\"linear\" !== t && \"cubic\" !== t || 2 === e.length || 4 === e.length && 1 === e[0] && 1 === e[1])) throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n ? \"Resize\" : \"Upsample\"} opeartor.`);\n        };\n      },\n      2757: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ProgramManager = void 0;\n        const r = n(2235),\n          o = n(1315),\n          i = n(8897),\n          a = n(6757);\n        t.ProgramManager = class {\n          constructor(e, t, n) {\n            this.profiler = e, this.glContext = t, this.textureLayoutStrategy = n, this.repo = new Map(), this.attributesBound = !1;\n          }\n          getArtifact(e) {\n            return this.repo.get(e);\n          }\n          setArtifact(e, t) {\n            this.repo.set(e, t);\n          }\n          run(e, t, n) {\n            var r;\n            this.profiler.event(\"op\", `ProgramManager.run ${null !== (r = e.programInfo.name) && void 0 !== r ? r : \"unknown kernel\"}`, () => {\n              var r;\n              const i = this.glContext.gl,\n                a = e.program;\n              i.useProgram(a);\n              try {\n                this.bindOutput(n), this.attributesBound || this.bindAttributes(e.attribLocations), this.bindUniforms(e.uniformLocations, null !== (r = e.programInfo.variables) && void 0 !== r ? r : [], t);\n              } catch (t) {\n                throw o.Logger.error(\"ProgramManager\", e.programInfo.shaderSource), t;\n              }\n              this.profiler.event(\"backend\", \"GlContext.draw()\", () => {\n                this.glContext.draw();\n              });\n            }, this.glContext);\n          }\n          dispose() {\n            this.vertexShader && this.glContext.deleteShader(this.vertexShader), this.repo.forEach(e => this.glContext.deleteProgram(e.program));\n          }\n          build(e, t, n) {\n            return this.profiler.event(\"backend\", \"ProgramManager.build\", () => {\n              const r = new i.GlslPreprocessor(this.glContext, e, t, n),\n                o = r.preprocess(),\n                a = this.compile(o);\n              return {\n                programInfo: e,\n                program: a,\n                uniformLocations: this.getUniformLocations(a, r.context.programInfo.inputNames, r.context.programInfo.variables),\n                attribLocations: this.getAttribLocations(a)\n              };\n            });\n          }\n          compile(e) {\n            if (!this.vertexShader) {\n              o.Logger.verbose(\"ProrgramManager\", \"Compiling and caching Vertex shader for the first time\");\n              const e = (0, a.getVertexShaderSource)(this.glContext.version);\n              this.vertexShader = this.glContext.compileShader(e, this.glContext.gl.VERTEX_SHADER);\n            }\n            r.env.debug && o.Logger.verbose(\"ProrgramManager\", `FragShader:\\n${e}\\n`);\n            const t = this.glContext.compileShader(e, this.glContext.gl.FRAGMENT_SHADER),\n              n = this.glContext.createProgram(this.vertexShader, t);\n            return this.glContext.deleteShader(t), n;\n          }\n          bindOutput(e) {\n            const t = e.width,\n              n = e.height;\n            o.Logger.verbose(\"ProrgramManager\", `Binding output texture to Framebuffer: w/h=${t}/${n}, shape=${e.shape}, type=${e.tensor.type}`), this.glContext.attachFramebuffer(e.texture, t, n);\n          }\n          bindAttributes(e) {\n            const t = e.position,\n              n = e.textureCoord;\n            this.glContext.setVertexAttributes(t, n), this.attributesBound = !0;\n          }\n          bindUniforms(e, t, n) {\n            var r;\n            const o = this.glContext.gl;\n            let i = 0;\n            for (const {\n              name: a,\n              type: s,\n              location: u,\n              arrayLength: l\n            } of e) {\n              const e = null === (r = t.find(e => e.name === a)) || void 0 === r ? void 0 : r.data;\n              if (\"sampler2D\" !== s && !e) throw new Error(`variable '${a}' does not have data defined in program info`);\n              switch (s) {\n                case \"sampler2D\":\n                  this.bindTexture(n[i], u, i), i++;\n                  break;\n                case \"float\":\n                  l ? o.uniform1fv(u, e) : o.uniform1f(u, e);\n                  break;\n                case \"int\":\n                  l ? o.uniform1iv(u, e) : o.uniform1i(u, e);\n                  break;\n                default:\n                  throw new Error(`Uniform not implemented: ${s}`);\n              }\n            }\n          }\n          bindTexture(e, t, n) {\n            this.glContext.bindTextureToUniform(e.texture, n, t);\n          }\n          getAttribLocations(e) {\n            return {\n              position: this.getAttribLocation(e, \"position\"),\n              textureCoord: this.getAttribLocation(e, \"textureCoord\")\n            };\n          }\n          getUniformLocations(e, t, n) {\n            const r = [];\n            if (t) for (const n of t) r.push({\n              name: n,\n              type: \"sampler2D\",\n              location: this.getUniformLocation(e, n)\n            });\n            if (n) for (const t of n) r.push(Object.assign(Object.assign({}, t), {\n              location: this.getUniformLocation(e, t.name)\n            }));\n            return r;\n          }\n          getUniformLocation(e, t) {\n            const n = this.glContext.gl.getUniformLocation(e, t);\n            if (null === n) throw new Error(`Uniform ${t} not found.`);\n            return n;\n          }\n          getAttribLocation(e, t) {\n            return this.glContext.gl.getAttribLocation(e, t);\n          }\n        };\n      },\n      2171: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.WebGLSessionHandler = void 0;\n        const r = n(1315),\n          o = n(5881),\n          i = n(7860),\n          a = n(4110),\n          s = n(2757),\n          u = n(7618),\n          l = n(5243);\n        t.WebGLSessionHandler = class {\n          constructor(e, t) {\n            this.backend = e, this.context = t, this.layoutStrategy = new u.PreferLogicalStrategy(e.glContext.maxTextureSize), this.programManager = new s.ProgramManager(this.context.profiler, e.glContext, this.layoutStrategy), this.textureManager = new l.TextureManager(e.glContext, this.layoutStrategy, this.context.profiler, {\n              reuseTextures: \"full\" === e.textureCacheMode\n            }), this.packedTextureDataCache = new Map(), this.unpackedTextureDataCache = new Map(), this.pack = e.pack, this.pack2unpackMap = new Map(), this.unpack2packMap = new Map();\n          }\n          createInferenceHandler() {\n            return new i.WebGLInferenceHandler(this);\n          }\n          onGraphInitialized(e) {\n            const t = e.getValues().filter(e => -1 === e.from && e.tensor).map(e => e.tensor.dataId);\n            this.initializers = new Set(t);\n          }\n          isInitializer(e) {\n            return !!this.initializers && this.initializers.has(e);\n          }\n          addInitializer(e) {\n            this.initializers.add(e);\n          }\n          getTextureData(e, t) {\n            return t ? this.packedTextureDataCache.get(e) : this.unpackedTextureDataCache.get(e);\n          }\n          setTextureData(e, t, n = !1) {\n            r.Logger.verbose(\"WebGLSessionHandler\", \"Storing Texture data in cache\"), n ? this.packedTextureDataCache.set(e, t) : this.unpackedTextureDataCache.set(e, t);\n          }\n          dispose() {\n            this.programManager.dispose(), this.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach(e => this.textureManager.releaseTexture(e, !0)), this.packedTextureDataCache = new Map(), this.unpackedTextureDataCache.forEach(e => this.textureManager.releaseTexture(e, !0)), this.unpackedTextureDataCache = new Map();\n          }\n          resolve(e, t, n) {\n            const r = (0, o.resolveOperator)(e, t, a.WEBGL_OP_RESOLVE_RULES);\n            return {\n              impl: r.opImpl,\n              context: r.opInit ? r.opInit(e, n) : e\n            };\n          }\n        };\n      },\n      9622: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Uint8DataEncoder = t.RGBAFloatDataEncoder = t.RedFloat32DataEncoder = void 0;\n        const r = n(1315);\n        t.RedFloat32DataEncoder = class {\n          constructor(e, t = 1) {\n            if (1 === t) this.internalFormat = e.R32F, this.format = e.RED, this.textureType = e.FLOAT, this.channelSize = t;else {\n              if (4 !== t) throw new Error(`Invalid number of channels: ${t}`);\n              this.internalFormat = e.RGBA32F, this.format = e.RGBA, this.textureType = e.FLOAT, this.channelSize = t;\n            }\n          }\n          encode(e, t) {\n            let n, o;\n            return e.constructor !== Float32Array && (r.Logger.warning(\"Encoder\", \"data was not of type Float32; creating new Float32Array\"), o = new Float32Array(e)), t * this.channelSize > e.length ? (r.Logger.warning(\"Encoder\", \"Source data too small. Allocating larger array\"), o = e, n = this.allocate(t * this.channelSize), o.forEach((e, t) => n[t] = e)) : (o = e, n = o), n;\n          }\n          allocate(e) {\n            return new Float32Array(4 * e);\n          }\n          decode(e, t) {\n            return 1 === this.channelSize ? e.filter((e, t) => t % 4 == 0).subarray(0, t) : e.subarray(0, t);\n          }\n        }, t.RGBAFloatDataEncoder = class {\n          constructor(e, t = 1, n) {\n            if (1 !== t && 4 !== t) throw new Error(`Invalid number of channels: ${t}`);\n            this.internalFormat = e.RGBA, this.format = e.RGBA, this.channelSize = t, this.textureType = n || e.FLOAT;\n          }\n          encode(e, t) {\n            let n = e;\n            return 1 === this.channelSize && (r.Logger.verbose(\"Encoder\", \"Exploding into a larger array\"), n = this.allocate(t), e.forEach((e, t) => n[4 * t] = e)), n;\n          }\n          allocate(e) {\n            return new Float32Array(4 * e);\n          }\n          decode(e, t) {\n            return 1 === this.channelSize ? e.filter((e, t) => t % 4 == 0).subarray(0, t) : e.subarray(0, t);\n          }\n        }, t.Uint8DataEncoder = class {\n          constructor(e, t = 1) {\n            if (this.channelSize = 4, 1 === t) this.internalFormat = e.ALPHA, this.format = e.ALPHA, this.textureType = e.UNSIGNED_BYTE, this.channelSize = t;else {\n              if (4 !== t) throw new Error(`Invalid number of channels: ${t}`);\n              this.internalFormat = e.RGBA, this.format = e.RGBA, this.textureType = e.UNSIGNED_BYTE, this.channelSize = t;\n            }\n          }\n          encode(e, t) {\n            return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);\n          }\n          allocate(e) {\n            return new Uint8Array(e * this.channelSize);\n          }\n          decode(e, t) {\n            if (e instanceof Uint8Array) return e.subarray(0, t);\n            throw new Error(`Invalid array type: ${e.constructor}`);\n          }\n        };\n      },\n      7618: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getBatchDim = t.sizeToSquarishShape = t.getRowsCols = t.sizeFromShape = t.isInt = t.parseAxisParam = t.squeezeShape = t.PreferLogicalStrategy = t.AlwaysKeepOriginalSizeStrategy = void 0;\n        const r = n(1315),\n          o = n(7273);\n        function i(e, t) {\n          const n = [],\n            r = [],\n            o = null != t && Array.isArray(t) && 0 === t.length,\n            i = null == t || o ? null : a(t, e).sort();\n          let s = 0;\n          for (let t = 0; t < e.length; ++t) {\n            if (null != i) {\n              if (i[s] === t && 1 !== e[t]) throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);\n              (null == i[s] || i[s] > t) && 1 === e[t] && (n.push(e[t]), r.push(t)), i[s] <= t && s++;\n            }\n            1 !== e[t] && (n.push(e[t]), r.push(t));\n          }\n          return {\n            newShape: n,\n            keptDims: r\n          };\n        }\n        function a(e, t) {\n          const n = t.length;\n          return e = null == e ? t.map((e, t) => t) : [].concat(e), (0, o.assert)(e.every(e => e >= -n && e < n), () => `All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`), (0, o.assert)(e.every(s), () => `All values in axis param must be integers but got axis ${e}`), e.map(e => e < 0 ? n + e : e);\n        }\n        function s(e) {\n          return e % 1 == 0;\n        }\n        function u(e) {\n          if (0 === e.length) return 1;\n          let t = e[0];\n          for (let n = 1; n < e.length; n++) t *= e[n];\n          return t;\n        }\n        function l(e) {\n          const t = Math.ceil(Math.sqrt(e));\n          return [t, Math.ceil(e / t)];\n        }\n        t.AlwaysKeepOriginalSizeStrategy = class {\n          constructor(e) {\n            this.maxTextureSize = e;\n          }\n          computeTextureWH(e, t) {\n            if (0 === e.length) return [1, 1];\n            const n = this.maxTextureSize;\n            if (t && void 0 !== t.breakAxis) {\n              const o = t.breakAxis >= e.length ? 1 : e.slice(t.breakAxis).reduce((e, t) => e * t),\n                i = t.breakAxis <= 0 ? 1 : e.slice(0, t.breakAxis).reduce((e, t) => e * t);\n              if (!(o > n || i > n)) return [o, i];\n              r.Logger.verbose(\"TextureLayout\", `Given width/height preferences were unattainable: shape:${e}, breakAxis:${t.breakAxis}`);\n            }\n            const o = e.reduce((e, t) => e * t);\n            let i = Math.floor(Math.sqrt(o));\n            for (; i < n && i < o && o % i != 0; i++);\n            if (i >= n || o % i != 0) throw new Error(`The given dimensions are outside this GPU's boundaries: ${e}`);\n            return [i, o / i];\n          }\n        }, t.PreferLogicalStrategy = class {\n          constructor(e) {\n            this.maxTextureSize = e;\n          }\n          computeTextureWH(e, t) {\n            const n = this.computeTexture(e, t);\n            return t && t.isPacked && (n[0] /= 2, n[1] /= 2), t && t.reverseWH ? [n[1], n[0]] : n;\n          }\n          computeTexture(e, t) {\n            const n = t && t.isPacked;\n            if (0 === e.length) return n ? [2, 2] : [1, 1];\n            let o = this.maxTextureSize;\n            if (t && void 0 !== t.breakAxis) {\n              const n = t.breakAxis >= e.length ? 1 : e.slice(t.breakAxis).reduce((e, t) => e * t),\n                i = t.breakAxis <= 0 ? 1 : e.slice(0, t.breakAxis).reduce((e, t) => e * t);\n              if (!(n > o || i > o)) return [n, i];\n              r.Logger.verbose(\"TextureLayout\", `Given width/height preferences were unattainable: shape:${e}, breakAxis:${t.breakAxis}`);\n            }\n            let a = e.slice(0);\n            if (n && (o *= 2, a = a.map((e, t) => t >= a.length - 2 ? a[t] % 2 == 0 ? a[t] : a[t] + 1 : a[t]), 1 === a.length && (a = [2, a[0]])), 2 !== a.length) {\n              const e = i(a);\n              a = e.newShape;\n            }\n            const s = u(a);\n            return a.length <= 1 && s <= o ? [1, s] : 2 === a.length && a[0] <= o && a[1] <= o ? a : 3 === a.length && a[0] * a[1] <= o && a[2] <= o ? [a[0] * a[1], a[2]] : 3 === a.length && a[0] <= o && a[1] * a[2] <= o ? [a[0], a[1] * a[2]] : 4 === a.length && a[0] * a[1] * a[2] <= o && a[3] <= o ? [a[0] * a[1] * a[2], a[3]] : 4 === a.length && a[0] <= o && a[1] * a[2] * a[3] <= o ? [a[0], a[1] * a[2] * a[3]] : n ? l(s / 4).map(e => 2 * e) : l(s);\n          }\n        }, t.squeezeShape = i, t.parseAxisParam = a, t.isInt = s, t.sizeFromShape = u, t.getRowsCols = function (e) {\n          if (0 === e.length) throw Error(\"Cannot get rows and columns of an empty shape array.\");\n          return [e.length > 1 ? e[e.length - 2] : 1, e[e.length - 1]];\n        }, t.sizeToSquarishShape = l, t.getBatchDim = function (e, t = 2) {\n          return u(e.slice(0, e.length - t));\n        };\n      },\n      3314: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.createTextureLayoutFromShape = t.calculateTextureWidthAndHeight = t.createTextureLayoutFromTextureType = void 0;\n        const r = n(7273),\n          o = n(5639);\n        t.createTextureLayoutFromTextureType = (e, n, r) => {\n          const i = r === o.TextureType.unpacked || r === o.TextureType.unpackedReversed ? 1 : 4,\n            a = r === o.TextureType.packed,\n            s = r === o.TextureType.unpackedReversed || r === o.TextureType.packed,\n            u = r === o.TextureType.packedLastDimension ? n.length - 1 : void 0,\n            l = r === o.TextureType.packedLastDimension ? n.map((e, t) => t === n.length - 1 ? 4 * e : e) : void 0;\n          return (0, t.createTextureLayoutFromShape)(e, n, i, l, {\n            isPacked: a,\n            reverseWH: s,\n            breakAxis: u\n          });\n        }, t.calculateTextureWidthAndHeight = (e, n, r) => {\n          const o = (0, t.createTextureLayoutFromTextureType)(e, n, r);\n          return [o.width, o.height];\n        }, t.createTextureLayoutFromShape = (e, t, n = 1, o, i) => {\n          const a = !(!i || !i.isPacked),\n            [s, u] = e.computeTextureWH(a && o || t, i),\n            l = t.length;\n          let c = t.slice(0);\n          if (0 === l && (c = [1]), 1 === n) o = t;else if (a) {\n            if (4 !== n) throw new Error(\"a packed texture must be 4-channel\");\n            o = t, l > 0 && (c[l - 1] = Math.ceil(c[l - 1] / 2)), l > 1 && (c[l - 2] = Math.ceil(c[l - 2] / 2));\n          } else if (!o) throw new Error(\"Unpacked shape is needed when using channels > 1\");\n          return {\n            width: s,\n            height: u,\n            channels: n,\n            isPacked: a,\n            shape: c,\n            strides: r.ShapeUtil.computeStrides(c),\n            unpackedShape: o,\n            reversedWH: i && i.reverseWH\n          };\n        };\n      },\n      5243: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.TextureManager = void 0;\n        const r = n(1315);\n        t.TextureManager = class {\n          constructor(e, t, n, r) {\n            this.glContext = e, this.layoutStrategy = t, this.profiler = n, this.config = r, this.pendingRead = new Map(), r.reuseTextures && (this.inUseTextures = new Map(), this.idleTextures = new Map(), this.textureLookup = new Map());\n          }\n          createTextureFromLayout(e, t, n, o) {\n            const i = this.toEncoderType(e),\n              a = this.glContext.getEncoder(i, t.channels || 1, o);\n            if (t.isPacked && 1 === o) throw new Error(\"not implemented\");\n            const s = t.width,\n              u = t.height;\n            let l, c;\n            if (this.config.reuseTextures) {\n              l = `${s}x${u}_${a.format}_${a.internalFormat}_${a.textureType}`, c = this.inUseTextures.get(l), c || (c = [], this.inUseTextures.set(l, c));\n              const t = this.idleTextures.get(l);\n              if (t && t.length > 0) {\n                const r = t.pop();\n                return c.push(r), 1 === o && this.glContext.updateTexture(r, s, u, a, this.toTextureData(e, n)), r;\n              }\n            }\n            r.Logger.verbose(\"TextureManager\", `Creating new texture of size ${t.width}x${t.height}`);\n            const p = this.glContext.allocateTexture(s, u, a, this.toTextureData(e, n));\n            return this.config.reuseTextures && (c.push(p), this.textureLookup.set(p, l)), p;\n          }\n          readTexture(e, t, n) {\n            return n || (n = 1), this.profiler.event(\"backend\", \"TextureManager.readTexture\", () => {\n              const r = e.shape.reduce((e, t) => e * t) * n,\n                o = this.glContext.readTexture(e.texture, e.width, e.height, r, this.toEncoderType(t), n);\n              return this.toTensorData(t, o);\n            });\n          }\n          async readTextureAsync(e, t, n) {\n            const r = e.tensor.dataId;\n            if (n || (n = 1), this.pendingRead.has(r)) {\n              const e = this.pendingRead.get(r);\n              return new Promise(t => null == e ? void 0 : e.push(t));\n            }\n            return this.profiler.event(\"backend\", \"TextureManager.readTextureAsync\", async () => {\n              this.pendingRead.set(r, []);\n              const o = e.shape.reduce((e, t) => e * t) * n;\n              await this.glContext.createAndWaitForFence();\n              const i = this.glContext.readTexture(e.texture, e.width, e.height, o, this.toEncoderType(t), n),\n                a = this.toTensorData(t, i),\n                s = this.pendingRead.get(r);\n              return this.pendingRead.delete(r), null == s || s.forEach(e => e(a)), a;\n            });\n          }\n          readUint8TextureAsFloat(e) {\n            return this.profiler.event(\"backend\", \"TextureManager.readUint8TextureAsFloat\", () => {\n              const t = e.shape.reduce((e, t) => e * t),\n                n = this.glContext.readTexture(e.texture, e.width, e.height, 4 * t, \"byte\", 4);\n              return new Float32Array(n.buffer, n.byteOffset, t);\n            });\n          }\n          releaseTexture(e, t) {\n            let n;\n            if (this.config.reuseTextures && (n = this.textureLookup.get(e.texture), n)) {\n              t && this.textureLookup.delete(n);\n              const r = this.inUseTextures.get(n);\n              if (r) {\n                const t = r.indexOf(e.texture);\n                if (-1 !== t) {\n                  r.splice(t, 1);\n                  let o = this.idleTextures.get(n);\n                  o || (o = [], this.idleTextures.set(n, o)), o.push(e.texture);\n                }\n              }\n            }\n            n && !t || (r.Logger.verbose(\"TextureManager\", `Deleting texture of size ${e.width}x${e.height}`), this.glContext.deleteTexture(e.texture));\n          }\n          toTensorData(e, t) {\n            switch (e) {\n              case \"int16\":\n                return t instanceof Int16Array ? t : Int16Array.from(t);\n              case \"int32\":\n                return t instanceof Int32Array ? t : Int32Array.from(t);\n              case \"int8\":\n                return t instanceof Int8Array ? t : Int8Array.from(t);\n              case \"uint16\":\n                return t instanceof Uint16Array ? t : Uint16Array.from(t);\n              case \"uint32\":\n                return t instanceof Uint32Array ? t : Uint32Array.from(t);\n              case \"uint8\":\n              case \"bool\":\n                return t instanceof Uint8Array ? t : Uint8Array.from(t);\n              case \"float32\":\n                return t instanceof Float32Array ? t : Float32Array.from(t);\n              case \"float64\":\n                return t instanceof Float64Array ? t : Float64Array.from(t);\n              default:\n                throw new Error(`TensorData type ${e} is not supported`);\n            }\n          }\n          toTextureData(e, t) {\n            if (t) return t instanceof Float32Array ? t : new Float32Array(t);\n          }\n          toEncoderType(e) {\n            return \"float\";\n          }\n          clearActiveTextures() {\n            this.glContext.clearActiveTextures();\n          }\n        };\n      },\n      5639: (e, t) => {\n        \"use strict\";\n\n        var n;\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.TextureType = void 0, (n = t.TextureType || (t.TextureType = {}))[n.unpacked = 0] = \"unpacked\", n[n.unpackedReversed = 1] = \"unpackedReversed\", n[n.packed = 2] = \"packed\", n[n.downloadUint8AsFloat = 3] = \"downloadUint8AsFloat\", n[n.packedLastDimension = 4] = \"packedLastDimension\";\n      },\n      432: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.getGlChannels = t.getCoordsDataType = t.getSqueezedParams = t.squeezeInputShape = t.generateShaderFuncNameFromInputSamplerNameAtOutCoords = t.generateShaderFuncNameFromInputSamplerName = t.repeatedTry = t.getPackedShape = void 0;\n        const r = n(7273);\n        t.getPackedShape = function (e) {\n          const t = e.length;\n          return e.slice(0, t - 1).concat(e[t - 1] / 4);\n        }, t.repeatedTry = async function (e, t = e => 0, n) {\n          return new Promise((r, o) => {\n            let i = 0;\n            const a = () => {\n              if (e()) return void r();\n              i++;\n              const s = t(i);\n              null != n && i >= n ? o() : setTimeout(a, s);\n            };\n            a();\n          });\n        }, t.generateShaderFuncNameFromInputSamplerName = function (e) {\n          return (0, r.assert)(void 0 !== e && 0 !== e.length, () => \"empty string found for sampler name\"), \"get\" + e.charAt(0).toUpperCase() + e.slice(1);\n        }, t.generateShaderFuncNameFromInputSamplerNameAtOutCoords = function (e) {\n          return (0, r.assert)(void 0 !== e && 0 !== e.length, () => \"empty string found for sampler name\"), \"get\" + e.charAt(0).toUpperCase() + e.slice(1) + \"AtOutCoords\";\n        }, t.squeezeInputShape = function (e, t) {\n          let n = JSON.parse(JSON.stringify(e));\n          return n = t, n;\n        }, t.getSqueezedParams = function (e, t) {\n          return t.map(t => e[t]).join(\", \");\n        }, t.getCoordsDataType = function (e) {\n          if (e <= 1) return \"int\";\n          if (2 === e) return \"ivec2\";\n          if (3 === e) return \"ivec3\";\n          if (4 === e) return \"ivec4\";\n          if (5 === e) return \"ivec5\";\n          if (6 === e) return \"ivec6\";\n          throw Error(`GPU for rank ${e} is not yet supported`);\n        }, t.getGlChannels = function (e = 6) {\n          return [\"x\", \"y\", \"z\", \"w\", \"u\", \"v\"].slice(0, e);\n        };\n      },\n      3389: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.createNewWebGLContext = t.createWebGLContext = void 0;\n        const r = n(1315),\n          o = n(3524),\n          i = {};\n        function a(e, t) {\n          let n;\n          const i = {\n            alpha: !1,\n            depth: !1,\n            antialias: !1,\n            stencil: !1,\n            preserveDrawingBuffer: !1,\n            premultipliedAlpha: !1,\n            failIfMajorPerformanceCaveat: !1\n          };\n          if ((!t || \"webgl2\" === t) && (n = e.getContext(\"webgl2\", i), n)) try {\n            return new o.WebGLContext(n, 2);\n          } catch (e) {\n            r.Logger.warning(\"GlContextFactory\", `failed to create WebGLContext using contextId 'webgl2'. Error: ${e}`);\n          }\n          if ((!t || \"webgl\" === t) && (n = e.getContext(\"webgl\", i) || e.getContext(\"experimental-webgl\", i), n)) try {\n            return new o.WebGLContext(n, 1);\n          } catch (e) {\n            r.Logger.warning(\"GlContextFactory\", `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${e}`);\n          }\n          throw new Error(\"WebGL is not supported\");\n        }\n        t.createWebGLContext = function e(t) {\n          let n;\n          if (t && \"webgl2\" !== t || !(\"webgl2\" in i) ? t && \"webgl\" !== t || !(\"webgl\" in i) || (n = i.webgl) : n = i.webgl2, !n) try {\n            n = a(function () {\n              if (\"undefined\" == typeof OffscreenCanvas) throw new TypeError(\"failed to create offscreen canvas: OffscreenCanvas is not supported\");\n              return new OffscreenCanvas(1, 1);\n            }(), t);\n          } catch (e) {\n            n = a(function () {\n              if (\"undefined\" == typeof document) throw new TypeError(\"failed to create canvas: document is not supported\");\n              const e = document.createElement(\"canvas\");\n              return e.width = 1, e.height = 1, e;\n            }(), t);\n          }\n          t = t || 1 === n.version ? \"webgl\" : \"webgl2\";\n          const r = n.gl;\n          return i[t] = n, r.isContextLost() ? (delete i[t], e(t)) : (r.disable(r.DEPTH_TEST), r.disable(r.STENCIL_TEST), r.disable(r.BLEND), r.disable(r.DITHER), r.disable(r.POLYGON_OFFSET_FILL), r.disable(r.SAMPLE_COVERAGE), r.enable(r.SCISSOR_TEST), r.enable(r.CULL_FACE), r.cullFace(r.BACK), n);\n        }, t.createNewWebGLContext = a;\n      },\n      3524: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__createBinding || (Object.create ? function (e, t, n, r) {\n            void 0 === r && (r = n);\n            var o = Object.getOwnPropertyDescriptor(t, n);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[n];\n              }\n            }), Object.defineProperty(e, r, o);\n          } : function (e, t, n, r) {\n            void 0 === r && (r = n), e[r] = t[n];\n          }),\n          o = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          i = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var n in e) \"default\" !== n && Object.prototype.hasOwnProperty.call(e, n) && r(t, e, n);\n            return o(t, e), t;\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.WebGLContext = t.linearSearchLastTrue = void 0;\n        const a = n(2235),\n          s = i(n(9622)),\n          u = n(432);\n        function l(e) {\n          let t = 0;\n          for (; t < e.length && e[t](); ++t);\n          return t - 1;\n        }\n        t.linearSearchLastTrue = l, t.WebGLContext = class {\n          constructor(e, t) {\n            this.frameBufferBound = !1, this.itemsToPoll = [], this.gl = e, this.version = t, this.getExtensions(), this.vertexbuffer = this.createVertexbuffer(), this.framebuffer = this.createFramebuffer(), this.queryVitalParameters();\n          }\n          allocateTexture(e, t, n, r) {\n            const o = this.gl,\n              i = o.createTexture();\n            o.bindTexture(o.TEXTURE_2D, i), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, o.NEAREST), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, o.NEAREST), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.CLAMP_TO_EDGE);\n            const a = r ? n.encode(r, e * t) : null;\n            return o.texImage2D(o.TEXTURE_2D, 0, n.internalFormat, e, t, 0, n.format, n.textureType, a), this.checkError(), i;\n          }\n          updateTexture(e, t, n, r, o) {\n            const i = this.gl;\n            i.bindTexture(i.TEXTURE_2D, e);\n            const a = r.encode(o, t * n);\n            i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, t, n, r.format, r.textureType, a), this.checkError();\n          }\n          attachFramebuffer(e, t, n) {\n            const r = this.gl;\n            r.bindTexture(r.TEXTURE_2D, e), r.bindFramebuffer(r.FRAMEBUFFER, this.framebuffer), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, e, 0), this.checkError(), r.viewport(0, 0, t, n), r.scissor(0, 0, t, n);\n          }\n          readTexture(e, t, n, r, o, i) {\n            const a = this.gl;\n            i || (i = 1), this.frameBufferBound || this.attachFramebuffer(e, t, n);\n            const s = this.getEncoder(o, i),\n              u = s.allocate(t * n);\n            return a.bindTexture(a.TEXTURE_2D, e), a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, e, 0), a.readPixels(0, 0, t, n, a.RGBA, s.textureType, u), this.checkError(), s.decode(u, r);\n          }\n          isFramebufferReady() {\n            return !0;\n          }\n          getActiveTexture() {\n            const e = this.gl;\n            return \"TEXTURE\" + (e.getParameter(this.gl.ACTIVE_TEXTURE) - e.TEXTURE0);\n          }\n          getTextureBinding() {\n            return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);\n          }\n          getFramebufferBinding() {\n            return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);\n          }\n          setVertexAttributes(e, t) {\n            const n = this.gl;\n            n.vertexAttribPointer(e, 3, n.FLOAT, !1, 20, 0), n.enableVertexAttribArray(e), -1 !== t && (n.vertexAttribPointer(t, 2, n.FLOAT, !1, 20, 12), n.enableVertexAttribArray(t)), this.checkError();\n          }\n          createProgram(e, t) {\n            const n = this.gl,\n              r = n.createProgram();\n            return n.attachShader(r, e), n.attachShader(r, t), n.linkProgram(r), r;\n          }\n          compileShader(e, t) {\n            const n = this.gl,\n              r = n.createShader(t);\n            if (!r) throw new Error(`createShader() returned null with type ${t}`);\n            if (n.shaderSource(r, e), n.compileShader(r), !1 === n.getShaderParameter(r, n.COMPILE_STATUS)) throw new Error(`Failed to compile shader: ${n.getShaderInfoLog(r)}\\nShader source:\\n${e}`);\n            return r;\n          }\n          deleteShader(e) {\n            this.gl.deleteShader(e);\n          }\n          bindTextureToUniform(e, t, n) {\n            const r = this.gl;\n            r.activeTexture(r.TEXTURE0 + t), this.checkError(), r.bindTexture(r.TEXTURE_2D, e), this.checkError(), r.uniform1i(n, t), this.checkError();\n          }\n          draw() {\n            this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.checkError();\n          }\n          checkError() {\n            if (a.env.debug) {\n              const e = this.gl,\n                t = e.getError();\n              let n = \"\";\n              switch (t) {\n                case e.NO_ERROR:\n                  return;\n                case e.INVALID_ENUM:\n                  n = \"INVALID_ENUM\";\n                  break;\n                case e.INVALID_VALUE:\n                  n = \"INVALID_VALUE\";\n                  break;\n                case e.INVALID_OPERATION:\n                  n = \"INVALID_OPERATION\";\n                  break;\n                case e.INVALID_FRAMEBUFFER_OPERATION:\n                  n = \"INVALID_FRAMEBUFFER_OPERATION\";\n                  break;\n                case e.OUT_OF_MEMORY:\n                  n = \"OUT_OF_MEMORY\";\n                  break;\n                case e.CONTEXT_LOST_WEBGL:\n                  n = \"CONTEXT_LOST_WEBGL\";\n                  break;\n                default:\n                  n = `Unknown WebGL Error: ${t.toString(16)}`;\n              }\n              throw new Error(n);\n            }\n          }\n          deleteTexture(e) {\n            this.gl.deleteTexture(e);\n          }\n          deleteProgram(e) {\n            this.gl.deleteProgram(e);\n          }\n          getEncoder(e, t, n = 0) {\n            if (2 === this.version) return new s.RedFloat32DataEncoder(this.gl, t);\n            switch (e) {\n              case \"float\":\n                return 1 === n || this.isRenderFloat32Supported ? new s.RGBAFloatDataEncoder(this.gl, t) : new s.RGBAFloatDataEncoder(this.gl, t, this.textureHalfFloatExtension.HALF_FLOAT_OES);\n              case \"int\":\n                throw new Error(\"not implemented\");\n              case \"byte\":\n                return new s.Uint8DataEncoder(this.gl, t);\n              default:\n                throw new Error(`Invalid dataType: ${e}`);\n            }\n          }\n          clearActiveTextures() {\n            const e = this.gl;\n            for (let t = 0; t < this.maxTextureImageUnits; ++t) e.activeTexture(e.TEXTURE0 + t), e.bindTexture(e.TEXTURE_2D, null);\n          }\n          dispose() {\n            if (this.disposed) return;\n            const e = this.gl;\n            e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteFramebuffer(this.framebuffer), e.bindBuffer(e.ARRAY_BUFFER, null), e.deleteBuffer(this.vertexbuffer), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null), e.finish(), this.disposed = !0;\n          }\n          createDefaultGeometry() {\n            return new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);\n          }\n          createVertexbuffer() {\n            const e = this.gl,\n              t = e.createBuffer();\n            if (!t) throw new Error(\"createBuffer() returned null\");\n            const n = this.createDefaultGeometry();\n            return e.bindBuffer(e.ARRAY_BUFFER, t), e.bufferData(e.ARRAY_BUFFER, n, e.STATIC_DRAW), this.checkError(), t;\n          }\n          createFramebuffer() {\n            const e = this.gl.createFramebuffer();\n            if (!e) throw new Error(\"createFramebuffer returned null\");\n            return e;\n          }\n          queryVitalParameters() {\n            const e = this.gl;\n            if (this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer(), this.isRenderFloat32Supported = this.checkRenderFloat32(), this.isFloat32DownloadSupported = this.checkFloat32Download(), 1 === this.version && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported) throw new Error(\"both float32 and float16 TextureType are not supported\");\n            this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend(), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), this.maxTextureImageUnits = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), this.version;\n          }\n          getExtensions() {\n            2 === this.version ? (this.colorBufferFloatExtension = this.gl.getExtension(\"EXT_color_buffer_float\"), this.disjointTimerQueryWebgl2Extension = this.gl.getExtension(\"EXT_disjoint_timer_query_webgl2\")) : (this.textureFloatExtension = this.gl.getExtension(\"OES_texture_float\"), this.textureHalfFloatExtension = this.gl.getExtension(\"OES_texture_half_float\"));\n          }\n          checkFloatTextureAttachableToFrameBuffer() {\n            const e = this.gl,\n              t = e.createTexture();\n            e.bindTexture(e.TEXTURE_2D, t);\n            const n = 2 === this.version ? e.RGBA32F : e.RGBA;\n            e.texImage2D(e.TEXTURE_2D, 0, n, 1, 1, 0, e.RGBA, e.FLOAT, null);\n            const r = e.createFramebuffer();\n            e.bindFramebuffer(e.FRAMEBUFFER, r), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0);\n            const o = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;\n            return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(t), e.deleteFramebuffer(r), o;\n          }\n          checkRenderFloat32() {\n            if (2 === this.version) {\n              if (!this.colorBufferFloatExtension) return !1;\n            } else if (!this.textureFloatExtension) return !1;\n            return this.isFloatTextureAttachableToFrameBuffer;\n          }\n          checkFloat32Download() {\n            if (2 === this.version) {\n              if (!this.colorBufferFloatExtension) return !1;\n            } else {\n              if (!this.textureFloatExtension) return !1;\n              if (!this.gl.getExtension(\"WEBGL_color_buffer_float\")) return !1;\n            }\n            return this.isFloatTextureAttachableToFrameBuffer;\n          }\n          checkFloat32Blend() {\n            const e = this.gl;\n            let t, n, r, o, i;\n            try {\n              t = e.createTexture(), n = e.createFramebuffer(), e.bindTexture(e.TEXTURE_2D, t);\n              const a = 2 === this.version ? e.RGBA32F : e.RGBA;\n              return e.texImage2D(e.TEXTURE_2D, 0, a, 1, 1, 0, e.RGBA, e.FLOAT, null), e.bindFramebuffer(e.FRAMEBUFFER, n), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0), e.enable(e.BLEND), r = e.createShader(e.VERTEX_SHADER), !!r && (e.shaderSource(r, \"void main(){}\"), e.compileShader(r), o = e.createShader(e.FRAGMENT_SHADER), !!o && (e.shaderSource(o, \"precision highp float;void main(){gl_FragColor=vec4(0.5);}\"), e.compileShader(o), i = e.createProgram(), !!i && (e.attachShader(i, r), e.attachShader(i, o), e.linkProgram(i), e.useProgram(i), e.drawArrays(e.POINTS, 0, 1), e.getError() === e.NO_ERROR)));\n            } finally {\n              e.disable(e.BLEND), i && e.deleteProgram(i), r && e.deleteShader(r), o && e.deleteShader(o), n && (e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteFramebuffer(n)), t && (e.bindTexture(e.TEXTURE_2D, null), e.deleteTexture(t));\n            }\n          }\n          beginTimer() {\n            if (2 === this.version && this.disjointTimerQueryWebgl2Extension) {\n              const e = this.gl,\n                t = this.disjointTimerQueryWebgl2Extension,\n                n = e.createQuery();\n              return e.beginQuery(t.TIME_ELAPSED_EXT, n), n;\n            }\n            throw new Error(\"WebGL1 profiling currently not supported.\");\n          }\n          endTimer() {\n            if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension) throw new Error(\"WebGL1 profiling currently not supported\");\n            {\n              const e = this.gl,\n                t = this.disjointTimerQueryWebgl2Extension;\n              e.endQuery(t.TIME_ELAPSED_EXT);\n            }\n          }\n          isTimerResultAvailable(e) {\n            let t = !1,\n              n = !1;\n            if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension) throw new Error(\"WebGL1 profiling currently not supported\");\n            {\n              const r = this.gl,\n                o = this.disjointTimerQueryWebgl2Extension;\n              t = r.getQueryParameter(e, r.QUERY_RESULT_AVAILABLE), n = r.getParameter(o.GPU_DISJOINT_EXT);\n            }\n            return t && !n;\n          }\n          getTimerResult(e) {\n            let t = 0;\n            if (2 !== this.version) throw new Error(\"WebGL1 profiling currently not supported\");\n            {\n              const n = this.gl;\n              t = n.getQueryParameter(e, n.QUERY_RESULT), n.deleteQuery(e);\n            }\n            return t / 1e6;\n          }\n          async waitForQueryAndGetTime(e) {\n            return await (0, u.repeatedTry)(() => this.isTimerResultAvailable(e)), this.getTimerResult(e);\n          }\n          async createAndWaitForFence() {\n            const e = this.createFence(this.gl);\n            return this.pollFence(e);\n          }\n          createFence(e) {\n            let t;\n            const n = e,\n              r = n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE, 0);\n            return e.flush(), t = null === r ? () => !0 : () => {\n              const e = n.clientWaitSync(r, 0, 0);\n              return e === n.ALREADY_SIGNALED || e === n.CONDITION_SATISFIED;\n            }, {\n              query: r,\n              isFencePassed: t\n            };\n          }\n          async pollFence(e) {\n            return new Promise(t => {\n              this.addItemToPoll(() => e.isFencePassed(), () => t());\n            });\n          }\n          pollItems() {\n            const e = l(this.itemsToPoll.map(e => e.isDoneFn));\n            for (let t = 0; t <= e; ++t) {\n              const {\n                resolveFn: e\n              } = this.itemsToPoll[t];\n              e();\n            }\n            this.itemsToPoll = this.itemsToPoll.slice(e + 1);\n          }\n          async addItemToPoll(e, t) {\n            this.itemsToPoll.push({\n              isDoneFn: e,\n              resolveFn: t\n            }), this.itemsToPoll.length > 1 || (await (0, u.repeatedTry)(() => (this.pollItems(), 0 === this.itemsToPoll.length)));\n          }\n        };\n      },\n      6496: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.ExecutionPlan = void 0;\n        const r = n(1315);\n        class o {\n          constructor(e, t) {\n            this.op = e, this.node = t;\n          }\n        }\n        t.ExecutionPlan = class {\n          constructor(e, t, n) {\n            this.graph = e, this.profiler = n, this.initialize(t);\n          }\n          initialize(e) {\n            this.profiler.event(\"session\", \"ExecutionPlan.initialize\", () => {\n              const t = this.graph.getNodes();\n              if (t.length !== e.length) throw new Error(\"The size of nodes and OPs do not match.\");\n              this._ops = e.map((e, n) => new o(e, t[n])), this.reset(), this._starter = [], this._ops.forEach((e, t) => {\n                let n = !0;\n                for (const t of e.node.inputs) if (!this._values[t] && -1 === this.graph.getInputIndices().indexOf(t)) {\n                  n = !1;\n                  break;\n                }\n                n && this._starter.push(t);\n              });\n            });\n          }\n          reset() {\n            this._values = this.graph.getValues().map(e => e.tensor);\n          }\n          async execute(e, t) {\n            return this.profiler.event(\"session\", \"ExecutionPlan.execute\", async () => {\n              this.reset();\n              const n = e.createInferenceHandler(),\n                o = this.graph.getInputIndices();\n              if (t.length !== o.length) throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${t.length} expected: ${o.length}`);\n              t.forEach((e, t) => {\n                const n = o[t];\n                this._values[n] = e;\n              });\n              const i = this._starter.slice(0),\n                a = this.graph.getValues(),\n                s = this.graph.getNodes();\n              let u = 0;\n              for (; u < i.length;) {\n                const e = i[u++],\n                  t = this._ops[e],\n                  o = t.node.inputs.map(e => this._values[e]);\n                if (-1 !== o.indexOf(void 0)) throw new Error(`unresolved input detected: op: ${t.node}`);\n                const l = o;\n                r.Logger.verbose(\"ExecPlan\", `Runing op:${t.node.name} (${l.map((e, n) => `'${t.node.inputs[n]}': ${e.type}[${e.dims.join(\",\")}]`).join(\", \")})`);\n                const c = await this.profiler.event(\"node\", t.node.name, async () => t.op.impl(n, l, t.op.context));\n                if (c.length !== t.node.outputs.length) throw new Error(\"the size of output does not match model definition.\");\n                c.forEach((e, n) => {\n                  const r = t.node.outputs[n];\n                  if (this._values[r]) throw new Error(`output [${r}] already has value: op:${t.node.name}`);\n                  this._values[r] = e;\n                });\n                const p = new Set();\n                c.forEach((e, n) => {\n                  const r = t.node.outputs[n];\n                  for (const e of a[r].to) {\n                    const t = s[e];\n                    let n = !0;\n                    for (const e of t.inputs) if (!this._values[e]) {\n                      n = !1;\n                      break;\n                    }\n                    n && p.add(e);\n                  }\n                }), i.push(...p);\n              }\n              const l = [];\n              for (let e = 0; e < this.graph.getOutputIndices().length; e++) {\n                const t = this.graph.getOutputIndices()[e],\n                  n = this._values[t];\n                if (void 0 === n) throw new Error(`required output [${t}] does not have value`);\n                0 === t ? await n.getData() : n.data, l.push(n);\n              }\n              return r.Logger.verbose(\"ExecPlan\", \"disposing of inferenceHandler\"), n.dispose(), l;\n            });\n          }\n        };\n      },\n      4662: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Graph = void 0;\n        const r = n(6874),\n          o = n(5127),\n          i = n(2446),\n          a = n(9240),\n          s = n(7273);\n        var u = o.onnxruntime.experimental.fbs;\n        t.Graph = {\n          from: (e, t) => new p(e, t)\n        };\n        class l {\n          constructor(e) {\n            this._from = void 0, this._to = [], this.tensor = void 0, this.type = void 0, e && (this.type = s.ProtoUtil.tensorValueTypeFromProto(e.type.tensorType));\n          }\n          get from() {\n            return this._from;\n          }\n          get to() {\n            return this._to;\n          }\n        }\n        class c {\n          constructor(e, t) {\n            e instanceof i.onnx.NodeProto ? (this.name = e.name, this.opType = e.opType, this.attributes = new r.Attribute(e.attribute)) : e instanceof u.Node && (this.name = null != t ? t : e.name(), this.opType = e.opType(), this.attributes = new r.Attribute(s.ProtoUtil.tensorAttributesFromORTFormat(e))), this.inputs = [], this.outputs = [], this.executeNode = !0;\n          }\n        }\n        class p {\n          constructor(e, t) {\n            if (!e) throw new TypeError(\"graph is empty\");\n            this.buildGraph(e), this.transformGraph(t), this.checkIsAcyclic();\n          }\n          getInputIndices() {\n            return this._allInputIndices;\n          }\n          getInputNames() {\n            return this._allInputNames;\n          }\n          getOutputIndices() {\n            return this._allOutputIndices;\n          }\n          getOutputNames() {\n            return this._allOutputNames;\n          }\n          getValues() {\n            return this._allData;\n          }\n          getNodes() {\n            return this._nodes;\n          }\n          buildGraph(e) {\n            if (e instanceof i.onnx.GraphProto) this.buildGraphFromOnnxFormat(e);else {\n              if (!(e instanceof u.Graph)) throw new TypeError(\"Graph type is not supported.\");\n              this.buildGraphFromOrtFormat(e);\n            }\n          }\n          buildGraphFromOnnxFormat(e) {\n            const t = new Map();\n            this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];\n            const n = new Map();\n            if (!e.input) throw new Error(\"missing information in graph: input\");\n            const r = [];\n            for (const n of e.input) {\n              if (t.has(n.name)) throw new Error(`duplicated input name: ${n.name}`);\n              const e = this._allData.push(new l(n)) - 1;\n              t.set(n.name, e), r.push(n.name);\n            }\n            if (!e.initializer) throw new Error(\"missing information in graph: initializer\");\n            for (const n of e.initializer) {\n              let e = t.get(n.name);\n              if (void 0 === e) {\n                const r = new l();\n                r.type = {\n                  shape: {\n                    dims: s.ProtoUtil.tensorDimsFromProto(n.dims)\n                  },\n                  tensorType: s.ProtoUtil.tensorDataTypeFromProto(n.dataType)\n                }, e = this._allData.push(r) - 1, t.set(n.name, e);\n              }\n              this._allData[e]._from = -1, this._allData[e].tensor = a.Tensor.fromProto(n);\n            }\n            for (let e = 0; e < this._allData.length; e++) this._allData[e].tensor || (this._allInputIndices.push(e), this._allInputNames.push(r[e]));\n            if (!e.output) throw new Error(\"missing information in graph: output\");\n            for (const n of e.output) {\n              if (t.has(n.name)) throw new Error(`duplicated output name: ${n.name}`);\n              const e = this._allData.push(new l(n)) - 1;\n              t.set(n.name, e), this._allOutputIndices.push(e), this._allOutputNames.push(n.name);\n            }\n            if (!e.node) throw new Error(\"missing information in graph: node\");\n            for (const t of e.node) {\n              if (!t.name) for (let e = 0;; e++) {\n                const r = `unnamed_${t.opType}_${e}`;\n                if (!n.has(r)) {\n                  t.name = r;\n                  break;\n                }\n              }\n              if (n.has(t.name)) throw new Error(`duplicated node name: ${t.name}`);\n              const e = this._nodes.push(new c(t)) - 1;\n              n.set(t.name, e);\n            }\n            for (let n = 0; n < this._nodes.length; n++) {\n              const r = this._nodes[n],\n                o = e.node[n];\n              if (!o.output) throw new Error(`missing output for node: ${o.name}`);\n              for (const e of o.output) {\n                let i = t.get(e);\n                if (void 0 === i && (i = this._allData.push(new l()) - 1, t.set(e, i)), r.outputs.push(i), void 0 !== this._allData[i]._from) throw new Error(`multiple nodes output to one data value: ${i}`);\n                if (this._allData[i]._from = n, \"Constant\" === o.opType) {\n                  if (!o.attribute || 1 !== o.attribute.length || !o.attribute[0].t) throw new Error(\"missing attributes or missing tensor value in attributes for this Constant operator\");\n                  if (!o.output || 1 !== o.output.length) throw new Error(\"missing output or incorrect number of outputs for this Constant operator\");\n                  r.outputs.pop(), r.executeNode = !1, this._allData[i]._from = -1, this._allData[i].tensor = a.Tensor.fromProto(o.attribute[0].t);\n                }\n              }\n            }\n            for (let n = 0; n < this._nodes.length; n++) {\n              const r = this._nodes[n],\n                o = e.node[n];\n              if (!o.input) throw new Error(`missing input for node: ${o.name}`);\n              for (const e of o.input) {\n                const i = t.get(e);\n                if (void 0 === i) {\n                  if (\"\" === e && (3 === o.input.length || 4 === o.input.length) && \"Resize\" === o.opType) continue;\n                  throw new Error(`unrecognized input '${e}' for node: ${o.name}`);\n                }\n                r.inputs.push(i), this._allData[i]._to.push(n);\n              }\n            }\n            return !0;\n          }\n          buildGraphFromOrtFormat(e) {\n            var t, n, r;\n            const o = new Map();\n            this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];\n            const i = new Map(),\n              p = [];\n            for (let i = 0; i < e.inputsLength(); i++) {\n              const a = e.inputs(i);\n              if (o.has(a)) throw new Error(`duplicated input name: ${a}`);\n              for (let i = 0; i < e.nodeArgsLength(); i++) if ((null === (t = e.nodeArgs(i)) || void 0 === t ? void 0 : t.name()) === a) {\n                const t = new l();\n                if ((null === (r = null === (n = e.nodeArgs(i)) || void 0 === n ? void 0 : n.type()) || void 0 === r ? void 0 : r.valueType()) !== u.TypeInfoValue.tensor_type) throw new Error(\"Unexpected value type for the nodeArg.\");\n                const c = e.nodeArgs(i).type().value(new u.TensorTypeAndShape()),\n                  d = s.ProtoUtil.tensorDataTypeFromProto(c.elemType()),\n                  f = c.shape(),\n                  h = [];\n                for (let e = 0; e < f.dimLength(); e++) h.push(s.LongUtil.longToNumber(f.dim(e).value().dimValue()));\n                t.type = {\n                  shape: {\n                    dims: h\n                  },\n                  tensorType: d\n                };\n                const g = this._allData.push(t) - 1;\n                o.set(a, g), p.push(a);\n              }\n            }\n            for (let t = 0; t < e.initializersLength(); t++) {\n              const n = e.initializers(t);\n              let r = o.get(n.name());\n              if (void 0 === r) {\n                const e = new l(),\n                  t = s.ProtoUtil.tensorDimsFromORTFormat(n),\n                  i = s.ProtoUtil.tensorDataTypeFromProto(n.dataType());\n                e.type = {\n                  shape: {\n                    dims: t\n                  },\n                  tensorType: i\n                }, r = this._allData.push(e) - 1, o.set(n.name(), r);\n              }\n              this._allData[r]._from = -1, this._allData[r].tensor = a.Tensor.fromOrtTensor(n);\n            }\n            for (let e = 0; e < this._allData.length; e++) this._allData[e].tensor || (this._allInputIndices.push(e), this._allInputNames.push(p[e]));\n            for (let t = 0; t < e.outputsLength(); t++) {\n              const n = e.outputs(t);\n              if (o.has(n)) throw new Error(`duplicated output name: ${n}`);\n              const r = this._allData.push(new l()) - 1;\n              o.set(n, r), this._allOutputIndices.push(r), this._allOutputNames.push(n);\n            }\n            if (!e.nodes) throw new Error(\"missing information in graph: node\");\n            for (let t = 0; t < e.nodesLength(); t++) {\n              const n = e.nodes(t);\n              let r = n.name();\n              if (!r) for (let e = 0; r = `unnamed_${n.opType()}_${e}`, i.has(r); e++);\n              if (i.has(r)) throw new Error(`duplicated node name: ${r}`);\n              const o = this._nodes.push(new c(n, r)) - 1;\n              i.set(r, o);\n            }\n            for (let t = 0; t < this._nodes.length; t++) {\n              const n = this._nodes[t],\n                r = e.nodes(t);\n              if (null == r) throw new Error(`No node exists at index ${t}`);\n              if (0 === (null == r ? void 0 : r.outputsLength())) throw new Error(`missing output for node: ${r.name}`);\n              for (let e = 0; e < (null == r ? void 0 : r.outputsLength()); e++) {\n                const i = null == r ? void 0 : r.outputs(e);\n                let s = o.get(i);\n                if (void 0 === s && (s = this._allData.push(new l()) - 1, o.set(i, s)), n.outputs.push(s), void 0 !== this._allData[s]._from) throw new Error(`multiple nodes output to one data value: ${s}`);\n                if (this._allData[s]._from = t, \"Constant\" === r.opType()) {\n                  if (1 !== r.attributesLength() || !r.attributes(0).t()) throw new Error(\"missing attributes or missing tensor value in attributes for this Constant operator\");\n                  if (1 !== r.outputsLength()) throw new Error(\"missing output or incorrect number of outputs for this Constant operator\");\n                  n.outputs.pop(), n.executeNode = !1, this._allData[s]._from = -1, this._allData[s].tensor = a.Tensor.fromOrtTensor(r.attributes(0).t());\n                }\n              }\n            }\n            for (let t = 0; t < this._nodes.length; t++) {\n              const n = this._nodes[t],\n                r = e.nodes(t);\n              if (0 === r.inputsLength()) throw new Error(`missing input for node: ${r.name}`);\n              for (let e = 0; e < r.inputsLength(); e++) {\n                const i = r.inputs(e),\n                  a = o.get(i);\n                if (void 0 === a) throw new Error(`unrecognized input '${i}' for node: ${r.name()}`);\n                n.inputs.push(a), this._allData[a]._to.push(t);\n              }\n            }\n          }\n          checkIsAcyclic() {\n            const e = new Set();\n            this._allInputIndices.forEach(t => {\n              this._allData[t]._to.forEach(t => {\n                e.add(t);\n              });\n            });\n            const t = Array.from(e),\n              n = new Array(this._nodes.length).fill(\"white\");\n            for (; t.length > 0;) {\n              const e = t.pop();\n              \"gray\" === n[e] ? n[e] = \"black\" : (t.push(e), n[e] = \"gray\", this._nodes[e].outputs.forEach(r => {\n                const o = this._allData[r];\n                if (void 0 !== o.tensor) throw new Error(\"node outputs should not be initialized\");\n                if (o._from !== e) throw new Error(\"from property of the Value object doesn't match index of Node being processed\");\n                o._to.forEach(e => {\n                  if (\"gray\" === n[e]) throw new Error(\"model graph is cyclic\");\n                  \"white\" === n[e] && t.push(e);\n                });\n              }));\n            }\n          }\n          transformGraph(e) {\n            this.removeAllIdentityNodes(), this.removeAllDropoutNodes(), this.fuseConvActivationNodes(), e && e.transformGraph(this), this.finalizeGraph();\n          }\n          finalizeGraph() {\n            let e = 0;\n            const t = new Array(this._nodes.length, 0);\n            let n = 0;\n            for (let e = 0; e < this._nodes.length; e++) t[e] = n, this._nodes[e].executeNode ? (n !== e && (this._nodes[n] = this._nodes[e]), n++) : this._nodes[e].outputs.forEach(e => {\n              this._allData[e]._from = -2;\n            });\n            this._nodes.splice(n, this._nodes.length - n);\n            for (let e = 0; e < this._allData.length; e++) {\n              const n = this._allData[e];\n              void 0 !== n._from && -1 !== n._from && -2 !== n._from && (n._from = t[n._from]);\n              for (let e = 0; e < n._to.length; e++) {\n                if (!(n._to[e] >= 0)) throw new Error(\"Trying to update a removed node\");\n                n._to[e] = t[n._to[e]];\n              }\n            }\n            e = 0;\n            for (let t = 0; t < this._allData.length; t++) if (-2 !== this._allData[t].from || -1 !== this._allOutputIndices.indexOf(t + e)) {\n              if (e > 0) {\n                let n = -1;\n                void 0 !== this._allData[t].from && -1 !== this._allData[t].from ? (n = this._nodes[this._allData[t].from].outputs.indexOf(t + e), -1 !== n && (this._nodes[this._allData[t].from].outputs[n] = t)) : (n = this._allInputIndices.indexOf(t + e), -1 !== n && (this._allInputIndices[n] = t)), this._allData[t].to.forEach(r => {\n                  n = this._nodes[r].inputs.indexOf(t + e), -1 !== n && (this._nodes[r].inputs[n] = t);\n                }), 0 === this._allData[t].to.length && (n = this._allOutputIndices.indexOf(t + e), -1 !== n && (this._allOutputIndices[n] = t));\n              }\n            } else e++, this._allData.splice(t, 1), t--;\n          }\n          deleteNode(e) {\n            const t = this._nodes[e];\n            if (t.outputs.length > 1) for (let e = 1; e < t.outputs.length; e++) if (this._allData[t.outputs[e]].to.length > 0) throw new Error(\"Node deletion with more than one output connected to other nodes is not supported. \");\n            t.executeNode = !1;\n            const n = t.inputs[0],\n              r = t.outputs[0],\n              o = this._allData[r].to;\n            for (let n = 0; n < t.inputs.length; n++) {\n              const r = this._allData[t.inputs[n]].to.indexOf(e);\n              if (-1 === r) throw new Error(\"The Value object doesn't have the current Node in it's 'to' property \");\n              this._allData[t.inputs[n]].to.splice(r, 1);\n            }\n            this._allData[r]._to = [];\n            const i = this._allOutputIndices.indexOf(r);\n            if (-1 !== i && (this._allOutputIndices[i] = n), o && o.length > 0) for (const e of o) {\n              const t = this._nodes[e].inputs.indexOf(r);\n              if (-1 === t) throw new Error(\"The Node object doesn't have the output Value in it's 'inputs' property \");\n              this._nodes[e].inputs[t] = n, this._allData[n].to.push(e);\n            }\n          }\n          removeAllDropoutNodes() {\n            let e = 0;\n            for (const t of this._nodes) {\n              if (\"Dropout\" === t.opType) {\n                if (1 !== t.inputs.length) throw new Error(\"Dropout nodes should only contain one input. \");\n                if (1 !== t.outputs.length && 2 !== t.outputs.length) throw new Error(\"Dropout nodes should contain either 1 or 2 output(s)\");\n                if (2 === t.outputs.length && 0 !== this._allData[t.outputs[1]]._to.length) throw new Error(\"Dropout nodes's second output should not be referenced by other nodes\");\n                this.deleteNode(e);\n              }\n              e++;\n            }\n          }\n          removeAllIdentityNodes() {\n            let e = 0;\n            for (const t of this._nodes) \"Identity\" === t.opType && this.deleteNode(e), e++;\n          }\n          isActivation(e) {\n            switch (e.opType) {\n              case \"Relu\":\n              case \"Sigmoid\":\n              case \"Clip\":\n                return !0;\n              default:\n                return !1;\n            }\n          }\n          fuseConvActivationNodes() {\n            for (const e of this._nodes) if (\"Conv\" === e.opType) {\n              const t = this._allData[e.outputs[0]]._to;\n              if (1 === t.length && this.isActivation(this._nodes[t[0]])) {\n                const n = this._nodes[t[0]];\n                if (\"Clip\" === n.opType) if (1 === n.inputs.length) try {\n                  e.attributes.set(\"activation_params\", \"floats\", [n.attributes.getFloat(\"min\"), n.attributes.getFloat(\"max\")]);\n                } catch (t) {\n                  e.attributes.set(\"activation_params\", \"floats\", [s.MIN_CLIP, s.MAX_CLIP]);\n                } else {\n                  if (!(n.inputs.length >= 3 && void 0 !== this._allData[n.inputs[1]].tensor && void 0 !== this._allData[n.inputs[2]].tensor)) continue;\n                  e.attributes.set(\"activation_params\", \"floats\", [this._allData[n.inputs[1]].tensor.floatData[0], this._allData[n.inputs[2]].tensor.floatData[0]]);\n                }\n                e.attributes.set(\"activation\", \"string\", n.opType), this.deleteNode(t[0]);\n              }\n            }\n          }\n        }\n      },\n      1315: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.now = t.Profiler = t.Logger = void 0;\n        const n = {\n            verbose: 1e3,\n            info: 2e3,\n            warning: 4e3,\n            error: 5e3,\n            fatal: 6e3\n          },\n          r = {\n            none: new class {\n              log(e, t, n) {}\n            }(),\n            console: new class {\n              log(e, t, n) {\n                console.log(`${this.color(e)} ${n ? \"\u001b[35m\" + n + \"\u001b[0m \" : \"\"}${t}`);\n              }\n              color(e) {\n                switch (e) {\n                  case \"verbose\":\n                    return \"\u001b[34;40mv\u001b[0m\";\n                  case \"info\":\n                    return \"\u001b[32mi\u001b[0m\";\n                  case \"warning\":\n                    return \"\u001b[30;43mw\u001b[0m\";\n                  case \"error\":\n                    return \"\u001b[31;40me\u001b[0m\";\n                  case \"fatal\":\n                    return \"\u001b[101mf\u001b[0m\";\n                  default:\n                    throw new Error(`unsupported severity: ${e}`);\n                }\n              }\n            }()\n          },\n          o = {\n            provider: \"console\",\n            minimalSeverity: \"warning\",\n            logDateTime: !0,\n            logSourceLocation: !1\n          };\n        let i = {\n          \"\": o\n        };\n        function a(e, t, n, r) {\n          if (void 0 === t) return o = e, {\n            verbose: a.verbose.bind(null, o),\n            info: a.info.bind(null, o),\n            warning: a.warning.bind(null, o),\n            error: a.error.bind(null, o),\n            fatal: a.fatal.bind(null, o)\n          };\n          if (void 0 === n) s(e, t);else if (\"number\" == typeof n && void 0 === r) s(e, t);else if (\"string\" == typeof n && void 0 === r) s(e, n, 0, t);else {\n            if (\"string\" != typeof n || \"number\" != typeof r) throw new TypeError(\"input is valid\");\n            s(e, n, 0, t);\n          }\n          var o;\n        }\n        function s(e, t, o, a) {\n          const s = i[a || \"\"] || i[\"\"];\n          n[e] < n[s.minimalSeverity] || (s.logDateTime && (t = `${new Date().toISOString()}|${t}`), s.logSourceLocation, r[s.provider].log(e, t, a));\n        }\n        !function (e) {\n          function t(e) {\n            i = {}, n(\"\", e || {});\n          }\n          function n(e, n) {\n            if (\"*\" === e) t(n);else {\n              const t = i[e] || o;\n              i[e] = {\n                provider: n.provider || t.provider,\n                minimalSeverity: n.minimalSeverity || t.minimalSeverity,\n                logDateTime: void 0 === n.logDateTime ? t.logDateTime : n.logDateTime,\n                logSourceLocation: void 0 === n.logSourceLocation ? t.logSourceLocation : n.logSourceLocation\n              };\n            }\n          }\n          e.verbose = function (t, n) {\n            e(\"verbose\", t, n);\n          }, e.info = function (t, n) {\n            e(\"info\", t, n);\n          }, e.warning = function (t, n) {\n            e(\"warning\", t, n);\n          }, e.error = function (t, n) {\n            e(\"error\", t, n);\n          }, e.fatal = function (t, n) {\n            e(\"fatal\", t, n);\n          }, e.reset = t, e.set = n, e.setWithEnv = function (e) {\n            const t = {};\n            e.logLevel && (t.minimalSeverity = e.logLevel), n(\"\", t);\n          };\n        }(a || (a = {})), t.Logger = a;\n        class u {\n          constructor(e, t, n, r, o, i) {\n            this.category = e, this.name = t, this.startTime = n, this.endCallback = r, this.timer = o, this.ctx = i;\n          }\n          async end() {\n            return this.endCallback(this);\n          }\n          async checkTimer() {\n            if (void 0 === this.ctx || void 0 === this.timer) throw new Error(\"No webgl timer found\");\n            return this.ctx.endTimer(), this.ctx.waitForQueryAndGetTime(this.timer);\n          }\n        }\n        class l {\n          constructor(e, t, n, r) {\n            this.category = e, this.name = t, this.startTime = n, this.endTime = r;\n          }\n        }\n        t.Profiler = class {\n          static create(e) {\n            return void 0 === e ? new this() : new this(e.maxNumberEvents, e.flushBatchSize, e.flushIntervalInMilliseconds);\n          }\n          constructor(e, t, n) {\n            this._started = !1, this._flushPointer = 0, this._started = !1, this._maxNumberEvents = void 0 === e ? 1e4 : e, this._flushBatchSize = void 0 === t ? 10 : t, this._flushIntervalInMilliseconds = void 0 === n ? 5e3 : n;\n          }\n          start() {\n            this._started = !0, this._timingEvents = [], this._flushTime = (0, t.now)(), this._flushPointer = 0;\n          }\n          stop() {\n            for (this._started = !1; this._flushPointer < this._timingEvents.length; this._flushPointer++) this.logOneEvent(this._timingEvents[this._flushPointer]);\n          }\n          event(e, t, n, r) {\n            const o = this._started ? this.begin(e, t, r) : void 0;\n            let i = !1;\n            const a = n();\n            if (a && \"function\" == typeof a.then) return i = !0, new Promise((e, t) => {\n              a.then(async t => {\n                o && (await o.end()), e(t);\n              }, async e => {\n                o && (await o.end()), t(e);\n              });\n            });\n            if (!i && o) {\n              const e = o.end();\n              if (e && \"function\" == typeof e.then) return new Promise((t, n) => {\n                e.then(() => {\n                  t(a);\n                }, e => {\n                  n(e);\n                });\n              });\n            }\n            return a;\n          }\n          begin(e, n, r) {\n            if (!this._started) throw new Error(\"profiler is not started yet\");\n            if (void 0 === r) {\n              const r = (0, t.now)();\n              return this.flush(r), new u(e, n, r, e => this.endSync(e));\n            }\n            {\n              const t = r.beginTimer();\n              return new u(e, n, 0, async e => this.end(e), t, r);\n            }\n          }\n          async end(e) {\n            const t = await e.checkTimer();\n            this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new l(e.category, e.name, e.startTime, t)), this.flush(t));\n          }\n          endSync(e) {\n            const n = (0, t.now)();\n            this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new l(e.category, e.name, e.startTime, n)), this.flush(n));\n          }\n          logOneEvent(e) {\n            t.Logger.verbose(`Profiler.${e.category}`, `${(e.endTime - e.startTime).toFixed(2)}ms on event '${e.name}' at ${e.endTime.toFixed(2)}`);\n          }\n          flush(e) {\n            if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize || e - this._flushTime >= this._flushIntervalInMilliseconds) {\n              for (const e = this._flushPointer; this._flushPointer < e + this._flushBatchSize && this._flushPointer < this._timingEvents.length; this._flushPointer++) this.logOneEvent(this._timingEvents[this._flushPointer]);\n              this._flushTime = (0, t.now)();\n            }\n          }\n          get started() {\n            return this._started;\n          }\n        }, t.now = \"undefined\" != typeof performance && performance.now ? () => performance.now() : Date.now;\n      },\n      1745: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Model = void 0;\n        const r = n(5686),\n          o = n(4662),\n          i = n(5127),\n          a = n(2446),\n          s = n(7273);\n        var u = i.onnxruntime.experimental.fbs;\n        t.Model = class {\n          constructor() {}\n          load(e, t, n) {\n            if (!n) try {\n              return void this.loadFromOnnxFormat(e, t);\n            } catch (e) {\n              if (void 0 !== n) throw e;\n            }\n            this.loadFromOrtFormat(e, t);\n          }\n          loadFromOnnxFormat(e, t) {\n            const n = a.onnx.ModelProto.decode(e);\n            if (s.LongUtil.longToNumber(n.irVersion) < 3) throw new Error(\"only support ONNX model with IR_VERSION>=3\");\n            this._opsets = n.opsetImport.map(e => ({\n              domain: e.domain,\n              version: s.LongUtil.longToNumber(e.version)\n            })), this._graph = o.Graph.from(n.graph, t);\n          }\n          loadFromOrtFormat(e, t) {\n            const n = new r.flatbuffers.ByteBuffer(e),\n              i = u.InferenceSession.getRootAsInferenceSession(n).model();\n            if (s.LongUtil.longToNumber(i.irVersion()) < 3) throw new Error(\"only support ONNX model with IR_VERSION>=3\");\n            this._opsets = [];\n            for (let e = 0; e < i.opsetImportLength(); e++) {\n              const t = i.opsetImport(e);\n              this._opsets.push({\n                domain: null == t ? void 0 : t.domain(),\n                version: s.LongUtil.longToNumber(t.version())\n              });\n            }\n            this._graph = o.Graph.from(i.graph(), t);\n          }\n          get graph() {\n            return this._graph;\n          }\n          get opsets() {\n            return this._opsets;\n          }\n        };\n      },\n      6145: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.FLOAT_TYPES = t.INT_TYPES = t.NUMBER_TYPES = void 0, t.NUMBER_TYPES = [\"float32\", \"float64\", \"int32\", \"int16\", \"int8\", \"uint16\", \"uint32\", \"uint8\"], t.INT_TYPES = [\"int32\", \"int16\", \"int8\", \"uint16\", \"uint32\", \"uint8\"], t.FLOAT_TYPES = [\"float32\", \"float64\"];\n      },\n      5881: (e, t) => {\n        \"use strict\";\n\n        function n(e, t) {\n          if (t.endsWith(\"+\")) {\n            const n = Number.parseInt(t.substring(0, t.length - 1), 10);\n            return !isNaN(n) && n <= e;\n          }\n          if (2 === t.split(\"-\").length) {\n            const n = t.split(\"-\"),\n              r = Number.parseInt(n[0], 10),\n              o = Number.parseInt(n[1], 10);\n            return !isNaN(r) && !isNaN(o) && r <= e && e <= o;\n          }\n          return Number.parseInt(t, 10) === e;\n        }\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.resolveOperator = void 0, t.resolveOperator = function (e, t, r) {\n          for (const o of r) {\n            const r = o[0],\n              i = o[1],\n              a = o[2],\n              s = o[3],\n              u = o[4];\n            if (e.opType === r) for (const e of t) if ((e.domain === i || \"ai.onnx\" === e.domain && \"\" === i) && n(e.version, a)) return {\n              opImpl: s,\n              opInit: u\n            };\n          }\n          throw new TypeError(`cannot resolve operator '${e.opType}' with opsets: ${t.map(e => `${e.domain || \"ai.onnx\"} v${e.version}`).join(\", \")}`);\n        };\n      },\n      5127: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.onnxruntime = void 0;\n        const r = n(5686);\n        var o, i;\n        o = t.onnxruntime || (t.onnxruntime = {}), function (e) {\n          let t;\n          !function (e) {\n            e[e.UNDEFINED = 0] = \"UNDEFINED\", e[e.FLOAT = 1] = \"FLOAT\", e[e.INT = 2] = \"INT\", e[e.STRING = 3] = \"STRING\", e[e.TENSOR = 4] = \"TENSOR\", e[e.GRAPH = 5] = \"GRAPH\", e[e.FLOATS = 6] = \"FLOATS\", e[e.INTS = 7] = \"INTS\", e[e.STRINGS = 8] = \"STRINGS\", e[e.TENSORS = 9] = \"TENSORS\", e[e.GRAPHS = 10] = \"GRAPHS\", e[e.SPARSE_TENSOR = 11] = \"SPARSE_TENSOR\", e[e.SPARSE_TENSORS = 12] = \"SPARSE_TENSORS\";\n          }(t = e.AttributeType || (e.AttributeType = {}));\n        }((i = o.experimental || (o.experimental = {})).fbs || (i.fbs = {})), function (e) {\n          !function (e) {\n            !function (e) {\n              let t;\n              !function (e) {\n                e[e.UNKNOWN = 0] = \"UNKNOWN\", e[e.VALUE = 1] = \"VALUE\", e[e.PARAM = 2] = \"PARAM\";\n              }(t = e.DimensionValueType || (e.DimensionValueType = {}));\n            }(e.fbs || (e.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (e) {\n            !function (e) {\n              let t;\n              !function (e) {\n                e[e.UNDEFINED = 0] = \"UNDEFINED\", e[e.FLOAT = 1] = \"FLOAT\", e[e.UINT8 = 2] = \"UINT8\", e[e.INT8 = 3] = \"INT8\", e[e.UINT16 = 4] = \"UINT16\", e[e.INT16 = 5] = \"INT16\", e[e.INT32 = 6] = \"INT32\", e[e.INT64 = 7] = \"INT64\", e[e.STRING = 8] = \"STRING\", e[e.BOOL = 9] = \"BOOL\", e[e.FLOAT16 = 10] = \"FLOAT16\", e[e.DOUBLE = 11] = \"DOUBLE\", e[e.UINT32 = 12] = \"UINT32\", e[e.UINT64 = 13] = \"UINT64\", e[e.COMPLEX64 = 14] = \"COMPLEX64\", e[e.COMPLEX128 = 15] = \"COMPLEX128\", e[e.BFLOAT16 = 16] = \"BFLOAT16\", e[e.FLOAT8E4M3FN = 17] = \"FLOAT8E4M3FN\", e[e.FLOAT8E4M3FNUZ = 18] = \"FLOAT8E4M3FNUZ\", e[e.FLOAT8E5M2 = 19] = \"FLOAT8E5M2\", e[e.FLOAT8E5M2FNUZ = 20] = \"FLOAT8E5M2FNUZ\";\n              }(t = e.TensorDataType || (e.TensorDataType = {}));\n            }(e.fbs || (e.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (e) {\n            !function (e) {\n              let t;\n              !function (e) {\n                e[e.Primitive = 0] = \"Primitive\", e[e.Fused = 1] = \"Fused\";\n              }(t = e.NodeType || (e.NodeType = {}));\n            }(e.fbs || (e.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (e) {\n            !function (e) {\n              let t;\n              !function (e) {\n                e[e.NONE = 0] = \"NONE\", e[e.tensor_type = 1] = \"tensor_type\", e[e.sequence_type = 2] = \"sequence_type\", e[e.map_type = 3] = \"map_type\";\n              }(t = e.TypeInfoValue || (e.TypeInfoValue = {}));\n            }(e.fbs || (e.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (t) {\n            !function (t) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(e, t) {\n                  return this.bb_pos = e, this.bb = t, this;\n                }\n                static getRootAsShape(e, t) {\n                  return (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                static getSizePrefixedRootAsShape(e, t) {\n                  return e.setPosition(e.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                dim(t, n) {\n                  let r = this.bb.__offset(this.bb_pos, 4);\n                  return r ? (n || new e.experimental.fbs.Dimension()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null;\n                }\n                dimLength() {\n                  let e = this.bb.__offset(this.bb_pos, 4);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                static startShape(e) {\n                  e.startObject(1);\n                }\n                static addDim(e, t) {\n                  e.addFieldOffset(0, t, 0);\n                }\n                static createDimVector(e, t) {\n                  e.startVector(4, t.length, 4);\n                  for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);\n                  return e.endVector();\n                }\n                static startDimVector(e, t) {\n                  e.startVector(4, t, 4);\n                }\n                static endShape(e) {\n                  return e.endObject();\n                }\n                static createShape(e, t) {\n                  return n.startShape(e), n.addDim(e, t), n.endShape(e);\n                }\n              }\n              t.Shape = n;\n            }(t.fbs || (t.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (t) {\n            !function (t) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(e, t) {\n                  return this.bb_pos = e, this.bb = t, this;\n                }\n                static getRootAsDimension(e, t) {\n                  return (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                static getSizePrefixedRootAsDimension(e, t) {\n                  return e.setPosition(e.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                value(t) {\n                  let n = this.bb.__offset(this.bb_pos, 4);\n                  return n ? (t || new e.experimental.fbs.DimensionValue()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                denotation(e) {\n                  let t = this.bb.__offset(this.bb_pos, 6);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                static startDimension(e) {\n                  e.startObject(2);\n                }\n                static addValue(e, t) {\n                  e.addFieldOffset(0, t, 0);\n                }\n                static addDenotation(e, t) {\n                  e.addFieldOffset(1, t, 0);\n                }\n                static endDimension(e) {\n                  return e.endObject();\n                }\n                static createDimension(e, t, r) {\n                  return n.startDimension(e), n.addValue(e, t), n.addDenotation(e, r), n.endDimension(e);\n                }\n              }\n              t.Dimension = n;\n            }(t.fbs || (t.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (t) {\n            !function (t) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(e, t) {\n                  return this.bb_pos = e, this.bb = t, this;\n                }\n                static getRootAsDimensionValue(e, t) {\n                  return (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                static getSizePrefixedRootAsDimensionValue(e, t) {\n                  return e.setPosition(e.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                dimType() {\n                  let t = this.bb.__offset(this.bb_pos, 4);\n                  return t ? this.bb.readInt8(this.bb_pos + t) : e.experimental.fbs.DimensionValueType.UNKNOWN;\n                }\n                dimValue() {\n                  let e = this.bb.__offset(this.bb_pos, 6);\n                  return e ? this.bb.readInt64(this.bb_pos + e) : this.bb.createLong(0, 0);\n                }\n                dimParam(e) {\n                  let t = this.bb.__offset(this.bb_pos, 8);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                static startDimensionValue(e) {\n                  e.startObject(3);\n                }\n                static addDimType(t, n) {\n                  t.addFieldInt8(0, n, e.experimental.fbs.DimensionValueType.UNKNOWN);\n                }\n                static addDimValue(e, t) {\n                  e.addFieldInt64(1, t, e.createLong(0, 0));\n                }\n                static addDimParam(e, t) {\n                  e.addFieldOffset(2, t, 0);\n                }\n                static endDimensionValue(e) {\n                  return e.endObject();\n                }\n                static createDimensionValue(e, t, r, o) {\n                  return n.startDimensionValue(e), n.addDimType(e, t), n.addDimValue(e, r), n.addDimParam(e, o), n.endDimensionValue(e);\n                }\n              }\n              t.DimensionValue = n;\n            }(t.fbs || (t.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (t) {\n            !function (t) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(e, t) {\n                  return this.bb_pos = e, this.bb = t, this;\n                }\n                static getRootAsTensorTypeAndShape(e, t) {\n                  return (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                static getSizePrefixedRootAsTensorTypeAndShape(e, t) {\n                  return e.setPosition(e.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                elemType() {\n                  let t = this.bb.__offset(this.bb_pos, 4);\n                  return t ? this.bb.readInt32(this.bb_pos + t) : e.experimental.fbs.TensorDataType.UNDEFINED;\n                }\n                shape(t) {\n                  let n = this.bb.__offset(this.bb_pos, 6);\n                  return n ? (t || new e.experimental.fbs.Shape()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                static startTensorTypeAndShape(e) {\n                  e.startObject(2);\n                }\n                static addElemType(t, n) {\n                  t.addFieldInt32(0, n, e.experimental.fbs.TensorDataType.UNDEFINED);\n                }\n                static addShape(e, t) {\n                  e.addFieldOffset(1, t, 0);\n                }\n                static endTensorTypeAndShape(e) {\n                  return e.endObject();\n                }\n                static createTensorTypeAndShape(e, t, r) {\n                  return n.startTensorTypeAndShape(e), n.addElemType(e, t), n.addShape(e, r), n.endTensorTypeAndShape(e);\n                }\n              }\n              t.TensorTypeAndShape = n;\n            }(t.fbs || (t.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (t) {\n            !function (t) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(e, t) {\n                  return this.bb_pos = e, this.bb = t, this;\n                }\n                static getRootAsMapType(e, t) {\n                  return (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                static getSizePrefixedRootAsMapType(e, t) {\n                  return e.setPosition(e.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                keyType() {\n                  let t = this.bb.__offset(this.bb_pos, 4);\n                  return t ? this.bb.readInt32(this.bb_pos + t) : e.experimental.fbs.TensorDataType.UNDEFINED;\n                }\n                valueType(t) {\n                  let n = this.bb.__offset(this.bb_pos, 6);\n                  return n ? (t || new e.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                static startMapType(e) {\n                  e.startObject(2);\n                }\n                static addKeyType(t, n) {\n                  t.addFieldInt32(0, n, e.experimental.fbs.TensorDataType.UNDEFINED);\n                }\n                static addValueType(e, t) {\n                  e.addFieldOffset(1, t, 0);\n                }\n                static endMapType(e) {\n                  return e.endObject();\n                }\n                static createMapType(e, t, r) {\n                  return n.startMapType(e), n.addKeyType(e, t), n.addValueType(e, r), n.endMapType(e);\n                }\n              }\n              t.MapType = n;\n            }(t.fbs || (t.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (t) {\n            !function (t) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(e, t) {\n                  return this.bb_pos = e, this.bb = t, this;\n                }\n                static getRootAsSequenceType(e, t) {\n                  return (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                static getSizePrefixedRootAsSequenceType(e, t) {\n                  return e.setPosition(e.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                elemType(t) {\n                  let n = this.bb.__offset(this.bb_pos, 4);\n                  return n ? (t || new e.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                static startSequenceType(e) {\n                  e.startObject(1);\n                }\n                static addElemType(e, t) {\n                  e.addFieldOffset(0, t, 0);\n                }\n                static endSequenceType(e) {\n                  return e.endObject();\n                }\n                static createSequenceType(e, t) {\n                  return n.startSequenceType(e), n.addElemType(e, t), n.endSequenceType(e);\n                }\n              }\n              t.SequenceType = n;\n            }(t.fbs || (t.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (e) {\n            (e.fbs || (e.fbs = {})).EdgeEnd = class {\n              constructor() {\n                this.bb = null, this.bb_pos = 0;\n              }\n              __init(e, t) {\n                return this.bb_pos = e, this.bb = t, this;\n              }\n              nodeIndex() {\n                return this.bb.readUint32(this.bb_pos);\n              }\n              srcArgIndex() {\n                return this.bb.readInt32(this.bb_pos + 4);\n              }\n              dstArgIndex() {\n                return this.bb.readInt32(this.bb_pos + 8);\n              }\n              static createEdgeEnd(e, t, n, r) {\n                return e.prep(4, 12), e.writeInt32(r), e.writeInt32(n), e.writeInt32(t), e.offset();\n              }\n            };\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (t) {\n            !function (t) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(e, t) {\n                  return this.bb_pos = e, this.bb = t, this;\n                }\n                static getRootAsNodeEdge(e, t) {\n                  return (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                static getSizePrefixedRootAsNodeEdge(e, t) {\n                  return e.setPosition(e.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                nodeIndex() {\n                  let e = this.bb.__offset(this.bb_pos, 4);\n                  return e ? this.bb.readUint32(this.bb_pos + e) : 0;\n                }\n                inputEdges(t, n) {\n                  let r = this.bb.__offset(this.bb_pos, 6);\n                  return r ? (n || new e.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + r) + 12 * t, this.bb) : null;\n                }\n                inputEdgesLength() {\n                  let e = this.bb.__offset(this.bb_pos, 6);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                outputEdges(t, n) {\n                  let r = this.bb.__offset(this.bb_pos, 8);\n                  return r ? (n || new e.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + r) + 12 * t, this.bb) : null;\n                }\n                outputEdgesLength() {\n                  let e = this.bb.__offset(this.bb_pos, 8);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                static startNodeEdge(e) {\n                  e.startObject(3);\n                }\n                static addNodeIndex(e, t) {\n                  e.addFieldInt32(0, t, 0);\n                }\n                static addInputEdges(e, t) {\n                  e.addFieldOffset(1, t, 0);\n                }\n                static startInputEdgesVector(e, t) {\n                  e.startVector(12, t, 4);\n                }\n                static addOutputEdges(e, t) {\n                  e.addFieldOffset(2, t, 0);\n                }\n                static startOutputEdgesVector(e, t) {\n                  e.startVector(12, t, 4);\n                }\n                static endNodeEdge(e) {\n                  return e.endObject();\n                }\n                static createNodeEdge(e, t, r, o) {\n                  return n.startNodeEdge(e), n.addNodeIndex(e, t), n.addInputEdges(e, r), n.addOutputEdges(e, o), n.endNodeEdge(e);\n                }\n              }\n              t.NodeEdge = n;\n            }(t.fbs || (t.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (t) {\n            !function (t) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(e, t) {\n                  return this.bb_pos = e, this.bb = t, this;\n                }\n                static getRootAsNode(e, t) {\n                  return (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                static getSizePrefixedRootAsNode(e, t) {\n                  return e.setPosition(e.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                name(e) {\n                  let t = this.bb.__offset(this.bb_pos, 4);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                docString(e) {\n                  let t = this.bb.__offset(this.bb_pos, 6);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                domain(e) {\n                  let t = this.bb.__offset(this.bb_pos, 8);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                sinceVersion() {\n                  let e = this.bb.__offset(this.bb_pos, 10);\n                  return e ? this.bb.readInt32(this.bb_pos + e) : 0;\n                }\n                index() {\n                  let e = this.bb.__offset(this.bb_pos, 12);\n                  return e ? this.bb.readUint32(this.bb_pos + e) : 0;\n                }\n                opType(e) {\n                  let t = this.bb.__offset(this.bb_pos, 14);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                type() {\n                  let t = this.bb.__offset(this.bb_pos, 16);\n                  return t ? this.bb.readInt32(this.bb_pos + t) : e.experimental.fbs.NodeType.Primitive;\n                }\n                executionProviderType(e) {\n                  let t = this.bb.__offset(this.bb_pos, 18);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                inputs(e, t) {\n                  let n = this.bb.__offset(this.bb_pos, 20);\n                  return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * e, t) : null;\n                }\n                inputsLength() {\n                  let e = this.bb.__offset(this.bb_pos, 20);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                outputs(e, t) {\n                  let n = this.bb.__offset(this.bb_pos, 22);\n                  return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * e, t) : null;\n                }\n                outputsLength() {\n                  let e = this.bb.__offset(this.bb_pos, 22);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                attributes(t, n) {\n                  let r = this.bb.__offset(this.bb_pos, 24);\n                  return r ? (n || new e.experimental.fbs.Attribute()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null;\n                }\n                attributesLength() {\n                  let e = this.bb.__offset(this.bb_pos, 24);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                inputArgCounts(e) {\n                  let t = this.bb.__offset(this.bb_pos, 26);\n                  return t ? this.bb.readInt32(this.bb.__vector(this.bb_pos + t) + 4 * e) : 0;\n                }\n                inputArgCountsLength() {\n                  let e = this.bb.__offset(this.bb_pos, 26);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                inputArgCountsArray() {\n                  let e = this.bb.__offset(this.bb_pos, 26);\n                  return e ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;\n                }\n                implicitInputs(e, t) {\n                  let n = this.bb.__offset(this.bb_pos, 28);\n                  return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * e, t) : null;\n                }\n                implicitInputsLength() {\n                  let e = this.bb.__offset(this.bb_pos, 28);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                static startNode(e) {\n                  e.startObject(13);\n                }\n                static addName(e, t) {\n                  e.addFieldOffset(0, t, 0);\n                }\n                static addDocString(e, t) {\n                  e.addFieldOffset(1, t, 0);\n                }\n                static addDomain(e, t) {\n                  e.addFieldOffset(2, t, 0);\n                }\n                static addSinceVersion(e, t) {\n                  e.addFieldInt32(3, t, 0);\n                }\n                static addIndex(e, t) {\n                  e.addFieldInt32(4, t, 0);\n                }\n                static addOpType(e, t) {\n                  e.addFieldOffset(5, t, 0);\n                }\n                static addType(t, n) {\n                  t.addFieldInt32(6, n, e.experimental.fbs.NodeType.Primitive);\n                }\n                static addExecutionProviderType(e, t) {\n                  e.addFieldOffset(7, t, 0);\n                }\n                static addInputs(e, t) {\n                  e.addFieldOffset(8, t, 0);\n                }\n                static createInputsVector(e, t) {\n                  e.startVector(4, t.length, 4);\n                  for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);\n                  return e.endVector();\n                }\n                static startInputsVector(e, t) {\n                  e.startVector(4, t, 4);\n                }\n                static addOutputs(e, t) {\n                  e.addFieldOffset(9, t, 0);\n                }\n                static createOutputsVector(e, t) {\n                  e.startVector(4, t.length, 4);\n                  for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);\n                  return e.endVector();\n                }\n                static startOutputsVector(e, t) {\n                  e.startVector(4, t, 4);\n                }\n                static addAttributes(e, t) {\n                  e.addFieldOffset(10, t, 0);\n                }\n                static createAttributesVector(e, t) {\n                  e.startVector(4, t.length, 4);\n                  for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);\n                  return e.endVector();\n                }\n                static startAttributesVector(e, t) {\n                  e.startVector(4, t, 4);\n                }\n                static addInputArgCounts(e, t) {\n                  e.addFieldOffset(11, t, 0);\n                }\n                static createInputArgCountsVector(e, t) {\n                  e.startVector(4, t.length, 4);\n                  for (let n = t.length - 1; n >= 0; n--) e.addInt32(t[n]);\n                  return e.endVector();\n                }\n                static startInputArgCountsVector(e, t) {\n                  e.startVector(4, t, 4);\n                }\n                static addImplicitInputs(e, t) {\n                  e.addFieldOffset(12, t, 0);\n                }\n                static createImplicitInputsVector(e, t) {\n                  e.startVector(4, t.length, 4);\n                  for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);\n                  return e.endVector();\n                }\n                static startImplicitInputsVector(e, t) {\n                  e.startVector(4, t, 4);\n                }\n                static endNode(e) {\n                  return e.endObject();\n                }\n                static createNode(e, t, r, o, i, a, s, u, l, c, p, d, f, h) {\n                  return n.startNode(e), n.addName(e, t), n.addDocString(e, r), n.addDomain(e, o), n.addSinceVersion(e, i), n.addIndex(e, a), n.addOpType(e, s), n.addType(e, u), n.addExecutionProviderType(e, l), n.addInputs(e, c), n.addOutputs(e, p), n.addAttributes(e, d), n.addInputArgCounts(e, f), n.addImplicitInputs(e, h), n.endNode(e);\n                }\n              }\n              t.Node = n;\n            }(t.fbs || (t.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (t) {\n            !function (t) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(e, t) {\n                  return this.bb_pos = e, this.bb = t, this;\n                }\n                static getRootAsValueInfo(e, t) {\n                  return (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                static getSizePrefixedRootAsValueInfo(e, t) {\n                  return e.setPosition(e.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                name(e) {\n                  let t = this.bb.__offset(this.bb_pos, 4);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                docString(e) {\n                  let t = this.bb.__offset(this.bb_pos, 6);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                type(t) {\n                  let n = this.bb.__offset(this.bb_pos, 8);\n                  return n ? (t || new e.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                static startValueInfo(e) {\n                  e.startObject(3);\n                }\n                static addName(e, t) {\n                  e.addFieldOffset(0, t, 0);\n                }\n                static addDocString(e, t) {\n                  e.addFieldOffset(1, t, 0);\n                }\n                static addType(e, t) {\n                  e.addFieldOffset(2, t, 0);\n                }\n                static endValueInfo(e) {\n                  return e.endObject();\n                }\n                static createValueInfo(e, t, r, o) {\n                  return n.startValueInfo(e), n.addName(e, t), n.addDocString(e, r), n.addType(e, o), n.endValueInfo(e);\n                }\n              }\n              t.ValueInfo = n;\n            }(t.fbs || (t.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (t) {\n            !function (t) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(e, t) {\n                  return this.bb_pos = e, this.bb = t, this;\n                }\n                static getRootAsTypeInfo(e, t) {\n                  return (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                static getSizePrefixedRootAsTypeInfo(e, t) {\n                  return e.setPosition(e.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                denotation(e) {\n                  let t = this.bb.__offset(this.bb_pos, 4);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                valueType() {\n                  let t = this.bb.__offset(this.bb_pos, 6);\n                  return t ? this.bb.readUint8(this.bb_pos + t) : e.experimental.fbs.TypeInfoValue.NONE;\n                }\n                value(e) {\n                  let t = this.bb.__offset(this.bb_pos, 8);\n                  return t ? this.bb.__union(e, this.bb_pos + t) : null;\n                }\n                static startTypeInfo(e) {\n                  e.startObject(3);\n                }\n                static addDenotation(e, t) {\n                  e.addFieldOffset(0, t, 0);\n                }\n                static addValueType(t, n) {\n                  t.addFieldInt8(1, n, e.experimental.fbs.TypeInfoValue.NONE);\n                }\n                static addValue(e, t) {\n                  e.addFieldOffset(2, t, 0);\n                }\n                static endTypeInfo(e) {\n                  return e.endObject();\n                }\n                static createTypeInfo(e, t, r, o) {\n                  return n.startTypeInfo(e), n.addDenotation(e, t), n.addValueType(e, r), n.addValue(e, o), n.endTypeInfo(e);\n                }\n              }\n              t.TypeInfo = n;\n            }(t.fbs || (t.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (e) {\n            !function (e) {\n              class t {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(e, t) {\n                  return this.bb_pos = e, this.bb = t, this;\n                }\n                static getRootAsOperatorSetId(e, n) {\n                  return (n || new t()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                static getSizePrefixedRootAsOperatorSetId(e, n) {\n                  return e.setPosition(e.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (n || new t()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                domain(e) {\n                  let t = this.bb.__offset(this.bb_pos, 4);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                version() {\n                  let e = this.bb.__offset(this.bb_pos, 6);\n                  return e ? this.bb.readInt64(this.bb_pos + e) : this.bb.createLong(0, 0);\n                }\n                static startOperatorSetId(e) {\n                  e.startObject(2);\n                }\n                static addDomain(e, t) {\n                  e.addFieldOffset(0, t, 0);\n                }\n                static addVersion(e, t) {\n                  e.addFieldInt64(1, t, e.createLong(0, 0));\n                }\n                static endOperatorSetId(e) {\n                  return e.endObject();\n                }\n                static createOperatorSetId(e, n, r) {\n                  return t.startOperatorSetId(e), t.addDomain(e, n), t.addVersion(e, r), t.endOperatorSetId(e);\n                }\n              }\n              e.OperatorSetId = t;\n            }(e.fbs || (e.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (t) {\n            !function (t) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(e, t) {\n                  return this.bb_pos = e, this.bb = t, this;\n                }\n                static getRootAsTensor(e, t) {\n                  return (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                static getSizePrefixedRootAsTensor(e, t) {\n                  return e.setPosition(e.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                name(e) {\n                  let t = this.bb.__offset(this.bb_pos, 4);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                docString(e) {\n                  let t = this.bb.__offset(this.bb_pos, 6);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                dims(e) {\n                  let t = this.bb.__offset(this.bb_pos, 8);\n                  return t ? this.bb.readInt64(this.bb.__vector(this.bb_pos + t) + 8 * e) : this.bb.createLong(0, 0);\n                }\n                dimsLength() {\n                  let e = this.bb.__offset(this.bb_pos, 8);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                dataType() {\n                  let t = this.bb.__offset(this.bb_pos, 10);\n                  return t ? this.bb.readInt32(this.bb_pos + t) : e.experimental.fbs.TensorDataType.UNDEFINED;\n                }\n                rawData(e) {\n                  let t = this.bb.__offset(this.bb_pos, 12);\n                  return t ? this.bb.readUint8(this.bb.__vector(this.bb_pos + t) + e) : 0;\n                }\n                rawDataLength() {\n                  let e = this.bb.__offset(this.bb_pos, 12);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                rawDataArray() {\n                  let e = this.bb.__offset(this.bb_pos, 12);\n                  return e ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;\n                }\n                stringData(e, t) {\n                  let n = this.bb.__offset(this.bb_pos, 14);\n                  return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * e, t) : null;\n                }\n                stringDataLength() {\n                  let e = this.bb.__offset(this.bb_pos, 14);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                static startTensor(e) {\n                  e.startObject(6);\n                }\n                static addName(e, t) {\n                  e.addFieldOffset(0, t, 0);\n                }\n                static addDocString(e, t) {\n                  e.addFieldOffset(1, t, 0);\n                }\n                static addDims(e, t) {\n                  e.addFieldOffset(2, t, 0);\n                }\n                static createDimsVector(e, t) {\n                  e.startVector(8, t.length, 8);\n                  for (let n = t.length - 1; n >= 0; n--) e.addInt64(t[n]);\n                  return e.endVector();\n                }\n                static startDimsVector(e, t) {\n                  e.startVector(8, t, 8);\n                }\n                static addDataType(t, n) {\n                  t.addFieldInt32(3, n, e.experimental.fbs.TensorDataType.UNDEFINED);\n                }\n                static addRawData(e, t) {\n                  e.addFieldOffset(4, t, 0);\n                }\n                static createRawDataVector(e, t) {\n                  e.startVector(1, t.length, 1);\n                  for (let n = t.length - 1; n >= 0; n--) e.addInt8(t[n]);\n                  return e.endVector();\n                }\n                static startRawDataVector(e, t) {\n                  e.startVector(1, t, 1);\n                }\n                static addStringData(e, t) {\n                  e.addFieldOffset(5, t, 0);\n                }\n                static createStringDataVector(e, t) {\n                  e.startVector(4, t.length, 4);\n                  for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);\n                  return e.endVector();\n                }\n                static startStringDataVector(e, t) {\n                  e.startVector(4, t, 4);\n                }\n                static endTensor(e) {\n                  return e.endObject();\n                }\n                static createTensor(e, t, r, o, i, a, s) {\n                  return n.startTensor(e), n.addName(e, t), n.addDocString(e, r), n.addDims(e, o), n.addDataType(e, i), n.addRawData(e, a), n.addStringData(e, s), n.endTensor(e);\n                }\n              }\n              t.Tensor = n;\n            }(t.fbs || (t.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (t) {\n            !function (t) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(e, t) {\n                  return this.bb_pos = e, this.bb = t, this;\n                }\n                static getRootAsSparseTensor(e, t) {\n                  return (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                static getSizePrefixedRootAsSparseTensor(e, t) {\n                  return e.setPosition(e.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                values(t) {\n                  let n = this.bb.__offset(this.bb_pos, 4);\n                  return n ? (t || new e.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                indices(t) {\n                  let n = this.bb.__offset(this.bb_pos, 6);\n                  return n ? (t || new e.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                dims(e) {\n                  let t = this.bb.__offset(this.bb_pos, 8);\n                  return t ? this.bb.readInt64(this.bb.__vector(this.bb_pos + t) + 8 * e) : this.bb.createLong(0, 0);\n                }\n                dimsLength() {\n                  let e = this.bb.__offset(this.bb_pos, 8);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                static startSparseTensor(e) {\n                  e.startObject(3);\n                }\n                static addValues(e, t) {\n                  e.addFieldOffset(0, t, 0);\n                }\n                static addIndices(e, t) {\n                  e.addFieldOffset(1, t, 0);\n                }\n                static addDims(e, t) {\n                  e.addFieldOffset(2, t, 0);\n                }\n                static createDimsVector(e, t) {\n                  e.startVector(8, t.length, 8);\n                  for (let n = t.length - 1; n >= 0; n--) e.addInt64(t[n]);\n                  return e.endVector();\n                }\n                static startDimsVector(e, t) {\n                  e.startVector(8, t, 8);\n                }\n                static endSparseTensor(e) {\n                  return e.endObject();\n                }\n                static createSparseTensor(e, t, r, o) {\n                  return n.startSparseTensor(e), n.addValues(e, t), n.addIndices(e, r), n.addDims(e, o), n.endSparseTensor(e);\n                }\n              }\n              t.SparseTensor = n;\n            }(t.fbs || (t.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (t) {\n            !function (t) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(e, t) {\n                  return this.bb_pos = e, this.bb = t, this;\n                }\n                static getRootAsAttribute(e, t) {\n                  return (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                static getSizePrefixedRootAsAttribute(e, t) {\n                  return e.setPosition(e.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                name(e) {\n                  let t = this.bb.__offset(this.bb_pos, 4);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                docString(e) {\n                  let t = this.bb.__offset(this.bb_pos, 6);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                type() {\n                  let t = this.bb.__offset(this.bb_pos, 8);\n                  return t ? this.bb.readInt32(this.bb_pos + t) : e.experimental.fbs.AttributeType.UNDEFINED;\n                }\n                f() {\n                  let e = this.bb.__offset(this.bb_pos, 10);\n                  return e ? this.bb.readFloat32(this.bb_pos + e) : 0;\n                }\n                i() {\n                  let e = this.bb.__offset(this.bb_pos, 12);\n                  return e ? this.bb.readInt64(this.bb_pos + e) : this.bb.createLong(0, 0);\n                }\n                s(e) {\n                  let t = this.bb.__offset(this.bb_pos, 14);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                t(t) {\n                  let n = this.bb.__offset(this.bb_pos, 16);\n                  return n ? (t || new e.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                g(t) {\n                  let n = this.bb.__offset(this.bb_pos, 18);\n                  return n ? (t || new e.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                floats(e) {\n                  let t = this.bb.__offset(this.bb_pos, 20);\n                  return t ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + t) + 4 * e) : 0;\n                }\n                floatsLength() {\n                  let e = this.bb.__offset(this.bb_pos, 20);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                floatsArray() {\n                  let e = this.bb.__offset(this.bb_pos, 20);\n                  return e ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;\n                }\n                ints(e) {\n                  let t = this.bb.__offset(this.bb_pos, 22);\n                  return t ? this.bb.readInt64(this.bb.__vector(this.bb_pos + t) + 8 * e) : this.bb.createLong(0, 0);\n                }\n                intsLength() {\n                  let e = this.bb.__offset(this.bb_pos, 22);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                strings(e, t) {\n                  let n = this.bb.__offset(this.bb_pos, 24);\n                  return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * e, t) : null;\n                }\n                stringsLength() {\n                  let e = this.bb.__offset(this.bb_pos, 24);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                tensors(t, n) {\n                  let r = this.bb.__offset(this.bb_pos, 26);\n                  return r ? (n || new e.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null;\n                }\n                tensorsLength() {\n                  let e = this.bb.__offset(this.bb_pos, 26);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                graphs(t, n) {\n                  let r = this.bb.__offset(this.bb_pos, 28);\n                  return r ? (n || new e.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null;\n                }\n                graphsLength() {\n                  let e = this.bb.__offset(this.bb_pos, 28);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                static startAttribute(e) {\n                  e.startObject(13);\n                }\n                static addName(e, t) {\n                  e.addFieldOffset(0, t, 0);\n                }\n                static addDocString(e, t) {\n                  e.addFieldOffset(1, t, 0);\n                }\n                static addType(t, n) {\n                  t.addFieldInt32(2, n, e.experimental.fbs.AttributeType.UNDEFINED);\n                }\n                static addF(e, t) {\n                  e.addFieldFloat32(3, t, 0);\n                }\n                static addI(e, t) {\n                  e.addFieldInt64(4, t, e.createLong(0, 0));\n                }\n                static addS(e, t) {\n                  e.addFieldOffset(5, t, 0);\n                }\n                static addT(e, t) {\n                  e.addFieldOffset(6, t, 0);\n                }\n                static addG(e, t) {\n                  e.addFieldOffset(7, t, 0);\n                }\n                static addFloats(e, t) {\n                  e.addFieldOffset(8, t, 0);\n                }\n                static createFloatsVector(e, t) {\n                  e.startVector(4, t.length, 4);\n                  for (let n = t.length - 1; n >= 0; n--) e.addFloat32(t[n]);\n                  return e.endVector();\n                }\n                static startFloatsVector(e, t) {\n                  e.startVector(4, t, 4);\n                }\n                static addInts(e, t) {\n                  e.addFieldOffset(9, t, 0);\n                }\n                static createIntsVector(e, t) {\n                  e.startVector(8, t.length, 8);\n                  for (let n = t.length - 1; n >= 0; n--) e.addInt64(t[n]);\n                  return e.endVector();\n                }\n                static startIntsVector(e, t) {\n                  e.startVector(8, t, 8);\n                }\n                static addStrings(e, t) {\n                  e.addFieldOffset(10, t, 0);\n                }\n                static createStringsVector(e, t) {\n                  e.startVector(4, t.length, 4);\n                  for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);\n                  return e.endVector();\n                }\n                static startStringsVector(e, t) {\n                  e.startVector(4, t, 4);\n                }\n                static addTensors(e, t) {\n                  e.addFieldOffset(11, t, 0);\n                }\n                static createTensorsVector(e, t) {\n                  e.startVector(4, t.length, 4);\n                  for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);\n                  return e.endVector();\n                }\n                static startTensorsVector(e, t) {\n                  e.startVector(4, t, 4);\n                }\n                static addGraphs(e, t) {\n                  e.addFieldOffset(12, t, 0);\n                }\n                static createGraphsVector(e, t) {\n                  e.startVector(4, t.length, 4);\n                  for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);\n                  return e.endVector();\n                }\n                static startGraphsVector(e, t) {\n                  e.startVector(4, t, 4);\n                }\n                static endAttribute(e) {\n                  return e.endObject();\n                }\n                static createAttribute(e, t, r, o, i, a, s, u, l, c, p, d, f, h) {\n                  return n.startAttribute(e), n.addName(e, t), n.addDocString(e, r), n.addType(e, o), n.addF(e, i), n.addI(e, a), n.addS(e, s), n.addT(e, u), n.addG(e, l), n.addFloats(e, c), n.addInts(e, p), n.addStrings(e, d), n.addTensors(e, f), n.addGraphs(e, h), n.endAttribute(e);\n                }\n              }\n              t.Attribute = n;\n            }(t.fbs || (t.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (t) {\n            !function (t) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(e, t) {\n                  return this.bb_pos = e, this.bb = t, this;\n                }\n                static getRootAsGraph(e, t) {\n                  return (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                static getSizePrefixedRootAsGraph(e, t) {\n                  return e.setPosition(e.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                initializers(t, n) {\n                  let r = this.bb.__offset(this.bb_pos, 4);\n                  return r ? (n || new e.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null;\n                }\n                initializersLength() {\n                  let e = this.bb.__offset(this.bb_pos, 4);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                nodeArgs(t, n) {\n                  let r = this.bb.__offset(this.bb_pos, 6);\n                  return r ? (n || new e.experimental.fbs.ValueInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null;\n                }\n                nodeArgsLength() {\n                  let e = this.bb.__offset(this.bb_pos, 6);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                nodes(t, n) {\n                  let r = this.bb.__offset(this.bb_pos, 8);\n                  return r ? (n || new e.experimental.fbs.Node()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null;\n                }\n                nodesLength() {\n                  let e = this.bb.__offset(this.bb_pos, 8);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                maxNodeIndex() {\n                  let e = this.bb.__offset(this.bb_pos, 10);\n                  return e ? this.bb.readUint32(this.bb_pos + e) : 0;\n                }\n                nodeEdges(t, n) {\n                  let r = this.bb.__offset(this.bb_pos, 12);\n                  return r ? (n || new e.experimental.fbs.NodeEdge()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null;\n                }\n                nodeEdgesLength() {\n                  let e = this.bb.__offset(this.bb_pos, 12);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                inputs(e, t) {\n                  let n = this.bb.__offset(this.bb_pos, 14);\n                  return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * e, t) : null;\n                }\n                inputsLength() {\n                  let e = this.bb.__offset(this.bb_pos, 14);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                outputs(e, t) {\n                  let n = this.bb.__offset(this.bb_pos, 16);\n                  return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * e, t) : null;\n                }\n                outputsLength() {\n                  let e = this.bb.__offset(this.bb_pos, 16);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                sparseInitializers(t, n) {\n                  let r = this.bb.__offset(this.bb_pos, 18);\n                  return r ? (n || new e.experimental.fbs.SparseTensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null;\n                }\n                sparseInitializersLength() {\n                  let e = this.bb.__offset(this.bb_pos, 18);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                static startGraph(e) {\n                  e.startObject(8);\n                }\n                static addInitializers(e, t) {\n                  e.addFieldOffset(0, t, 0);\n                }\n                static createInitializersVector(e, t) {\n                  e.startVector(4, t.length, 4);\n                  for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);\n                  return e.endVector();\n                }\n                static startInitializersVector(e, t) {\n                  e.startVector(4, t, 4);\n                }\n                static addNodeArgs(e, t) {\n                  e.addFieldOffset(1, t, 0);\n                }\n                static createNodeArgsVector(e, t) {\n                  e.startVector(4, t.length, 4);\n                  for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);\n                  return e.endVector();\n                }\n                static startNodeArgsVector(e, t) {\n                  e.startVector(4, t, 4);\n                }\n                static addNodes(e, t) {\n                  e.addFieldOffset(2, t, 0);\n                }\n                static createNodesVector(e, t) {\n                  e.startVector(4, t.length, 4);\n                  for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);\n                  return e.endVector();\n                }\n                static startNodesVector(e, t) {\n                  e.startVector(4, t, 4);\n                }\n                static addMaxNodeIndex(e, t) {\n                  e.addFieldInt32(3, t, 0);\n                }\n                static addNodeEdges(e, t) {\n                  e.addFieldOffset(4, t, 0);\n                }\n                static createNodeEdgesVector(e, t) {\n                  e.startVector(4, t.length, 4);\n                  for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);\n                  return e.endVector();\n                }\n                static startNodeEdgesVector(e, t) {\n                  e.startVector(4, t, 4);\n                }\n                static addInputs(e, t) {\n                  e.addFieldOffset(5, t, 0);\n                }\n                static createInputsVector(e, t) {\n                  e.startVector(4, t.length, 4);\n                  for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);\n                  return e.endVector();\n                }\n                static startInputsVector(e, t) {\n                  e.startVector(4, t, 4);\n                }\n                static addOutputs(e, t) {\n                  e.addFieldOffset(6, t, 0);\n                }\n                static createOutputsVector(e, t) {\n                  e.startVector(4, t.length, 4);\n                  for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);\n                  return e.endVector();\n                }\n                static startOutputsVector(e, t) {\n                  e.startVector(4, t, 4);\n                }\n                static addSparseInitializers(e, t) {\n                  e.addFieldOffset(7, t, 0);\n                }\n                static createSparseInitializersVector(e, t) {\n                  e.startVector(4, t.length, 4);\n                  for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);\n                  return e.endVector();\n                }\n                static startSparseInitializersVector(e, t) {\n                  e.startVector(4, t, 4);\n                }\n                static endGraph(e) {\n                  return e.endObject();\n                }\n                static createGraph(e, t, r, o, i, a, s, u, l) {\n                  return n.startGraph(e), n.addInitializers(e, t), n.addNodeArgs(e, r), n.addNodes(e, o), n.addMaxNodeIndex(e, i), n.addNodeEdges(e, a), n.addInputs(e, s), n.addOutputs(e, u), n.addSparseInitializers(e, l), n.endGraph(e);\n                }\n              }\n              t.Graph = n;\n            }(t.fbs || (t.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (t) {\n            !function (t) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(e, t) {\n                  return this.bb_pos = e, this.bb = t, this;\n                }\n                static getRootAsModel(e, t) {\n                  return (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                static getSizePrefixedRootAsModel(e, t) {\n                  return e.setPosition(e.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                irVersion() {\n                  let e = this.bb.__offset(this.bb_pos, 4);\n                  return e ? this.bb.readInt64(this.bb_pos + e) : this.bb.createLong(0, 0);\n                }\n                opsetImport(t, n) {\n                  let r = this.bb.__offset(this.bb_pos, 6);\n                  return r ? (n || new e.experimental.fbs.OperatorSetId()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null;\n                }\n                opsetImportLength() {\n                  let e = this.bb.__offset(this.bb_pos, 6);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                producerName(e) {\n                  let t = this.bb.__offset(this.bb_pos, 8);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                producerVersion(e) {\n                  let t = this.bb.__offset(this.bb_pos, 10);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                domain(e) {\n                  let t = this.bb.__offset(this.bb_pos, 12);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                modelVersion() {\n                  let e = this.bb.__offset(this.bb_pos, 14);\n                  return e ? this.bb.readInt64(this.bb_pos + e) : this.bb.createLong(0, 0);\n                }\n                docString(e) {\n                  let t = this.bb.__offset(this.bb_pos, 16);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                graph(t) {\n                  let n = this.bb.__offset(this.bb_pos, 18);\n                  return n ? (t || new e.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                graphDocString(e) {\n                  let t = this.bb.__offset(this.bb_pos, 20);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                static startModel(e) {\n                  e.startObject(9);\n                }\n                static addIrVersion(e, t) {\n                  e.addFieldInt64(0, t, e.createLong(0, 0));\n                }\n                static addOpsetImport(e, t) {\n                  e.addFieldOffset(1, t, 0);\n                }\n                static createOpsetImportVector(e, t) {\n                  e.startVector(4, t.length, 4);\n                  for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);\n                  return e.endVector();\n                }\n                static startOpsetImportVector(e, t) {\n                  e.startVector(4, t, 4);\n                }\n                static addProducerName(e, t) {\n                  e.addFieldOffset(2, t, 0);\n                }\n                static addProducerVersion(e, t) {\n                  e.addFieldOffset(3, t, 0);\n                }\n                static addDomain(e, t) {\n                  e.addFieldOffset(4, t, 0);\n                }\n                static addModelVersion(e, t) {\n                  e.addFieldInt64(5, t, e.createLong(0, 0));\n                }\n                static addDocString(e, t) {\n                  e.addFieldOffset(6, t, 0);\n                }\n                static addGraph(e, t) {\n                  e.addFieldOffset(7, t, 0);\n                }\n                static addGraphDocString(e, t) {\n                  e.addFieldOffset(8, t, 0);\n                }\n                static endModel(e) {\n                  return e.endObject();\n                }\n                static createModel(e, t, r, o, i, a, s, u, l, c) {\n                  return n.startModel(e), n.addIrVersion(e, t), n.addOpsetImport(e, r), n.addProducerName(e, o), n.addProducerVersion(e, i), n.addDomain(e, a), n.addModelVersion(e, s), n.addDocString(e, u), n.addGraph(e, l), n.addGraphDocString(e, c), n.endModel(e);\n                }\n              }\n              t.Model = n;\n            }(t.fbs || (t.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (e) {\n            !function (e) {\n              class t {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(e, t) {\n                  return this.bb_pos = e, this.bb = t, this;\n                }\n                static getRootAsKernelCreateInfos(e, n) {\n                  return (n || new t()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                static getSizePrefixedRootAsKernelCreateInfos(e, n) {\n                  return e.setPosition(e.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (n || new t()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                nodeIndices(e) {\n                  let t = this.bb.__offset(this.bb_pos, 4);\n                  return t ? this.bb.readUint32(this.bb.__vector(this.bb_pos + t) + 4 * e) : 0;\n                }\n                nodeIndicesLength() {\n                  let e = this.bb.__offset(this.bb_pos, 4);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                nodeIndicesArray() {\n                  let e = this.bb.__offset(this.bb_pos, 4);\n                  return e ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;\n                }\n                kernelDefHashes(e) {\n                  let t = this.bb.__offset(this.bb_pos, 6);\n                  return t ? this.bb.readUint64(this.bb.__vector(this.bb_pos + t) + 8 * e) : this.bb.createLong(0, 0);\n                }\n                kernelDefHashesLength() {\n                  let e = this.bb.__offset(this.bb_pos, 6);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                static startKernelCreateInfos(e) {\n                  e.startObject(2);\n                }\n                static addNodeIndices(e, t) {\n                  e.addFieldOffset(0, t, 0);\n                }\n                static createNodeIndicesVector(e, t) {\n                  e.startVector(4, t.length, 4);\n                  for (let n = t.length - 1; n >= 0; n--) e.addInt32(t[n]);\n                  return e.endVector();\n                }\n                static startNodeIndicesVector(e, t) {\n                  e.startVector(4, t, 4);\n                }\n                static addKernelDefHashes(e, t) {\n                  e.addFieldOffset(1, t, 0);\n                }\n                static createKernelDefHashesVector(e, t) {\n                  e.startVector(8, t.length, 8);\n                  for (let n = t.length - 1; n >= 0; n--) e.addInt64(t[n]);\n                  return e.endVector();\n                }\n                static startKernelDefHashesVector(e, t) {\n                  e.startVector(8, t, 8);\n                }\n                static endKernelCreateInfos(e) {\n                  return e.endObject();\n                }\n                static createKernelCreateInfos(e, n, r) {\n                  return t.startKernelCreateInfos(e), t.addNodeIndices(e, n), t.addKernelDefHashes(e, r), t.endKernelCreateInfos(e);\n                }\n              }\n              e.KernelCreateInfos = t;\n            }(e.fbs || (e.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (t) {\n            !function (t) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(e, t) {\n                  return this.bb_pos = e, this.bb = t, this;\n                }\n                static getRootAsSubGraphSessionState(e, t) {\n                  return (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                static getSizePrefixedRootAsSubGraphSessionState(e, t) {\n                  return e.setPosition(e.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                graphId(e) {\n                  let t = this.bb.__offset(this.bb_pos, 4);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                sessionState(t) {\n                  let n = this.bb.__offset(this.bb_pos, 6);\n                  return n ? (t || new e.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                static startSubGraphSessionState(e) {\n                  e.startObject(2);\n                }\n                static addGraphId(e, t) {\n                  e.addFieldOffset(0, t, 0);\n                }\n                static addSessionState(e, t) {\n                  e.addFieldOffset(1, t, 0);\n                }\n                static endSubGraphSessionState(e) {\n                  let t = e.endObject();\n                  return e.requiredField(t, 4), t;\n                }\n                static createSubGraphSessionState(e, t, r) {\n                  return n.startSubGraphSessionState(e), n.addGraphId(e, t), n.addSessionState(e, r), n.endSubGraphSessionState(e);\n                }\n              }\n              t.SubGraphSessionState = n;\n            }(t.fbs || (t.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (t) {\n            !function (t) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(e, t) {\n                  return this.bb_pos = e, this.bb = t, this;\n                }\n                static getRootAsSessionState(e, t) {\n                  return (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                static getSizePrefixedRootAsSessionState(e, t) {\n                  return e.setPosition(e.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                kernels(t) {\n                  let n = this.bb.__offset(this.bb_pos, 4);\n                  return n ? (t || new e.experimental.fbs.KernelCreateInfos()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                subGraphSessionStates(t, n) {\n                  let r = this.bb.__offset(this.bb_pos, 6);\n                  return r ? (n || new e.experimental.fbs.SubGraphSessionState()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null;\n                }\n                subGraphSessionStatesLength() {\n                  let e = this.bb.__offset(this.bb_pos, 6);\n                  return e ? this.bb.__vector_len(this.bb_pos + e) : 0;\n                }\n                static startSessionState(e) {\n                  e.startObject(2);\n                }\n                static addKernels(e, t) {\n                  e.addFieldOffset(0, t, 0);\n                }\n                static addSubGraphSessionStates(e, t) {\n                  e.addFieldOffset(1, t, 0);\n                }\n                static createSubGraphSessionStatesVector(e, t) {\n                  e.startVector(4, t.length, 4);\n                  for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);\n                  return e.endVector();\n                }\n                static startSubGraphSessionStatesVector(e, t) {\n                  e.startVector(4, t, 4);\n                }\n                static endSessionState(e) {\n                  return e.endObject();\n                }\n                static createSessionState(e, t, r) {\n                  return n.startSessionState(e), n.addKernels(e, t), n.addSubGraphSessionStates(e, r), n.endSessionState(e);\n                }\n              }\n              t.SessionState = n;\n            }(t.fbs || (t.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {})), function (e) {\n          !function (t) {\n            !function (t) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(e, t) {\n                  return this.bb_pos = e, this.bb = t, this;\n                }\n                static getRootAsInferenceSession(e, t) {\n                  return (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                static getSizePrefixedRootAsInferenceSession(e, t) {\n                  return e.setPosition(e.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n()).__init(e.readInt32(e.position()) + e.position(), e);\n                }\n                static bufferHasIdentifier(e) {\n                  return e.__has_identifier(\"ORTM\");\n                }\n                ortVersion(e) {\n                  let t = this.bb.__offset(this.bb_pos, 4);\n                  return t ? this.bb.__string(this.bb_pos + t, e) : null;\n                }\n                model(t) {\n                  let n = this.bb.__offset(this.bb_pos, 6);\n                  return n ? (t || new e.experimental.fbs.Model()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                sessionState(t) {\n                  let n = this.bb.__offset(this.bb_pos, 8);\n                  return n ? (t || new e.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                static startInferenceSession(e) {\n                  e.startObject(3);\n                }\n                static addOrtVersion(e, t) {\n                  e.addFieldOffset(0, t, 0);\n                }\n                static addModel(e, t) {\n                  e.addFieldOffset(1, t, 0);\n                }\n                static addSessionState(e, t) {\n                  e.addFieldOffset(2, t, 0);\n                }\n                static endInferenceSession(e) {\n                  return e.endObject();\n                }\n                static finishInferenceSessionBuffer(e, t) {\n                  e.finish(t, \"ORTM\");\n                }\n                static finishSizePrefixedInferenceSessionBuffer(e, t) {\n                  e.finish(t, \"ORTM\", !0);\n                }\n                static createInferenceSession(e, t, r, o) {\n                  return n.startInferenceSession(e), n.addOrtVersion(e, t), n.addModel(e, r), n.addSessionState(e, o), n.endInferenceSession(e);\n                }\n              }\n              t.InferenceSession = n;\n            }(t.fbs || (t.fbs = {}));\n          }(e.experimental || (e.experimental = {}));\n        }(t.onnxruntime || (t.onnxruntime = {}));\n      },\n      1723: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.OnnxjsSessionHandler = void 0;\n        const r = n(2235),\n          o = n(9240);\n        t.OnnxjsSessionHandler = class {\n          constructor(e) {\n            this.session = e, this.inputNames = this.session.inputNames, this.outputNames = this.session.outputNames;\n          }\n          async dispose() {}\n          async run(e, t, n) {\n            const i = new Map();\n            for (const t in e) if (Object.hasOwnProperty.call(e, t)) {\n              const n = e[t];\n              i.set(t, new o.Tensor(n.dims, n.type, void 0, void 0, n.data));\n            }\n            const a = await this.session.run(i),\n              s = {};\n            return a.forEach((e, t) => {\n              s[t] = new r.Tensor(e.type, e.data, e.dims);\n            }), s;\n          }\n          startProfiling() {\n            this.session.startProfiling();\n          }\n          endProfiling() {\n            this.session.endProfiling();\n          }\n        };\n      },\n      6027: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Session = void 0;\n        const r = n(7067),\n          o = n(1296),\n          i = n(1975),\n          a = n(6496),\n          s = n(1315),\n          u = n(1745);\n        t.Session = class {\n          constructor(e = {}) {\n            this._initialized = !1, this.backendHint = e.backendHint, this.profiler = s.Profiler.create(e.profiler), this.context = {\n              profiler: this.profiler,\n              graphInputTypes: [],\n              graphInputDims: []\n            };\n          }\n          get inputNames() {\n            return this._model.graph.getInputNames();\n          }\n          get outputNames() {\n            return this._model.graph.getOutputNames();\n          }\n          startProfiling() {\n            this.profiler.start();\n          }\n          endProfiling() {\n            this.profiler.stop();\n          }\n          async loadModel(e, t, n) {\n            await this.profiler.event(\"session\", \"Session.loadModel\", async () => {\n              const a = await (0, i.resolveBackend)(this.backendHint);\n              if (this.sessionHandler = a.createSessionHandler(this.context), this._model = new u.Model(), \"string\" == typeof e) {\n                const t = e.endsWith(\".ort\");\n                if (\"undefined\" != typeof process && process.versions && process.versions.node) {\n                  const n = await (0, o.promisify)(r.readFile)(e);\n                  this.initialize(n, t);\n                } else {\n                  const n = await fetch(e),\n                    r = await n.arrayBuffer();\n                  this.initialize(new Uint8Array(r), t);\n                }\n              } else if (ArrayBuffer.isView(e)) this.initialize(e);else {\n                const r = new Uint8Array(e, t || 0, n || e.byteLength);\n                this.initialize(r);\n              }\n            });\n          }\n          initialize(e, t) {\n            if (this._initialized) throw new Error(\"already initialized\");\n            this.profiler.event(\"session\", \"Session.initialize\", () => {\n              const n = this.sessionHandler.transformGraph ? this.sessionHandler : void 0;\n              this._model.load(e, n, t), this.sessionHandler.onGraphInitialized && this.sessionHandler.onGraphInitialized(this._model.graph), this.initializeOps(this._model.graph), this._executionPlan = new a.ExecutionPlan(this._model.graph, this._ops, this.profiler);\n            }), this._initialized = !0;\n          }\n          async run(e) {\n            if (!this._initialized) throw new Error(\"session not initialized yet\");\n            return this.profiler.event(\"session\", \"Session.run\", async () => {\n              const t = this.normalizeAndValidateInputs(e),\n                n = await this._executionPlan.execute(this.sessionHandler, t);\n              return this.createOutput(n);\n            });\n          }\n          normalizeAndValidateInputs(e) {\n            const t = this._model.graph.getInputNames();\n            if (Array.isArray(e)) {\n              if (e.length !== t.length) throw new Error(`incorrect input array length: expected ${t.length} but got ${e.length}`);\n            } else {\n              if (e.size !== t.length) throw new Error(`incorrect input map size: expected ${t.length} but got ${e.size}`);\n              const n = new Array(e.size);\n              let r = 0;\n              for (let o = 0; o < t.length; ++o) {\n                const i = e.get(t[o]);\n                if (!i) throw new Error(`missing input tensor for: '${name}'`);\n                n[r++] = i;\n              }\n              e = n;\n            }\n            if (this.context.graphInputTypes && 0 !== this.context.graphInputTypes.length && this.context.graphInputDims && 0 !== this.context.graphInputDims.length) this.validateInputTensorDims(this.context.graphInputDims, e, !1);else {\n              const t = this._model.graph.getInputIndices(),\n                n = this._model.graph.getValues(),\n                r = new Array(t.length);\n              for (let o = 0; o < t.length; ++o) {\n                const i = n[t[o]];\n                r[o] = i.type.shape.dims, this.context.graphInputTypes.push(i.type.tensorType), this.context.graphInputDims.push(e[o].dims);\n              }\n              this.validateInputTensorDims(r, e, !0);\n            }\n            return this.validateInputTensorTypes(this.context.graphInputTypes, e), e;\n          }\n          validateInputTensorTypes(e, t) {\n            for (let n = 0; n < t.length; n++) {\n              const r = e[n],\n                o = t[n].type;\n              if (r !== o) throw new Error(`input tensor[${n}] check failed: expected type '${r}' but got ${o}`);\n            }\n          }\n          validateInputTensorDims(e, t, n) {\n            for (let r = 0; r < t.length; r++) {\n              const o = e[r],\n                i = t[r].dims;\n              if (!this.compareTensorDims(o, i, n)) throw new Error(`input tensor[${r}] check failed: expected shape '[${o.join(\",\")}]' but got [${i.join(\",\")}]`);\n            }\n          }\n          compareTensorDims(e, t, n) {\n            if (e.length !== t.length) return !1;\n            for (let r = 0; r < e.length; ++r) if (e[r] !== t[r] && (!n || 0 !== e[r])) return !1;\n            return !0;\n          }\n          createOutput(e) {\n            const t = this._model.graph.getOutputNames();\n            if (e.length !== t.length) throw new Error(\"expected number of outputs do not match number of generated outputs\");\n            const n = new Map();\n            for (let r = 0; r < t.length; ++r) n.set(t[r], e[r]);\n            return n;\n          }\n          initializeOps(e) {\n            const t = e.getNodes();\n            this._ops = new Array(t.length);\n            for (let n = 0; n < t.length; n++) this._ops[n] = this.sessionHandler.resolve(t[n], this._model.opsets, e);\n          }\n        };\n      },\n      9240: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Tensor = void 0;\n        const o = n(3442),\n          i = r(n(1583)),\n          a = n(5127),\n          s = n(2446),\n          u = n(7273);\n        var l = a.onnxruntime.experimental.fbs;\n        class c {\n          get data() {\n            if (void 0 === this.cache) {\n              const e = this.dataProvider(this.dataId);\n              if (e.length !== this.size) throw new Error(\"Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.\");\n              this.cache = e;\n            }\n            return this.cache;\n          }\n          get stringData() {\n            if (\"string\" !== this.type) throw new TypeError(\"data type is not string\");\n            return this.data;\n          }\n          get integerData() {\n            switch (this.type) {\n              case \"uint8\":\n              case \"int8\":\n              case \"uint16\":\n              case \"int16\":\n              case \"int32\":\n              case \"uint32\":\n              case \"bool\":\n                return this.data;\n              default:\n                throw new TypeError(\"data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)\");\n            }\n          }\n          get floatData() {\n            switch (this.type) {\n              case \"float32\":\n              case \"float64\":\n                return this.data;\n              default:\n                throw new TypeError(\"data type is not float (float32, float64)\");\n            }\n          }\n          get numberData() {\n            if (\"string\" !== this.type) return this.data;\n            throw new TypeError(\"type cannot be non-number (string)\");\n          }\n          get(e) {\n            return this.data[u.ShapeUtil.indicesToOffset(e, this.strides)];\n          }\n          set(e, t) {\n            this.data[u.ShapeUtil.indicesToOffset(e, this.strides)] = t;\n          }\n          async getData() {\n            return void 0 === this.cache && (this.cache = await this.asyncDataProvider(this.dataId)), this.cache;\n          }\n          get strides() {\n            return this._strides || (this._strides = u.ShapeUtil.computeStrides(this.dims)), this._strides;\n          }\n          constructor(e, t, n, r, i, a = o.Guid.create()) {\n            this.dims = e, this.type = t, this.dataProvider = n, this.asyncDataProvider = r, this.cache = i, this.dataId = a, this.size = u.ShapeUtil.validateDimsAndCalcSize(e);\n            const s = this.size,\n              l = void 0 === n && void 0 === r && void 0 === i;\n            if (void 0 !== i && i.length !== s) throw new RangeError(\"Input dims doesn't match data length.\");\n            if (\"string\" === t) {\n              if (!(void 0 === i || Array.isArray(i) && i.every(e => \"string\" == typeof e))) throw new TypeError(\"cache should be a string array\");\n              l && (this.cache = new Array(s));\n            } else {\n              if (void 0 !== i) {\n                const e = d(t);\n                if (!(i instanceof e)) throw new TypeError(`cache should be type ${e.name}`);\n              }\n              if (l) {\n                const e = new ArrayBuffer(s * function (e) {\n                  switch (e) {\n                    case \"bool\":\n                    case \"int8\":\n                    case \"uint8\":\n                      return 1;\n                    case \"int16\":\n                    case \"uint16\":\n                      return 2;\n                    case \"int32\":\n                    case \"uint32\":\n                    case \"float32\":\n                      return 4;\n                    case \"float64\":\n                      return 8;\n                    default:\n                      throw new Error(`cannot calculate sizeof() on type ${e}`);\n                  }\n                }(t));\n                this.cache = function (e, t) {\n                  return new (d(t))(e);\n                }(e, t);\n              }\n            }\n          }\n          static fromProto(e) {\n            if (!e) throw new Error(\"cannot construct Value from an empty tensor\");\n            const t = u.ProtoUtil.tensorDataTypeFromProto(e.dataType),\n              n = u.ProtoUtil.tensorDimsFromProto(e.dims),\n              r = new c(n, t);\n            if (\"string\" === t) e.stringData.forEach((e, t) => {\n              r.data[t] = (0, u.decodeUtf8String)(e);\n            });else if (e.rawData && \"number\" == typeof e.rawData.byteLength && e.rawData.byteLength > 0) {\n              const t = r.data,\n                n = new DataView(e.rawData.buffer, e.rawData.byteOffset, e.rawData.byteLength),\n                o = p(e.dataType),\n                i = e.rawData.byteLength / o;\n              if (e.rawData.byteLength % o != 0) throw new Error(\"invalid buffer length\");\n              if (t.length !== i) throw new Error(\"buffer length mismatch\");\n              for (let r = 0; r < i; r++) {\n                const i = h(n, e.dataType, r * o);\n                t[r] = i;\n              }\n            } else {\n              let t;\n              switch (e.dataType) {\n                case s.onnx.TensorProto.DataType.FLOAT:\n                  t = e.floatData;\n                  break;\n                case s.onnx.TensorProto.DataType.INT32:\n                case s.onnx.TensorProto.DataType.INT16:\n                case s.onnx.TensorProto.DataType.UINT16:\n                case s.onnx.TensorProto.DataType.INT8:\n                case s.onnx.TensorProto.DataType.UINT8:\n                case s.onnx.TensorProto.DataType.BOOL:\n                  t = e.int32Data;\n                  break;\n                case s.onnx.TensorProto.DataType.INT64:\n                  t = e.int64Data;\n                  break;\n                case s.onnx.TensorProto.DataType.DOUBLE:\n                  t = e.doubleData;\n                  break;\n                case s.onnx.TensorProto.DataType.UINT32:\n                case s.onnx.TensorProto.DataType.UINT64:\n                  t = e.uint64Data;\n                  break;\n                default:\n                  throw new Error(\"unspecific error\");\n              }\n              if (null == t) throw new Error(\"failed to populate data from a tensorproto value\");\n              const n = r.data;\n              if (n.length !== t.length) throw new Error(\"array length mismatch\");\n              for (let r = 0; r < t.length; r++) {\n                const o = t[r];\n                i.default.isLong(o) ? n[r] = f(o, e.dataType) : n[r] = o;\n              }\n            }\n            return r;\n          }\n          static fromData(e, t, n) {\n            return new c(t, n, void 0, void 0, e);\n          }\n          static fromOrtTensor(e) {\n            if (!e) throw new Error(\"cannot construct Value from an empty tensor\");\n            const t = u.ProtoUtil.tensorDimsFromORTFormat(e),\n              n = u.ProtoUtil.tensorDataTypeFromProto(e.dataType()),\n              r = new c(t, n);\n            if (\"string\" === n) for (let t = 0; t < e.stringDataLength(); t++) r.data[t] = e.stringData(t);else if (e.rawDataArray() && \"number\" == typeof e.rawDataLength() && e.rawDataLength() > 0) {\n              const t = r.data,\n                n = new DataView(e.rawDataArray().buffer, e.rawDataArray().byteOffset, e.rawDataLength()),\n                o = p(e.dataType()),\n                i = e.rawDataLength() / o;\n              if (e.rawDataLength() % o != 0) throw new Error(\"invalid buffer length\");\n              if (t.length !== i) throw new Error(\"buffer length mismatch\");\n              for (let r = 0; r < i; r++) {\n                const i = h(n, e.dataType(), r * o);\n                t[r] = i;\n              }\n            }\n            return r;\n          }\n        }\n        function p(e) {\n          switch (e) {\n            case s.onnx.TensorProto.DataType.UINT8:\n            case s.onnx.TensorProto.DataType.INT8:\n            case s.onnx.TensorProto.DataType.BOOL:\n              return 1;\n            case s.onnx.TensorProto.DataType.UINT16:\n            case s.onnx.TensorProto.DataType.INT16:\n              return 2;\n            case s.onnx.TensorProto.DataType.FLOAT:\n            case s.onnx.TensorProto.DataType.INT32:\n            case s.onnx.TensorProto.DataType.UINT32:\n              return 4;\n            case s.onnx.TensorProto.DataType.INT64:\n            case s.onnx.TensorProto.DataType.DOUBLE:\n            case s.onnx.TensorProto.DataType.UINT64:\n              return 8;\n            default:\n              throw new Error(`cannot calculate sizeof() on type ${s.onnx.TensorProto.DataType[e]}`);\n          }\n        }\n        function d(e) {\n          switch (e) {\n            case \"bool\":\n            case \"uint8\":\n              return Uint8Array;\n            case \"int8\":\n              return Int8Array;\n            case \"int16\":\n              return Int16Array;\n            case \"uint16\":\n              return Uint16Array;\n            case \"int32\":\n              return Int32Array;\n            case \"uint32\":\n              return Uint32Array;\n            case \"int64\":\n              return BigInt64Array;\n            case \"float32\":\n              return Float32Array;\n            case \"float64\":\n              return Float64Array;\n            default:\n              throw new Error(\"unspecified error\");\n          }\n        }\n        function f(e, t) {\n          if (t === s.onnx.TensorProto.DataType.INT64 || t === l.TensorDataType.INT64) {\n            if (e.greaterThanOrEqual(2147483648) || e.lessThan(-2147483648)) throw new TypeError(\"int64 is not supported\");\n          } else {\n            if (t !== s.onnx.TensorProto.DataType.UINT32 && t !== l.TensorDataType.UINT32 && t !== s.onnx.TensorProto.DataType.UINT64 && t !== l.TensorDataType.UINT64) throw new TypeError(`not a LONG type: ${s.onnx.TensorProto.DataType[t]}`);\n            if (e.greaterThanOrEqual(4294967296) || e.lessThan(0)) throw new TypeError(\"uint64 is not supported\");\n          }\n          return e.toNumber();\n        }\n        function h(e, t, n) {\n          switch (t) {\n            case s.onnx.TensorProto.DataType.BOOL:\n            case s.onnx.TensorProto.DataType.UINT8:\n              return e.getUint8(n);\n            case s.onnx.TensorProto.DataType.INT8:\n              return e.getInt8(n);\n            case s.onnx.TensorProto.DataType.UINT16:\n              return e.getUint16(n, !0);\n            case s.onnx.TensorProto.DataType.INT16:\n              return e.getInt16(n, !0);\n            case s.onnx.TensorProto.DataType.FLOAT:\n              return e.getFloat32(n, !0);\n            case s.onnx.TensorProto.DataType.INT32:\n              return e.getInt32(n, !0);\n            case s.onnx.TensorProto.DataType.UINT32:\n              return e.getUint32(n, !0);\n            case s.onnx.TensorProto.DataType.INT64:\n              return f(i.default.fromBits(e.getUint32(n, !0), e.getUint32(n + 4, !0), !1), t);\n            case s.onnx.TensorProto.DataType.DOUBLE:\n              return e.getFloat64(n, !0);\n            case s.onnx.TensorProto.DataType.UINT64:\n              return f(i.default.fromBits(e.getUint32(n, !0), e.getUint32(n + 4, !0), !0), t);\n            default:\n              throw new Error(`cannot read from DataView for type ${s.onnx.TensorProto.DataType[t]}`);\n          }\n        }\n        t.Tensor = c;\n      },\n      7273: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__importDefault || function (e) {\n          return e && e.__esModule ? e : {\n            default: e\n          };\n        };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.decodeUtf8String = t.MAX_CLIP = t.MIN_CLIP = t.PoolConvUtil = t.ReduceUtil = t.SplitUtil = t.MathUtil = t.ShapeUtil = t.LongUtil = t.ProtoUtil = t.GemmUtil = t.arrayCopyHelper = t.BroadcastUtil = t.MatMulUtil = t.ArrayUtil = t.assert = t.checkInputsShape = void 0;\n        const o = n(5686),\n          i = r(n(1583)),\n          a = n(2446),\n          s = n(9240);\n        t.checkInputsShape = function (e, ...t) {\n          if (!e || e.length !== t.length) return !1;\n          for (let n = 0; n < e.length; n++) if (!e[n].dims || e[n].dims.length !== t[n]) return !1;\n          return !0;\n        }, t.assert = function (e, t) {\n          if (!e) throw new Error(\"string\" == typeof t ? t : t());\n        }, t.ArrayUtil = class {\n          static arraysEqual(e, t) {\n            if (e.length !== t.length) return !1;\n            for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;\n            return !0;\n          }\n        };\n        class u {\n          static preprocessInputShapes(e, t) {\n            return [1 === e.length ? [1, e[0]] : e, 1 === t.length ? [t[0], 1] : t];\n          }\n          static postprocessOutputShape(e, t, n) {\n            1 === t && e.splice(e.length - 2, 1), 1 === n && e.pop();\n          }\n          static calcMatMulShape(e, t) {\n            return e[1] !== t[0] ? void 0 : [e[0], t[1]];\n          }\n        }\n        t.MatMulUtil = u;\n        class l {\n          static calcShape(e, t, n = !1) {\n            const r = e.length,\n              o = t.length;\n            if (0 === r) return t;\n            if (0 === o) return e;\n            const i = Math.max(e.length, t.length),\n              a = new Array(i);\n            if (n) {\n              if (r < 2 || o < 2) return;\n              const n = u.calcMatMulShape([e[r - 2], e[r - 1]], [t[o - 2], t[o - 1]]);\n              if (void 0 === n) return;\n              [a[i - 2], a[i - 1]] = n;\n            }\n            for (let s = n ? 3 : 1; s <= i; s++) {\n              const n = r - s < 0 ? 1 : e[r - s],\n                u = o - s < 0 ? 1 : t[o - s];\n              if (n !== u && n > 1 && u > 1) return;\n              a[i - s] = Math.max(n, u);\n            }\n            return a;\n          }\n          static index(e, t) {\n            const n = new Array(t.length);\n            return l.fillIndex(e, t, n), n;\n          }\n          static fillIndex(e, t, n) {\n            const r = e.length - t.length;\n            for (let o = 0; o < t.length; o++) n[o] = e[r + o] % t[o];\n          }\n          static calc(e, t, n, r, o) {\n            const i = l.calcShape(e.dims, t.dims);\n            if (i) {\n              if (r && !d.areEqual(i, e.dims)) return;\n              const a = d.size(i),\n                u = r ? e : new s.Tensor(i, o || e.type);\n              if (0 === i.length) u.set([], n(e.get([]), t.get([])));else {\n                const r = new Array(i.length),\n                  o = new Array(e.dims.length),\n                  s = new Array(t.dims.length);\n                let c,\n                  p = 0,\n                  d = 0,\n                  f = !1,\n                  h = !1;\n                0 === e.dims.length && (p = e.get([]), f = !0), 0 === t.dims.length && (d = t.get([]), h = !0);\n                for (let g = 0; g < a; g++) {\n                  c = g;\n                  for (let e = i.length - 1; e >= 0; e--) r[e] = c % i[e], c = Math.floor(c / i[e]);\n                  f || (l.fillIndex(r, e.dims, o), p = e.get(o)), h || (l.fillIndex(r, t.dims, s), d = t.get(s)), u.set(r, n(p, d));\n                }\n              }\n              return u;\n            }\n          }\n          static isValidBroadcast(e, t) {\n            const n = e.length,\n              r = t.length;\n            if (n > r) return !1;\n            for (let o = 1; o <= n; o++) if (1 !== e[n - o] && e[n - o] !== t[r - o]) return !1;\n            return !0;\n          }\n          static getBroadcastDims(e, t) {\n            const n = e.length,\n              r = [];\n            for (let o = 0; o < n; o++) {\n              const i = n - 1 - o,\n                a = e[i] || 1;\n              (t[t.length - 1 - o] || 1) > 1 && 1 === a && r.unshift(i);\n            }\n            return r;\n          }\n        }\n        t.BroadcastUtil = l, t.arrayCopyHelper = function (e, t, n, r, o) {\n          if (r < 0 || r >= t.length) throw new Error(\"sourceIndex out of bounds\");\n          if (n < 0 || n >= e.length) throw new Error(\"targetIndex out of bounds\");\n          if (r + o > t.length) throw new Error(\"source indices to be copied are outside bounds\");\n          if (n + o > e.length) throw new Error(\"target array is too small to hold result\");\n          for (let i = 0; i < o; i++) e[n + i] = t[r + i];\n        }, t.GemmUtil = class {\n          static getShapeOfGemmResult(e, t, n, r, o) {\n            if (2 !== e.length || 2 !== n.length) throw new Error(\"shape need to be of size 2\");\n            let i, a, s;\n            t ? (i = e[1], a = e[0]) : (i = e[0], a = e[1]);\n            let u = -1;\n            if (r ? (s = n[0], u = 1) : (s = n[1], u = 0), n[u] !== a) throw new Error(\"dimension mismatch\");\n            if (i <= 0 || s <= 0 || a <= 0) throw new Error(\"invalid shape specified\");\n            if (o && !l.isValidBroadcast(o, [i, s])) throw new Error(\"gemm: invalid bias shape for broadcast\");\n            return [i, s, a];\n          }\n        };\n        class c {\n          static tensorDataTypeFromProto(e) {\n            switch (e) {\n              case a.onnx.TensorProto.DataType.INT8:\n                return \"int8\";\n              case a.onnx.TensorProto.DataType.UINT8:\n                return \"uint8\";\n              case a.onnx.TensorProto.DataType.BOOL:\n                return \"bool\";\n              case a.onnx.TensorProto.DataType.INT16:\n                return \"int16\";\n              case a.onnx.TensorProto.DataType.UINT16:\n                return \"uint16\";\n              case a.onnx.TensorProto.DataType.INT32:\n                return \"int32\";\n              case a.onnx.TensorProto.DataType.UINT32:\n                return \"uint32\";\n              case a.onnx.TensorProto.DataType.FLOAT:\n                return \"float32\";\n              case a.onnx.TensorProto.DataType.DOUBLE:\n                return \"float64\";\n              case a.onnx.TensorProto.DataType.STRING:\n                return \"string\";\n              case a.onnx.TensorProto.DataType.INT64:\n                return \"int32\";\n              case a.onnx.TensorProto.DataType.UINT64:\n                return \"uint32\";\n              default:\n                throw new Error(`unsupported data type: ${a.onnx.TensorProto.DataType[e]}`);\n            }\n          }\n          static tensorDataTypeStringToEnum(e) {\n            switch (e) {\n              case \"int8\":\n                return a.onnx.TensorProto.DataType.INT8;\n              case \"uint8\":\n                return a.onnx.TensorProto.DataType.UINT8;\n              case \"bool\":\n                return a.onnx.TensorProto.DataType.BOOL;\n              case \"int16\":\n                return a.onnx.TensorProto.DataType.INT16;\n              case \"uint16\":\n                return a.onnx.TensorProto.DataType.UINT16;\n              case \"int32\":\n                return a.onnx.TensorProto.DataType.INT32;\n              case \"uint32\":\n                return a.onnx.TensorProto.DataType.UINT32;\n              case \"float32\":\n                return a.onnx.TensorProto.DataType.FLOAT;\n              case \"float64\":\n                return a.onnx.TensorProto.DataType.DOUBLE;\n              case \"string\":\n                return a.onnx.TensorProto.DataType.STRING;\n              case \"int64\":\n                return a.onnx.TensorProto.DataType.INT64;\n              case \"uint64\":\n                return a.onnx.TensorProto.DataType.UINT64;\n              default:\n                throw new Error(`unsupported data type: ${e}`);\n            }\n          }\n          static tensorDimsFromProto(e) {\n            return e.map(e => i.default.isLong(e) ? e.toNumber() : e);\n          }\n          static tensorValueTypeFromProto(e) {\n            return {\n              tensorType: c.tensorDataTypeFromProto(e.elemType),\n              shape: {\n                dims: c.tensorDimsFromProto(e.shape.dim.map(e => e.dimValue))\n              }\n            };\n          }\n          static tensorDimsFromORTFormat(e) {\n            const t = [];\n            for (let n = 0; n < e.dimsLength(); n++) t.push(p.longToNumber(e.dims(n)));\n            return t;\n          }\n          static tensorAttributesFromORTFormat(e) {\n            const t = [];\n            for (let n = 0; n < e.attributesLength(); n++) t.push(e.attributes(n));\n            return t;\n          }\n        }\n        t.ProtoUtil = c;\n        class p {\n          static longToNumber(e, t) {\n            return i.default.isLong(e) ? e.toNumber() : e instanceof o.flatbuffers.Long ? i.default.fromValue({\n              low: e.low,\n              high: e.high,\n              unsigned: null != t && t\n            }).toNumber() : e;\n          }\n          static isLong(e) {\n            return i.default.isLong(e) || e instanceof o.flatbuffers.Long;\n          }\n        }\n        t.LongUtil = p;\n        class d {\n          static size(e) {\n            return d.getSizeFromDimensionRange(e, 0, e.length);\n          }\n          static sizeFromDimension(e, t) {\n            if (t < 0 || t > e.length) throw new Error(`invalid dimension of ${t} for sizeFromDimension as Tensor has ${e.length} dimensions.`);\n            return d.getSizeFromDimensionRange(e, t, e.length);\n          }\n          static sizeToDimension(e, t) {\n            if (t < 0 || t > e.length) throw new Error(`invalid dimension of ${t} for sizeToDimension as Tensor has ${e.length} dimensions.`);\n            return d.getSizeFromDimensionRange(e, 0, t);\n          }\n          static getSizeFromDimensionRange(e, t, n) {\n            let r = 1;\n            for (let o = t; o < n; o++) {\n              if (e[o] <= 0) throw new Error(\"cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.\");\n              r *= e[o];\n            }\n            return r;\n          }\n          static computeStrides(e) {\n            const t = e.length;\n            if (0 === t) return [];\n            if (1 === t) return [1];\n            const n = new Array(t);\n            n[t - 1] = 1, n[t - 2] = e[t - 1];\n            for (let r = t - 3; r >= 0; --r) n[r] = n[r + 1] * e[r + 1];\n            return n;\n          }\n          static transpose(e) {\n            return e.slice().reverse();\n          }\n          static indicesToOffset(e, t, n) {\n            void 0 === n && (n = e.length);\n            let r = 0;\n            for (let o = 0; o < n; ++o) r += t[o] * e[o];\n            return r;\n          }\n          static offsetToIndices(e, t) {\n            const n = t.length;\n            if (0 === n) return [];\n            if (1 === n) return [e * t[0]];\n            const r = new Array(t.length);\n            for (let n = 0; n < r.length - 1; ++n) r[n] = Math.floor(e / t[n]), e -= r[n] * t[n];\n            return r[r.length - 1] = e, r;\n          }\n          static normalizeAxis(e, t) {\n            if (e < -t && e >= t) throw new Error(\"unsupported axis for this operation.\");\n            return e < 0 ? e + t : e;\n          }\n          static normalizeAxes(e, t) {\n            return e.map(e => this.normalizeAxis(e, t));\n          }\n          static incrementIndex(e, t, n) {\n            if (0 === t.length || 0 === e.length) throw new Error(\"Index incrementing unsupported for scalar Tensor\");\n            if (void 0 === n) n = t.length;else if (n <= 0 || n > t.length) throw new Error(\"Incorrect axis to increment on\");\n            for (let r = n - 1; r >= 0 && (e[r]++, !(e[r] < t[r])); --r) e[r] = 0;\n          }\n          static calculateReshapedDims(e, t) {\n            if (0 === t.length) {\n              if (0 === e.length || 1 === d.size(e)) return [];\n              throw new Error(\"cannot reshape to a scalar Tensor\");\n            }\n            const n = t.length,\n              r = new Array(n);\n            let o = -1,\n              i = 1;\n            for (let a = 0; a < n; a++) {\n              if (t[a] < -1) throw new Error(\"a dimension in shape hints cannot be less than -1\");\n              if (-1 === t[a]) {\n                if (-1 !== o) throw new Error(\"at most one dimension in shape hints can be -1\");\n                o = a;\n              } else {\n                if (0 === t[a]) {\n                  if (a >= e.length) throw new Error(\"the dimension with value zero exceeds the dimension size of the input tensor\");\n                  r[a] = e[a];\n                } else r[a] = t[a];\n                i *= r[a];\n              }\n            }\n            const a = d.size(e);\n            if (-1 !== o) {\n              if (a % i != 0) throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${e}] Output shape: [${t}]`);\n              r[o] = a / i;\n            } else if (i !== a) throw new Error(\"reshapedDims and originalDims don't have matching sizes\");\n            return r;\n          }\n          static sortBasedOnPerm(e, t) {\n            return t ? t.map(t => e[t]) : e.slice().reverse();\n          }\n          static padShape(e, t) {\n            const n = e.length;\n            return e.map((e, r) => e + t[r] + t[r + n]);\n          }\n          static areEqual(e, t) {\n            return e.length === t.length && e.every((e, n) => e === t[n]);\n          }\n          static validateDimsAndCalcSize(e) {\n            if (e.length > 6) throw new TypeError(\"Only rank 0 to 6 is supported for tensor shape.\");\n            let t = 1;\n            for (const n of e) {\n              if (!Number.isInteger(n)) throw new TypeError(`Invalid shape: ${n} is not an integer`);\n              if (n < 0 || n > 2147483647) throw new TypeError(`Invalid shape: length ${n} is not allowed`);\n              t *= n;\n            }\n            return t;\n          }\n          static flattenShape(e, t) {\n            t < 0 && (t += e.length);\n            const n = e.reduce((e, t) => e * t, 1),\n              r = e.slice(t).reduce((e, t) => e * t, 1);\n            return [n / r, r];\n          }\n          static squeezeShape(e, t) {\n            const n = new Array();\n            t = d.normalizeAxes(t, e.length);\n            for (let r = 0; r < e.length; r++) {\n              const o = t.indexOf(r) >= 0;\n              if (o && 1 !== e[r]) throw new Error(\"squeeze an axis of size different than 1\");\n              (0 === t.length && e[r] > 1 || t.length > 0 && !o) && n.push(e[r]);\n            }\n            return n;\n          }\n          static unsqueezeShape(e, t) {\n            const n = new Array(e.length + t.length);\n            n.fill(0);\n            for (let e = 0; e < t.length; e++) {\n              const r = d.normalizeAxis(t[e], n.length);\n              if (r >= n.length) throw new Error(\"'axes' has an out of range axis\");\n              if (0 !== n[r]) throw new Error(\"'axes' has a duplicate axis\");\n              n[r] = 1;\n            }\n            let r = 0;\n            for (let t = 0; t < n.length; t++) 0 === n[t] && (n[t] = e[r++]);\n            if (r !== e.length) throw new Error(\"the unsqueezed dimension could not be established\");\n            return n;\n          }\n        }\n        t.ShapeUtil = d, t.MathUtil = class {\n          static sqr(e, t, n, r, o) {\n            if (r < 0 || r >= t.length) throw new Error(\"sourceIndex out of bounds\");\n            if (n < 0 || n >= e.length) throw new Error(\"targetIndex out of bounds\");\n            if (r + o > t.length) throw new Error(\"source indices to be copied are outside bounds\");\n            if (n + o > e.length) throw new Error(\"target array is too small to hold result\");\n            for (let i = 0; i < o; i++) e[n + i] += Math.pow(t[r + i], 2);\n          }\n          static axpy(e, t, n, r, o, i) {\n            if (r < 0 || r >= t.length) throw new Error(\"sourceIndex out of bounds\");\n            if (n < 0 || n >= e.length) throw new Error(\"targetIndex out of bounds\");\n            if (r + o > t.length) throw new Error(\"source indices to be copied are outside bounds\");\n            if (n + o > e.length) throw new Error(\"target array is too small to hold result\");\n            for (let a = 0; a < o; a++) e[n + a] += i * t[r + a];\n          }\n          static powx(e, t, n, r, o, i) {\n            if (r < 0 || r >= t.length) throw new Error(\"sourceIndex out of bounds\");\n            if (n < 0 || n >= e.length) throw new Error(\"targetIndex out of bounds\");\n            if (r + o > t.length) throw new Error(\"source indices to be copied are outside bounds\");\n            if (n + o > e.length) throw new Error(\"target array is too small to hold result\");\n            for (let a = 0; a < o; a++) e[n + a] = Math.pow(t[r + a], i);\n          }\n          static mul(e, t, n, r, o) {\n            if (r < 0 || r >= t.length) throw new Error(\"sourceIndex out of bounds\");\n            if (n < 0 || n >= e.length) throw new Error(\"targetIndex out of bounds\");\n            if (r + o > t.length) throw new Error(\"source indices to be copied are outside bounds\");\n            if (n + o > e.length) throw new Error(\"target array is too small to hold result\");\n            for (let i = 0; i < o; i++) e[n + i] = t[r + i] * e[n + i];\n          }\n        };\n        class f {\n          static splitShape(e, t, n, r) {\n            if (0 === n.length) {\n              if (!r) throw new Error(\"need to know number of outputs when the 'split' attribute is not specified\");\n              f.determineSplit(e[t], r, n);\n            }\n            const o = [],\n              i = [0];\n            for (let r = 0; r < n.length; ++r) {\n              0 !== r && i.push(i[r - 1] + n[r - 1]);\n              const a = e.slice();\n              a[t] = n[r], o.push(a);\n            }\n            return [o, i];\n          }\n          static determineSplit(e, t, n) {\n            if (e % t != 0) throw new Error(\"cannot split tensor to equal sized parts\");\n            for (let r = 0; r < t; ++r) n.push(e / t);\n          }\n        }\n        t.SplitUtil = f;\n        class h {\n          static calcReduce(e, t, n, r, o) {\n            const i = e.dims.slice(0);\n            0 === t.length && i.forEach((e, n) => t.push(n));\n            const a = h.calcReduceShape(i, t, !0),\n              u = d.size(a),\n              c = new s.Tensor(a, e.type),\n              p = d.computeStrides(a),\n              f = d.computeStrides(i),\n              g = new Array(i.length);\n            for (let n = 0; n < u; n++) {\n              const a = d.offsetToIndices(n, p);\n              l.fillIndex(a, i, g), c.set(a, h.calcReduceByAxis(e.numberData, t, i, 0, d.indicesToOffset(g, f), r, o));\n            }\n            return n ? c : new s.Tensor(h.calcReduceShape(i, t, n), c.type, void 0, void 0, c.data, c.dataId);\n          }\n          static calcReduceByAxis(e, t, n, r, o, i, a) {\n            let s = 0;\n            if (r >= t.length) return i(e[o]);\n            const u = t[r],\n              l = u >= n.length ? 1 : d.size(n.slice(u + 1));\n            for (let c = 0; c < n[u]; c++) s = 0 === c ? h.calcReduceByAxis(e, t, n, r + 1, o, i, a) : a(s, h.calcReduceByAxis(e, t, n, r + 1, o, i, a)), o += l;\n            return s;\n          }\n          static calcReduceShape(e, t, n) {\n            const r = e.slice();\n            for (let e = 0; e < t.length; e++) r[t[e]] = n ? 1 : 0;\n            return r.filter(e => 0 !== e);\n          }\n        }\n        t.ReduceUtil = h;\n        class g {\n          static adjustPoolAttributes(e, t, n, r, o, i) {\n            if (!e && n.length !== t.length - 2) throw new Error(\"length of specified kernel shapes should be 2 less than length of input dimensions\");\n            if (e) for (let e = 0; e < t.length - 2; e++) e >= n.length ? n.push(t[e + 2]) : n[e] = t[e + 2];\n            for (let e = 0; e < n.length; e++) if (e < r.length) {\n              if (r[e] < 0) throw new Error(\"strides should be greater than or equal to 1\");\n            } else r.push(1);\n            for (let e = 0; e < n.length; e++) if (e < o.length) {\n              if (o[e] < 0) throw new Error(\"dilations should be greater than or equal to 1\");\n            } else o.push(1);\n            for (let e = 0; e < 2 * n.length; e++) if (e < i.length) {\n              if (i[e] < 0) throw new Error(\"pad should be greater than or equal to 1\");\n            } else i.push(0);\n            for (let e = 0; e < n.length; e++) {\n              if (n[e] <= 0) throw new Error(\"kernel shapes need to be greater than 0\");\n              if (i[e] >= n[e] || i[e + n.length] >= n[e]) throw new Error(\"pads should be smaller than kernel\");\n            }\n          }\n          static adjustPadsBasedOnAutoPad(e, t, n, r, o, i) {\n            if (i) {\n              if (o.length !== 2 * (e.length - 2)) throw new Error(\"length of pads should be twice the length of data dimensions\");\n              if (t.length !== e.length - 2) throw new Error(\"length of strides should be the length of data dimensions\");\n              if (r.length !== e.length - 2) throw new Error(\"length of kernel shapes should be the length of data dimensions\");\n              for (let a = 0; a < e.length - 2; a++) g.adjustPadAndReturnShape(e[a + 2], t[a], n[a], r[a], o, a, a + e.length - 2, i);\n            }\n          }\n          static computePoolOutputShape(e, t, n, r, o, i, a) {\n            if (t.length <= 0) throw new Error(\"input shape must be of size greater than 0\");\n            const s = [t[0], t[1]];\n            return g.computeShapeHelper(e, t, s, n, r, o, i, a), s;\n          }\n          static computeConvOutputShape(e, t, n, r, o, i, a) {\n            if (e.length <= 0 || t.length <= 0) throw new Error(\"invalid input tensor dims or invalid filter tensor dims\");\n            const s = [e[0], t[0]];\n            return g.computeShapeHelper(!1, e, s, n, r, o, i, a), s;\n          }\n          static computeShapeHelper(e, t, n, r, o, i, a, s) {\n            if (e) for (let e = 0; e < t.length - 2; e++) n.push(1);else for (let e = 0; e < t.length - 2; e++) n.push(g.adjustPadAndReturnShape(t[e + 2], r[e], o[e], i[e], a, e, e + t.length - 2, s));\n          }\n          static adjustPadAndReturnShape(e, t, n, r, o, i, a, s) {\n            const u = n * (r - 1) + 1;\n            if (!s || \"NOTSET\" === s) return Math.floor((e + o[i] + o[a] - u) / t + 1);\n            switch (s) {\n              case \"VALID\":\n                return o[i] = 0, o[a] = 0, Math.floor((e - u) / t + 1);\n              case \"SAME_LOWER\":\n              case \"SAME_UPPER\":\n                if (1 !== n) throw new Error(\"Dilation not supported for SAME_UPPER or SAME_LOWER\");\n                {\n                  const n = ((e + t - 1) / t - 1) * t + r - e;\n                  return o[i] = \"SAME_LOWER\" === s ? Math.floor((n + 1) / 2) : Math.floor(n / 2), o[a] = n - o[i], Math.floor((e + n - r) / t + 1);\n                }\n              default:\n                throw new Error(\"Unsupported AutoPad type\");\n            }\n          }\n        }\n        t.PoolConvUtil = g, t.MIN_CLIP = -34028234663852886e22, t.MAX_CLIP = 34028234663852886e22, t.decodeUtf8String = function (e) {\n          return new TextDecoder().decode(e);\n        };\n      },\n      8408: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.version = void 0, t.version = \"1.16.3\";\n      },\n      9544: function (e, t, n) {\n        \"use strict\";\n\n        var r,\n          o = this && this.__createBinding || (Object.create ? function (e, t, n, r) {\n            void 0 === r && (r = n);\n            var o = Object.getOwnPropertyDescriptor(t, n);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[n];\n              }\n            }), Object.defineProperty(e, r, o);\n          } : function (e, t, n, r) {\n            void 0 === r && (r = n), e[r] = t[n];\n          }),\n          i = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          a = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var n in e) \"default\" !== n && Object.prototype.hasOwnProperty.call(e, n) && o(t, e, n);\n            return i(t, e), t;\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.endProfiling = t.run = t.releaseSession = t.createSession = t.createSessionFinalize = t.createSessionAllocate = t.initializeRuntime = t.initializeWebAssemblyInstance = void 0;\n        const s = n(2235),\n          u = a(n(1259)),\n          l = n(263),\n          c = () => !!s.env.wasm.proxy && \"undefined\" != typeof document;\n        let p,\n          d,\n          f,\n          h = !1,\n          g = !1,\n          b = !1;\n        const m = [],\n          y = [],\n          v = [],\n          _ = [],\n          w = [],\n          T = [],\n          x = () => {\n            if (h || !g || b || !p) throw new Error(\"worker not ready\");\n          },\n          O = e => {\n            switch (e.data.type) {\n              case \"init-wasm\":\n                h = !1, e.data.err ? (b = !0, d[1](e.data.err)) : (g = !0, d[0]());\n                break;\n              case \"init-ort\":\n                e.data.err ? f[1](e.data.err) : f[0]();\n                break;\n              case \"create_allocate\":\n                e.data.err ? m.shift()[1](e.data.err) : m.shift()[0](e.data.out);\n                break;\n              case \"create_finalize\":\n                e.data.err ? y.shift()[1](e.data.err) : y.shift()[0](e.data.out);\n                break;\n              case \"create\":\n                e.data.err ? v.shift()[1](e.data.err) : v.shift()[0](e.data.out);\n                break;\n              case \"release\":\n                e.data.err ? _.shift()[1](e.data.err) : _.shift()[0]();\n                break;\n              case \"run\":\n                e.data.err ? w.shift()[1](e.data.err) : w.shift()[0](e.data.out);\n                break;\n              case \"end-profiling\":\n                e.data.err ? T.shift()[1](e.data.err) : T.shift()[0]();\n            }\n          },\n          S = \"undefined\" != typeof document ? null === (r = null === document || void 0 === document ? void 0 : document.currentScript) || void 0 === r ? void 0 : r.src : void 0;\n        t.initializeWebAssemblyInstance = async () => {\n          if (c()) {\n            if (g) return;\n            if (h) throw new Error(\"multiple calls to 'initWasm()' detected.\");\n            if (b) throw new Error(\"previous call to 'initWasm()' failed.\");\n            return h = !0, void 0 === s.env.wasm.wasmPaths && S && 0 !== S.indexOf(\"blob:\") && (s.env.wasm.wasmPaths = S.substr(0, +S.lastIndexOf(\"/\") + 1)), new Promise((e, t) => {\n              null == p || p.terminate(), p = n(8050).Z(), p.onmessage = O, d = [e, t];\n              const r = {\n                type: \"init-wasm\",\n                in: s.env.wasm\n              };\n              p.postMessage(r);\n            });\n          }\n          return (0, l.initializeWebAssembly)(s.env.wasm);\n        }, t.initializeRuntime = async e => {\n          if (c()) return x(), new Promise((t, n) => {\n            f = [t, n];\n            const r = {\n              type: \"init-ort\",\n              in: e\n            };\n            p.postMessage(r);\n          });\n          await u.initRuntime(e);\n        }, t.createSessionAllocate = async e => c() ? (x(), new Promise((t, n) => {\n          m.push([t, n]);\n          const r = {\n            type: \"create_allocate\",\n            in: {\n              model: e\n            }\n          };\n          p.postMessage(r, [e.buffer]);\n        })) : u.createSessionAllocate(e), t.createSessionFinalize = async (e, t) => c() ? (x(), new Promise((n, r) => {\n          y.push([n, r]);\n          const o = {\n            type: \"create_finalize\",\n            in: {\n              modeldata: e,\n              options: t\n            }\n          };\n          p.postMessage(o);\n        })) : u.createSessionFinalize(e, t), t.createSession = async (e, t) => c() ? (x(), new Promise((n, r) => {\n          v.push([n, r]);\n          const o = {\n            type: \"create\",\n            in: {\n              model: e,\n              options: t\n            }\n          };\n          p.postMessage(o, [e.buffer]);\n        })) : u.createSession(e, t), t.releaseSession = async e => {\n          if (c()) return x(), new Promise((t, n) => {\n            _.push([t, n]);\n            const r = {\n              type: \"release\",\n              in: e\n            };\n            p.postMessage(r);\n          });\n          u.releaseSession(e);\n        }, t.run = async (e, t, n, r, o) => c() ? (x(), new Promise((i, a) => {\n          w.push([i, a]);\n          const s = {\n            type: \"run\",\n            in: {\n              sessionId: e,\n              inputIndices: t,\n              inputs: n,\n              outputIndices: r,\n              options: o\n            }\n          };\n          p.postMessage(s, u.extractTransferableBuffers(n));\n        })) : u.run(e, t, n, r, o), t.endProfiling = async e => {\n          if (c()) return x(), new Promise((t, n) => {\n            T.push([t, n]);\n            const r = {\n              type: \"end-profiling\",\n              in: e\n            };\n            p.postMessage(r);\n          });\n          u.endProfiling(e);\n        };\n      },\n      7918: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.setRunOptions = void 0;\n        const r = n(263),\n          o = n(1497);\n        t.setRunOptions = e => {\n          const t = (0, r.getInstance)();\n          let n = 0;\n          const i = [],\n            a = e || {};\n          try {\n            if (void 0 === (null == e ? void 0 : e.logSeverityLevel)) a.logSeverityLevel = 2;else if (\"number\" != typeof e.logSeverityLevel || !Number.isInteger(e.logSeverityLevel) || e.logSeverityLevel < 0 || e.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);\n            if (void 0 === (null == e ? void 0 : e.logVerbosityLevel)) a.logVerbosityLevel = 0;else if (\"number\" != typeof e.logVerbosityLevel || !Number.isInteger(e.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);\n            void 0 === (null == e ? void 0 : e.terminate) && (a.terminate = !1);\n            let r = 0;\n            return void 0 !== (null == e ? void 0 : e.tag) && (r = (0, o.allocWasmString)(e.tag, i)), n = t._OrtCreateRunOptions(a.logSeverityLevel, a.logVerbosityLevel, !!a.terminate, r), 0 === n && (0, o.checkLastError)(\"Can't create run options.\"), void 0 !== (null == e ? void 0 : e.extra) && (0, o.iterateExtraOptions)(e.extra, \"\", new WeakSet(), (e, r) => {\n              const a = (0, o.allocWasmString)(e, i),\n                s = (0, o.allocWasmString)(r, i);\n              0 !== t._OrtAddRunConfigEntry(n, a, s) && (0, o.checkLastError)(`Can't set a run config entry: ${e} - ${r}.`);\n            }), [n, i];\n          } catch (e) {\n            throw 0 !== n && t._OrtReleaseRunOptions(n), i.forEach(e => t._free(e)), e;\n          }\n        };\n      },\n      6640: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.OnnxruntimeWebAssemblySessionHandler = void 0;\n        const r = n(2806),\n          o = n(2235),\n          i = n(2850),\n          a = n(9544);\n        let s;\n        t.OnnxruntimeWebAssemblySessionHandler = class {\n          async createSessionAllocate(e) {\n            const t = await fetch(e);\n            if (200 !== t.status) throw new Error(`failed to load model: ${e}`);\n            const n = await t.arrayBuffer();\n            return (0, a.createSessionAllocate)(new Uint8Array(n));\n          }\n          async loadModel(e, t) {\n            if (s || (await (0, a.initializeRuntime)(o.env), s = !0), \"string\" == typeof e) {\n              if (\"undefined\" != typeof process && process.versions && process.versions.node) {\n                const n = await (0, i.promisify)(r.readFile)(e);\n                [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSession)(n, t);\n              } else {\n                const n = await this.createSessionAllocate(e);\n                [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSessionFinalize)(n, t);\n              }\n            } else [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSession)(e, t);\n          }\n          async dispose() {\n            return (0, a.releaseSession)(this.sessionId);\n          }\n          async run(e, t, n) {\n            const r = [],\n              i = [];\n            Object.entries(e).forEach(e => {\n              const t = e[0],\n                n = e[1],\n                o = this.inputNames.indexOf(t);\n              if (-1 === o) throw new Error(`invalid input '${t}'`);\n              r.push(n), i.push(o);\n            });\n            const s = [];\n            Object.entries(t).forEach(e => {\n              const t = e[0],\n                n = this.outputNames.indexOf(t);\n              if (-1 === n) throw new Error(`invalid output '${t}'`);\n              s.push(n);\n            });\n            const u = await (0, a.run)(this.sessionId, i, r.map(e => [e.type, e.dims, e.data]), s, n),\n              l = {};\n            for (let e = 0; e < u.length; e++) l[this.outputNames[s[e]]] = new o.Tensor(u[e][0], u[e][2], u[e][1]);\n            return l;\n          }\n          startProfiling() {}\n          endProfiling() {\n            (0, a.endProfiling)(this.sessionId);\n          }\n        };\n      },\n      7622: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.setSessionOptions = void 0;\n        const r = n(263),\n          o = n(1497);\n        t.setSessionOptions = e => {\n          var t, n, i, a;\n          const s = (0, r.getInstance)();\n          let u = 0;\n          const l = [],\n            c = e || {};\n          (e => {\n            e.extra || (e.extra = {}), e.extra.session || (e.extra.session = {});\n            const t = e.extra.session;\n            t.use_ort_model_bytes_directly || (t.use_ort_model_bytes_directly = \"1\"), e.executionProviders && e.executionProviders.some(e => \"webgpu\" === (\"string\" == typeof e ? e : e.name)) && (e.enableMemPattern = !1);\n          })(c);\n          try {\n            const e = (e => {\n                switch (e) {\n                  case \"disabled\":\n                    return 0;\n                  case \"basic\":\n                    return 1;\n                  case \"extended\":\n                    return 2;\n                  case \"all\":\n                    return 99;\n                  default:\n                    throw new Error(`unsupported graph optimization level: ${e}`);\n                }\n              })(null !== (t = c.graphOptimizationLevel) && void 0 !== t ? t : \"all\"),\n              p = (e => {\n                switch (e) {\n                  case \"sequential\":\n                    return 0;\n                  case \"parallel\":\n                    return 1;\n                  default:\n                    throw new Error(`unsupported execution mode: ${e}`);\n                }\n              })(null !== (n = c.executionMode) && void 0 !== n ? n : \"sequential\"),\n              d = \"string\" == typeof c.logId ? (0, o.allocWasmString)(c.logId, l) : 0,\n              f = null !== (i = c.logSeverityLevel) && void 0 !== i ? i : 2;\n            if (!Number.isInteger(f) || f < 0 || f > 4) throw new Error(`log serverity level is not valid: ${f}`);\n            const h = null !== (a = c.logVerbosityLevel) && void 0 !== a ? a : 0;\n            if (!Number.isInteger(h) || h < 0 || h > 4) throw new Error(`log verbosity level is not valid: ${h}`);\n            const g = \"string\" == typeof c.optimizedModelFilePath ? (0, o.allocWasmString)(c.optimizedModelFilePath, l) : 0;\n            return u = s._OrtCreateSessionOptions(e, !!c.enableCpuMemArena, !!c.enableMemPattern, p, !!c.enableProfiling, 0, d, f, h, g), 0 === u && (0, o.checkLastError)(\"Can't create session options.\"), c.executionProviders && ((e, t, n) => {\n              for (const i of t) {\n                let t = \"string\" == typeof i ? i : i.name;\n                switch (t) {\n                  case \"xnnpack\":\n                    t = \"XNNPACK\";\n                    break;\n                  case \"webnn\":\n                    if (t = \"WEBNN\", \"string\" != typeof i) {\n                      const t = i;\n                      if (null == t ? void 0 : t.deviceType) {\n                        const i = (0, o.allocWasmString)(\"deviceType\", n),\n                          a = (0, o.allocWasmString)(t.deviceType, n);\n                        0 !== (0, r.getInstance)()._OrtAddSessionConfigEntry(e, i, a) && (0, o.checkLastError)(`Can't set a session config entry: 'deviceType' - ${t.deviceType}.`);\n                      }\n                      if (null == t ? void 0 : t.powerPreference) {\n                        const i = (0, o.allocWasmString)(\"powerPreference\", n),\n                          a = (0, o.allocWasmString)(t.powerPreference, n);\n                        0 !== (0, r.getInstance)()._OrtAddSessionConfigEntry(e, i, a) && (0, o.checkLastError)(`Can't set a session config entry: 'powerPreference' - ${t.powerPreference}.`);\n                      }\n                    }\n                    break;\n                  case \"webgpu\":\n                    t = \"JS\";\n                    break;\n                  case \"wasm\":\n                  case \"cpu\":\n                    continue;\n                  default:\n                    throw new Error(`not supported execution provider: ${t}`);\n                }\n                const a = (0, o.allocWasmString)(t, n);\n                0 !== (0, r.getInstance)()._OrtAppendExecutionProvider(e, a) && (0, o.checkLastError)(`Can't append execution provider: ${t}.`);\n              }\n            })(u, c.executionProviders, l), void 0 !== c.extra && (0, o.iterateExtraOptions)(c.extra, \"\", new WeakSet(), (e, t) => {\n              const n = (0, o.allocWasmString)(e, l),\n                r = (0, o.allocWasmString)(t, l);\n              0 !== s._OrtAddSessionConfigEntry(u, n, r) && (0, o.checkLastError)(`Can't set a session config entry: ${e} - ${t}.`);\n            }), [u, l];\n          } catch (e) {\n            throw 0 !== u && s._OrtReleaseSessionOptions(u), l.forEach(e => s._free(e)), e;\n          }\n        };\n      },\n      7917: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.logLevelStringToEnum = t.tensorTypeToTypedArrayConstructor = t.getTensorElementSize = t.tensorDataTypeEnumToString = t.tensorDataTypeStringToEnum = void 0, t.tensorDataTypeStringToEnum = e => {\n          switch (e) {\n            case \"int8\":\n              return 3;\n            case \"uint8\":\n              return 2;\n            case \"bool\":\n              return 9;\n            case \"int16\":\n              return 5;\n            case \"uint16\":\n              return 4;\n            case \"int32\":\n              return 6;\n            case \"uint32\":\n              return 12;\n            case \"float16\":\n              return 10;\n            case \"float32\":\n              return 1;\n            case \"float64\":\n              return 11;\n            case \"string\":\n              return 8;\n            case \"int64\":\n              return 7;\n            case \"uint64\":\n              return 13;\n            default:\n              throw new Error(`unsupported data type: ${e}`);\n          }\n        }, t.tensorDataTypeEnumToString = e => {\n          switch (e) {\n            case 3:\n              return \"int8\";\n            case 2:\n              return \"uint8\";\n            case 9:\n              return \"bool\";\n            case 5:\n              return \"int16\";\n            case 4:\n              return \"uint16\";\n            case 6:\n              return \"int32\";\n            case 12:\n              return \"uint32\";\n            case 10:\n              return \"float16\";\n            case 1:\n              return \"float32\";\n            case 11:\n              return \"float64\";\n            case 8:\n              return \"string\";\n            case 7:\n              return \"int64\";\n            case 13:\n              return \"uint64\";\n            default:\n              throw new Error(`unsupported data type: ${e}`);\n          }\n        }, t.getTensorElementSize = e => [void 0, 4, 1, 1, 2, 2, 4, 8, void 0, 1, 2, 8, 4, 8, void 0, void 0, void 0][e], t.tensorTypeToTypedArrayConstructor = e => {\n          switch (e) {\n            case \"float16\":\n            case \"uint16\":\n              return Uint16Array;\n            case \"float32\":\n              return Float32Array;\n            case \"uint8\":\n            case \"bool\":\n              return Uint8Array;\n            case \"int8\":\n              return Int8Array;\n            case \"int16\":\n              return Int16Array;\n            case \"int32\":\n              return Int32Array;\n            case \"float64\":\n              return Float64Array;\n            case \"uint32\":\n              return Uint32Array;\n            case \"int64\":\n              return BigInt64Array;\n            case \"uint64\":\n              return BigUint64Array;\n            default:\n              throw new Error(`unsupported type: ${e}`);\n          }\n        }, t.logLevelStringToEnum = e => {\n          switch (e) {\n            case \"verbose\":\n              return 0;\n            case \"info\":\n              return 1;\n            case \"warning\":\n              return 2;\n            case \"error\":\n              return 3;\n            case \"fatal\":\n              return 4;\n            default:\n              throw new Error(`unsupported logging level: ${e}`);\n          }\n        };\n      },\n      1259: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.extractTransferableBuffers = t.endProfiling = t.run = t.releaseSession = t.createSession = t.createSessionFinalize = t.createSessionAllocate = t.initRuntime = void 0;\n        const r = n(7918),\n          o = n(7622),\n          i = n(7917),\n          a = n(263),\n          s = n(1497);\n        t.initRuntime = async e => {\n          var t, n;\n          t = e.wasm.numThreads, n = (0, i.logLevelStringToEnum)(e.logLevel), 0 !== (0, a.getInstance)()._OrtInit(t, n) && (0, s.checkLastError)(\"Can't initialize onnxruntime.\");\n        };\n        const u = new Map();\n        t.createSessionAllocate = e => {\n          const t = (0, a.getInstance)(),\n            n = t._malloc(e.byteLength);\n          if (0 === n) throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);\n          return t.HEAPU8.set(e, n), [n, e.byteLength];\n        }, t.createSessionFinalize = (e, t) => {\n          const n = (0, a.getInstance)();\n          let r = 0,\n            i = 0,\n            l = [];\n          const c = [],\n            p = [];\n          try {\n            [i, l] = (0, o.setSessionOptions)(t), r = n._OrtCreateSession(e[0], e[1], i), 0 === r && (0, s.checkLastError)(\"Can't create a session.\");\n            const [d, f] = (e => {\n                const t = (0, a.getInstance)(),\n                  n = t.stackSave();\n                try {\n                  const n = t.stackAlloc(8);\n                  return 0 !== t._OrtGetInputOutputCount(e, n, n + 4) && (0, s.checkLastError)(\"Can't get session input/output count.\"), [t.HEAP32[n / 4], t.HEAP32[n / 4 + 1]];\n                } finally {\n                  t.stackRestore(n);\n                }\n              })(r),\n              h = [],\n              g = [];\n            for (let e = 0; e < d; e++) {\n              const t = n._OrtGetInputName(r, e);\n              0 === t && (0, s.checkLastError)(\"Can't get an input name.\"), c.push(t), h.push(n.UTF8ToString(t));\n            }\n            for (let e = 0; e < f; e++) {\n              const t = n._OrtGetOutputName(r, e);\n              0 === t && (0, s.checkLastError)(\"Can't get an output name.\"), p.push(t), g.push(n.UTF8ToString(t));\n            }\n            return u.set(r, [r, c, p]), [r, h, g];\n          } catch (e) {\n            throw c.forEach(e => n._OrtFree(e)), p.forEach(e => n._OrtFree(e)), 0 !== r && n._OrtReleaseSession(r), e;\n          } finally {\n            n._free(e[0]), 0 !== i && n._OrtReleaseSessionOptions(i), l.forEach(e => n._free(e));\n          }\n        }, t.createSession = (e, n) => {\n          const r = (0, t.createSessionAllocate)(e);\n          return (0, t.createSessionFinalize)(r, n);\n        }, t.releaseSession = e => {\n          const t = (0, a.getInstance)(),\n            n = u.get(e);\n          if (!n) throw new Error(`cannot release session. invalid session id: ${e}`);\n          const [r, o, i] = n;\n          o.forEach(e => t._OrtFree(e)), i.forEach(e => t._OrtFree(e)), t._OrtReleaseSession(r), u.delete(e);\n        }, t.run = async (e, t, n, o, l) => {\n          const c = (0, a.getInstance)(),\n            p = u.get(e);\n          if (!p) throw new Error(`cannot run inference. invalid session id: ${e}`);\n          const [d, f, h] = p,\n            g = t.length,\n            b = o.length;\n          let m = 0,\n            y = [];\n          const v = [],\n            _ = [];\n          try {\n            [m, y] = (0, r.setRunOptions)(l);\n            for (let e = 0; e < g; e++) {\n              const t = n[e][0],\n                r = n[e][1],\n                o = n[e][2];\n              let a, u;\n              if (Array.isArray(o)) {\n                u = 4 * o.length, a = c._malloc(u), _.push(a);\n                let e = a / 4;\n                for (let t = 0; t < o.length; t++) {\n                  if (\"string\" != typeof o[t]) throw new TypeError(`tensor data at index ${t} is not a string`);\n                  c.HEAPU32[e++] = (0, s.allocWasmString)(o[t], _);\n                }\n              } else u = o.byteLength, a = c._malloc(u), _.push(a), c.HEAPU8.set(new Uint8Array(o.buffer, o.byteOffset, u), a);\n              const l = c.stackSave(),\n                p = c.stackAlloc(4 * r.length);\n              try {\n                let n = p / 4;\n                r.forEach(e => c.HEAP32[n++] = e);\n                const o = c._OrtCreateTensor((0, i.tensorDataTypeStringToEnum)(t), a, u, p, r.length);\n                0 === o && (0, s.checkLastError)(`Can't create tensor for input[${e}].`), v.push(o);\n              } finally {\n                c.stackRestore(l);\n              }\n            }\n            const e = c.stackSave(),\n              a = c.stackAlloc(4 * g),\n              u = c.stackAlloc(4 * g),\n              p = c.stackAlloc(4 * b),\n              w = c.stackAlloc(4 * b);\n            try {\n              let e = a / 4,\n                n = u / 4,\n                r = p / 4,\n                l = w / 4;\n              for (let r = 0; r < g; r++) c.HEAPU32[e++] = v[r], c.HEAPU32[n++] = f[t[r]];\n              for (let e = 0; e < b; e++) c.HEAPU32[r++] = 0, c.HEAPU32[l++] = h[o[e]];\n              let y = c._OrtRun(d, u, a, g, w, b, p, m);\n              const _ = c.jsepRunPromise;\n              _ && void 0 !== _.then && (y = await _);\n              const T = [];\n              0 !== y && (0, s.checkLastError)(\"failed to call OrtRun().\");\n              for (let e = 0; e < b; e++) {\n                const t = c.HEAPU32[p / 4 + e],\n                  n = c.stackSave(),\n                  r = c.stackAlloc(16);\n                let o,\n                  a = 0;\n                try {\n                  y = c._OrtGetTensorData(t, r, r + 4, r + 8, r + 12), 0 !== y && (0, s.checkLastError)(`Can't access output tensor data on index ${e}.`);\n                  let n = r / 4;\n                  const u = c.HEAPU32[n++];\n                  a = c.HEAPU32[n++];\n                  const l = c.HEAPU32[n++],\n                    p = c.HEAPU32[n++],\n                    d = [];\n                  for (let e = 0; e < p; e++) d.push(c.HEAPU32[l / 4 + e]);\n                  c._OrtFree(l);\n                  const f = 0 === d.length ? 1 : d.reduce((e, t) => e * t);\n                  if (o = (0, i.tensorDataTypeEnumToString)(u), \"string\" === o) {\n                    const e = [];\n                    let t = a / 4;\n                    for (let n = 0; n < f; n++) {\n                      const r = c.HEAPU32[t++],\n                        o = n === f - 1 ? void 0 : c.HEAPU32[t] - r;\n                      e.push(c.UTF8ToString(r, o));\n                    }\n                    T.push([o, d, e]);\n                  } else {\n                    const e = new ((0, i.tensorTypeToTypedArrayConstructor)(o))(f);\n                    new Uint8Array(e.buffer, e.byteOffset, e.byteLength).set(c.HEAPU8.subarray(a, a + e.byteLength)), T.push([o, d, e]);\n                  }\n                } finally {\n                  c.stackRestore(n), \"string\" === o && a && c._free(a), c._OrtReleaseTensor(t);\n                }\n              }\n              return T;\n            } finally {\n              c.stackRestore(e);\n            }\n          } finally {\n            v.forEach(e => c._OrtReleaseTensor(e)), _.forEach(e => c._free(e)), 0 !== m && c._OrtReleaseRunOptions(m), y.forEach(e => c._free(e));\n          }\n        }, t.endProfiling = e => {\n          const t = (0, a.getInstance)(),\n            n = u.get(e);\n          if (!n) throw new Error(\"invalid session id\");\n          const r = n[0],\n            o = t._OrtEndProfiling(r);\n          0 === o && (0, s.checkLastError)(\"Can't get an profile file name.\"), t._OrtFree(o);\n        }, t.extractTransferableBuffers = e => {\n          const t = [];\n          for (const n of e) {\n            const e = n[2];\n            !Array.isArray(e) && e.buffer && t.push(e.buffer);\n          }\n          return t;\n        };\n      },\n      263: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__createBinding || (Object.create ? function (e, t, n, r) {\n            void 0 === r && (r = n);\n            var o = Object.getOwnPropertyDescriptor(t, n);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[n];\n              }\n            }), Object.defineProperty(e, r, o);\n          } : function (e, t, n, r) {\n            void 0 === r && (r = n), e[r] = t[n];\n          }),\n          o = this && this.__setModuleDefault || (Object.create ? function (e, t) {\n            Object.defineProperty(e, \"default\", {\n              enumerable: !0,\n              value: t\n            });\n          } : function (e, t) {\n            e.default = t;\n          }),\n          i = this && this.__importStar || function (e) {\n            if (e && e.__esModule) return e;\n            var t = {};\n            if (null != e) for (var n in e) \"default\" !== n && Object.prototype.hasOwnProperty.call(e, n) && r(t, e, n);\n            return o(t, e), t;\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.dispose = t.getInstance = t.initializeWebAssembly = void 0;\n        const a = i(n(6449)),\n          s = n(932),\n          u = n(3474);\n        let l,\n          c = !1,\n          p = !1,\n          d = !1;\n        t.initializeWebAssembly = async e => {\n          if (c) return Promise.resolve();\n          if (p) throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");\n          if (d) throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");\n          p = !0;\n          const t = e.initTimeout,\n            r = e.numThreads,\n            o = e.simd,\n            i = r > 1 && (() => {\n              try {\n                return \"undefined\" != typeof SharedArrayBuffer && (\"undefined\" != typeof MessageChannel && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11])));\n              } catch (e) {\n                return !1;\n              }\n            })(),\n            f = o && (() => {\n              try {\n                return WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 30, 1, 28, 0, 65, 0, 253, 15, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 186, 1, 26, 11]));\n              } catch (e) {\n                return !1;\n              }\n            })(),\n            h = e.wasmPaths,\n            g = \"string\" == typeof h ? h : void 0,\n            b = ((e, t) => t ? e ? \"ort-wasm-simd-threaded.wasm\" : \"ort-wasm-threaded.wasm\" : e ? \"ort-wasm-simd.wasm\" : \"ort-wasm.wasm\")(f, i),\n            m = \"object\" == typeof h ? h[b] : void 0;\n          let y = !1;\n          const v = [];\n          if (t > 0 && v.push(new Promise(e => {\n            setTimeout(() => {\n              y = !0, e();\n            }, t);\n          })), v.push(new Promise((e, t) => {\n            const r = i ? u : s,\n              o = {\n                locateFile: (e, t) => i && e.endsWith(\".worker.js\") && \"undefined\" != typeof Blob ? URL.createObjectURL(new Blob([n(4154)], {\n                  type: \"text/javascript\"\n                })) : e.endsWith(\".wasm\") ? m || (null != g ? g : t) + b : t + e\n              };\n            if (i) if (\"undefined\" == typeof Blob) o.mainScriptUrlOrBlob = a.join(__dirname, \"ort-wasm-threaded.js\");else {\n              const e = `var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;\n              o.mainScriptUrlOrBlob = new Blob([e], {\n                type: \"text/javascript\"\n              });\n            }\n            r(o).then(t => {\n              p = !1, c = !0, l = t, e();\n            }, e => {\n              p = !1, d = !0, t(e);\n            });\n          })), await Promise.race(v), y) throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`);\n        }, t.getInstance = () => {\n          if (c && l) return l;\n          throw new Error(\"WebAssembly is not initialized yet.\");\n        }, t.dispose = () => {\n          var e;\n          !c || p || d || (p = !0, null === (e = l.PThread) || void 0 === e || e.terminateAllThreads(), l = void 0, p = !1, c = !1, d = !0);\n        };\n      },\n      1497: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.checkLastError = t.iterateExtraOptions = t.allocWasmString = void 0;\n        const r = n(263);\n        t.allocWasmString = (e, t) => {\n          const n = (0, r.getInstance)(),\n            o = n.lengthBytesUTF8(e) + 1,\n            i = n._malloc(o);\n          return n.stringToUTF8(e, i, o), t.push(i), i;\n        }, t.iterateExtraOptions = (e, n, r, o) => {\n          if (\"object\" == typeof e && null !== e) {\n            if (r.has(e)) throw new Error(\"Circular reference in options\");\n            r.add(e);\n          }\n          Object.entries(e).forEach(([e, i]) => {\n            const a = n ? n + e : e;\n            if (\"object\" == typeof i) (0, t.iterateExtraOptions)(i, a + \".\", r, o);else if (\"string\" == typeof i || \"number\" == typeof i) o(a, i.toString());else {\n              if (\"boolean\" != typeof i) throw new Error(\"Can't handle extra config type: \" + typeof i);\n              o(a, i ? \"1\" : \"0\");\n            }\n          });\n        }, t.checkLastError = e => {\n          const t = (0, r.getInstance)(),\n            n = t.stackSave();\n          try {\n            const n = t.stackAlloc(8);\n            t._OrtGetLastError(n, n + 4);\n            const r = t.HEAP32[n / 4],\n              o = t.HEAPU32[n / 4 + 1],\n              i = o ? t.UTF8ToString(o) : \"\";\n            throw new Error(`${e} ERROR_CODE: ${r}, ERROR_MESSAGE: ${i}`);\n          } finally {\n            t.stackRestore(n);\n          }\n        };\n      },\n      8050: (e, t, n) => {\n        \"use strict\";\n\n        n.d(t, {\n          Z: () => i\n        });\n        var r = n(6614),\n          o = n.n(r);\n        function i() {\n          return o()('/*!\\n* ONNX Runtime Web v1.16.3\\n* Copyright (c) Microsoft Corporation. All rights reserved.\\n* Licensed under the MIT License.\\n*/\\n(()=>{var e={918:(e,t,r)=>{\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.setRunOptions=void 0;const n=r(263),a=r(497);t.setRunOptions=e=>{const t=(0,n.getInstance)();let r=0;const o=[],i=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))i.logSeverityLevel=2;else if(\"number\"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))i.logVerbosityLevel=0;else if(\"number\"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(i.terminate=!1);let n=0;return void 0!==(null==e?void 0:e.tag)&&(n=(0,a.allocWasmString)(e.tag,o)),r=t._OrtCreateRunOptions(i.logSeverityLevel,i.logVerbosityLevel,!!i.terminate,n),0===r&&(0,a.checkLastError)(\"Can\\'t create run options.\"),void 0!==(null==e?void 0:e.extra)&&(0,a.iterateExtraOptions)(e.extra,\"\",new WeakSet,((e,n)=>{const i=(0,a.allocWasmString)(e,o),s=(0,a.allocWasmString)(n,o);0!==t._OrtAddRunConfigEntry(r,i,s)&&(0,a.checkLastError)(`Can\\'t set a run config entry: ${e} - ${n}.`)})),[r,o]}catch(e){throw 0!==r&&t._OrtReleaseRunOptions(r),o.forEach((e=>t._free(e))),e}}},622:(e,t,r)=>{\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.setSessionOptions=void 0;const n=r(263),a=r(497);t.setSessionOptions=e=>{var t,r,o,i;const s=(0,n.getInstance)();let u=0;const c=[],l=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly=\"1\"),e.executionProviders&&e.executionProviders.some((e=>\"webgpu\"===(\"string\"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(l);try{const e=(e=>{switch(e){case\"disabled\":return 0;case\"basic\":return 1;case\"extended\":return 2;case\"all\":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=l.graphOptimizationLevel)&&void 0!==t?t:\"all\"),f=(e=>{switch(e){case\"sequential\":return 0;case\"parallel\":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(r=l.executionMode)&&void 0!==r?r:\"sequential\"),d=\"string\"==typeof l.logId?(0,a.allocWasmString)(l.logId,c):0,p=null!==(o=l.logSeverityLevel)&&void 0!==o?o:2;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log serverity level is not valid: ${p}`);const g=null!==(i=l.logVerbosityLevel)&&void 0!==i?i:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);const h=\"string\"==typeof l.optimizedModelFilePath?(0,a.allocWasmString)(l.optimizedModelFilePath,c):0;return u=s._OrtCreateSessionOptions(e,!!l.enableCpuMemArena,!!l.enableMemPattern,f,!!l.enableProfiling,0,d,p,g,h),0===u&&(0,a.checkLastError)(\"Can\\'t create session options.\"),l.executionProviders&&((e,t,r)=>{for(const o of t){let t=\"string\"==typeof o?o:o.name;switch(t){case\"xnnpack\":t=\"XNNPACK\";break;case\"webnn\":if(t=\"WEBNN\",\"string\"!=typeof o){const t=o;if(null==t?void 0:t.deviceType){const o=(0,a.allocWasmString)(\"deviceType\",r),i=(0,a.allocWasmString)(t.deviceType,r);0!==(0,n.getInstance)()._OrtAddSessionConfigEntry(e,o,i)&&(0,a.checkLastError)(`Can\\'t set a session config entry: \\'deviceType\\' - ${t.deviceType}.`)}if(null==t?void 0:t.powerPreference){const o=(0,a.allocWasmString)(\"powerPreference\",r),i=(0,a.allocWasmString)(t.powerPreference,r);0!==(0,n.getInstance)()._OrtAddSessionConfigEntry(e,o,i)&&(0,a.checkLastError)(`Can\\'t set a session config entry: \\'powerPreference\\' - ${t.powerPreference}.`)}}break;case\"webgpu\":t=\"JS\";break;case\"wasm\":case\"cpu\":continue;default:throw new Error(`not supported execution provider: ${t}`)}const i=(0,a.allocWasmString)(t,r);0!==(0,n.getInstance)()._OrtAppendExecutionProvider(e,i)&&(0,a.checkLastError)(`Can\\'t append execution provider: ${t}.`)}})(u,l.executionProviders,c),void 0!==l.extra&&(0,a.iterateExtraOptions)(l.extra,\"\",new WeakSet,((e,t)=>{const r=(0,a.allocWasmString)(e,c),n=(0,a.allocWasmString)(t,c);0!==s._OrtAddSessionConfigEntry(u,r,n)&&(0,a.checkLastError)(`Can\\'t set a session config entry: ${e} - ${t}.`)})),[u,c]}catch(e){throw 0!==u&&s._OrtReleaseSessionOptions(u),c.forEach((e=>s._free(e))),e}}},917:(e,t)=>{\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case\"int8\":return 3;case\"uint8\":return 2;case\"bool\":return 9;case\"int16\":return 5;case\"uint16\":return 4;case\"int32\":return 6;case\"uint32\":return 12;case\"float16\":return 10;case\"float32\":return 1;case\"float64\":return 11;case\"string\":return 8;case\"int64\":return 7;case\"uint64\":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return\"int8\";case 2:return\"uint8\";case 9:return\"bool\";case 5:return\"int16\";case 4:return\"uint16\";case 6:return\"int32\";case 12:return\"uint32\";case 10:return\"float16\";case 1:return\"float32\";case 11:return\"float64\";case 8:return\"string\";case 7:return\"int64\";case 13:return\"uint64\";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case\"float16\":case\"uint16\":return Uint16Array;case\"float32\":return Float32Array;case\"uint8\":case\"bool\":return Uint8Array;case\"int8\":return Int8Array;case\"int16\":return Int16Array;case\"int32\":return Int32Array;case\"float64\":return Float64Array;case\"uint32\":return Uint32Array;case\"int64\":return BigInt64Array;case\"uint64\":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case\"verbose\":return 0;case\"info\":return 1;case\"warning\":return 2;case\"error\":return 3;case\"fatal\":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},259:(e,t,r)=>{\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initRuntime=void 0;const n=r(918),a=r(622),o=r(917),i=r(263),s=r(497);t.initRuntime=async e=>{var t,r;t=e.wasm.numThreads,r=(0,o.logLevelStringToEnum)(e.logLevel),0!==(0,i.getInstance)()._OrtInit(t,r)&&(0,s.checkLastError)(\"Can\\'t initialize onnxruntime.\")};const u=new Map;t.createSessionAllocate=e=>{const t=(0,i.getInstance)(),r=t._malloc(e.byteLength);if(0===r)throw new Error(`Can\\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},t.createSessionFinalize=(e,t)=>{const r=(0,i.getInstance)();let n=0,o=0,c=[];const l=[],f=[];try{[o,c]=(0,a.setSessionOptions)(t),n=r._OrtCreateSession(e[0],e[1],o),0===n&&(0,s.checkLastError)(\"Can\\'t create a session.\");const[d,p]=(e=>{const t=(0,i.getInstance)(),r=t.stackSave();try{const r=t.stackAlloc(8);return 0!==t._OrtGetInputOutputCount(e,r,r+4)&&(0,s.checkLastError)(\"Can\\'t get session input/output count.\"),[t.HEAP32[r/4],t.HEAP32[r/4+1]]}finally{t.stackRestore(r)}})(n),g=[],h=[];for(let e=0;e<d;e++){const t=r._OrtGetInputName(n,e);0===t&&(0,s.checkLastError)(\"Can\\'t get an input name.\"),l.push(t),g.push(r.UTF8ToString(t))}for(let e=0;e<p;e++){const t=r._OrtGetOutputName(n,e);0===t&&(0,s.checkLastError)(\"Can\\'t get an output name.\"),f.push(t),h.push(r.UTF8ToString(t))}return u.set(n,[n,l,f]),[n,g,h]}catch(e){throw l.forEach((e=>r._OrtFree(e))),f.forEach((e=>r._OrtFree(e))),0!==n&&r._OrtReleaseSession(n),e}finally{r._free(e[0]),0!==o&&r._OrtReleaseSessionOptions(o),c.forEach((e=>r._free(e)))}},t.createSession=(e,r)=>{const n=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(n,r)},t.releaseSession=e=>{const t=(0,i.getInstance)(),r=u.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);const[n,a,o]=r;a.forEach((e=>t._OrtFree(e))),o.forEach((e=>t._OrtFree(e))),t._OrtReleaseSession(n),u.delete(e)},t.run=async(e,t,r,a,c)=>{const l=(0,i.getInstance)(),f=u.get(e);if(!f)throw new Error(`cannot run inference. invalid session id: ${e}`);const[d,p,g]=f,h=t.length,m=a.length;let y=0,v=[];const b=[],w=[];try{[y,v]=(0,n.setRunOptions)(c);for(let e=0;e<h;e++){const t=r[e][0],n=r[e][1],a=r[e][2];let i,u;if(Array.isArray(a)){u=4*a.length,i=l._malloc(u),w.push(i);let e=i/4;for(let t=0;t<a.length;t++){if(\"string\"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);l.HEAPU32[e++]=(0,s.allocWasmString)(a[t],w)}}else u=a.byteLength,i=l._malloc(u),w.push(i),l.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),i);const c=l.stackSave(),f=l.stackAlloc(4*n.length);try{let r=f/4;n.forEach((e=>l.HEAP32[r++]=e));const a=l._OrtCreateTensor((0,o.tensorDataTypeStringToEnum)(t),i,u,f,n.length);0===a&&(0,s.checkLastError)(`Can\\'t create tensor for input[${e}].`),b.push(a)}finally{l.stackRestore(c)}}const e=l.stackSave(),i=l.stackAlloc(4*h),u=l.stackAlloc(4*h),f=l.stackAlloc(4*m),_=l.stackAlloc(4*m);try{let e=i/4,r=u/4,n=f/4,c=_/4;for(let n=0;n<h;n++)l.HEAPU32[e++]=b[n],l.HEAPU32[r++]=p[t[n]];for(let e=0;e<m;e++)l.HEAPU32[n++]=0,l.HEAPU32[c++]=g[a[e]];let v=l._OrtRun(d,u,i,h,_,m,f,y);const w=l.jsepRunPromise;w&&void 0!==w.then&&(v=await w);const O=[];0!==v&&(0,s.checkLastError)(\"failed to call OrtRun().\");for(let e=0;e<m;e++){const t=l.HEAPU32[f/4+e],r=l.stackSave(),n=l.stackAlloc(16);let a,i=0;try{v=l._OrtGetTensorData(t,n,n+4,n+8,n+12),0!==v&&(0,s.checkLastError)(`Can\\'t access output tensor data on index ${e}.`);let r=n/4;const u=l.HEAPU32[r++];i=l.HEAPU32[r++];const c=l.HEAPU32[r++],f=l.HEAPU32[r++],d=[];for(let e=0;e<f;e++)d.push(l.HEAPU32[c/4+e]);l._OrtFree(c);const p=0===d.length?1:d.reduce(((e,t)=>e*t));if(a=(0,o.tensorDataTypeEnumToString)(u),\"string\"===a){const e=[];let t=i/4;for(let r=0;r<p;r++){const n=l.HEAPU32[t++],a=r===p-1?void 0:l.HEAPU32[t]-n;e.push(l.UTF8ToString(n,a))}O.push([a,d,e])}else{const e=new((0,o.tensorTypeToTypedArrayConstructor)(a))(p);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(l.HEAPU8.subarray(i,i+e.byteLength)),O.push([a,d,e])}}finally{l.stackRestore(r),\"string\"===a&&i&&l._free(i),l._OrtReleaseTensor(t)}}return O}finally{l.stackRestore(e)}}finally{b.forEach((e=>l._OrtReleaseTensor(e))),w.forEach((e=>l._free(e))),0!==y&&l._OrtReleaseRunOptions(y),v.forEach((e=>l._free(e)))}},t.endProfiling=e=>{const t=(0,i.getInstance)(),r=u.get(e);if(!r)throw new Error(\"invalid session id\");const n=r[0],a=t._OrtEndProfiling(n);0===a&&(0,s.checkLastError)(\"Can\\'t get an profile file name.\"),t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const r of e){const e=r[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,r){\"use strict\";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!(\"get\"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,\"default\",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)\"default\"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&n(t,e,r);return a(t,e),t};Object.defineProperty(t,\"__esModule\",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const i=o(r(449)),s=r(932),u=r(474);let c,l=!1,f=!1,d=!1;t.initializeWebAssembly=async e=>{if(l)return Promise.resolve();if(f)throw new Error(\"multiple calls to \\'initializeWebAssembly()\\' detected.\");if(d)throw new Error(\"previous call to \\'initializeWebAssembly()\\' failed.\");f=!0;const t=e.initTimeout,n=e.numThreads,a=e.simd,o=n>1&&(()=>{try{return\"undefined\"!=typeof SharedArrayBuffer&&(\"undefined\"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),p=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),g=e.wasmPaths,h=\"string\"==typeof g?g:void 0,m=((e,t)=>t?e?\"ort-wasm-simd-threaded.wasm\":\"ort-wasm-threaded.wasm\":e?\"ort-wasm-simd.wasm\":\"ort-wasm.wasm\")(p,o),y=\"object\"==typeof g?g[m]:void 0;let v=!1;const b=[];if(t>0&&b.push(new Promise((e=>{setTimeout((()=>{v=!0,e()}),t)}))),b.push(new Promise(((e,t)=>{const n=o?u:s,a={locateFile:(e,t)=>o&&e.endsWith(\".worker.js\")&&\"undefined\"!=typeof Blob?URL.createObjectURL(new Blob([r(154)],{type:\"text/javascript\"})):e.endsWith(\".wasm\")?y||(null!=h?h:t)+m:t+e};if(o)if(\"undefined\"==typeof Blob)a.mainScriptUrlOrBlob=i.join(__dirname,\"ort-wasm-threaded.js\");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${n.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([e],{type:\"text/javascript\"})}n(a).then((t=>{f=!1,l=!0,c=t,e()}),(e=>{f=!1,d=!0,t(e)}))}))),await Promise.race(b),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(l&&c)return c;throw new Error(\"WebAssembly is not initialized yet.\")},t.dispose=()=>{var e;!l||f||d||(f=!0,null===(e=c.PThread)||void 0===e||e.terminateAllThreads(),c=void 0,f=!1,l=!1,d=!0)}},497:(e,t,r)=>{\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.checkLastError=t.iterateExtraOptions=t.allocWasmString=void 0;const n=r(263);t.allocWasmString=(e,t)=>{const r=(0,n.getInstance)(),a=r.lengthBytesUTF8(e)+1,o=r._malloc(a);return r.stringToUTF8(e,o,a),t.push(o),o},t.iterateExtraOptions=(e,r,n,a)=>{if(\"object\"==typeof e&&null!==e){if(n.has(e))throw new Error(\"Circular reference in options\");n.add(e)}Object.entries(e).forEach((([e,o])=>{const i=r?r+e:e;if(\"object\"==typeof o)(0,t.iterateExtraOptions)(o,i+\".\",n,a);else if(\"string\"==typeof o||\"number\"==typeof o)a(i,o.toString());else{if(\"boolean\"!=typeof o)throw new Error(\"Can\\'t handle extra config type: \"+typeof o);a(i,o?\"1\":\"0\")}}))},t.checkLastError=e=>{const t=(0,n.getInstance)(),r=t.stackSave();try{const r=t.stackAlloc(8);t._OrtGetLastError(r,r+4);const n=t.HEAP32[r/4],a=t.HEAPU32[r/4+1],o=a?t.UTF8ToString(a):\"\";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${o}`)}finally{t.stackRestore(r)}}},474:(e,t,r)=>{var _scriptDir,n=(_scriptDir=\"undefined\"!=typeof document&&document.currentScript?document.currentScript.src:void 0,\"undefined\"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){function t(){return k.buffer!=x.buffer&&Y(),x}function n(){return k.buffer!=x.buffer&&Y(),I}function a(){return k.buffer!=x.buffer&&Y(),U}function o(){return k.buffer!=x.buffer&&Y(),L}function i(){return k.buffer!=x.buffer&&Y(),W}var s,u,c=e;c.ready=new Promise(((e,t)=>{s=e,u=t}));var l,f,d,p=Object.assign({},c),g=\"./this.program\",h=(e,t)=>{throw t},m=\"object\"==typeof window,y=\"function\"==typeof importScripts,v=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node,b=c.ENVIRONMENT_IS_PTHREAD||!1,w=\"\";function _(e){return c.locateFile?c.locateFile(e,w):w+e}if(v){var O=r(384),S=r(908);let t;w=y?S.dirname(w)+\"/\":__dirname+\"/\",l=(e,t)=>(e=e.startsWith(\"file://\")?new URL(e):S.normalize(e),O.readFileSync(e,t?void 0:\"utf8\")),d=e=>((e=l(e,!0)).buffer||(e=new Uint8Array(e)),e),f=(e,t,r,n=!0)=>{e=e.startsWith(\"file://\")?new URL(e):S.normalize(e),O.readFile(e,n?void 0:\"utf8\",((e,a)=>{e?r(e):t(n?a.buffer:a)}))},!c.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\\\\\\\/g,\"/\")),process.argv.slice(2),h=(e,t)=>{throw process.exitCode=e,t},c.inspect=()=>\"[Emscripten Module object]\";try{t=r(925)}catch(e){throw console.error(\\'The \"worker_threads\" module is not supported in this node.js build - perhaps a newer version is needed?\\'),e}global.Worker=t.Worker}else(m||y)&&(y?w=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(w=document.currentScript.src),_scriptDir&&(w=_scriptDir),w=0!==w.indexOf(\"blob:\")?w.substr(0,w.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):\"\",v||(l=e=>{var t=new XMLHttpRequest;return t.open(\"GET\",e,!1),t.send(null),t.responseText},y&&(d=e=>{var t=new XMLHttpRequest;return t.open(\"GET\",e,!1),t.responseType=\"arraybuffer\",t.send(null),new Uint8Array(t.response)}),f=(e,t,r)=>{var n=new XMLHttpRequest;n.open(\"GET\",e,!0),n.responseType=\"arraybuffer\",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)}));v&&\"undefined\"==typeof performance&&(global.performance=r(953).performance);var E=console.log.bind(console),A=console.error.bind(console);v&&(E=(...e)=>O.writeSync(1,e.join(\" \")+\"\\\\n\"),A=(...e)=>O.writeSync(2,e.join(\" \")+\"\\\\n\"));var T,M=c.print||E,R=c.printErr||A;Object.assign(c,p),p=null,c.thisProgram&&(g=c.thisProgram),c.quit&&(h=c.quit),c.wasmBinary&&(T=c.wasmBinary);var F=c.noExitRuntime||!0;\"object\"!=typeof WebAssembly&&te(\"no native wasm support detected\");var k,C,P,D,x,I,U,L,W,H=!1;function Y(){var e=k.buffer;c.HEAP8=x=new Int8Array(e),c.HEAP16=new Int16Array(e),c.HEAP32=U=new Int32Array(e),c.HEAPU8=I=new Uint8Array(e),c.HEAPU16=new Uint16Array(e),c.HEAPU32=L=new Uint32Array(e),c.HEAPF32=new Float32Array(e),c.HEAPF64=W=new Float64Array(e)}var j=c.INITIAL_MEMORY||16777216;if(5242880<=j||te(\"INITIAL_MEMORY should be larger than STACK_SIZE, was \"+j+\"! (STACK_SIZE=5242880)\"),b)k=c.wasmMemory;else if(c.wasmMemory)k=c.wasmMemory;else if(!((k=new WebAssembly.Memory({initial:j/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw R(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"),v&&R(\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)\"),Error(\"bad memory\");Y(),j=k.buffer.byteLength;var z,G=[],N=[],B=[],$=0;function q(){return F||0<$}var V,J,X=0,K=null,Z=null;function Q(){X++,c.monitorRunDependencies&&c.monitorRunDependencies(X)}function ee(){if(X--,c.monitorRunDependencies&&c.monitorRunDependencies(X),0==X&&(null!==K&&(clearInterval(K),K=null),Z)){var e=Z;Z=null,e()}}function te(e){throw c.onAbort&&c.onAbort(e),R(e=\"Aborted(\"+e+\")\"),H=!0,D=1,e=new WebAssembly.RuntimeError(e+\". Build with -sASSERTIONS for more info.\"),u(e),e}function re(e){return e.startsWith(\"data:application/octet-stream;base64,\")}function ne(e){if(e==V&&T)return new Uint8Array(T);if(d)return d(e);throw\"both async and sync fetching of the wasm failed\"}function ae(e,t,r){return function(e){if(!T&&(m||y)){if(\"function\"==typeof fetch&&!e.startsWith(\"file://\"))return fetch(e,{credentials:\"same-origin\"}).then((t=>{if(!t.ok)throw\"failed to load wasm binary file at \\'\"+e+\"\\'\";return t.arrayBuffer()})).catch((()=>ne(e)));if(f)return new Promise(((t,r)=>{f(e,(e=>t(new Uint8Array(e))),r)}))}return Promise.resolve().then((()=>ne(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(r,(e=>{R(\"failed to asynchronously prepare wasm: \"+e),te(e)}))}function oe(e){this.name=\"ExitStatus\",this.message=`Program terminated with exit(${e})`,this.status=e}function ie(e){e.terminate(),e.onmessage=()=>{}}function se(e){(e=ge.Fa[e])||te(),ge.fb(e)}function ue(e){var t=ge.Za();if(!t)return 6;ge.Ia.push(t),ge.Fa[e.Ha]=t,t.Ha=e.Ha;var r={cmd:\"run\",start_routine:e.gb,arg:e.Ya,pthread_ptr:e.Ha};return v&&t.unref(),t.postMessage(r,e.mb),0}re(V=\"ort-wasm-threaded.wasm\")||(V=_(V));var ce=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0,le=(e,t,r)=>{var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&ce)return ce.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,r):e.subarray(t,r));for(n=\"\";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n},fe=(e,t)=>(e>>>=0)?le(n(),e,t):\"\";function de(e){if(b)return qe(1,1,e);D=e,q()||(ge.hb(),c.onExit&&c.onExit(e),H=!0),h(e,new oe(e))}var pe=e=>{if(D=e,b)throw me(e),\"unwind\";de(e)},ge={La:[],Ia:[],Ta:[],Fa:{},Pa:function(){b?ge.ab():ge.$a()},$a:function(){G.unshift((()=>{Q(),ge.bb((()=>ee()))}))},ab:function(){ge.receiveObjectTransfer=ge.eb,ge.threadInitTLS=ge.Sa,ge.setExitStatus=ge.Ra,F=!1},Ra:function(e){D=e},rb:[\"$terminateWorker\"],hb:function(){for(var e of ge.Ia)ie(e);for(e of ge.La)ie(e);ge.La=[],ge.Ia=[],ge.Fa=[]},fb:function(e){var t=e.Ha;delete ge.Fa[t],ge.La.push(e),ge.Ia.splice(ge.Ia.indexOf(e),1),e.Ha=0,yt(t)},eb:function(){},Sa:function(){ge.Ta.forEach((e=>e()))},cb:e=>new Promise((t=>{e.onmessage=r=>{var n=(r=r.data).cmd;if(r.targetThread&&r.targetThread!=dt()){var a=ge.Fa[r.qb];a?a.postMessage(r,r.transferList):R(\\'Internal error! Worker sent a message \"\\'+n+\\'\" to target pthread \\'+r.targetThread+\", but that thread no longer exists!\")}else\"checkMailbox\"===n?He():\"spawnThread\"===n?ue(r):\"cleanupThread\"===n?se(r.thread):\"killThread\"===n?(r=r.thread,n=ge.Fa[r],delete ge.Fa[r],ie(n),yt(r),ge.Ia.splice(ge.Ia.indexOf(n),1),n.Ha=0):\"cancelThread\"===n?ge.Fa[r.thread].postMessage({cmd:\"cancel\"}):\"loaded\"===n?(e.loaded=!0,t(e)):\"alert\"===n?alert(\"Thread \"+r.threadId+\": \"+r.text):\"setimmediate\"===r.target?e.postMessage(r):\"callHandler\"===n?c[r.handler](...r.args):n&&R(\"worker sent an unknown command \"+n)},e.onerror=e=>{throw R(\"worker sent an error! \"+e.filename+\":\"+e.lineno+\": \"+e.message),e},v&&(e.on(\"message\",(function(t){e.onmessage({data:t})})),e.on(\"error\",(function(t){e.onerror(t)})));var r,n=[];for(r of[\"onExit\",\"onAbort\",\"print\",\"printErr\"])c.hasOwnProperty(r)&&n.push(r);e.postMessage({cmd:\"load\",handlers:n,urlOrBlob:c.mainScriptUrlOrBlob||_scriptDir,wasmMemory:k,wasmModule:P})})),bb:function(e){e()},Xa:function(){var e=_(\"ort-wasm-threaded.worker.js\");e=new Worker(e),ge.La.push(e)},Za:function(){return 0==ge.La.length&&(ge.Xa(),ge.cb(ge.La[0])),ge.La.pop()}};c.PThread=ge;var he=e=>{for(;0<e.length;)e.shift()(c)};function me(e){if(b)return qe(2,0,e);pe(e)}c.establishStackSpace=function(){var e=dt(),t=a()[e+52>>2>>>0];e=a()[e+56>>2>>>0],_t(t,t-e),St(t)};var ye=[];function ve(e){this.Oa=e-24,this.Wa=function(e){o()[this.Oa+4>>2>>>0]=e},this.Va=function(e){o()[this.Oa+8>>2>>>0]=e},this.Pa=function(e,t){this.Ua(),this.Wa(e),this.Va(t)},this.Ua=function(){o()[this.Oa+16>>2>>>0]=0}}function be(e,t,r,n){return b?qe(3,1,e,t,r,n):we(e,t,r,n)}function we(e,t,r,n){if(e>>>=0,t>>>=0,r>>>=0,n>>>=0,\"undefined\"==typeof SharedArrayBuffer)return R(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"),6;var a=[];return b&&0===a.length?be(e,t,r,n):(e={gb:r,Ha:e,Ya:n,mb:a},b?(e.ob=\"spawnThread\",postMessage(e,a),0):ue(e))}function _e(e,t,r){return b?qe(4,1,e,t,r):0}function Oe(e,t){if(b)return qe(5,1,e,t)}c.invokeEntryPoint=function(e,t){var r=ye[e];r||(e>=ye.length&&(ye.length=e+1),ye[e]=r=z.get(e)),e=r(t),q()?ge.Ra(e):vt(e)};var Se=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t},Ee=(e,t,r,n)=>{if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(r>=n)break;t[r++>>>0]=i}else{if(2047>=i){if(r+1>=n)break;t[r++>>>0]=192|i>>6}else{if(65535>=i){if(r+2>=n)break;t[r++>>>0]=224|i>>12}else{if(r+3>=n)break;t[r++>>>0]=240|i>>18,t[r++>>>0]=128|i>>12&63}t[r++>>>0]=128|i>>6&63}t[r++>>>0]=128|63&i}}return t[r>>>0]=0,r-a},Ae=(e,t,r)=>Ee(e,n(),t,r);function Te(e,t){if(b)return qe(6,1,e,t)}function Me(e,t,r){if(b)return qe(7,1,e,t,r)}function Re(e,t,r){return b?qe(8,1,e,t,r):0}function Fe(e,t){if(b)return qe(9,1,e,t)}function ke(e,t,r){if(b)return qe(10,1,e,t,r)}function Ce(e,t,r,n){if(b)return qe(11,1,e,t,r,n)}function Pe(e,t,r,n){if(b)return qe(12,1,e,t,r,n)}function De(e,t,r,n){if(b)return qe(13,1,e,t,r,n)}function xe(e){if(b)return qe(14,1,e)}function Ie(e,t){if(b)return qe(15,1,e,t)}function Ue(e,t,r){if(b)return qe(16,1,e,t,r)}var Le=e=>{if(!H)try{if(e(),!q())try{b?vt(D):pe(D)}catch(e){e instanceof oe||\"unwind\"==e||h(1,e)}}catch(e){e instanceof oe||\"unwind\"==e||h(1,e)}};function We(e){e>>>=0,\"function\"==typeof Atomics.nb&&(Atomics.nb(a(),e>>2,e).value.then(He),e+=128,Atomics.store(a(),e>>2,1))}function He(){var e=dt();e&&(We(e),Le((()=>bt())))}c.__emscripten_thread_mailbox_await=We,c.checkMailbox=He;var Ye=e=>0==e%4&&(0!=e%100||0==e%400),je=[0,31,60,91,121,152,182,213,244,274,305,335],ze=[0,31,59,90,120,151,181,212,243,273,304,334];function Ge(e,t,r,n,a,o,i,s){return b?qe(17,1,e,t,r,n,a,o,i,s):-52}function Ne(e,t,r,n,a,o,i){if(b)return qe(18,1,e,t,r,n,a,o,i)}var Be=e=>{var t=Se(e)+1,r=pt(t);return r&&Ae(e,r,t),r},$e=e=>{var t=Ot();return e=e(),St(t),e};function qe(e,t){var r=arguments.length-2,n=arguments;return $e((()=>{for(var a=Et(8*r),o=a>>3,s=0;s<r;s++){var u=n[2+s];i()[o+s>>>0]=u}return mt(e,r,a,t)}))}var Ve,Je=[],Xe={},Ke=()=>{if(!Ve){var e,t={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:g||\"./this.program\"};for(e in Xe)void 0===Xe[e]?delete t[e]:t[e]=Xe[e];var r=[];for(e in t)r.push(`${e}=${t[e]}`);Ve=r}return Ve};function Ze(e,r){if(b)return qe(19,1,e,r);e>>>=0,r>>>=0;var n=0;return Ke().forEach((function(a,i){var s=r+n;for(i=o()[e+4*i>>2>>>0]=s,s=0;s<a.length;++s)t()[i++>>0>>>0]=a.charCodeAt(s);t()[i>>0>>>0]=0,n+=a.length+1})),0}function Qe(e,t){if(b)return qe(20,1,e,t);e>>>=0,t>>>=0;var r=Ke();o()[e>>2>>>0]=r.length;var n=0;return r.forEach((function(e){n+=e.length+1})),o()[t>>2>>>0]=n,0}function et(e){return b?qe(21,1,e):52}function tt(e,t,r,n){return b?qe(22,1,e,t,r,n):52}function rt(e,t,r,n,a){return b?qe(23,1,e,t,r,n,a):70}var nt=[null,[],[]];function at(e,t,r,a){if(b)return qe(24,1,e,t,r,a);t>>>=0,r>>>=0,a>>>=0;for(var i=0,s=0;s<r;s++){var u=o()[t>>2>>>0],c=o()[t+4>>2>>>0];t+=8;for(var l=0;l<c;l++){var f=n()[u+l>>>0],d=nt[e];0===f||10===f?((1===e?M:R)(le(d,0)),d.length=0):d.push(f)}i+=c}return o()[a>>2>>>0]=i,0}var ot=e=>(ot=(()=>{if(\"object\"==typeof crypto&&\"function\"==typeof crypto.getRandomValues)return e=>(e.set(crypto.getRandomValues(new Uint8Array(e.byteLength))),e);if(v)try{var e=r(760);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}te(\"initRandomDevice\")})())(e),it=[31,29,31,30,31,30,31,31,30,31,30,31],st=[31,28,31,30,31,30,31,31,30,31,30,31],ut=(e,r)=>{t().set(e,r>>>0)};function ct(e,t,r,n){function o(e,t,r){for(e=\"number\"==typeof e?e.toString():e||\"\";e.length<t;)e=r[0]+e;return e}function i(e,t){return o(e,t,\"0\")}function s(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function u(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function c(e){var t=e.Ja;for(e=new Date(new Date(e.Ka+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(Ye(e.getFullYear())?it:st)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=u(new Date(e.getFullYear(),0,4)),r=u(r),0>=s(t,e)?0>=s(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,r>>>=0,n>>>=0;var l=a()[n+40>>2>>>0];for(var f in n={kb:a()[n>>2>>>0],jb:a()[n+4>>2>>>0],Ma:a()[n+8>>2>>>0],Qa:a()[n+12>>2>>>0],Na:a()[n+16>>2>>>0],Ka:a()[n+20>>2>>>0],Ga:a()[n+24>>2>>>0],Ja:a()[n+28>>2>>>0],sb:a()[n+32>>2>>>0],ib:a()[n+36>>2>>>0],lb:l?fe(l):\"\"},r=fe(r),l={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})r=r.replace(new RegExp(f,\"g\"),l[f]);var d=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),p=\"January February March April May June July August September October November December\".split(\" \");for(f in l={\"%a\":e=>d[e.Ga].substring(0,3),\"%A\":e=>d[e.Ga],\"%b\":e=>p[e.Na].substring(0,3),\"%B\":e=>p[e.Na],\"%C\":e=>i((e.Ka+1900)/100|0,2),\"%d\":e=>i(e.Qa,2),\"%e\":e=>o(e.Qa,2,\" \"),\"%g\":e=>c(e).toString().substring(2),\"%G\":e=>c(e),\"%H\":e=>i(e.Ma,2),\"%I\":e=>(0==(e=e.Ma)?e=12:12<e&&(e-=12),i(e,2)),\"%j\":e=>{for(var t=0,r=0;r<=e.Na-1;t+=(Ye(e.Ka+1900)?it:st)[r++]);return i(e.Qa+t,3)},\"%m\":e=>i(e.Na+1,2),\"%M\":e=>i(e.jb,2),\"%n\":()=>\"\\\\n\",\"%p\":e=>0<=e.Ma&&12>e.Ma?\"AM\":\"PM\",\"%S\":e=>i(e.kb,2),\"%t\":()=>\"\\\\t\",\"%u\":e=>e.Ga||7,\"%U\":e=>i(Math.floor((e.Ja+7-e.Ga)/7),2),\"%V\":e=>{var t=Math.floor((e.Ja+7-(e.Ga+6)%7)/7);if(2>=(e.Ga+371-e.Ja-2)%7&&t++,t)53==t&&(4==(r=(e.Ga+371-e.Ja)%7)||3==r&&Ye(e.Ka)||(t=1));else{t=52;var r=(e.Ga+7-e.Ja-1)%7;(4==r||5==r&&Ye(e.Ka%400-1))&&t++}return i(t,2)},\"%w\":e=>e.Ga,\"%W\":e=>i(Math.floor((e.Ja+7-(e.Ga+6)%7)/7),2),\"%y\":e=>(e.Ka+1900).toString().substring(2),\"%Y\":e=>e.Ka+1900,\"%z\":e=>{var t=0<=(e=e.ib);return e=Math.abs(e)/60,(t?\"+\":\"-\")+String(\"0000\"+(e/60*100+e%60)).slice(-4)},\"%Z\":e=>e.lb,\"%%\":()=>\"%\"},r=r.replace(/%%/g,\"\\\\0\\\\0\"),l)r.includes(f)&&(r=r.replace(new RegExp(f,\"g\"),l[f](n)));return f=function(e){var t=Array(Se(e)+1);return Ee(e,t,0,t.length),t}(r=r.replace(/\\\\0\\\\0/g,\"%\")),f.length>t?0:(ut(f,e),f.length-1)}ge.Pa();var lt=[null,de,me,be,_e,Oe,Te,Me,Re,Fe,ke,Ce,Pe,De,xe,Ie,Ue,Ge,Ne,Ze,Qe,et,tt,rt,at],ft={b:function(e,t,r){throw new ve(e>>>=0).Pa(t>>>0,r>>>0),e},N:function(e){gt(e>>>0,!y,1,!m,131072,!1),ge.Sa()},k:function(e){e>>>=0,b?postMessage({cmd:\"cleanupThread\",thread:e}):se(e)},I:we,h:_e,T:Oe,E:Te,G:Me,U:Re,R:Fe,J:ke,Q:Ce,o:Pe,F:De,C:xe,S:Ie,D:Ue,q:()=>!0,A:function(e,t){(e>>>=0)==t>>>0?setTimeout((()=>He())):b?postMessage({targetThread:e,cmd:\"checkMailbox\"}):(e=ge.Fa[e])&&e.postMessage({cmd:\"checkMailbox\"})},L:function(){return-1},M:We,p:function(e){v&&ge.Fa[e>>>0].ref()},t:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),a()[r>>2>>>0]=e.getUTCSeconds(),a()[r+4>>2>>>0]=e.getUTCMinutes(),a()[r+8>>2>>>0]=e.getUTCHours(),a()[r+12>>2>>>0]=e.getUTCDate(),a()[r+16>>2>>>0]=e.getUTCMonth(),a()[r+20>>2>>>0]=e.getUTCFullYear()-1900,a()[r+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[r+28>>2>>>0]=e},u:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),a()[r>>2>>>0]=e.getSeconds(),a()[r+4>>2>>>0]=e.getMinutes(),a()[r+8>>2>>>0]=e.getHours(),a()[r+12>>2>>>0]=e.getDate(),a()[r+16>>2>>>0]=e.getMonth(),a()[r+20>>2>>>0]=e.getFullYear()-1900,a()[r+24>>2>>>0]=e.getDay(),t=(Ye(e.getFullYear())?je:ze)[e.getMonth()]+e.getDate()-1|0,a()[r+28>>2>>>0]=t,a()[r+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var n=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(t!=n&&e.getTimezoneOffset()==Math.min(n,t)),a()[r+32>>2>>>0]=e},v:function(e){e>>>=0;var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),r=a()[e+32>>2>>>0],n=t.getTimezoneOffset(),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=new Date(t.getFullYear(),0,1).getTimezoneOffset(),s=Math.min(i,o);return 0>r?a()[e+32>>2>>>0]=Number(o!=i&&s==n):0<r!=(s==n)&&(o=Math.max(i,o),t.setTime(t.getTime()+6e4*((0<r?s:o)-n))),a()[e+24>>2>>>0]=t.getDay(),r=(Ye(t.getFullYear())?je:ze)[t.getMonth()]+t.getDate()-1|0,a()[e+28>>2>>>0]=r,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,wt((J=e,1<=+Math.abs(J)?0<J?+Math.floor(J/4294967296)>>>0:~~+Math.ceil((J-+(~~J>>>0))/4294967296)>>>0:0)),e>>>0},r:Ge,s:Ne,z:function(e,t,r){function n(e){return(e=e.toTimeString().match(/\\\\(([A-Za-z ]+)\\\\)$/))?e[1]:\"GMT\"}e>>>=0,t>>>=0,r>>>=0;var i=(new Date).getFullYear(),s=new Date(i,0,1),u=new Date(i,6,1);i=s.getTimezoneOffset();var c=u.getTimezoneOffset(),l=Math.max(i,c);o()[e>>2>>>0]=60*l,a()[t>>2>>>0]=Number(i!=c),e=n(s),t=n(u),e=Be(e),t=Be(t),c<i?(o()[r>>2>>>0]=e,o()[r+4>>2>>>0]=t):(o()[r>>2>>>0]=t,o()[r+4>>2>>>0]=e)},c:()=>{te(\"\")},l:function(){},i:function(){return Date.now()},V:()=>{throw $+=1,\"unwind\"},B:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:function(){return v?r(993).cpus().length:navigator.hardwareConcurrency},K:function(e,t,r,n){for(ge.pb=t>>>0,Je.length=r,t=n>>>0>>3,n=0;n<r;n++)Je[n]=i()[t+n>>>0];return lt[e].apply(null,Je)},y:function(e){e>>>=0;var t=n().length;if(e<=t||4294901760<e)return!1;for(var r=1;4>=r;r*=2){var a=t*(1+.2/r);a=Math.min(a,e+100663296);var o=Math;a=Math.max(e,a);e:{o=o.min.call(o,4294901760,a+(65536-a%65536)%65536)-k.buffer.byteLength+65535>>>16;try{k.grow(o),Y();var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},O:Ze,P:Qe,j:pe,g:et,n:tt,w:rt,m:at,x:function(e,t){return e>>>=0,t>>>=0,ot(n().subarray(e>>>0,e+t>>>0)),0},a:k||c.wasmMemory,H:ct,d:function(e,t,r,n){return ct(e>>>0,t>>>0,r>>>0,n>>>0)}};!function(){function e(e,t){return e=e.exports,C=e=function(e){var t=e=>()=>e()>>>0,r=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.pthread_self=t(e.pthread_self),e.malloc=r(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=r(e.stackAlloc),e}(e),ge.Ta.push(C.sa),z=C.ta,N.unshift(C.W),P=t,ee(),e}var t={a:ft};if(Q(),c.instantiateWasm)try{return c.instantiateWasm(t,e)}catch(e){R(\"Module.instantiateWasm callback failed with error: \"+e),u(e)}(function(e,t){var r=V;return T||\"function\"!=typeof WebAssembly.instantiateStreaming||re(r)||r.startsWith(\"file://\")||v||\"function\"!=typeof fetch?ae(r,e,t):fetch(r,{credentials:\"same-origin\"}).then((n=>WebAssembly.instantiateStreaming(n,e).then(t,(function(n){return R(\"wasm streaming compile failed: \"+n),R(\"falling back to ArrayBuffer instantiation\"),ae(r,e,t)}))))})(t,(function(t){e(t.instance,t.module)})).catch(u)}(),c._OrtInit=(e,t)=>(c._OrtInit=C.X)(e,t),c._OrtGetLastError=(e,t)=>(c._OrtGetLastError=C.Y)(e,t),c._OrtCreateSessionOptions=(e,t,r,n,a,o,i,s,u,l)=>(c._OrtCreateSessionOptions=C.Z)(e,t,r,n,a,o,i,s,u,l),c._OrtAppendExecutionProvider=(e,t)=>(c._OrtAppendExecutionProvider=C._)(e,t),c._OrtAddSessionConfigEntry=(e,t,r)=>(c._OrtAddSessionConfigEntry=C.$)(e,t,r),c._OrtReleaseSessionOptions=e=>(c._OrtReleaseSessionOptions=C.aa)(e),c._OrtCreateSession=(e,t,r)=>(c._OrtCreateSession=C.ba)(e,t,r),c._OrtReleaseSession=e=>(c._OrtReleaseSession=C.ca)(e),c._OrtGetInputOutputCount=(e,t,r)=>(c._OrtGetInputOutputCount=C.da)(e,t,r),c._OrtGetInputName=(e,t)=>(c._OrtGetInputName=C.ea)(e,t),c._OrtGetOutputName=(e,t)=>(c._OrtGetOutputName=C.fa)(e,t),c._OrtFree=e=>(c._OrtFree=C.ga)(e),c._OrtCreateTensor=(e,t,r,n,a)=>(c._OrtCreateTensor=C.ha)(e,t,r,n,a),c._OrtGetTensorData=(e,t,r,n,a)=>(c._OrtGetTensorData=C.ia)(e,t,r,n,a),c._OrtReleaseTensor=e=>(c._OrtReleaseTensor=C.ja)(e),c._OrtCreateRunOptions=(e,t,r,n)=>(c._OrtCreateRunOptions=C.ka)(e,t,r,n),c._OrtAddRunConfigEntry=(e,t,r)=>(c._OrtAddRunConfigEntry=C.la)(e,t,r),c._OrtReleaseRunOptions=e=>(c._OrtReleaseRunOptions=C.ma)(e),c._OrtRun=(e,t,r,n,a,o,i,s)=>(c._OrtRun=C.na)(e,t,r,n,a,o,i,s),c._OrtEndProfiling=e=>(c._OrtEndProfiling=C.oa)(e);var dt=c._pthread_self=()=>(dt=c._pthread_self=C.pa)(),pt=c._malloc=e=>(pt=c._malloc=C.qa)(e);c._free=e=>(c._free=C.ra)(e),c.__emscripten_tls_init=()=>(c.__emscripten_tls_init=C.sa)();var gt=c.__emscripten_thread_init=(e,t,r,n,a,o)=>(gt=c.__emscripten_thread_init=C.ua)(e,t,r,n,a,o);c.__emscripten_thread_crashed=()=>(c.__emscripten_thread_crashed=C.va)();var ht,mt=(e,t,r,n)=>(mt=C.wa)(e,t,r,n),yt=e=>(yt=C.xa)(e),vt=c.__emscripten_thread_exit=e=>(vt=c.__emscripten_thread_exit=C.ya)(e),bt=c.__emscripten_check_mailbox=()=>(bt=c.__emscripten_check_mailbox=C.za)(),wt=e=>(wt=C.Aa)(e),_t=(e,t)=>(_t=C.Ba)(e,t),Ot=()=>(Ot=C.Ca)(),St=e=>(St=C.Da)(e),Et=e=>(Et=C.Ea)(e);function At(){function e(){if(!ht&&(ht=!0,c.calledRun=!0,!H)&&(b||he(N),s(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),!b)){if(c.postRun)for(\"function\"==typeof c.postRun&&(c.postRun=[c.postRun]);c.postRun.length;){var e=c.postRun.shift();B.unshift(e)}he(B)}}if(!(0<X))if(b)s(c),b||he(N),startWorker(c);else{if(c.preRun)for(\"function\"==typeof c.preRun&&(c.preRun=[c.preRun]);c.preRun.length;)G.unshift(c.preRun.shift());he(G),0<X||(c.setStatus?(c.setStatus(\"Running...\"),setTimeout((function(){setTimeout((function(){c.setStatus(\"\")}),1),e()}),1)):e())}}if(c.keepRuntimeAlive=q,c.wasmMemory=k,c.stackAlloc=Et,c.stackSave=Ot,c.stackRestore=St,c.UTF8ToString=fe,c.stringToUTF8=Ae,c.lengthBytesUTF8=Se,c.ExitStatus=oe,c.PThread=ge,Z=function e(){ht||At(),ht||(Z=e)},c.preInit)for(\"function\"==typeof c.preInit&&(c.preInit=[c.preInit]);0<c.preInit.length;)c.preInit.pop()();return At(),e.ready});e.exports=n},932:(e,t,r)=>{var _scriptDir,n=(_scriptDir=\"undefined\"!=typeof document&&document.currentScript?document.currentScript.src:void 0,\"undefined\"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){var t,n,a=e;a.ready=new Promise(((e,r)=>{t=e,n=r}));var o,i,s,u=Object.assign({},a),c=\"./this.program\",l=(e,t)=>{throw t},f=\"object\"==typeof window,d=\"function\"==typeof importScripts,p=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node,g=\"\";if(p){var h=r(384),m=r(908);g=d?m.dirname(g)+\"/\":__dirname+\"/\",o=(e,t)=>(e=e.startsWith(\"file://\")?new URL(e):m.normalize(e),h.readFileSync(e,t?void 0:\"utf8\")),s=e=>((e=o(e,!0)).buffer||(e=new Uint8Array(e)),e),i=(e,t,r,n=!0)=>{e=e.startsWith(\"file://\")?new URL(e):m.normalize(e),h.readFile(e,n?void 0:\"utf8\",((e,a)=>{e?r(e):t(n?a.buffer:a)}))},!a.thisProgram&&1<process.argv.length&&(c=process.argv[1].replace(/\\\\\\\\/g,\"/\")),process.argv.slice(2),l=(e,t)=>{throw process.exitCode=e,t},a.inspect=()=>\"[Emscripten Module object]\"}else(f||d)&&(d?g=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(g=document.currentScript.src),_scriptDir&&(g=_scriptDir),g=0!==g.indexOf(\"blob:\")?g.substr(0,g.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):\"\",o=e=>{var t=new XMLHttpRequest;return t.open(\"GET\",e,!1),t.send(null),t.responseText},d&&(s=e=>{var t=new XMLHttpRequest;return t.open(\"GET\",e,!1),t.responseType=\"arraybuffer\",t.send(null),new Uint8Array(t.response)}),i=(e,t,r)=>{var n=new XMLHttpRequest;n.open(\"GET\",e,!0),n.responseType=\"arraybuffer\",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)});var y,v=a.print||console.log.bind(console),b=a.printErr||console.error.bind(console);Object.assign(a,u),u=null,a.thisProgram&&(c=a.thisProgram),a.quit&&(l=a.quit),a.wasmBinary&&(y=a.wasmBinary);var w=a.noExitRuntime||!0;\"object\"!=typeof WebAssembly&&W(\"no native wasm support detected\");var _,O,S,E,A,T,M=!1;function R(){var e=_.buffer;a.HEAP8=S=new Int8Array(e),a.HEAP16=new Int16Array(e),a.HEAP32=A=new Int32Array(e),a.HEAPU8=E=new Uint8Array(e),a.HEAPU16=new Uint16Array(e),a.HEAPU32=T=new Uint32Array(e),a.HEAPF32=new Float32Array(e),a.HEAPF64=new Float64Array(e)}var F=[],k=[],C=[];function P(){var e=a.preRun.shift();F.unshift(e)}var D,x,I=0,U=null,L=null;function W(e){throw a.onAbort&&a.onAbort(e),b(e=\"Aborted(\"+e+\")\"),M=!0,e=new WebAssembly.RuntimeError(e+\". Build with -sASSERTIONS for more info.\"),n(e),e}function H(e){return e.startsWith(\"data:application/octet-stream;base64,\")}if(!H(D=\"ort-wasm.wasm\")){var Y=D;D=a.locateFile?a.locateFile(Y,g):g+Y}function j(e){if(e==D&&y)return new Uint8Array(y);if(s)return s(e);throw\"both async and sync fetching of the wasm failed\"}function z(e,t,r){return function(e){if(!y&&(f||d)){if(\"function\"==typeof fetch&&!e.startsWith(\"file://\"))return fetch(e,{credentials:\"same-origin\"}).then((t=>{if(!t.ok)throw\"failed to load wasm binary file at \\'\"+e+\"\\'\";return t.arrayBuffer()})).catch((()=>j(e)));if(i)return new Promise(((t,r)=>{i(e,(e=>t(new Uint8Array(e))),r)}))}return Promise.resolve().then((()=>j(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(r,(e=>{b(\"failed to asynchronously prepare wasm: \"+e),W(e)}))}function G(e){this.name=\"ExitStatus\",this.message=`Program terminated with exit(${e})`,this.status=e}var N=e=>{for(;0<e.length;)e.shift()(a)};function B(e){this.qa=e-24,this.va=function(e){T[this.qa+4>>2>>>0]=e},this.ua=function(e){T[this.qa+8>>2>>>0]=e},this.sa=function(e,t){this.ta(),this.va(e),this.ua(t)},this.ta=function(){T[this.qa+16>>2>>>0]=0}}var $,q=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0,V=(e,t,r)=>{var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&q)return q.decode(e.subarray(t,r));for(n=\"\";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n},J=(e,t)=>(e>>>=0)?V(E,e,t):\"\",X=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t},K=(e,t,r,n)=>{if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(r>=n)break;t[r++>>>0]=i}else{if(2047>=i){if(r+1>=n)break;t[r++>>>0]=192|i>>6}else{if(65535>=i){if(r+2>=n)break;t[r++>>>0]=224|i>>12}else{if(r+3>=n)break;t[r++>>>0]=240|i>>18,t[r++>>>0]=128|i>>12&63}t[r++>>>0]=128|i>>6&63}t[r++>>>0]=128|63&i}}return t[r>>>0]=0,r-a},Z=e=>0==e%4&&(0!=e%100||0==e%400),Q=[0,31,60,91,121,152,182,213,244,274,305,335],ee=[0,31,59,90,120,151,181,212,243,273,304,334],te=e=>{var t=X(e)+1,r=le(t);return r&&K(e,E,r,t),r},re={},ne=()=>{if(!$){var e,t={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:c||\"./this.program\"};for(e in re)void 0===re[e]?delete t[e]:t[e]=re[e];var r=[];for(e in t)r.push(`${e}=${t[e]}`);$=r}return $},ae=[null,[],[]],oe=e=>(oe=(()=>{if(\"object\"==typeof crypto&&\"function\"==typeof crypto.getRandomValues)return e=>crypto.getRandomValues(e);if(p)try{var e=r(760);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}W(\"initRandomDevice\")})())(e),ie=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function ue(e,t,r,n){function a(e,t,r){for(e=\"number\"==typeof e?e.toString():e||\"\";e.length<t;)e=r[0]+e;return e}function o(e,t){return a(e,t,\"0\")}function i(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.ma;for(e=new Date(new Date(e.na+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(Z(e.getFullYear())?ie:se)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),r=s(r),0>=i(t,e)?0>=i(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,r>>>=0;var c=A[40+(n>>>=0)>>2>>>0];for(var l in n={ya:A[n>>2>>>0],xa:A[n+4>>2>>>0],oa:A[n+8>>2>>>0],ra:A[n+12>>2>>>0],pa:A[n+16>>2>>>0],na:A[n+20>>2>>>0],ha:A[n+24>>2>>>0],ma:A[n+28>>2>>>0],Aa:A[n+32>>2>>>0],wa:A[n+36>>2>>>0],za:c?J(c):\"\"},r=J(r),c={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})r=r.replace(new RegExp(l,\"g\"),c[l]);var f=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),d=\"January February March April May June July August September October November December\".split(\" \");for(l in c={\"%a\":e=>f[e.ha].substring(0,3),\"%A\":e=>f[e.ha],\"%b\":e=>d[e.pa].substring(0,3),\"%B\":e=>d[e.pa],\"%C\":e=>o((e.na+1900)/100|0,2),\"%d\":e=>o(e.ra,2),\"%e\":e=>a(e.ra,2,\" \"),\"%g\":e=>u(e).toString().substring(2),\"%G\":e=>u(e),\"%H\":e=>o(e.oa,2),\"%I\":e=>(0==(e=e.oa)?e=12:12<e&&(e-=12),o(e,2)),\"%j\":e=>{for(var t=0,r=0;r<=e.pa-1;t+=(Z(e.na+1900)?ie:se)[r++]);return o(e.ra+t,3)},\"%m\":e=>o(e.pa+1,2),\"%M\":e=>o(e.xa,2),\"%n\":()=>\"\\\\n\",\"%p\":e=>0<=e.oa&&12>e.oa?\"AM\":\"PM\",\"%S\":e=>o(e.ya,2),\"%t\":()=>\"\\\\t\",\"%u\":e=>e.ha||7,\"%U\":e=>o(Math.floor((e.ma+7-e.ha)/7),2),\"%V\":e=>{var t=Math.floor((e.ma+7-(e.ha+6)%7)/7);if(2>=(e.ha+371-e.ma-2)%7&&t++,t)53==t&&(4==(r=(e.ha+371-e.ma)%7)||3==r&&Z(e.na)||(t=1));else{t=52;var r=(e.ha+7-e.ma-1)%7;(4==r||5==r&&Z(e.na%400-1))&&t++}return o(t,2)},\"%w\":e=>e.ha,\"%W\":e=>o(Math.floor((e.ma+7-(e.ha+6)%7)/7),2),\"%y\":e=>(e.na+1900).toString().substring(2),\"%Y\":e=>e.na+1900,\"%z\":e=>{var t=0<=(e=e.wa);return e=Math.abs(e)/60,(t?\"+\":\"-\")+String(\"0000\"+(e/60*100+e%60)).slice(-4)},\"%Z\":e=>e.za,\"%%\":()=>\"%\"},r=r.replace(/%%/g,\"\\\\0\\\\0\"),c)r.includes(l)&&(r=r.replace(new RegExp(l,\"g\"),c[l](n)));return l=function(e){var t=Array(X(e)+1);return K(e,t,0,t.length),t}(r=r.replace(/\\\\0\\\\0/g,\"%\")),l.length>t?0:(S.set(l,e>>>0),l.length-1)}var ce={a:function(e,t,r){throw new B(e>>>=0).sa(t>>>0,r>>>0),e},e:function(){return 0},I:function(){},y:function(){},A:function(){},K:function(){return 0},G:function(){},B:function(){},F:function(){},g:function(){},z:function(){},w:function(){},H:function(){},x:function(){},k:()=>!0,n:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),A[r>>2>>>0]=e.getUTCSeconds(),A[r+4>>2>>>0]=e.getUTCMinutes(),A[r+8>>2>>>0]=e.getUTCHours(),A[r+12>>2>>>0]=e.getUTCDate(),A[r+16>>2>>>0]=e.getUTCMonth(),A[r+20>>2>>>0]=e.getUTCFullYear()-1900,A[r+24>>2>>>0]=e.getUTCDay(),A[r+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},o:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),A[r>>2>>>0]=e.getSeconds(),A[r+4>>2>>>0]=e.getMinutes(),A[r+8>>2>>>0]=e.getHours(),A[r+12>>2>>>0]=e.getDate(),A[r+16>>2>>>0]=e.getMonth(),A[r+20>>2>>>0]=e.getFullYear()-1900,A[r+24>>2>>>0]=e.getDay(),A[r+28>>2>>>0]=(Z(e.getFullYear())?Q:ee)[e.getMonth()]+e.getDate()-1|0,A[r+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var n=new Date(e.getFullYear(),0,1).getTimezoneOffset();A[r+32>>2>>>0]=0|(t!=n&&e.getTimezoneOffset()==Math.min(n,t))},p:function(e){e>>>=0;var t=new Date(A[e+20>>2>>>0]+1900,A[e+16>>2>>>0],A[e+12>>2>>>0],A[e+8>>2>>>0],A[e+4>>2>>>0],A[e>>2>>>0],0),r=A[e+32>>2>>>0],n=t.getTimezoneOffset(),a=new Date(t.getFullYear(),6,1).getTimezoneOffset(),o=new Date(t.getFullYear(),0,1).getTimezoneOffset(),i=Math.min(o,a);return 0>r?A[e+32>>2>>>0]=Number(a!=o&&i==n):0<r!=(i==n)&&(a=Math.max(o,a),t.setTime(t.getTime()+6e4*((0<r?i:a)-n))),A[e+24>>2>>>0]=t.getDay(),A[e+28>>2>>>0]=(Z(t.getFullYear())?Q:ee)[t.getMonth()]+t.getDate()-1|0,A[e>>2>>>0]=t.getSeconds(),A[e+4>>2>>>0]=t.getMinutes(),A[e+8>>2>>>0]=t.getHours(),A[e+12>>2>>>0]=t.getDate(),A[e+16>>2>>>0]=t.getMonth(),A[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,de((x=e,1<=+Math.abs(x)?0<x?+Math.floor(x/4294967296)>>>0:~~+Math.ceil((x-+(~~x>>>0))/4294967296)>>>0:0)),e>>>0},l:function(){return-52},m:function(){},u:function(e,t,r){function n(e){return(e=e.toTimeString().match(/\\\\(([A-Za-z ]+)\\\\)$/))?e[1]:\"GMT\"}r>>>=0;var a=(new Date).getFullYear(),o=new Date(a,0,1),i=new Date(a,6,1);a=o.getTimezoneOffset();var s=i.getTimezoneOffset();T[e>>>0>>2>>>0]=60*Math.max(a,s),A[t>>>0>>2>>>0]=Number(a!=s),e=n(o),t=n(i),e=te(e),t=te(t),s<a?(T[r>>2>>>0]=e,T[r+4>>2>>>0]=t):(T[r>>2>>>0]=t,T[r+4>>2>>>0]=e)},d:()=>{W(\"\")},h:function(){return Date.now()},v:function(){return 4294901760},b:()=>performance.now(),J:function(e,t,r){return t>>>=0,E.copyWithin(e>>>0>>>0,t>>>0,t+(r>>>0)>>>0)},t:function(e){e>>>=0;var t=E.length;if(4294901760<e)return!1;for(var r=1;4>=r;r*=2){var n=t*(1+.2/r);n=Math.min(n,e+100663296);var a=Math;n=Math.max(e,n);e:{a=a.min.call(a,4294901760,n+(65536-n%65536)%65536)-_.buffer.byteLength+65535>>>16;try{_.grow(a),R();var o=1;break e}catch(e){}o=void 0}if(o)return!0}return!1},D:function(e,t){e>>>=0,t>>>=0;var r=0;return ne().forEach((function(n,a){var o=t+r;for(a=T[e+4*a>>2>>>0]=o,o=0;o<n.length;++o)S[a++>>0>>>0]=n.charCodeAt(o);S[a>>0>>>0]=0,r+=n.length+1})),0},E:function(e,t){e>>>=0,t>>>=0;var r=ne();T[e>>2>>>0]=r.length;var n=0;return r.forEach((function(e){n+=e.length+1})),T[t>>2>>>0]=n,0},s:e=>{w||(a.onExit&&a.onExit(e),M=!0),l(e,new G(e))},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(e,t,r,n){t>>>=0,r>>>=0,n>>>=0;for(var a=0,o=0;o<r;o++){var i=T[t>>2>>>0],s=T[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var c=E[i+u>>>0],l=ae[e];0===c||10===c?((1===e?v:b)(V(l,0)),l.length=0):l.push(c)}a+=s}return T[n>>2>>>0]=a,0},r:function(e,t){return e>>>=0,oe(E.subarray(e>>>0,e+(t>>>0)>>>0)),0},C:ue,c:function(e,t,r,n){return ue(e>>>0,t>>>0,r>>>0,n>>>0)}};!function(){function e(e){if(e=e.exports,O=e=function(e){var t=e=>()=>e()>>>0,r=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.malloc=r(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=r(e.stackAlloc),e}(e),_=O.L,R(),k.unshift(O.M),I--,a.monitorRunDependencies&&a.monitorRunDependencies(I),0==I&&(null!==U&&(clearInterval(U),U=null),L)){var t=L;L=null,t()}return e}var t={a:ce};if(I++,a.monitorRunDependencies&&a.monitorRunDependencies(I),a.instantiateWasm)try{return a.instantiateWasm(t,e)}catch(e){b(\"Module.instantiateWasm callback failed with error: \"+e),n(e)}(function(e,t){var r=D;return y||\"function\"!=typeof WebAssembly.instantiateStreaming||H(r)||r.startsWith(\"file://\")||p||\"function\"!=typeof fetch?z(r,e,t):fetch(r,{credentials:\"same-origin\"}).then((n=>WebAssembly.instantiateStreaming(n,e).then(t,(function(n){return b(\"wasm streaming compile failed: \"+n),b(\"falling back to ArrayBuffer instantiation\"),z(r,e,t)}))))})(t,(function(t){e(t.instance)})).catch(n)}(),a._OrtInit=(e,t)=>(a._OrtInit=O.N)(e,t),a._OrtGetLastError=(e,t)=>(a._OrtGetLastError=O.O)(e,t),a._OrtCreateSessionOptions=(e,t,r,n,o,i,s,u,c,l)=>(a._OrtCreateSessionOptions=O.P)(e,t,r,n,o,i,s,u,c,l),a._OrtAppendExecutionProvider=(e,t)=>(a._OrtAppendExecutionProvider=O.Q)(e,t),a._OrtAddSessionConfigEntry=(e,t,r)=>(a._OrtAddSessionConfigEntry=O.R)(e,t,r),a._OrtReleaseSessionOptions=e=>(a._OrtReleaseSessionOptions=O.S)(e),a._OrtCreateSession=(e,t,r)=>(a._OrtCreateSession=O.T)(e,t,r),a._OrtReleaseSession=e=>(a._OrtReleaseSession=O.U)(e),a._OrtGetInputOutputCount=(e,t,r)=>(a._OrtGetInputOutputCount=O.V)(e,t,r),a._OrtGetInputName=(e,t)=>(a._OrtGetInputName=O.W)(e,t),a._OrtGetOutputName=(e,t)=>(a._OrtGetOutputName=O.X)(e,t),a._OrtFree=e=>(a._OrtFree=O.Y)(e),a._OrtCreateTensor=(e,t,r,n,o)=>(a._OrtCreateTensor=O.Z)(e,t,r,n,o),a._OrtGetTensorData=(e,t,r,n,o)=>(a._OrtGetTensorData=O._)(e,t,r,n,o),a._OrtReleaseTensor=e=>(a._OrtReleaseTensor=O.$)(e),a._OrtCreateRunOptions=(e,t,r,n)=>(a._OrtCreateRunOptions=O.aa)(e,t,r,n),a._OrtAddRunConfigEntry=(e,t,r)=>(a._OrtAddRunConfigEntry=O.ba)(e,t,r),a._OrtReleaseRunOptions=e=>(a._OrtReleaseRunOptions=O.ca)(e),a._OrtRun=(e,t,r,n,o,i,s,u)=>(a._OrtRun=O.da)(e,t,r,n,o,i,s,u),a._OrtEndProfiling=e=>(a._OrtEndProfiling=O.ea)(e);var le=a._malloc=e=>(le=a._malloc=O.fa)(e);a._free=e=>(a._free=O.ga)(e);var fe,de=e=>(de=O.ia)(e),pe=()=>(pe=O.ja)(),ge=e=>(ge=O.ka)(e),he=e=>(he=O.la)(e);function me(){function e(){if(!fe&&(fe=!0,a.calledRun=!0,!M)){if(N(k),t(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),a.postRun)for(\"function\"==typeof a.postRun&&(a.postRun=[a.postRun]);a.postRun.length;){var e=a.postRun.shift();C.unshift(e)}N(C)}}if(!(0<I)){if(a.preRun)for(\"function\"==typeof a.preRun&&(a.preRun=[a.preRun]);a.preRun.length;)P();N(F),0<I||(a.setStatus?(a.setStatus(\"Running...\"),setTimeout((function(){setTimeout((function(){a.setStatus(\"\")}),1),e()}),1)):e())}}if(a.stackAlloc=he,a.stackSave=pe,a.stackRestore=ge,a.UTF8ToString=J,a.stringToUTF8=(e,t,r)=>K(e,E,t,r),a.lengthBytesUTF8=X,L=function e(){fe||me(),fe||(L=e)},a.preInit)for(\"function\"==typeof a.preInit&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();return me(),e.ready});e.exports=n},154:e=>{\"use strict\";e.exports=\\'\"use strict\";var e={},a=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node;if(a){var r=require(\"worker_threads\"),t=r.parentPort;t.on(\"message\",(e=>onmessage({data:e})));var s=require(\"fs\");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:e=>(0,eval)(s.readFileSync(e,\"utf8\")+\"//# sourceURL=\"+e),postMessage:e=>t.postMessage(e),performance:global.performance||{now:Date.now}})}var o=!1,d=function(){var e=Array.prototype.slice.call(arguments).join(\" \");a?s.writeSync(2,e+\"\\\\\\\\n\"):console.error(e)};self.alert=function(){var a=Array.prototype.slice.call(arguments).join(\" \");postMessage({cmd:\"alert\",text:a,threadId:e._pthread_self()})},e.instantiateWasm=(a,r)=>{var t=e.wasmModule;return e.wasmModule=null,r(new WebAssembly.Instance(t,a))},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=function a(r){try{if(\"load\"===r.data.cmd){let s=[];self.onmessage=e=>s.push(e),self.startWorker=r=>{e=r,postMessage({cmd:\"loaded\"});for(let e of s)a(e);self.onmessage=a},e.wasmModule=r.data.wasmModule;for(const a of r.data.handlers)e[a]=(...e)=>{postMessage({cmd:\"callHandler\",handler:a,args:e})};if(e.wasmMemory=r.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,\"string\"==typeof r.data.urlOrBlob)importScripts(r.data.urlOrBlob);else{var t=URL.createObjectURL(r.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(e)}else if(\"run\"===r.data.cmd){e.__emscripten_thread_init(r.data.pthread_ptr,0,0,1),e.__emscripten_thread_mailbox_await(r.data.pthread_ptr),e.establishStackSpace(),e.PThread.receiveObjectTransfer(r.data),e.PThread.threadInitTLS(),o||(o=!0);try{e.invokeEntryPoint(r.data.start_routine,r.data.arg)}catch(e){if(\"unwind\"!=e)throw e}}else\"cancel\"===r.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):\"setimmediate\"===r.data.target||(\"checkMailbox\"===r.data.cmd?o&&e.checkMailbox():r.data.cmd&&(d(\"worker.js received unknown command \"+r.data.cmd),d(r.data)))}catch(a){throw e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),a}};\\\\n\\'},760:()=>{},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},t={};function r(n){var a=t[n];if(void 0!==a)return a.exports;var o=t[n]={exports:{}};return e[n].call(o.exports,o,o.exports,r),o.exports}(()=>{\"use strict\";const e=r(259),t=r(263);self.onmessage=r=>{switch(r.data.type){case\"init-wasm\":try{(0,t.initializeWebAssembly)(r.data.in).then((()=>postMessage({type:\"init-wasm\"})),(e=>postMessage({type:\"init-wasm\",err:e})))}catch(e){postMessage({type:\"init-wasm\",err:e})}break;case\"init-ort\":try{(0,e.initRuntime)(r.data.in).then((()=>postMessage({type:\"init-ort\"})),(e=>postMessage({type:\"init-ort\",err:e}))),postMessage({type:\"init-ort\"})}catch(e){postMessage({type:\"init-ort\",err:e})}break;case\"create_allocate\":try{const{model:t}=r.data.in,n=(0,e.createSessionAllocate)(t);postMessage({type:\"create_allocate\",out:n})}catch(e){postMessage({type:\"create_allocate\",err:e})}break;case\"create_finalize\":try{const{modeldata:t,options:n}=r.data.in,a=(0,e.createSessionFinalize)(t,n);postMessage({type:\"create_finalize\",out:a})}catch(e){postMessage({type:\"create_finalize\",err:e})}break;case\"create\":try{const{model:t,options:n}=r.data.in,a=(0,e.createSession)(t,n);postMessage({type:\"create\",out:a})}catch(e){postMessage({type:\"create\",err:e})}break;case\"release\":try{const t=r.data.in;(0,e.releaseSession)(t),postMessage({type:\"release\"})}catch(e){postMessage({type:\"release\",err:e})}break;case\"run\":try{const{sessionId:t,inputIndices:n,inputs:a,outputIndices:o,options:i}=r.data.in;(0,e.run)(t,n,a,o,i).then((t=>{postMessage({type:\"run\",out:t},(0,e.extractTransferableBuffers)(t))}),(e=>{postMessage({type:\"run\",err:e})}))}catch(e){postMessage({type:\"run\",err:e})}break;case\"end-profiling\":try{const t=r.data.in;(0,e.endProfiling)(t),postMessage({type:\"end-profiling\"})}catch(e){postMessage({type:\"end-profiling\",err:e})}}}})()})();\\n', \"Worker\", void 0, void 0);\n        }\n      },\n      6614: e => {\n        \"use strict\";\n\n        e.exports = function (e, t, n, r) {\n          var o = self || window;\n          try {\n            try {\n              var i;\n              try {\n                i = new o.Blob([e]);\n              } catch (t) {\n                (i = new (o.BlobBuilder || o.WebKitBlobBuilder || o.MozBlobBuilder || o.MSBlobBuilder)()).append(e), i = i.getBlob();\n              }\n              var a = o.URL || o.webkitURL,\n                s = a.createObjectURL(i),\n                u = new o[t](s, n);\n              return a.revokeObjectURL(s), u;\n            } catch (r) {\n              return new o[t](\"data:application/javascript,\".concat(encodeURIComponent(e)), n);\n            }\n          } catch (e) {\n            if (!r) throw Error(\"Inline worker is not supported\");\n            return new o[t](r, n);\n          }\n        };\n      },\n      2446: (e, t, n) => {\n        \"use strict\";\n\n        var r,\n          o,\n          i,\n          a = n(2100),\n          s = a.Reader,\n          u = a.Writer,\n          l = a.util,\n          c = a.roots.default || (a.roots.default = {});\n        c.onnx = ((i = {}).Version = (r = {}, (o = Object.create(r))[r[0] = \"_START_VERSION\"] = 0, o[r[1] = \"IR_VERSION_2017_10_10\"] = 1, o[r[2] = \"IR_VERSION_2017_10_30\"] = 2, o[r[3] = \"IR_VERSION_2017_11_3\"] = 3, o[r[4] = \"IR_VERSION_2019_1_22\"] = 4, o[r[5] = \"IR_VERSION_2019_3_18\"] = 5, o[r[6] = \"IR_VERSION_2019_9_19\"] = 6, o[r[7] = \"IR_VERSION_2020_5_8\"] = 7, o[r[8] = \"IR_VERSION_2021_7_30\"] = 8, o[r[9] = \"IR_VERSION\"] = 9, o), i.AttributeProto = function () {\n          function e(e) {\n            if (this.floats = [], this.ints = [], this.strings = [], this.tensors = [], this.graphs = [], this.sparseTensors = [], this.typeProtos = [], e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n          }\n          return e.prototype.name = \"\", e.prototype.refAttrName = \"\", e.prototype.docString = \"\", e.prototype.type = 0, e.prototype.f = 0, e.prototype.i = l.Long ? l.Long.fromBits(0, 0, !1) : 0, e.prototype.s = l.newBuffer([]), e.prototype.t = null, e.prototype.g = null, e.prototype.sparseTensor = null, e.prototype.tp = null, e.prototype.floats = l.emptyArray, e.prototype.ints = l.emptyArray, e.prototype.strings = l.emptyArray, e.prototype.tensors = l.emptyArray, e.prototype.graphs = l.emptyArray, e.prototype.sparseTensors = l.emptyArray, e.prototype.typeProtos = l.emptyArray, e.create = function (t) {\n            return new e(t);\n          }, e.encode = function (e, t) {\n            if (t || (t = u.create()), null != e.name && Object.hasOwnProperty.call(e, \"name\") && t.uint32(10).string(e.name), null != e.f && Object.hasOwnProperty.call(e, \"f\") && t.uint32(21).float(e.f), null != e.i && Object.hasOwnProperty.call(e, \"i\") && t.uint32(24).int64(e.i), null != e.s && Object.hasOwnProperty.call(e, \"s\") && t.uint32(34).bytes(e.s), null != e.t && Object.hasOwnProperty.call(e, \"t\") && c.onnx.TensorProto.encode(e.t, t.uint32(42).fork()).ldelim(), null != e.g && Object.hasOwnProperty.call(e, \"g\") && c.onnx.GraphProto.encode(e.g, t.uint32(50).fork()).ldelim(), null != e.floats && e.floats.length) {\n              t.uint32(58).fork();\n              for (var n = 0; n < e.floats.length; ++n) t.float(e.floats[n]);\n              t.ldelim();\n            }\n            if (null != e.ints && e.ints.length) {\n              for (t.uint32(66).fork(), n = 0; n < e.ints.length; ++n) t.int64(e.ints[n]);\n              t.ldelim();\n            }\n            if (null != e.strings && e.strings.length) for (n = 0; n < e.strings.length; ++n) t.uint32(74).bytes(e.strings[n]);\n            if (null != e.tensors && e.tensors.length) for (n = 0; n < e.tensors.length; ++n) c.onnx.TensorProto.encode(e.tensors[n], t.uint32(82).fork()).ldelim();\n            if (null != e.graphs && e.graphs.length) for (n = 0; n < e.graphs.length; ++n) c.onnx.GraphProto.encode(e.graphs[n], t.uint32(90).fork()).ldelim();\n            if (null != e.docString && Object.hasOwnProperty.call(e, \"docString\") && t.uint32(106).string(e.docString), null != e.tp && Object.hasOwnProperty.call(e, \"tp\") && c.onnx.TypeProto.encode(e.tp, t.uint32(114).fork()).ldelim(), null != e.typeProtos && e.typeProtos.length) for (n = 0; n < e.typeProtos.length; ++n) c.onnx.TypeProto.encode(e.typeProtos[n], t.uint32(122).fork()).ldelim();\n            if (null != e.type && Object.hasOwnProperty.call(e, \"type\") && t.uint32(160).int32(e.type), null != e.refAttrName && Object.hasOwnProperty.call(e, \"refAttrName\") && t.uint32(170).string(e.refAttrName), null != e.sparseTensor && Object.hasOwnProperty.call(e, \"sparseTensor\") && c.onnx.SparseTensorProto.encode(e.sparseTensor, t.uint32(178).fork()).ldelim(), null != e.sparseTensors && e.sparseTensors.length) for (n = 0; n < e.sparseTensors.length; ++n) c.onnx.SparseTensorProto.encode(e.sparseTensors[n], t.uint32(186).fork()).ldelim();\n            return t;\n          }, e.encodeDelimited = function (e, t) {\n            return this.encode(e, t).ldelim();\n          }, e.decode = function (e, t) {\n            e instanceof s || (e = s.create(e));\n            for (var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.AttributeProto(); e.pos < n;) {\n              var o = e.uint32();\n              switch (o >>> 3) {\n                case 1:\n                  r.name = e.string();\n                  break;\n                case 21:\n                  r.refAttrName = e.string();\n                  break;\n                case 13:\n                  r.docString = e.string();\n                  break;\n                case 20:\n                  r.type = e.int32();\n                  break;\n                case 2:\n                  r.f = e.float();\n                  break;\n                case 3:\n                  r.i = e.int64();\n                  break;\n                case 4:\n                  r.s = e.bytes();\n                  break;\n                case 5:\n                  r.t = c.onnx.TensorProto.decode(e, e.uint32());\n                  break;\n                case 6:\n                  r.g = c.onnx.GraphProto.decode(e, e.uint32());\n                  break;\n                case 22:\n                  r.sparseTensor = c.onnx.SparseTensorProto.decode(e, e.uint32());\n                  break;\n                case 14:\n                  r.tp = c.onnx.TypeProto.decode(e, e.uint32());\n                  break;\n                case 7:\n                  if (r.floats && r.floats.length || (r.floats = []), 2 == (7 & o)) for (var i = e.uint32() + e.pos; e.pos < i;) r.floats.push(e.float());else r.floats.push(e.float());\n                  break;\n                case 8:\n                  if (r.ints && r.ints.length || (r.ints = []), 2 == (7 & o)) for (i = e.uint32() + e.pos; e.pos < i;) r.ints.push(e.int64());else r.ints.push(e.int64());\n                  break;\n                case 9:\n                  r.strings && r.strings.length || (r.strings = []), r.strings.push(e.bytes());\n                  break;\n                case 10:\n                  r.tensors && r.tensors.length || (r.tensors = []), r.tensors.push(c.onnx.TensorProto.decode(e, e.uint32()));\n                  break;\n                case 11:\n                  r.graphs && r.graphs.length || (r.graphs = []), r.graphs.push(c.onnx.GraphProto.decode(e, e.uint32()));\n                  break;\n                case 23:\n                  r.sparseTensors && r.sparseTensors.length || (r.sparseTensors = []), r.sparseTensors.push(c.onnx.SparseTensorProto.decode(e, e.uint32()));\n                  break;\n                case 15:\n                  r.typeProtos && r.typeProtos.length || (r.typeProtos = []), r.typeProtos.push(c.onnx.TypeProto.decode(e, e.uint32()));\n                  break;\n                default:\n                  e.skipType(7 & o);\n              }\n            }\n            return r;\n          }, e.decodeDelimited = function (e) {\n            return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n          }, e.verify = function (e) {\n            if (\"object\" != typeof e || null === e) return \"object expected\";\n            if (null != e.name && e.hasOwnProperty(\"name\") && !l.isString(e.name)) return \"name: string expected\";\n            if (null != e.refAttrName && e.hasOwnProperty(\"refAttrName\") && !l.isString(e.refAttrName)) return \"refAttrName: string expected\";\n            if (null != e.docString && e.hasOwnProperty(\"docString\") && !l.isString(e.docString)) return \"docString: string expected\";\n            if (null != e.type && e.hasOwnProperty(\"type\")) switch (e.type) {\n              default:\n                return \"type: enum value expected\";\n              case 0:\n              case 1:\n              case 2:\n              case 3:\n              case 4:\n              case 5:\n              case 11:\n              case 13:\n              case 6:\n              case 7:\n              case 8:\n              case 9:\n              case 10:\n              case 12:\n              case 14:\n            }\n            if (null != e.f && e.hasOwnProperty(\"f\") && \"number\" != typeof e.f) return \"f: number expected\";\n            if (null != e.i && e.hasOwnProperty(\"i\") && !(l.isInteger(e.i) || e.i && l.isInteger(e.i.low) && l.isInteger(e.i.high))) return \"i: integer|Long expected\";\n            if (null != e.s && e.hasOwnProperty(\"s\") && !(e.s && \"number\" == typeof e.s.length || l.isString(e.s))) return \"s: buffer expected\";\n            if (null != e.t && e.hasOwnProperty(\"t\") && (n = c.onnx.TensorProto.verify(e.t))) return \"t.\" + n;\n            if (null != e.g && e.hasOwnProperty(\"g\") && (n = c.onnx.GraphProto.verify(e.g))) return \"g.\" + n;\n            if (null != e.sparseTensor && e.hasOwnProperty(\"sparseTensor\") && (n = c.onnx.SparseTensorProto.verify(e.sparseTensor))) return \"sparseTensor.\" + n;\n            if (null != e.tp && e.hasOwnProperty(\"tp\") && (n = c.onnx.TypeProto.verify(e.tp))) return \"tp.\" + n;\n            if (null != e.floats && e.hasOwnProperty(\"floats\")) {\n              if (!Array.isArray(e.floats)) return \"floats: array expected\";\n              for (var t = 0; t < e.floats.length; ++t) if (\"number\" != typeof e.floats[t]) return \"floats: number[] expected\";\n            }\n            if (null != e.ints && e.hasOwnProperty(\"ints\")) {\n              if (!Array.isArray(e.ints)) return \"ints: array expected\";\n              for (t = 0; t < e.ints.length; ++t) if (!(l.isInteger(e.ints[t]) || e.ints[t] && l.isInteger(e.ints[t].low) && l.isInteger(e.ints[t].high))) return \"ints: integer|Long[] expected\";\n            }\n            if (null != e.strings && e.hasOwnProperty(\"strings\")) {\n              if (!Array.isArray(e.strings)) return \"strings: array expected\";\n              for (t = 0; t < e.strings.length; ++t) if (!(e.strings[t] && \"number\" == typeof e.strings[t].length || l.isString(e.strings[t]))) return \"strings: buffer[] expected\";\n            }\n            if (null != e.tensors && e.hasOwnProperty(\"tensors\")) {\n              if (!Array.isArray(e.tensors)) return \"tensors: array expected\";\n              for (t = 0; t < e.tensors.length; ++t) if (n = c.onnx.TensorProto.verify(e.tensors[t])) return \"tensors.\" + n;\n            }\n            if (null != e.graphs && e.hasOwnProperty(\"graphs\")) {\n              if (!Array.isArray(e.graphs)) return \"graphs: array expected\";\n              for (t = 0; t < e.graphs.length; ++t) if (n = c.onnx.GraphProto.verify(e.graphs[t])) return \"graphs.\" + n;\n            }\n            if (null != e.sparseTensors && e.hasOwnProperty(\"sparseTensors\")) {\n              if (!Array.isArray(e.sparseTensors)) return \"sparseTensors: array expected\";\n              for (t = 0; t < e.sparseTensors.length; ++t) if (n = c.onnx.SparseTensorProto.verify(e.sparseTensors[t])) return \"sparseTensors.\" + n;\n            }\n            if (null != e.typeProtos && e.hasOwnProperty(\"typeProtos\")) {\n              if (!Array.isArray(e.typeProtos)) return \"typeProtos: array expected\";\n              for (t = 0; t < e.typeProtos.length; ++t) {\n                var n;\n                if (n = c.onnx.TypeProto.verify(e.typeProtos[t])) return \"typeProtos.\" + n;\n              }\n            }\n            return null;\n          }, e.fromObject = function (e) {\n            if (e instanceof c.onnx.AttributeProto) return e;\n            var t = new c.onnx.AttributeProto();\n            switch (null != e.name && (t.name = String(e.name)), null != e.refAttrName && (t.refAttrName = String(e.refAttrName)), null != e.docString && (t.docString = String(e.docString)), e.type) {\n              default:\n                if (\"number\" == typeof e.type) {\n                  t.type = e.type;\n                  break;\n                }\n                break;\n              case \"UNDEFINED\":\n              case 0:\n                t.type = 0;\n                break;\n              case \"FLOAT\":\n              case 1:\n                t.type = 1;\n                break;\n              case \"INT\":\n              case 2:\n                t.type = 2;\n                break;\n              case \"STRING\":\n              case 3:\n                t.type = 3;\n                break;\n              case \"TENSOR\":\n              case 4:\n                t.type = 4;\n                break;\n              case \"GRAPH\":\n              case 5:\n                t.type = 5;\n                break;\n              case \"SPARSE_TENSOR\":\n              case 11:\n                t.type = 11;\n                break;\n              case \"TYPE_PROTO\":\n              case 13:\n                t.type = 13;\n                break;\n              case \"FLOATS\":\n              case 6:\n                t.type = 6;\n                break;\n              case \"INTS\":\n              case 7:\n                t.type = 7;\n                break;\n              case \"STRINGS\":\n              case 8:\n                t.type = 8;\n                break;\n              case \"TENSORS\":\n              case 9:\n                t.type = 9;\n                break;\n              case \"GRAPHS\":\n              case 10:\n                t.type = 10;\n                break;\n              case \"SPARSE_TENSORS\":\n              case 12:\n                t.type = 12;\n                break;\n              case \"TYPE_PROTOS\":\n              case 14:\n                t.type = 14;\n            }\n            if (null != e.f && (t.f = Number(e.f)), null != e.i && (l.Long ? (t.i = l.Long.fromValue(e.i)).unsigned = !1 : \"string\" == typeof e.i ? t.i = parseInt(e.i, 10) : \"number\" == typeof e.i ? t.i = e.i : \"object\" == typeof e.i && (t.i = new l.LongBits(e.i.low >>> 0, e.i.high >>> 0).toNumber())), null != e.s && (\"string\" == typeof e.s ? l.base64.decode(e.s, t.s = l.newBuffer(l.base64.length(e.s)), 0) : e.s.length >= 0 && (t.s = e.s)), null != e.t) {\n              if (\"object\" != typeof e.t) throw TypeError(\".onnx.AttributeProto.t: object expected\");\n              t.t = c.onnx.TensorProto.fromObject(e.t);\n            }\n            if (null != e.g) {\n              if (\"object\" != typeof e.g) throw TypeError(\".onnx.AttributeProto.g: object expected\");\n              t.g = c.onnx.GraphProto.fromObject(e.g);\n            }\n            if (null != e.sparseTensor) {\n              if (\"object\" != typeof e.sparseTensor) throw TypeError(\".onnx.AttributeProto.sparseTensor: object expected\");\n              t.sparseTensor = c.onnx.SparseTensorProto.fromObject(e.sparseTensor);\n            }\n            if (null != e.tp) {\n              if (\"object\" != typeof e.tp) throw TypeError(\".onnx.AttributeProto.tp: object expected\");\n              t.tp = c.onnx.TypeProto.fromObject(e.tp);\n            }\n            if (e.floats) {\n              if (!Array.isArray(e.floats)) throw TypeError(\".onnx.AttributeProto.floats: array expected\");\n              t.floats = [];\n              for (var n = 0; n < e.floats.length; ++n) t.floats[n] = Number(e.floats[n]);\n            }\n            if (e.ints) {\n              if (!Array.isArray(e.ints)) throw TypeError(\".onnx.AttributeProto.ints: array expected\");\n              for (t.ints = [], n = 0; n < e.ints.length; ++n) l.Long ? (t.ints[n] = l.Long.fromValue(e.ints[n])).unsigned = !1 : \"string\" == typeof e.ints[n] ? t.ints[n] = parseInt(e.ints[n], 10) : \"number\" == typeof e.ints[n] ? t.ints[n] = e.ints[n] : \"object\" == typeof e.ints[n] && (t.ints[n] = new l.LongBits(e.ints[n].low >>> 0, e.ints[n].high >>> 0).toNumber());\n            }\n            if (e.strings) {\n              if (!Array.isArray(e.strings)) throw TypeError(\".onnx.AttributeProto.strings: array expected\");\n              for (t.strings = [], n = 0; n < e.strings.length; ++n) \"string\" == typeof e.strings[n] ? l.base64.decode(e.strings[n], t.strings[n] = l.newBuffer(l.base64.length(e.strings[n])), 0) : e.strings[n].length >= 0 && (t.strings[n] = e.strings[n]);\n            }\n            if (e.tensors) {\n              if (!Array.isArray(e.tensors)) throw TypeError(\".onnx.AttributeProto.tensors: array expected\");\n              for (t.tensors = [], n = 0; n < e.tensors.length; ++n) {\n                if (\"object\" != typeof e.tensors[n]) throw TypeError(\".onnx.AttributeProto.tensors: object expected\");\n                t.tensors[n] = c.onnx.TensorProto.fromObject(e.tensors[n]);\n              }\n            }\n            if (e.graphs) {\n              if (!Array.isArray(e.graphs)) throw TypeError(\".onnx.AttributeProto.graphs: array expected\");\n              for (t.graphs = [], n = 0; n < e.graphs.length; ++n) {\n                if (\"object\" != typeof e.graphs[n]) throw TypeError(\".onnx.AttributeProto.graphs: object expected\");\n                t.graphs[n] = c.onnx.GraphProto.fromObject(e.graphs[n]);\n              }\n            }\n            if (e.sparseTensors) {\n              if (!Array.isArray(e.sparseTensors)) throw TypeError(\".onnx.AttributeProto.sparseTensors: array expected\");\n              for (t.sparseTensors = [], n = 0; n < e.sparseTensors.length; ++n) {\n                if (\"object\" != typeof e.sparseTensors[n]) throw TypeError(\".onnx.AttributeProto.sparseTensors: object expected\");\n                t.sparseTensors[n] = c.onnx.SparseTensorProto.fromObject(e.sparseTensors[n]);\n              }\n            }\n            if (e.typeProtos) {\n              if (!Array.isArray(e.typeProtos)) throw TypeError(\".onnx.AttributeProto.typeProtos: array expected\");\n              for (t.typeProtos = [], n = 0; n < e.typeProtos.length; ++n) {\n                if (\"object\" != typeof e.typeProtos[n]) throw TypeError(\".onnx.AttributeProto.typeProtos: object expected\");\n                t.typeProtos[n] = c.onnx.TypeProto.fromObject(e.typeProtos[n]);\n              }\n            }\n            return t;\n          }, e.toObject = function (e, t) {\n            t || (t = {});\n            var n = {};\n            if ((t.arrays || t.defaults) && (n.floats = [], n.ints = [], n.strings = [], n.tensors = [], n.graphs = [], n.typeProtos = [], n.sparseTensors = []), t.defaults) {\n              if (n.name = \"\", n.f = 0, l.Long) {\n                var r = new l.Long(0, 0, !1);\n                n.i = t.longs === String ? r.toString() : t.longs === Number ? r.toNumber() : r;\n              } else n.i = t.longs === String ? \"0\" : 0;\n              t.bytes === String ? n.s = \"\" : (n.s = [], t.bytes !== Array && (n.s = l.newBuffer(n.s))), n.t = null, n.g = null, n.docString = \"\", n.tp = null, n.type = t.enums === String ? \"UNDEFINED\" : 0, n.refAttrName = \"\", n.sparseTensor = null;\n            }\n            if (null != e.name && e.hasOwnProperty(\"name\") && (n.name = e.name), null != e.f && e.hasOwnProperty(\"f\") && (n.f = t.json && !isFinite(e.f) ? String(e.f) : e.f), null != e.i && e.hasOwnProperty(\"i\") && (\"number\" == typeof e.i ? n.i = t.longs === String ? String(e.i) : e.i : n.i = t.longs === String ? l.Long.prototype.toString.call(e.i) : t.longs === Number ? new l.LongBits(e.i.low >>> 0, e.i.high >>> 0).toNumber() : e.i), null != e.s && e.hasOwnProperty(\"s\") && (n.s = t.bytes === String ? l.base64.encode(e.s, 0, e.s.length) : t.bytes === Array ? Array.prototype.slice.call(e.s) : e.s), null != e.t && e.hasOwnProperty(\"t\") && (n.t = c.onnx.TensorProto.toObject(e.t, t)), null != e.g && e.hasOwnProperty(\"g\") && (n.g = c.onnx.GraphProto.toObject(e.g, t)), e.floats && e.floats.length) {\n              n.floats = [];\n              for (var o = 0; o < e.floats.length; ++o) n.floats[o] = t.json && !isFinite(e.floats[o]) ? String(e.floats[o]) : e.floats[o];\n            }\n            if (e.ints && e.ints.length) for (n.ints = [], o = 0; o < e.ints.length; ++o) \"number\" == typeof e.ints[o] ? n.ints[o] = t.longs === String ? String(e.ints[o]) : e.ints[o] : n.ints[o] = t.longs === String ? l.Long.prototype.toString.call(e.ints[o]) : t.longs === Number ? new l.LongBits(e.ints[o].low >>> 0, e.ints[o].high >>> 0).toNumber() : e.ints[o];\n            if (e.strings && e.strings.length) for (n.strings = [], o = 0; o < e.strings.length; ++o) n.strings[o] = t.bytes === String ? l.base64.encode(e.strings[o], 0, e.strings[o].length) : t.bytes === Array ? Array.prototype.slice.call(e.strings[o]) : e.strings[o];\n            if (e.tensors && e.tensors.length) for (n.tensors = [], o = 0; o < e.tensors.length; ++o) n.tensors[o] = c.onnx.TensorProto.toObject(e.tensors[o], t);\n            if (e.graphs && e.graphs.length) for (n.graphs = [], o = 0; o < e.graphs.length; ++o) n.graphs[o] = c.onnx.GraphProto.toObject(e.graphs[o], t);\n            if (null != e.docString && e.hasOwnProperty(\"docString\") && (n.docString = e.docString), null != e.tp && e.hasOwnProperty(\"tp\") && (n.tp = c.onnx.TypeProto.toObject(e.tp, t)), e.typeProtos && e.typeProtos.length) for (n.typeProtos = [], o = 0; o < e.typeProtos.length; ++o) n.typeProtos[o] = c.onnx.TypeProto.toObject(e.typeProtos[o], t);\n            if (null != e.type && e.hasOwnProperty(\"type\") && (n.type = t.enums === String ? void 0 === c.onnx.AttributeProto.AttributeType[e.type] ? e.type : c.onnx.AttributeProto.AttributeType[e.type] : e.type), null != e.refAttrName && e.hasOwnProperty(\"refAttrName\") && (n.refAttrName = e.refAttrName), null != e.sparseTensor && e.hasOwnProperty(\"sparseTensor\") && (n.sparseTensor = c.onnx.SparseTensorProto.toObject(e.sparseTensor, t)), e.sparseTensors && e.sparseTensors.length) for (n.sparseTensors = [], o = 0; o < e.sparseTensors.length; ++o) n.sparseTensors[o] = c.onnx.SparseTensorProto.toObject(e.sparseTensors[o], t);\n            return n;\n          }, e.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, e.getTypeUrl = function (e) {\n            return void 0 === e && (e = \"type.googleapis.com\"), e + \"/onnx.AttributeProto\";\n          }, e.AttributeType = function () {\n            var e = {},\n              t = Object.create(e);\n            return t[e[0] = \"UNDEFINED\"] = 0, t[e[1] = \"FLOAT\"] = 1, t[e[2] = \"INT\"] = 2, t[e[3] = \"STRING\"] = 3, t[e[4] = \"TENSOR\"] = 4, t[e[5] = \"GRAPH\"] = 5, t[e[11] = \"SPARSE_TENSOR\"] = 11, t[e[13] = \"TYPE_PROTO\"] = 13, t[e[6] = \"FLOATS\"] = 6, t[e[7] = \"INTS\"] = 7, t[e[8] = \"STRINGS\"] = 8, t[e[9] = \"TENSORS\"] = 9, t[e[10] = \"GRAPHS\"] = 10, t[e[12] = \"SPARSE_TENSORS\"] = 12, t[e[14] = \"TYPE_PROTOS\"] = 14, t;\n          }(), e;\n        }(), i.ValueInfoProto = function () {\n          function e(e) {\n            if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n          }\n          return e.prototype.name = \"\", e.prototype.type = null, e.prototype.docString = \"\", e.create = function (t) {\n            return new e(t);\n          }, e.encode = function (e, t) {\n            return t || (t = u.create()), null != e.name && Object.hasOwnProperty.call(e, \"name\") && t.uint32(10).string(e.name), null != e.type && Object.hasOwnProperty.call(e, \"type\") && c.onnx.TypeProto.encode(e.type, t.uint32(18).fork()).ldelim(), null != e.docString && Object.hasOwnProperty.call(e, \"docString\") && t.uint32(26).string(e.docString), t;\n          }, e.encodeDelimited = function (e, t) {\n            return this.encode(e, t).ldelim();\n          }, e.decode = function (e, t) {\n            e instanceof s || (e = s.create(e));\n            for (var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.ValueInfoProto(); e.pos < n;) {\n              var o = e.uint32();\n              switch (o >>> 3) {\n                case 1:\n                  r.name = e.string();\n                  break;\n                case 2:\n                  r.type = c.onnx.TypeProto.decode(e, e.uint32());\n                  break;\n                case 3:\n                  r.docString = e.string();\n                  break;\n                default:\n                  e.skipType(7 & o);\n              }\n            }\n            return r;\n          }, e.decodeDelimited = function (e) {\n            return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n          }, e.verify = function (e) {\n            if (\"object\" != typeof e || null === e) return \"object expected\";\n            if (null != e.name && e.hasOwnProperty(\"name\") && !l.isString(e.name)) return \"name: string expected\";\n            if (null != e.type && e.hasOwnProperty(\"type\")) {\n              var t = c.onnx.TypeProto.verify(e.type);\n              if (t) return \"type.\" + t;\n            }\n            return null != e.docString && e.hasOwnProperty(\"docString\") && !l.isString(e.docString) ? \"docString: string expected\" : null;\n          }, e.fromObject = function (e) {\n            if (e instanceof c.onnx.ValueInfoProto) return e;\n            var t = new c.onnx.ValueInfoProto();\n            if (null != e.name && (t.name = String(e.name)), null != e.type) {\n              if (\"object\" != typeof e.type) throw TypeError(\".onnx.ValueInfoProto.type: object expected\");\n              t.type = c.onnx.TypeProto.fromObject(e.type);\n            }\n            return null != e.docString && (t.docString = String(e.docString)), t;\n          }, e.toObject = function (e, t) {\n            t || (t = {});\n            var n = {};\n            return t.defaults && (n.name = \"\", n.type = null, n.docString = \"\"), null != e.name && e.hasOwnProperty(\"name\") && (n.name = e.name), null != e.type && e.hasOwnProperty(\"type\") && (n.type = c.onnx.TypeProto.toObject(e.type, t)), null != e.docString && e.hasOwnProperty(\"docString\") && (n.docString = e.docString), n;\n          }, e.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, e.getTypeUrl = function (e) {\n            return void 0 === e && (e = \"type.googleapis.com\"), e + \"/onnx.ValueInfoProto\";\n          }, e;\n        }(), i.NodeProto = function () {\n          function e(e) {\n            if (this.input = [], this.output = [], this.attribute = [], e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n          }\n          return e.prototype.input = l.emptyArray, e.prototype.output = l.emptyArray, e.prototype.name = \"\", e.prototype.opType = \"\", e.prototype.domain = \"\", e.prototype.attribute = l.emptyArray, e.prototype.docString = \"\", e.create = function (t) {\n            return new e(t);\n          }, e.encode = function (e, t) {\n            if (t || (t = u.create()), null != e.input && e.input.length) for (var n = 0; n < e.input.length; ++n) t.uint32(10).string(e.input[n]);\n            if (null != e.output && e.output.length) for (n = 0; n < e.output.length; ++n) t.uint32(18).string(e.output[n]);\n            if (null != e.name && Object.hasOwnProperty.call(e, \"name\") && t.uint32(26).string(e.name), null != e.opType && Object.hasOwnProperty.call(e, \"opType\") && t.uint32(34).string(e.opType), null != e.attribute && e.attribute.length) for (n = 0; n < e.attribute.length; ++n) c.onnx.AttributeProto.encode(e.attribute[n], t.uint32(42).fork()).ldelim();\n            return null != e.docString && Object.hasOwnProperty.call(e, \"docString\") && t.uint32(50).string(e.docString), null != e.domain && Object.hasOwnProperty.call(e, \"domain\") && t.uint32(58).string(e.domain), t;\n          }, e.encodeDelimited = function (e, t) {\n            return this.encode(e, t).ldelim();\n          }, e.decode = function (e, t) {\n            e instanceof s || (e = s.create(e));\n            for (var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.NodeProto(); e.pos < n;) {\n              var o = e.uint32();\n              switch (o >>> 3) {\n                case 1:\n                  r.input && r.input.length || (r.input = []), r.input.push(e.string());\n                  break;\n                case 2:\n                  r.output && r.output.length || (r.output = []), r.output.push(e.string());\n                  break;\n                case 3:\n                  r.name = e.string();\n                  break;\n                case 4:\n                  r.opType = e.string();\n                  break;\n                case 7:\n                  r.domain = e.string();\n                  break;\n                case 5:\n                  r.attribute && r.attribute.length || (r.attribute = []), r.attribute.push(c.onnx.AttributeProto.decode(e, e.uint32()));\n                  break;\n                case 6:\n                  r.docString = e.string();\n                  break;\n                default:\n                  e.skipType(7 & o);\n              }\n            }\n            return r;\n          }, e.decodeDelimited = function (e) {\n            return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n          }, e.verify = function (e) {\n            if (\"object\" != typeof e || null === e) return \"object expected\";\n            if (null != e.input && e.hasOwnProperty(\"input\")) {\n              if (!Array.isArray(e.input)) return \"input: array expected\";\n              for (var t = 0; t < e.input.length; ++t) if (!l.isString(e.input[t])) return \"input: string[] expected\";\n            }\n            if (null != e.output && e.hasOwnProperty(\"output\")) {\n              if (!Array.isArray(e.output)) return \"output: array expected\";\n              for (t = 0; t < e.output.length; ++t) if (!l.isString(e.output[t])) return \"output: string[] expected\";\n            }\n            if (null != e.name && e.hasOwnProperty(\"name\") && !l.isString(e.name)) return \"name: string expected\";\n            if (null != e.opType && e.hasOwnProperty(\"opType\") && !l.isString(e.opType)) return \"opType: string expected\";\n            if (null != e.domain && e.hasOwnProperty(\"domain\") && !l.isString(e.domain)) return \"domain: string expected\";\n            if (null != e.attribute && e.hasOwnProperty(\"attribute\")) {\n              if (!Array.isArray(e.attribute)) return \"attribute: array expected\";\n              for (t = 0; t < e.attribute.length; ++t) {\n                var n = c.onnx.AttributeProto.verify(e.attribute[t]);\n                if (n) return \"attribute.\" + n;\n              }\n            }\n            return null != e.docString && e.hasOwnProperty(\"docString\") && !l.isString(e.docString) ? \"docString: string expected\" : null;\n          }, e.fromObject = function (e) {\n            if (e instanceof c.onnx.NodeProto) return e;\n            var t = new c.onnx.NodeProto();\n            if (e.input) {\n              if (!Array.isArray(e.input)) throw TypeError(\".onnx.NodeProto.input: array expected\");\n              t.input = [];\n              for (var n = 0; n < e.input.length; ++n) t.input[n] = String(e.input[n]);\n            }\n            if (e.output) {\n              if (!Array.isArray(e.output)) throw TypeError(\".onnx.NodeProto.output: array expected\");\n              for (t.output = [], n = 0; n < e.output.length; ++n) t.output[n] = String(e.output[n]);\n            }\n            if (null != e.name && (t.name = String(e.name)), null != e.opType && (t.opType = String(e.opType)), null != e.domain && (t.domain = String(e.domain)), e.attribute) {\n              if (!Array.isArray(e.attribute)) throw TypeError(\".onnx.NodeProto.attribute: array expected\");\n              for (t.attribute = [], n = 0; n < e.attribute.length; ++n) {\n                if (\"object\" != typeof e.attribute[n]) throw TypeError(\".onnx.NodeProto.attribute: object expected\");\n                t.attribute[n] = c.onnx.AttributeProto.fromObject(e.attribute[n]);\n              }\n            }\n            return null != e.docString && (t.docString = String(e.docString)), t;\n          }, e.toObject = function (e, t) {\n            t || (t = {});\n            var n = {};\n            if ((t.arrays || t.defaults) && (n.input = [], n.output = [], n.attribute = []), t.defaults && (n.name = \"\", n.opType = \"\", n.docString = \"\", n.domain = \"\"), e.input && e.input.length) {\n              n.input = [];\n              for (var r = 0; r < e.input.length; ++r) n.input[r] = e.input[r];\n            }\n            if (e.output && e.output.length) for (n.output = [], r = 0; r < e.output.length; ++r) n.output[r] = e.output[r];\n            if (null != e.name && e.hasOwnProperty(\"name\") && (n.name = e.name), null != e.opType && e.hasOwnProperty(\"opType\") && (n.opType = e.opType), e.attribute && e.attribute.length) for (n.attribute = [], r = 0; r < e.attribute.length; ++r) n.attribute[r] = c.onnx.AttributeProto.toObject(e.attribute[r], t);\n            return null != e.docString && e.hasOwnProperty(\"docString\") && (n.docString = e.docString), null != e.domain && e.hasOwnProperty(\"domain\") && (n.domain = e.domain), n;\n          }, e.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, e.getTypeUrl = function (e) {\n            return void 0 === e && (e = \"type.googleapis.com\"), e + \"/onnx.NodeProto\";\n          }, e;\n        }(), i.TrainingInfoProto = function () {\n          function e(e) {\n            if (this.initializationBinding = [], this.updateBinding = [], e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n          }\n          return e.prototype.initialization = null, e.prototype.algorithm = null, e.prototype.initializationBinding = l.emptyArray, e.prototype.updateBinding = l.emptyArray, e.create = function (t) {\n            return new e(t);\n          }, e.encode = function (e, t) {\n            if (t || (t = u.create()), null != e.initialization && Object.hasOwnProperty.call(e, \"initialization\") && c.onnx.GraphProto.encode(e.initialization, t.uint32(10).fork()).ldelim(), null != e.algorithm && Object.hasOwnProperty.call(e, \"algorithm\") && c.onnx.GraphProto.encode(e.algorithm, t.uint32(18).fork()).ldelim(), null != e.initializationBinding && e.initializationBinding.length) for (var n = 0; n < e.initializationBinding.length; ++n) c.onnx.StringStringEntryProto.encode(e.initializationBinding[n], t.uint32(26).fork()).ldelim();\n            if (null != e.updateBinding && e.updateBinding.length) for (n = 0; n < e.updateBinding.length; ++n) c.onnx.StringStringEntryProto.encode(e.updateBinding[n], t.uint32(34).fork()).ldelim();\n            return t;\n          }, e.encodeDelimited = function (e, t) {\n            return this.encode(e, t).ldelim();\n          }, e.decode = function (e, t) {\n            e instanceof s || (e = s.create(e));\n            for (var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.TrainingInfoProto(); e.pos < n;) {\n              var o = e.uint32();\n              switch (o >>> 3) {\n                case 1:\n                  r.initialization = c.onnx.GraphProto.decode(e, e.uint32());\n                  break;\n                case 2:\n                  r.algorithm = c.onnx.GraphProto.decode(e, e.uint32());\n                  break;\n                case 3:\n                  r.initializationBinding && r.initializationBinding.length || (r.initializationBinding = []), r.initializationBinding.push(c.onnx.StringStringEntryProto.decode(e, e.uint32()));\n                  break;\n                case 4:\n                  r.updateBinding && r.updateBinding.length || (r.updateBinding = []), r.updateBinding.push(c.onnx.StringStringEntryProto.decode(e, e.uint32()));\n                  break;\n                default:\n                  e.skipType(7 & o);\n              }\n            }\n            return r;\n          }, e.decodeDelimited = function (e) {\n            return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n          }, e.verify = function (e) {\n            if (\"object\" != typeof e || null === e) return \"object expected\";\n            if (null != e.initialization && e.hasOwnProperty(\"initialization\") && (n = c.onnx.GraphProto.verify(e.initialization))) return \"initialization.\" + n;\n            if (null != e.algorithm && e.hasOwnProperty(\"algorithm\") && (n = c.onnx.GraphProto.verify(e.algorithm))) return \"algorithm.\" + n;\n            if (null != e.initializationBinding && e.hasOwnProperty(\"initializationBinding\")) {\n              if (!Array.isArray(e.initializationBinding)) return \"initializationBinding: array expected\";\n              for (var t = 0; t < e.initializationBinding.length; ++t) if (n = c.onnx.StringStringEntryProto.verify(e.initializationBinding[t])) return \"initializationBinding.\" + n;\n            }\n            if (null != e.updateBinding && e.hasOwnProperty(\"updateBinding\")) {\n              if (!Array.isArray(e.updateBinding)) return \"updateBinding: array expected\";\n              for (t = 0; t < e.updateBinding.length; ++t) {\n                var n;\n                if (n = c.onnx.StringStringEntryProto.verify(e.updateBinding[t])) return \"updateBinding.\" + n;\n              }\n            }\n            return null;\n          }, e.fromObject = function (e) {\n            if (e instanceof c.onnx.TrainingInfoProto) return e;\n            var t = new c.onnx.TrainingInfoProto();\n            if (null != e.initialization) {\n              if (\"object\" != typeof e.initialization) throw TypeError(\".onnx.TrainingInfoProto.initialization: object expected\");\n              t.initialization = c.onnx.GraphProto.fromObject(e.initialization);\n            }\n            if (null != e.algorithm) {\n              if (\"object\" != typeof e.algorithm) throw TypeError(\".onnx.TrainingInfoProto.algorithm: object expected\");\n              t.algorithm = c.onnx.GraphProto.fromObject(e.algorithm);\n            }\n            if (e.initializationBinding) {\n              if (!Array.isArray(e.initializationBinding)) throw TypeError(\".onnx.TrainingInfoProto.initializationBinding: array expected\");\n              t.initializationBinding = [];\n              for (var n = 0; n < e.initializationBinding.length; ++n) {\n                if (\"object\" != typeof e.initializationBinding[n]) throw TypeError(\".onnx.TrainingInfoProto.initializationBinding: object expected\");\n                t.initializationBinding[n] = c.onnx.StringStringEntryProto.fromObject(e.initializationBinding[n]);\n              }\n            }\n            if (e.updateBinding) {\n              if (!Array.isArray(e.updateBinding)) throw TypeError(\".onnx.TrainingInfoProto.updateBinding: array expected\");\n              for (t.updateBinding = [], n = 0; n < e.updateBinding.length; ++n) {\n                if (\"object\" != typeof e.updateBinding[n]) throw TypeError(\".onnx.TrainingInfoProto.updateBinding: object expected\");\n                t.updateBinding[n] = c.onnx.StringStringEntryProto.fromObject(e.updateBinding[n]);\n              }\n            }\n            return t;\n          }, e.toObject = function (e, t) {\n            t || (t = {});\n            var n = {};\n            if ((t.arrays || t.defaults) && (n.initializationBinding = [], n.updateBinding = []), t.defaults && (n.initialization = null, n.algorithm = null), null != e.initialization && e.hasOwnProperty(\"initialization\") && (n.initialization = c.onnx.GraphProto.toObject(e.initialization, t)), null != e.algorithm && e.hasOwnProperty(\"algorithm\") && (n.algorithm = c.onnx.GraphProto.toObject(e.algorithm, t)), e.initializationBinding && e.initializationBinding.length) {\n              n.initializationBinding = [];\n              for (var r = 0; r < e.initializationBinding.length; ++r) n.initializationBinding[r] = c.onnx.StringStringEntryProto.toObject(e.initializationBinding[r], t);\n            }\n            if (e.updateBinding && e.updateBinding.length) for (n.updateBinding = [], r = 0; r < e.updateBinding.length; ++r) n.updateBinding[r] = c.onnx.StringStringEntryProto.toObject(e.updateBinding[r], t);\n            return n;\n          }, e.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, e.getTypeUrl = function (e) {\n            return void 0 === e && (e = \"type.googleapis.com\"), e + \"/onnx.TrainingInfoProto\";\n          }, e;\n        }(), i.ModelProto = function () {\n          function e(e) {\n            if (this.opsetImport = [], this.metadataProps = [], this.trainingInfo = [], this.functions = [], e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n          }\n          return e.prototype.irVersion = l.Long ? l.Long.fromBits(0, 0, !1) : 0, e.prototype.opsetImport = l.emptyArray, e.prototype.producerName = \"\", e.prototype.producerVersion = \"\", e.prototype.domain = \"\", e.prototype.modelVersion = l.Long ? l.Long.fromBits(0, 0, !1) : 0, e.prototype.docString = \"\", e.prototype.graph = null, e.prototype.metadataProps = l.emptyArray, e.prototype.trainingInfo = l.emptyArray, e.prototype.functions = l.emptyArray, e.create = function (t) {\n            return new e(t);\n          }, e.encode = function (e, t) {\n            if (t || (t = u.create()), null != e.irVersion && Object.hasOwnProperty.call(e, \"irVersion\") && t.uint32(8).int64(e.irVersion), null != e.producerName && Object.hasOwnProperty.call(e, \"producerName\") && t.uint32(18).string(e.producerName), null != e.producerVersion && Object.hasOwnProperty.call(e, \"producerVersion\") && t.uint32(26).string(e.producerVersion), null != e.domain && Object.hasOwnProperty.call(e, \"domain\") && t.uint32(34).string(e.domain), null != e.modelVersion && Object.hasOwnProperty.call(e, \"modelVersion\") && t.uint32(40).int64(e.modelVersion), null != e.docString && Object.hasOwnProperty.call(e, \"docString\") && t.uint32(50).string(e.docString), null != e.graph && Object.hasOwnProperty.call(e, \"graph\") && c.onnx.GraphProto.encode(e.graph, t.uint32(58).fork()).ldelim(), null != e.opsetImport && e.opsetImport.length) for (var n = 0; n < e.opsetImport.length; ++n) c.onnx.OperatorSetIdProto.encode(e.opsetImport[n], t.uint32(66).fork()).ldelim();\n            if (null != e.metadataProps && e.metadataProps.length) for (n = 0; n < e.metadataProps.length; ++n) c.onnx.StringStringEntryProto.encode(e.metadataProps[n], t.uint32(114).fork()).ldelim();\n            if (null != e.trainingInfo && e.trainingInfo.length) for (n = 0; n < e.trainingInfo.length; ++n) c.onnx.TrainingInfoProto.encode(e.trainingInfo[n], t.uint32(162).fork()).ldelim();\n            if (null != e.functions && e.functions.length) for (n = 0; n < e.functions.length; ++n) c.onnx.FunctionProto.encode(e.functions[n], t.uint32(202).fork()).ldelim();\n            return t;\n          }, e.encodeDelimited = function (e, t) {\n            return this.encode(e, t).ldelim();\n          }, e.decode = function (e, t) {\n            e instanceof s || (e = s.create(e));\n            for (var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.ModelProto(); e.pos < n;) {\n              var o = e.uint32();\n              switch (o >>> 3) {\n                case 1:\n                  r.irVersion = e.int64();\n                  break;\n                case 8:\n                  r.opsetImport && r.opsetImport.length || (r.opsetImport = []), r.opsetImport.push(c.onnx.OperatorSetIdProto.decode(e, e.uint32()));\n                  break;\n                case 2:\n                  r.producerName = e.string();\n                  break;\n                case 3:\n                  r.producerVersion = e.string();\n                  break;\n                case 4:\n                  r.domain = e.string();\n                  break;\n                case 5:\n                  r.modelVersion = e.int64();\n                  break;\n                case 6:\n                  r.docString = e.string();\n                  break;\n                case 7:\n                  r.graph = c.onnx.GraphProto.decode(e, e.uint32());\n                  break;\n                case 14:\n                  r.metadataProps && r.metadataProps.length || (r.metadataProps = []), r.metadataProps.push(c.onnx.StringStringEntryProto.decode(e, e.uint32()));\n                  break;\n                case 20:\n                  r.trainingInfo && r.trainingInfo.length || (r.trainingInfo = []), r.trainingInfo.push(c.onnx.TrainingInfoProto.decode(e, e.uint32()));\n                  break;\n                case 25:\n                  r.functions && r.functions.length || (r.functions = []), r.functions.push(c.onnx.FunctionProto.decode(e, e.uint32()));\n                  break;\n                default:\n                  e.skipType(7 & o);\n              }\n            }\n            return r;\n          }, e.decodeDelimited = function (e) {\n            return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n          }, e.verify = function (e) {\n            if (\"object\" != typeof e || null === e) return \"object expected\";\n            if (null != e.irVersion && e.hasOwnProperty(\"irVersion\") && !(l.isInteger(e.irVersion) || e.irVersion && l.isInteger(e.irVersion.low) && l.isInteger(e.irVersion.high))) return \"irVersion: integer|Long expected\";\n            if (null != e.opsetImport && e.hasOwnProperty(\"opsetImport\")) {\n              if (!Array.isArray(e.opsetImport)) return \"opsetImport: array expected\";\n              for (var t = 0; t < e.opsetImport.length; ++t) if (n = c.onnx.OperatorSetIdProto.verify(e.opsetImport[t])) return \"opsetImport.\" + n;\n            }\n            if (null != e.producerName && e.hasOwnProperty(\"producerName\") && !l.isString(e.producerName)) return \"producerName: string expected\";\n            if (null != e.producerVersion && e.hasOwnProperty(\"producerVersion\") && !l.isString(e.producerVersion)) return \"producerVersion: string expected\";\n            if (null != e.domain && e.hasOwnProperty(\"domain\") && !l.isString(e.domain)) return \"domain: string expected\";\n            if (null != e.modelVersion && e.hasOwnProperty(\"modelVersion\") && !(l.isInteger(e.modelVersion) || e.modelVersion && l.isInteger(e.modelVersion.low) && l.isInteger(e.modelVersion.high))) return \"modelVersion: integer|Long expected\";\n            if (null != e.docString && e.hasOwnProperty(\"docString\") && !l.isString(e.docString)) return \"docString: string expected\";\n            if (null != e.graph && e.hasOwnProperty(\"graph\") && (n = c.onnx.GraphProto.verify(e.graph))) return \"graph.\" + n;\n            if (null != e.metadataProps && e.hasOwnProperty(\"metadataProps\")) {\n              if (!Array.isArray(e.metadataProps)) return \"metadataProps: array expected\";\n              for (t = 0; t < e.metadataProps.length; ++t) if (n = c.onnx.StringStringEntryProto.verify(e.metadataProps[t])) return \"metadataProps.\" + n;\n            }\n            if (null != e.trainingInfo && e.hasOwnProperty(\"trainingInfo\")) {\n              if (!Array.isArray(e.trainingInfo)) return \"trainingInfo: array expected\";\n              for (t = 0; t < e.trainingInfo.length; ++t) if (n = c.onnx.TrainingInfoProto.verify(e.trainingInfo[t])) return \"trainingInfo.\" + n;\n            }\n            if (null != e.functions && e.hasOwnProperty(\"functions\")) {\n              if (!Array.isArray(e.functions)) return \"functions: array expected\";\n              for (t = 0; t < e.functions.length; ++t) {\n                var n;\n                if (n = c.onnx.FunctionProto.verify(e.functions[t])) return \"functions.\" + n;\n              }\n            }\n            return null;\n          }, e.fromObject = function (e) {\n            if (e instanceof c.onnx.ModelProto) return e;\n            var t = new c.onnx.ModelProto();\n            if (null != e.irVersion && (l.Long ? (t.irVersion = l.Long.fromValue(e.irVersion)).unsigned = !1 : \"string\" == typeof e.irVersion ? t.irVersion = parseInt(e.irVersion, 10) : \"number\" == typeof e.irVersion ? t.irVersion = e.irVersion : \"object\" == typeof e.irVersion && (t.irVersion = new l.LongBits(e.irVersion.low >>> 0, e.irVersion.high >>> 0).toNumber())), e.opsetImport) {\n              if (!Array.isArray(e.opsetImport)) throw TypeError(\".onnx.ModelProto.opsetImport: array expected\");\n              t.opsetImport = [];\n              for (var n = 0; n < e.opsetImport.length; ++n) {\n                if (\"object\" != typeof e.opsetImport[n]) throw TypeError(\".onnx.ModelProto.opsetImport: object expected\");\n                t.opsetImport[n] = c.onnx.OperatorSetIdProto.fromObject(e.opsetImport[n]);\n              }\n            }\n            if (null != e.producerName && (t.producerName = String(e.producerName)), null != e.producerVersion && (t.producerVersion = String(e.producerVersion)), null != e.domain && (t.domain = String(e.domain)), null != e.modelVersion && (l.Long ? (t.modelVersion = l.Long.fromValue(e.modelVersion)).unsigned = !1 : \"string\" == typeof e.modelVersion ? t.modelVersion = parseInt(e.modelVersion, 10) : \"number\" == typeof e.modelVersion ? t.modelVersion = e.modelVersion : \"object\" == typeof e.modelVersion && (t.modelVersion = new l.LongBits(e.modelVersion.low >>> 0, e.modelVersion.high >>> 0).toNumber())), null != e.docString && (t.docString = String(e.docString)), null != e.graph) {\n              if (\"object\" != typeof e.graph) throw TypeError(\".onnx.ModelProto.graph: object expected\");\n              t.graph = c.onnx.GraphProto.fromObject(e.graph);\n            }\n            if (e.metadataProps) {\n              if (!Array.isArray(e.metadataProps)) throw TypeError(\".onnx.ModelProto.metadataProps: array expected\");\n              for (t.metadataProps = [], n = 0; n < e.metadataProps.length; ++n) {\n                if (\"object\" != typeof e.metadataProps[n]) throw TypeError(\".onnx.ModelProto.metadataProps: object expected\");\n                t.metadataProps[n] = c.onnx.StringStringEntryProto.fromObject(e.metadataProps[n]);\n              }\n            }\n            if (e.trainingInfo) {\n              if (!Array.isArray(e.trainingInfo)) throw TypeError(\".onnx.ModelProto.trainingInfo: array expected\");\n              for (t.trainingInfo = [], n = 0; n < e.trainingInfo.length; ++n) {\n                if (\"object\" != typeof e.trainingInfo[n]) throw TypeError(\".onnx.ModelProto.trainingInfo: object expected\");\n                t.trainingInfo[n] = c.onnx.TrainingInfoProto.fromObject(e.trainingInfo[n]);\n              }\n            }\n            if (e.functions) {\n              if (!Array.isArray(e.functions)) throw TypeError(\".onnx.ModelProto.functions: array expected\");\n              for (t.functions = [], n = 0; n < e.functions.length; ++n) {\n                if (\"object\" != typeof e.functions[n]) throw TypeError(\".onnx.ModelProto.functions: object expected\");\n                t.functions[n] = c.onnx.FunctionProto.fromObject(e.functions[n]);\n              }\n            }\n            return t;\n          }, e.toObject = function (e, t) {\n            t || (t = {});\n            var n = {};\n            if ((t.arrays || t.defaults) && (n.opsetImport = [], n.metadataProps = [], n.trainingInfo = [], n.functions = []), t.defaults) {\n              if (l.Long) {\n                var r = new l.Long(0, 0, !1);\n                n.irVersion = t.longs === String ? r.toString() : t.longs === Number ? r.toNumber() : r;\n              } else n.irVersion = t.longs === String ? \"0\" : 0;\n              n.producerName = \"\", n.producerVersion = \"\", n.domain = \"\", l.Long ? (r = new l.Long(0, 0, !1), n.modelVersion = t.longs === String ? r.toString() : t.longs === Number ? r.toNumber() : r) : n.modelVersion = t.longs === String ? \"0\" : 0, n.docString = \"\", n.graph = null;\n            }\n            if (null != e.irVersion && e.hasOwnProperty(\"irVersion\") && (\"number\" == typeof e.irVersion ? n.irVersion = t.longs === String ? String(e.irVersion) : e.irVersion : n.irVersion = t.longs === String ? l.Long.prototype.toString.call(e.irVersion) : t.longs === Number ? new l.LongBits(e.irVersion.low >>> 0, e.irVersion.high >>> 0).toNumber() : e.irVersion), null != e.producerName && e.hasOwnProperty(\"producerName\") && (n.producerName = e.producerName), null != e.producerVersion && e.hasOwnProperty(\"producerVersion\") && (n.producerVersion = e.producerVersion), null != e.domain && e.hasOwnProperty(\"domain\") && (n.domain = e.domain), null != e.modelVersion && e.hasOwnProperty(\"modelVersion\") && (\"number\" == typeof e.modelVersion ? n.modelVersion = t.longs === String ? String(e.modelVersion) : e.modelVersion : n.modelVersion = t.longs === String ? l.Long.prototype.toString.call(e.modelVersion) : t.longs === Number ? new l.LongBits(e.modelVersion.low >>> 0, e.modelVersion.high >>> 0).toNumber() : e.modelVersion), null != e.docString && e.hasOwnProperty(\"docString\") && (n.docString = e.docString), null != e.graph && e.hasOwnProperty(\"graph\") && (n.graph = c.onnx.GraphProto.toObject(e.graph, t)), e.opsetImport && e.opsetImport.length) {\n              n.opsetImport = [];\n              for (var o = 0; o < e.opsetImport.length; ++o) n.opsetImport[o] = c.onnx.OperatorSetIdProto.toObject(e.opsetImport[o], t);\n            }\n            if (e.metadataProps && e.metadataProps.length) for (n.metadataProps = [], o = 0; o < e.metadataProps.length; ++o) n.metadataProps[o] = c.onnx.StringStringEntryProto.toObject(e.metadataProps[o], t);\n            if (e.trainingInfo && e.trainingInfo.length) for (n.trainingInfo = [], o = 0; o < e.trainingInfo.length; ++o) n.trainingInfo[o] = c.onnx.TrainingInfoProto.toObject(e.trainingInfo[o], t);\n            if (e.functions && e.functions.length) for (n.functions = [], o = 0; o < e.functions.length; ++o) n.functions[o] = c.onnx.FunctionProto.toObject(e.functions[o], t);\n            return n;\n          }, e.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, e.getTypeUrl = function (e) {\n            return void 0 === e && (e = \"type.googleapis.com\"), e + \"/onnx.ModelProto\";\n          }, e;\n        }(), i.StringStringEntryProto = function () {\n          function e(e) {\n            if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n          }\n          return e.prototype.key = \"\", e.prototype.value = \"\", e.create = function (t) {\n            return new e(t);\n          }, e.encode = function (e, t) {\n            return t || (t = u.create()), null != e.key && Object.hasOwnProperty.call(e, \"key\") && t.uint32(10).string(e.key), null != e.value && Object.hasOwnProperty.call(e, \"value\") && t.uint32(18).string(e.value), t;\n          }, e.encodeDelimited = function (e, t) {\n            return this.encode(e, t).ldelim();\n          }, e.decode = function (e, t) {\n            e instanceof s || (e = s.create(e));\n            for (var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.StringStringEntryProto(); e.pos < n;) {\n              var o = e.uint32();\n              switch (o >>> 3) {\n                case 1:\n                  r.key = e.string();\n                  break;\n                case 2:\n                  r.value = e.string();\n                  break;\n                default:\n                  e.skipType(7 & o);\n              }\n            }\n            return r;\n          }, e.decodeDelimited = function (e) {\n            return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n          }, e.verify = function (e) {\n            return \"object\" != typeof e || null === e ? \"object expected\" : null != e.key && e.hasOwnProperty(\"key\") && !l.isString(e.key) ? \"key: string expected\" : null != e.value && e.hasOwnProperty(\"value\") && !l.isString(e.value) ? \"value: string expected\" : null;\n          }, e.fromObject = function (e) {\n            if (e instanceof c.onnx.StringStringEntryProto) return e;\n            var t = new c.onnx.StringStringEntryProto();\n            return null != e.key && (t.key = String(e.key)), null != e.value && (t.value = String(e.value)), t;\n          }, e.toObject = function (e, t) {\n            t || (t = {});\n            var n = {};\n            return t.defaults && (n.key = \"\", n.value = \"\"), null != e.key && e.hasOwnProperty(\"key\") && (n.key = e.key), null != e.value && e.hasOwnProperty(\"value\") && (n.value = e.value), n;\n          }, e.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, e.getTypeUrl = function (e) {\n            return void 0 === e && (e = \"type.googleapis.com\"), e + \"/onnx.StringStringEntryProto\";\n          }, e;\n        }(), i.TensorAnnotation = function () {\n          function e(e) {\n            if (this.quantParameterTensorNames = [], e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n          }\n          return e.prototype.tensorName = \"\", e.prototype.quantParameterTensorNames = l.emptyArray, e.create = function (t) {\n            return new e(t);\n          }, e.encode = function (e, t) {\n            if (t || (t = u.create()), null != e.tensorName && Object.hasOwnProperty.call(e, \"tensorName\") && t.uint32(10).string(e.tensorName), null != e.quantParameterTensorNames && e.quantParameterTensorNames.length) for (var n = 0; n < e.quantParameterTensorNames.length; ++n) c.onnx.StringStringEntryProto.encode(e.quantParameterTensorNames[n], t.uint32(18).fork()).ldelim();\n            return t;\n          }, e.encodeDelimited = function (e, t) {\n            return this.encode(e, t).ldelim();\n          }, e.decode = function (e, t) {\n            e instanceof s || (e = s.create(e));\n            for (var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.TensorAnnotation(); e.pos < n;) {\n              var o = e.uint32();\n              switch (o >>> 3) {\n                case 1:\n                  r.tensorName = e.string();\n                  break;\n                case 2:\n                  r.quantParameterTensorNames && r.quantParameterTensorNames.length || (r.quantParameterTensorNames = []), r.quantParameterTensorNames.push(c.onnx.StringStringEntryProto.decode(e, e.uint32()));\n                  break;\n                default:\n                  e.skipType(7 & o);\n              }\n            }\n            return r;\n          }, e.decodeDelimited = function (e) {\n            return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n          }, e.verify = function (e) {\n            if (\"object\" != typeof e || null === e) return \"object expected\";\n            if (null != e.tensorName && e.hasOwnProperty(\"tensorName\") && !l.isString(e.tensorName)) return \"tensorName: string expected\";\n            if (null != e.quantParameterTensorNames && e.hasOwnProperty(\"quantParameterTensorNames\")) {\n              if (!Array.isArray(e.quantParameterTensorNames)) return \"quantParameterTensorNames: array expected\";\n              for (var t = 0; t < e.quantParameterTensorNames.length; ++t) {\n                var n = c.onnx.StringStringEntryProto.verify(e.quantParameterTensorNames[t]);\n                if (n) return \"quantParameterTensorNames.\" + n;\n              }\n            }\n            return null;\n          }, e.fromObject = function (e) {\n            if (e instanceof c.onnx.TensorAnnotation) return e;\n            var t = new c.onnx.TensorAnnotation();\n            if (null != e.tensorName && (t.tensorName = String(e.tensorName)), e.quantParameterTensorNames) {\n              if (!Array.isArray(e.quantParameterTensorNames)) throw TypeError(\".onnx.TensorAnnotation.quantParameterTensorNames: array expected\");\n              t.quantParameterTensorNames = [];\n              for (var n = 0; n < e.quantParameterTensorNames.length; ++n) {\n                if (\"object\" != typeof e.quantParameterTensorNames[n]) throw TypeError(\".onnx.TensorAnnotation.quantParameterTensorNames: object expected\");\n                t.quantParameterTensorNames[n] = c.onnx.StringStringEntryProto.fromObject(e.quantParameterTensorNames[n]);\n              }\n            }\n            return t;\n          }, e.toObject = function (e, t) {\n            t || (t = {});\n            var n = {};\n            if ((t.arrays || t.defaults) && (n.quantParameterTensorNames = []), t.defaults && (n.tensorName = \"\"), null != e.tensorName && e.hasOwnProperty(\"tensorName\") && (n.tensorName = e.tensorName), e.quantParameterTensorNames && e.quantParameterTensorNames.length) {\n              n.quantParameterTensorNames = [];\n              for (var r = 0; r < e.quantParameterTensorNames.length; ++r) n.quantParameterTensorNames[r] = c.onnx.StringStringEntryProto.toObject(e.quantParameterTensorNames[r], t);\n            }\n            return n;\n          }, e.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, e.getTypeUrl = function (e) {\n            return void 0 === e && (e = \"type.googleapis.com\"), e + \"/onnx.TensorAnnotation\";\n          }, e;\n        }(), i.GraphProto = function () {\n          function e(e) {\n            if (this.node = [], this.initializer = [], this.sparseInitializer = [], this.input = [], this.output = [], this.valueInfo = [], this.quantizationAnnotation = [], e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n          }\n          return e.prototype.node = l.emptyArray, e.prototype.name = \"\", e.prototype.initializer = l.emptyArray, e.prototype.sparseInitializer = l.emptyArray, e.prototype.docString = \"\", e.prototype.input = l.emptyArray, e.prototype.output = l.emptyArray, e.prototype.valueInfo = l.emptyArray, e.prototype.quantizationAnnotation = l.emptyArray, e.create = function (t) {\n            return new e(t);\n          }, e.encode = function (e, t) {\n            if (t || (t = u.create()), null != e.node && e.node.length) for (var n = 0; n < e.node.length; ++n) c.onnx.NodeProto.encode(e.node[n], t.uint32(10).fork()).ldelim();\n            if (null != e.name && Object.hasOwnProperty.call(e, \"name\") && t.uint32(18).string(e.name), null != e.initializer && e.initializer.length) for (n = 0; n < e.initializer.length; ++n) c.onnx.TensorProto.encode(e.initializer[n], t.uint32(42).fork()).ldelim();\n            if (null != e.docString && Object.hasOwnProperty.call(e, \"docString\") && t.uint32(82).string(e.docString), null != e.input && e.input.length) for (n = 0; n < e.input.length; ++n) c.onnx.ValueInfoProto.encode(e.input[n], t.uint32(90).fork()).ldelim();\n            if (null != e.output && e.output.length) for (n = 0; n < e.output.length; ++n) c.onnx.ValueInfoProto.encode(e.output[n], t.uint32(98).fork()).ldelim();\n            if (null != e.valueInfo && e.valueInfo.length) for (n = 0; n < e.valueInfo.length; ++n) c.onnx.ValueInfoProto.encode(e.valueInfo[n], t.uint32(106).fork()).ldelim();\n            if (null != e.quantizationAnnotation && e.quantizationAnnotation.length) for (n = 0; n < e.quantizationAnnotation.length; ++n) c.onnx.TensorAnnotation.encode(e.quantizationAnnotation[n], t.uint32(114).fork()).ldelim();\n            if (null != e.sparseInitializer && e.sparseInitializer.length) for (n = 0; n < e.sparseInitializer.length; ++n) c.onnx.SparseTensorProto.encode(e.sparseInitializer[n], t.uint32(122).fork()).ldelim();\n            return t;\n          }, e.encodeDelimited = function (e, t) {\n            return this.encode(e, t).ldelim();\n          }, e.decode = function (e, t) {\n            e instanceof s || (e = s.create(e));\n            for (var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.GraphProto(); e.pos < n;) {\n              var o = e.uint32();\n              switch (o >>> 3) {\n                case 1:\n                  r.node && r.node.length || (r.node = []), r.node.push(c.onnx.NodeProto.decode(e, e.uint32()));\n                  break;\n                case 2:\n                  r.name = e.string();\n                  break;\n                case 5:\n                  r.initializer && r.initializer.length || (r.initializer = []), r.initializer.push(c.onnx.TensorProto.decode(e, e.uint32()));\n                  break;\n                case 15:\n                  r.sparseInitializer && r.sparseInitializer.length || (r.sparseInitializer = []), r.sparseInitializer.push(c.onnx.SparseTensorProto.decode(e, e.uint32()));\n                  break;\n                case 10:\n                  r.docString = e.string();\n                  break;\n                case 11:\n                  r.input && r.input.length || (r.input = []), r.input.push(c.onnx.ValueInfoProto.decode(e, e.uint32()));\n                  break;\n                case 12:\n                  r.output && r.output.length || (r.output = []), r.output.push(c.onnx.ValueInfoProto.decode(e, e.uint32()));\n                  break;\n                case 13:\n                  r.valueInfo && r.valueInfo.length || (r.valueInfo = []), r.valueInfo.push(c.onnx.ValueInfoProto.decode(e, e.uint32()));\n                  break;\n                case 14:\n                  r.quantizationAnnotation && r.quantizationAnnotation.length || (r.quantizationAnnotation = []), r.quantizationAnnotation.push(c.onnx.TensorAnnotation.decode(e, e.uint32()));\n                  break;\n                default:\n                  e.skipType(7 & o);\n              }\n            }\n            return r;\n          }, e.decodeDelimited = function (e) {\n            return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n          }, e.verify = function (e) {\n            if (\"object\" != typeof e || null === e) return \"object expected\";\n            if (null != e.node && e.hasOwnProperty(\"node\")) {\n              if (!Array.isArray(e.node)) return \"node: array expected\";\n              for (var t = 0; t < e.node.length; ++t) if (n = c.onnx.NodeProto.verify(e.node[t])) return \"node.\" + n;\n            }\n            if (null != e.name && e.hasOwnProperty(\"name\") && !l.isString(e.name)) return \"name: string expected\";\n            if (null != e.initializer && e.hasOwnProperty(\"initializer\")) {\n              if (!Array.isArray(e.initializer)) return \"initializer: array expected\";\n              for (t = 0; t < e.initializer.length; ++t) if (n = c.onnx.TensorProto.verify(e.initializer[t])) return \"initializer.\" + n;\n            }\n            if (null != e.sparseInitializer && e.hasOwnProperty(\"sparseInitializer\")) {\n              if (!Array.isArray(e.sparseInitializer)) return \"sparseInitializer: array expected\";\n              for (t = 0; t < e.sparseInitializer.length; ++t) if (n = c.onnx.SparseTensorProto.verify(e.sparseInitializer[t])) return \"sparseInitializer.\" + n;\n            }\n            if (null != e.docString && e.hasOwnProperty(\"docString\") && !l.isString(e.docString)) return \"docString: string expected\";\n            if (null != e.input && e.hasOwnProperty(\"input\")) {\n              if (!Array.isArray(e.input)) return \"input: array expected\";\n              for (t = 0; t < e.input.length; ++t) if (n = c.onnx.ValueInfoProto.verify(e.input[t])) return \"input.\" + n;\n            }\n            if (null != e.output && e.hasOwnProperty(\"output\")) {\n              if (!Array.isArray(e.output)) return \"output: array expected\";\n              for (t = 0; t < e.output.length; ++t) if (n = c.onnx.ValueInfoProto.verify(e.output[t])) return \"output.\" + n;\n            }\n            if (null != e.valueInfo && e.hasOwnProperty(\"valueInfo\")) {\n              if (!Array.isArray(e.valueInfo)) return \"valueInfo: array expected\";\n              for (t = 0; t < e.valueInfo.length; ++t) if (n = c.onnx.ValueInfoProto.verify(e.valueInfo[t])) return \"valueInfo.\" + n;\n            }\n            if (null != e.quantizationAnnotation && e.hasOwnProperty(\"quantizationAnnotation\")) {\n              if (!Array.isArray(e.quantizationAnnotation)) return \"quantizationAnnotation: array expected\";\n              for (t = 0; t < e.quantizationAnnotation.length; ++t) {\n                var n;\n                if (n = c.onnx.TensorAnnotation.verify(e.quantizationAnnotation[t])) return \"quantizationAnnotation.\" + n;\n              }\n            }\n            return null;\n          }, e.fromObject = function (e) {\n            if (e instanceof c.onnx.GraphProto) return e;\n            var t = new c.onnx.GraphProto();\n            if (e.node) {\n              if (!Array.isArray(e.node)) throw TypeError(\".onnx.GraphProto.node: array expected\");\n              t.node = [];\n              for (var n = 0; n < e.node.length; ++n) {\n                if (\"object\" != typeof e.node[n]) throw TypeError(\".onnx.GraphProto.node: object expected\");\n                t.node[n] = c.onnx.NodeProto.fromObject(e.node[n]);\n              }\n            }\n            if (null != e.name && (t.name = String(e.name)), e.initializer) {\n              if (!Array.isArray(e.initializer)) throw TypeError(\".onnx.GraphProto.initializer: array expected\");\n              for (t.initializer = [], n = 0; n < e.initializer.length; ++n) {\n                if (\"object\" != typeof e.initializer[n]) throw TypeError(\".onnx.GraphProto.initializer: object expected\");\n                t.initializer[n] = c.onnx.TensorProto.fromObject(e.initializer[n]);\n              }\n            }\n            if (e.sparseInitializer) {\n              if (!Array.isArray(e.sparseInitializer)) throw TypeError(\".onnx.GraphProto.sparseInitializer: array expected\");\n              for (t.sparseInitializer = [], n = 0; n < e.sparseInitializer.length; ++n) {\n                if (\"object\" != typeof e.sparseInitializer[n]) throw TypeError(\".onnx.GraphProto.sparseInitializer: object expected\");\n                t.sparseInitializer[n] = c.onnx.SparseTensorProto.fromObject(e.sparseInitializer[n]);\n              }\n            }\n            if (null != e.docString && (t.docString = String(e.docString)), e.input) {\n              if (!Array.isArray(e.input)) throw TypeError(\".onnx.GraphProto.input: array expected\");\n              for (t.input = [], n = 0; n < e.input.length; ++n) {\n                if (\"object\" != typeof e.input[n]) throw TypeError(\".onnx.GraphProto.input: object expected\");\n                t.input[n] = c.onnx.ValueInfoProto.fromObject(e.input[n]);\n              }\n            }\n            if (e.output) {\n              if (!Array.isArray(e.output)) throw TypeError(\".onnx.GraphProto.output: array expected\");\n              for (t.output = [], n = 0; n < e.output.length; ++n) {\n                if (\"object\" != typeof e.output[n]) throw TypeError(\".onnx.GraphProto.output: object expected\");\n                t.output[n] = c.onnx.ValueInfoProto.fromObject(e.output[n]);\n              }\n            }\n            if (e.valueInfo) {\n              if (!Array.isArray(e.valueInfo)) throw TypeError(\".onnx.GraphProto.valueInfo: array expected\");\n              for (t.valueInfo = [], n = 0; n < e.valueInfo.length; ++n) {\n                if (\"object\" != typeof e.valueInfo[n]) throw TypeError(\".onnx.GraphProto.valueInfo: object expected\");\n                t.valueInfo[n] = c.onnx.ValueInfoProto.fromObject(e.valueInfo[n]);\n              }\n            }\n            if (e.quantizationAnnotation) {\n              if (!Array.isArray(e.quantizationAnnotation)) throw TypeError(\".onnx.GraphProto.quantizationAnnotation: array expected\");\n              for (t.quantizationAnnotation = [], n = 0; n < e.quantizationAnnotation.length; ++n) {\n                if (\"object\" != typeof e.quantizationAnnotation[n]) throw TypeError(\".onnx.GraphProto.quantizationAnnotation: object expected\");\n                t.quantizationAnnotation[n] = c.onnx.TensorAnnotation.fromObject(e.quantizationAnnotation[n]);\n              }\n            }\n            return t;\n          }, e.toObject = function (e, t) {\n            t || (t = {});\n            var n = {};\n            if ((t.arrays || t.defaults) && (n.node = [], n.initializer = [], n.input = [], n.output = [], n.valueInfo = [], n.quantizationAnnotation = [], n.sparseInitializer = []), t.defaults && (n.name = \"\", n.docString = \"\"), e.node && e.node.length) {\n              n.node = [];\n              for (var r = 0; r < e.node.length; ++r) n.node[r] = c.onnx.NodeProto.toObject(e.node[r], t);\n            }\n            if (null != e.name && e.hasOwnProperty(\"name\") && (n.name = e.name), e.initializer && e.initializer.length) for (n.initializer = [], r = 0; r < e.initializer.length; ++r) n.initializer[r] = c.onnx.TensorProto.toObject(e.initializer[r], t);\n            if (null != e.docString && e.hasOwnProperty(\"docString\") && (n.docString = e.docString), e.input && e.input.length) for (n.input = [], r = 0; r < e.input.length; ++r) n.input[r] = c.onnx.ValueInfoProto.toObject(e.input[r], t);\n            if (e.output && e.output.length) for (n.output = [], r = 0; r < e.output.length; ++r) n.output[r] = c.onnx.ValueInfoProto.toObject(e.output[r], t);\n            if (e.valueInfo && e.valueInfo.length) for (n.valueInfo = [], r = 0; r < e.valueInfo.length; ++r) n.valueInfo[r] = c.onnx.ValueInfoProto.toObject(e.valueInfo[r], t);\n            if (e.quantizationAnnotation && e.quantizationAnnotation.length) for (n.quantizationAnnotation = [], r = 0; r < e.quantizationAnnotation.length; ++r) n.quantizationAnnotation[r] = c.onnx.TensorAnnotation.toObject(e.quantizationAnnotation[r], t);\n            if (e.sparseInitializer && e.sparseInitializer.length) for (n.sparseInitializer = [], r = 0; r < e.sparseInitializer.length; ++r) n.sparseInitializer[r] = c.onnx.SparseTensorProto.toObject(e.sparseInitializer[r], t);\n            return n;\n          }, e.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, e.getTypeUrl = function (e) {\n            return void 0 === e && (e = \"type.googleapis.com\"), e + \"/onnx.GraphProto\";\n          }, e;\n        }(), i.TensorProto = function () {\n          function e(e) {\n            if (this.dims = [], this.floatData = [], this.int32Data = [], this.stringData = [], this.int64Data = [], this.externalData = [], this.doubleData = [], this.uint64Data = [], e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n          }\n          return e.prototype.dims = l.emptyArray, e.prototype.dataType = 0, e.prototype.segment = null, e.prototype.floatData = l.emptyArray, e.prototype.int32Data = l.emptyArray, e.prototype.stringData = l.emptyArray, e.prototype.int64Data = l.emptyArray, e.prototype.name = \"\", e.prototype.docString = \"\", e.prototype.rawData = l.newBuffer([]), e.prototype.externalData = l.emptyArray, e.prototype.dataLocation = 0, e.prototype.doubleData = l.emptyArray, e.prototype.uint64Data = l.emptyArray, e.create = function (t) {\n            return new e(t);\n          }, e.encode = function (e, t) {\n            if (t || (t = u.create()), null != e.dims && e.dims.length) {\n              t.uint32(10).fork();\n              for (var n = 0; n < e.dims.length; ++n) t.int64(e.dims[n]);\n              t.ldelim();\n            }\n            if (null != e.dataType && Object.hasOwnProperty.call(e, \"dataType\") && t.uint32(16).int32(e.dataType), null != e.segment && Object.hasOwnProperty.call(e, \"segment\") && c.onnx.TensorProto.Segment.encode(e.segment, t.uint32(26).fork()).ldelim(), null != e.floatData && e.floatData.length) {\n              for (t.uint32(34).fork(), n = 0; n < e.floatData.length; ++n) t.float(e.floatData[n]);\n              t.ldelim();\n            }\n            if (null != e.int32Data && e.int32Data.length) {\n              for (t.uint32(42).fork(), n = 0; n < e.int32Data.length; ++n) t.int32(e.int32Data[n]);\n              t.ldelim();\n            }\n            if (null != e.stringData && e.stringData.length) for (n = 0; n < e.stringData.length; ++n) t.uint32(50).bytes(e.stringData[n]);\n            if (null != e.int64Data && e.int64Data.length) {\n              for (t.uint32(58).fork(), n = 0; n < e.int64Data.length; ++n) t.int64(e.int64Data[n]);\n              t.ldelim();\n            }\n            if (null != e.name && Object.hasOwnProperty.call(e, \"name\") && t.uint32(66).string(e.name), null != e.rawData && Object.hasOwnProperty.call(e, \"rawData\") && t.uint32(74).bytes(e.rawData), null != e.doubleData && e.doubleData.length) {\n              for (t.uint32(82).fork(), n = 0; n < e.doubleData.length; ++n) t.double(e.doubleData[n]);\n              t.ldelim();\n            }\n            if (null != e.uint64Data && e.uint64Data.length) {\n              for (t.uint32(90).fork(), n = 0; n < e.uint64Data.length; ++n) t.uint64(e.uint64Data[n]);\n              t.ldelim();\n            }\n            if (null != e.docString && Object.hasOwnProperty.call(e, \"docString\") && t.uint32(98).string(e.docString), null != e.externalData && e.externalData.length) for (n = 0; n < e.externalData.length; ++n) c.onnx.StringStringEntryProto.encode(e.externalData[n], t.uint32(106).fork()).ldelim();\n            return null != e.dataLocation && Object.hasOwnProperty.call(e, \"dataLocation\") && t.uint32(112).int32(e.dataLocation), t;\n          }, e.encodeDelimited = function (e, t) {\n            return this.encode(e, t).ldelim();\n          }, e.decode = function (e, t) {\n            e instanceof s || (e = s.create(e));\n            for (var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.TensorProto(); e.pos < n;) {\n              var o = e.uint32();\n              switch (o >>> 3) {\n                case 1:\n                  if (r.dims && r.dims.length || (r.dims = []), 2 == (7 & o)) for (var i = e.uint32() + e.pos; e.pos < i;) r.dims.push(e.int64());else r.dims.push(e.int64());\n                  break;\n                case 2:\n                  r.dataType = e.int32();\n                  break;\n                case 3:\n                  r.segment = c.onnx.TensorProto.Segment.decode(e, e.uint32());\n                  break;\n                case 4:\n                  if (r.floatData && r.floatData.length || (r.floatData = []), 2 == (7 & o)) for (i = e.uint32() + e.pos; e.pos < i;) r.floatData.push(e.float());else r.floatData.push(e.float());\n                  break;\n                case 5:\n                  if (r.int32Data && r.int32Data.length || (r.int32Data = []), 2 == (7 & o)) for (i = e.uint32() + e.pos; e.pos < i;) r.int32Data.push(e.int32());else r.int32Data.push(e.int32());\n                  break;\n                case 6:\n                  r.stringData && r.stringData.length || (r.stringData = []), r.stringData.push(e.bytes());\n                  break;\n                case 7:\n                  if (r.int64Data && r.int64Data.length || (r.int64Data = []), 2 == (7 & o)) for (i = e.uint32() + e.pos; e.pos < i;) r.int64Data.push(e.int64());else r.int64Data.push(e.int64());\n                  break;\n                case 8:\n                  r.name = e.string();\n                  break;\n                case 12:\n                  r.docString = e.string();\n                  break;\n                case 9:\n                  r.rawData = e.bytes();\n                  break;\n                case 13:\n                  r.externalData && r.externalData.length || (r.externalData = []), r.externalData.push(c.onnx.StringStringEntryProto.decode(e, e.uint32()));\n                  break;\n                case 14:\n                  r.dataLocation = e.int32();\n                  break;\n                case 10:\n                  if (r.doubleData && r.doubleData.length || (r.doubleData = []), 2 == (7 & o)) for (i = e.uint32() + e.pos; e.pos < i;) r.doubleData.push(e.double());else r.doubleData.push(e.double());\n                  break;\n                case 11:\n                  if (r.uint64Data && r.uint64Data.length || (r.uint64Data = []), 2 == (7 & o)) for (i = e.uint32() + e.pos; e.pos < i;) r.uint64Data.push(e.uint64());else r.uint64Data.push(e.uint64());\n                  break;\n                default:\n                  e.skipType(7 & o);\n              }\n            }\n            return r;\n          }, e.decodeDelimited = function (e) {\n            return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n          }, e.verify = function (e) {\n            if (\"object\" != typeof e || null === e) return \"object expected\";\n            if (null != e.dims && e.hasOwnProperty(\"dims\")) {\n              if (!Array.isArray(e.dims)) return \"dims: array expected\";\n              for (var t = 0; t < e.dims.length; ++t) if (!(l.isInteger(e.dims[t]) || e.dims[t] && l.isInteger(e.dims[t].low) && l.isInteger(e.dims[t].high))) return \"dims: integer|Long[] expected\";\n            }\n            if (null != e.dataType && e.hasOwnProperty(\"dataType\") && !l.isInteger(e.dataType)) return \"dataType: integer expected\";\n            if (null != e.segment && e.hasOwnProperty(\"segment\") && (n = c.onnx.TensorProto.Segment.verify(e.segment))) return \"segment.\" + n;\n            if (null != e.floatData && e.hasOwnProperty(\"floatData\")) {\n              if (!Array.isArray(e.floatData)) return \"floatData: array expected\";\n              for (t = 0; t < e.floatData.length; ++t) if (\"number\" != typeof e.floatData[t]) return \"floatData: number[] expected\";\n            }\n            if (null != e.int32Data && e.hasOwnProperty(\"int32Data\")) {\n              if (!Array.isArray(e.int32Data)) return \"int32Data: array expected\";\n              for (t = 0; t < e.int32Data.length; ++t) if (!l.isInteger(e.int32Data[t])) return \"int32Data: integer[] expected\";\n            }\n            if (null != e.stringData && e.hasOwnProperty(\"stringData\")) {\n              if (!Array.isArray(e.stringData)) return \"stringData: array expected\";\n              for (t = 0; t < e.stringData.length; ++t) if (!(e.stringData[t] && \"number\" == typeof e.stringData[t].length || l.isString(e.stringData[t]))) return \"stringData: buffer[] expected\";\n            }\n            if (null != e.int64Data && e.hasOwnProperty(\"int64Data\")) {\n              if (!Array.isArray(e.int64Data)) return \"int64Data: array expected\";\n              for (t = 0; t < e.int64Data.length; ++t) if (!(l.isInteger(e.int64Data[t]) || e.int64Data[t] && l.isInteger(e.int64Data[t].low) && l.isInteger(e.int64Data[t].high))) return \"int64Data: integer|Long[] expected\";\n            }\n            if (null != e.name && e.hasOwnProperty(\"name\") && !l.isString(e.name)) return \"name: string expected\";\n            if (null != e.docString && e.hasOwnProperty(\"docString\") && !l.isString(e.docString)) return \"docString: string expected\";\n            if (null != e.rawData && e.hasOwnProperty(\"rawData\") && !(e.rawData && \"number\" == typeof e.rawData.length || l.isString(e.rawData))) return \"rawData: buffer expected\";\n            if (null != e.externalData && e.hasOwnProperty(\"externalData\")) {\n              if (!Array.isArray(e.externalData)) return \"externalData: array expected\";\n              for (t = 0; t < e.externalData.length; ++t) {\n                var n;\n                if (n = c.onnx.StringStringEntryProto.verify(e.externalData[t])) return \"externalData.\" + n;\n              }\n            }\n            if (null != e.dataLocation && e.hasOwnProperty(\"dataLocation\")) switch (e.dataLocation) {\n              default:\n                return \"dataLocation: enum value expected\";\n              case 0:\n              case 1:\n            }\n            if (null != e.doubleData && e.hasOwnProperty(\"doubleData\")) {\n              if (!Array.isArray(e.doubleData)) return \"doubleData: array expected\";\n              for (t = 0; t < e.doubleData.length; ++t) if (\"number\" != typeof e.doubleData[t]) return \"doubleData: number[] expected\";\n            }\n            if (null != e.uint64Data && e.hasOwnProperty(\"uint64Data\")) {\n              if (!Array.isArray(e.uint64Data)) return \"uint64Data: array expected\";\n              for (t = 0; t < e.uint64Data.length; ++t) if (!(l.isInteger(e.uint64Data[t]) || e.uint64Data[t] && l.isInteger(e.uint64Data[t].low) && l.isInteger(e.uint64Data[t].high))) return \"uint64Data: integer|Long[] expected\";\n            }\n            return null;\n          }, e.fromObject = function (e) {\n            if (e instanceof c.onnx.TensorProto) return e;\n            var t = new c.onnx.TensorProto();\n            if (e.dims) {\n              if (!Array.isArray(e.dims)) throw TypeError(\".onnx.TensorProto.dims: array expected\");\n              t.dims = [];\n              for (var n = 0; n < e.dims.length; ++n) l.Long ? (t.dims[n] = l.Long.fromValue(e.dims[n])).unsigned = !1 : \"string\" == typeof e.dims[n] ? t.dims[n] = parseInt(e.dims[n], 10) : \"number\" == typeof e.dims[n] ? t.dims[n] = e.dims[n] : \"object\" == typeof e.dims[n] && (t.dims[n] = new l.LongBits(e.dims[n].low >>> 0, e.dims[n].high >>> 0).toNumber());\n            }\n            if (null != e.dataType && (t.dataType = 0 | e.dataType), null != e.segment) {\n              if (\"object\" != typeof e.segment) throw TypeError(\".onnx.TensorProto.segment: object expected\");\n              t.segment = c.onnx.TensorProto.Segment.fromObject(e.segment);\n            }\n            if (e.floatData) {\n              if (!Array.isArray(e.floatData)) throw TypeError(\".onnx.TensorProto.floatData: array expected\");\n              for (t.floatData = [], n = 0; n < e.floatData.length; ++n) t.floatData[n] = Number(e.floatData[n]);\n            }\n            if (e.int32Data) {\n              if (!Array.isArray(e.int32Data)) throw TypeError(\".onnx.TensorProto.int32Data: array expected\");\n              for (t.int32Data = [], n = 0; n < e.int32Data.length; ++n) t.int32Data[n] = 0 | e.int32Data[n];\n            }\n            if (e.stringData) {\n              if (!Array.isArray(e.stringData)) throw TypeError(\".onnx.TensorProto.stringData: array expected\");\n              for (t.stringData = [], n = 0; n < e.stringData.length; ++n) \"string\" == typeof e.stringData[n] ? l.base64.decode(e.stringData[n], t.stringData[n] = l.newBuffer(l.base64.length(e.stringData[n])), 0) : e.stringData[n].length >= 0 && (t.stringData[n] = e.stringData[n]);\n            }\n            if (e.int64Data) {\n              if (!Array.isArray(e.int64Data)) throw TypeError(\".onnx.TensorProto.int64Data: array expected\");\n              for (t.int64Data = [], n = 0; n < e.int64Data.length; ++n) l.Long ? (t.int64Data[n] = l.Long.fromValue(e.int64Data[n])).unsigned = !1 : \"string\" == typeof e.int64Data[n] ? t.int64Data[n] = parseInt(e.int64Data[n], 10) : \"number\" == typeof e.int64Data[n] ? t.int64Data[n] = e.int64Data[n] : \"object\" == typeof e.int64Data[n] && (t.int64Data[n] = new l.LongBits(e.int64Data[n].low >>> 0, e.int64Data[n].high >>> 0).toNumber());\n            }\n            if (null != e.name && (t.name = String(e.name)), null != e.docString && (t.docString = String(e.docString)), null != e.rawData && (\"string\" == typeof e.rawData ? l.base64.decode(e.rawData, t.rawData = l.newBuffer(l.base64.length(e.rawData)), 0) : e.rawData.length >= 0 && (t.rawData = e.rawData)), e.externalData) {\n              if (!Array.isArray(e.externalData)) throw TypeError(\".onnx.TensorProto.externalData: array expected\");\n              for (t.externalData = [], n = 0; n < e.externalData.length; ++n) {\n                if (\"object\" != typeof e.externalData[n]) throw TypeError(\".onnx.TensorProto.externalData: object expected\");\n                t.externalData[n] = c.onnx.StringStringEntryProto.fromObject(e.externalData[n]);\n              }\n            }\n            switch (e.dataLocation) {\n              default:\n                if (\"number\" == typeof e.dataLocation) {\n                  t.dataLocation = e.dataLocation;\n                  break;\n                }\n                break;\n              case \"DEFAULT\":\n              case 0:\n                t.dataLocation = 0;\n                break;\n              case \"EXTERNAL\":\n              case 1:\n                t.dataLocation = 1;\n            }\n            if (e.doubleData) {\n              if (!Array.isArray(e.doubleData)) throw TypeError(\".onnx.TensorProto.doubleData: array expected\");\n              for (t.doubleData = [], n = 0; n < e.doubleData.length; ++n) t.doubleData[n] = Number(e.doubleData[n]);\n            }\n            if (e.uint64Data) {\n              if (!Array.isArray(e.uint64Data)) throw TypeError(\".onnx.TensorProto.uint64Data: array expected\");\n              for (t.uint64Data = [], n = 0; n < e.uint64Data.length; ++n) l.Long ? (t.uint64Data[n] = l.Long.fromValue(e.uint64Data[n])).unsigned = !0 : \"string\" == typeof e.uint64Data[n] ? t.uint64Data[n] = parseInt(e.uint64Data[n], 10) : \"number\" == typeof e.uint64Data[n] ? t.uint64Data[n] = e.uint64Data[n] : \"object\" == typeof e.uint64Data[n] && (t.uint64Data[n] = new l.LongBits(e.uint64Data[n].low >>> 0, e.uint64Data[n].high >>> 0).toNumber(!0));\n            }\n            return t;\n          }, e.toObject = function (e, t) {\n            t || (t = {});\n            var n = {};\n            if ((t.arrays || t.defaults) && (n.dims = [], n.floatData = [], n.int32Data = [], n.stringData = [], n.int64Data = [], n.doubleData = [], n.uint64Data = [], n.externalData = []), t.defaults && (n.dataType = 0, n.segment = null, n.name = \"\", t.bytes === String ? n.rawData = \"\" : (n.rawData = [], t.bytes !== Array && (n.rawData = l.newBuffer(n.rawData))), n.docString = \"\", n.dataLocation = t.enums === String ? \"DEFAULT\" : 0), e.dims && e.dims.length) {\n              n.dims = [];\n              for (var r = 0; r < e.dims.length; ++r) \"number\" == typeof e.dims[r] ? n.dims[r] = t.longs === String ? String(e.dims[r]) : e.dims[r] : n.dims[r] = t.longs === String ? l.Long.prototype.toString.call(e.dims[r]) : t.longs === Number ? new l.LongBits(e.dims[r].low >>> 0, e.dims[r].high >>> 0).toNumber() : e.dims[r];\n            }\n            if (null != e.dataType && e.hasOwnProperty(\"dataType\") && (n.dataType = e.dataType), null != e.segment && e.hasOwnProperty(\"segment\") && (n.segment = c.onnx.TensorProto.Segment.toObject(e.segment, t)), e.floatData && e.floatData.length) for (n.floatData = [], r = 0; r < e.floatData.length; ++r) n.floatData[r] = t.json && !isFinite(e.floatData[r]) ? String(e.floatData[r]) : e.floatData[r];\n            if (e.int32Data && e.int32Data.length) for (n.int32Data = [], r = 0; r < e.int32Data.length; ++r) n.int32Data[r] = e.int32Data[r];\n            if (e.stringData && e.stringData.length) for (n.stringData = [], r = 0; r < e.stringData.length; ++r) n.stringData[r] = t.bytes === String ? l.base64.encode(e.stringData[r], 0, e.stringData[r].length) : t.bytes === Array ? Array.prototype.slice.call(e.stringData[r]) : e.stringData[r];\n            if (e.int64Data && e.int64Data.length) for (n.int64Data = [], r = 0; r < e.int64Data.length; ++r) \"number\" == typeof e.int64Data[r] ? n.int64Data[r] = t.longs === String ? String(e.int64Data[r]) : e.int64Data[r] : n.int64Data[r] = t.longs === String ? l.Long.prototype.toString.call(e.int64Data[r]) : t.longs === Number ? new l.LongBits(e.int64Data[r].low >>> 0, e.int64Data[r].high >>> 0).toNumber() : e.int64Data[r];\n            if (null != e.name && e.hasOwnProperty(\"name\") && (n.name = e.name), null != e.rawData && e.hasOwnProperty(\"rawData\") && (n.rawData = t.bytes === String ? l.base64.encode(e.rawData, 0, e.rawData.length) : t.bytes === Array ? Array.prototype.slice.call(e.rawData) : e.rawData), e.doubleData && e.doubleData.length) for (n.doubleData = [], r = 0; r < e.doubleData.length; ++r) n.doubleData[r] = t.json && !isFinite(e.doubleData[r]) ? String(e.doubleData[r]) : e.doubleData[r];\n            if (e.uint64Data && e.uint64Data.length) for (n.uint64Data = [], r = 0; r < e.uint64Data.length; ++r) \"number\" == typeof e.uint64Data[r] ? n.uint64Data[r] = t.longs === String ? String(e.uint64Data[r]) : e.uint64Data[r] : n.uint64Data[r] = t.longs === String ? l.Long.prototype.toString.call(e.uint64Data[r]) : t.longs === Number ? new l.LongBits(e.uint64Data[r].low >>> 0, e.uint64Data[r].high >>> 0).toNumber(!0) : e.uint64Data[r];\n            if (null != e.docString && e.hasOwnProperty(\"docString\") && (n.docString = e.docString), e.externalData && e.externalData.length) for (n.externalData = [], r = 0; r < e.externalData.length; ++r) n.externalData[r] = c.onnx.StringStringEntryProto.toObject(e.externalData[r], t);\n            return null != e.dataLocation && e.hasOwnProperty(\"dataLocation\") && (n.dataLocation = t.enums === String ? void 0 === c.onnx.TensorProto.DataLocation[e.dataLocation] ? e.dataLocation : c.onnx.TensorProto.DataLocation[e.dataLocation] : e.dataLocation), n;\n          }, e.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, e.getTypeUrl = function (e) {\n            return void 0 === e && (e = \"type.googleapis.com\"), e + \"/onnx.TensorProto\";\n          }, e.DataType = function () {\n            var e = {},\n              t = Object.create(e);\n            return t[e[0] = \"UNDEFINED\"] = 0, t[e[1] = \"FLOAT\"] = 1, t[e[2] = \"UINT8\"] = 2, t[e[3] = \"INT8\"] = 3, t[e[4] = \"UINT16\"] = 4, t[e[5] = \"INT16\"] = 5, t[e[6] = \"INT32\"] = 6, t[e[7] = \"INT64\"] = 7, t[e[8] = \"STRING\"] = 8, t[e[9] = \"BOOL\"] = 9, t[e[10] = \"FLOAT16\"] = 10, t[e[11] = \"DOUBLE\"] = 11, t[e[12] = \"UINT32\"] = 12, t[e[13] = \"UINT64\"] = 13, t[e[14] = \"COMPLEX64\"] = 14, t[e[15] = \"COMPLEX128\"] = 15, t[e[16] = \"BFLOAT16\"] = 16, t[e[17] = \"FLOAT8E4M3FN\"] = 17, t[e[18] = \"FLOAT8E4M3FNUZ\"] = 18, t[e[19] = \"FLOAT8E5M2\"] = 19, t[e[20] = \"FLOAT8E5M2FNUZ\"] = 20, t;\n          }(), e.Segment = function () {\n            function e(e) {\n              if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n            }\n            return e.prototype.begin = l.Long ? l.Long.fromBits(0, 0, !1) : 0, e.prototype.end = l.Long ? l.Long.fromBits(0, 0, !1) : 0, e.create = function (t) {\n              return new e(t);\n            }, e.encode = function (e, t) {\n              return t || (t = u.create()), null != e.begin && Object.hasOwnProperty.call(e, \"begin\") && t.uint32(8).int64(e.begin), null != e.end && Object.hasOwnProperty.call(e, \"end\") && t.uint32(16).int64(e.end), t;\n            }, e.encodeDelimited = function (e, t) {\n              return this.encode(e, t).ldelim();\n            }, e.decode = function (e, t) {\n              e instanceof s || (e = s.create(e));\n              for (var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.TensorProto.Segment(); e.pos < n;) {\n                var o = e.uint32();\n                switch (o >>> 3) {\n                  case 1:\n                    r.begin = e.int64();\n                    break;\n                  case 2:\n                    r.end = e.int64();\n                    break;\n                  default:\n                    e.skipType(7 & o);\n                }\n              }\n              return r;\n            }, e.decodeDelimited = function (e) {\n              return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n            }, e.verify = function (e) {\n              return \"object\" != typeof e || null === e ? \"object expected\" : null != e.begin && e.hasOwnProperty(\"begin\") && !(l.isInteger(e.begin) || e.begin && l.isInteger(e.begin.low) && l.isInteger(e.begin.high)) ? \"begin: integer|Long expected\" : null != e.end && e.hasOwnProperty(\"end\") && !(l.isInteger(e.end) || e.end && l.isInteger(e.end.low) && l.isInteger(e.end.high)) ? \"end: integer|Long expected\" : null;\n            }, e.fromObject = function (e) {\n              if (e instanceof c.onnx.TensorProto.Segment) return e;\n              var t = new c.onnx.TensorProto.Segment();\n              return null != e.begin && (l.Long ? (t.begin = l.Long.fromValue(e.begin)).unsigned = !1 : \"string\" == typeof e.begin ? t.begin = parseInt(e.begin, 10) : \"number\" == typeof e.begin ? t.begin = e.begin : \"object\" == typeof e.begin && (t.begin = new l.LongBits(e.begin.low >>> 0, e.begin.high >>> 0).toNumber())), null != e.end && (l.Long ? (t.end = l.Long.fromValue(e.end)).unsigned = !1 : \"string\" == typeof e.end ? t.end = parseInt(e.end, 10) : \"number\" == typeof e.end ? t.end = e.end : \"object\" == typeof e.end && (t.end = new l.LongBits(e.end.low >>> 0, e.end.high >>> 0).toNumber())), t;\n            }, e.toObject = function (e, t) {\n              t || (t = {});\n              var n = {};\n              if (t.defaults) {\n                if (l.Long) {\n                  var r = new l.Long(0, 0, !1);\n                  n.begin = t.longs === String ? r.toString() : t.longs === Number ? r.toNumber() : r;\n                } else n.begin = t.longs === String ? \"0\" : 0;\n                l.Long ? (r = new l.Long(0, 0, !1), n.end = t.longs === String ? r.toString() : t.longs === Number ? r.toNumber() : r) : n.end = t.longs === String ? \"0\" : 0;\n              }\n              return null != e.begin && e.hasOwnProperty(\"begin\") && (\"number\" == typeof e.begin ? n.begin = t.longs === String ? String(e.begin) : e.begin : n.begin = t.longs === String ? l.Long.prototype.toString.call(e.begin) : t.longs === Number ? new l.LongBits(e.begin.low >>> 0, e.begin.high >>> 0).toNumber() : e.begin), null != e.end && e.hasOwnProperty(\"end\") && (\"number\" == typeof e.end ? n.end = t.longs === String ? String(e.end) : e.end : n.end = t.longs === String ? l.Long.prototype.toString.call(e.end) : t.longs === Number ? new l.LongBits(e.end.low >>> 0, e.end.high >>> 0).toNumber() : e.end), n;\n            }, e.prototype.toJSON = function () {\n              return this.constructor.toObject(this, a.util.toJSONOptions);\n            }, e.getTypeUrl = function (e) {\n              return void 0 === e && (e = \"type.googleapis.com\"), e + \"/onnx.TensorProto.Segment\";\n            }, e;\n          }(), e.DataLocation = function () {\n            var e = {},\n              t = Object.create(e);\n            return t[e[0] = \"DEFAULT\"] = 0, t[e[1] = \"EXTERNAL\"] = 1, t;\n          }(), e;\n        }(), i.SparseTensorProto = function () {\n          function e(e) {\n            if (this.dims = [], e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n          }\n          return e.prototype.values = null, e.prototype.indices = null, e.prototype.dims = l.emptyArray, e.create = function (t) {\n            return new e(t);\n          }, e.encode = function (e, t) {\n            if (t || (t = u.create()), null != e.values && Object.hasOwnProperty.call(e, \"values\") && c.onnx.TensorProto.encode(e.values, t.uint32(10).fork()).ldelim(), null != e.indices && Object.hasOwnProperty.call(e, \"indices\") && c.onnx.TensorProto.encode(e.indices, t.uint32(18).fork()).ldelim(), null != e.dims && e.dims.length) {\n              t.uint32(26).fork();\n              for (var n = 0; n < e.dims.length; ++n) t.int64(e.dims[n]);\n              t.ldelim();\n            }\n            return t;\n          }, e.encodeDelimited = function (e, t) {\n            return this.encode(e, t).ldelim();\n          }, e.decode = function (e, t) {\n            e instanceof s || (e = s.create(e));\n            for (var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.SparseTensorProto(); e.pos < n;) {\n              var o = e.uint32();\n              switch (o >>> 3) {\n                case 1:\n                  r.values = c.onnx.TensorProto.decode(e, e.uint32());\n                  break;\n                case 2:\n                  r.indices = c.onnx.TensorProto.decode(e, e.uint32());\n                  break;\n                case 3:\n                  if (r.dims && r.dims.length || (r.dims = []), 2 == (7 & o)) for (var i = e.uint32() + e.pos; e.pos < i;) r.dims.push(e.int64());else r.dims.push(e.int64());\n                  break;\n                default:\n                  e.skipType(7 & o);\n              }\n            }\n            return r;\n          }, e.decodeDelimited = function (e) {\n            return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n          }, e.verify = function (e) {\n            if (\"object\" != typeof e || null === e) return \"object expected\";\n            var t;\n            if (null != e.values && e.hasOwnProperty(\"values\") && (t = c.onnx.TensorProto.verify(e.values))) return \"values.\" + t;\n            if (null != e.indices && e.hasOwnProperty(\"indices\") && (t = c.onnx.TensorProto.verify(e.indices))) return \"indices.\" + t;\n            if (null != e.dims && e.hasOwnProperty(\"dims\")) {\n              if (!Array.isArray(e.dims)) return \"dims: array expected\";\n              for (var n = 0; n < e.dims.length; ++n) if (!(l.isInteger(e.dims[n]) || e.dims[n] && l.isInteger(e.dims[n].low) && l.isInteger(e.dims[n].high))) return \"dims: integer|Long[] expected\";\n            }\n            return null;\n          }, e.fromObject = function (e) {\n            if (e instanceof c.onnx.SparseTensorProto) return e;\n            var t = new c.onnx.SparseTensorProto();\n            if (null != e.values) {\n              if (\"object\" != typeof e.values) throw TypeError(\".onnx.SparseTensorProto.values: object expected\");\n              t.values = c.onnx.TensorProto.fromObject(e.values);\n            }\n            if (null != e.indices) {\n              if (\"object\" != typeof e.indices) throw TypeError(\".onnx.SparseTensorProto.indices: object expected\");\n              t.indices = c.onnx.TensorProto.fromObject(e.indices);\n            }\n            if (e.dims) {\n              if (!Array.isArray(e.dims)) throw TypeError(\".onnx.SparseTensorProto.dims: array expected\");\n              t.dims = [];\n              for (var n = 0; n < e.dims.length; ++n) l.Long ? (t.dims[n] = l.Long.fromValue(e.dims[n])).unsigned = !1 : \"string\" == typeof e.dims[n] ? t.dims[n] = parseInt(e.dims[n], 10) : \"number\" == typeof e.dims[n] ? t.dims[n] = e.dims[n] : \"object\" == typeof e.dims[n] && (t.dims[n] = new l.LongBits(e.dims[n].low >>> 0, e.dims[n].high >>> 0).toNumber());\n            }\n            return t;\n          }, e.toObject = function (e, t) {\n            t || (t = {});\n            var n = {};\n            if ((t.arrays || t.defaults) && (n.dims = []), t.defaults && (n.values = null, n.indices = null), null != e.values && e.hasOwnProperty(\"values\") && (n.values = c.onnx.TensorProto.toObject(e.values, t)), null != e.indices && e.hasOwnProperty(\"indices\") && (n.indices = c.onnx.TensorProto.toObject(e.indices, t)), e.dims && e.dims.length) {\n              n.dims = [];\n              for (var r = 0; r < e.dims.length; ++r) \"number\" == typeof e.dims[r] ? n.dims[r] = t.longs === String ? String(e.dims[r]) : e.dims[r] : n.dims[r] = t.longs === String ? l.Long.prototype.toString.call(e.dims[r]) : t.longs === Number ? new l.LongBits(e.dims[r].low >>> 0, e.dims[r].high >>> 0).toNumber() : e.dims[r];\n            }\n            return n;\n          }, e.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, e.getTypeUrl = function (e) {\n            return void 0 === e && (e = \"type.googleapis.com\"), e + \"/onnx.SparseTensorProto\";\n          }, e;\n        }(), i.TensorShapeProto = function () {\n          function e(e) {\n            if (this.dim = [], e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n          }\n          return e.prototype.dim = l.emptyArray, e.create = function (t) {\n            return new e(t);\n          }, e.encode = function (e, t) {\n            if (t || (t = u.create()), null != e.dim && e.dim.length) for (var n = 0; n < e.dim.length; ++n) c.onnx.TensorShapeProto.Dimension.encode(e.dim[n], t.uint32(10).fork()).ldelim();\n            return t;\n          }, e.encodeDelimited = function (e, t) {\n            return this.encode(e, t).ldelim();\n          }, e.decode = function (e, t) {\n            e instanceof s || (e = s.create(e));\n            for (var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.TensorShapeProto(); e.pos < n;) {\n              var o = e.uint32();\n              o >>> 3 == 1 ? (r.dim && r.dim.length || (r.dim = []), r.dim.push(c.onnx.TensorShapeProto.Dimension.decode(e, e.uint32()))) : e.skipType(7 & o);\n            }\n            return r;\n          }, e.decodeDelimited = function (e) {\n            return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n          }, e.verify = function (e) {\n            if (\"object\" != typeof e || null === e) return \"object expected\";\n            if (null != e.dim && e.hasOwnProperty(\"dim\")) {\n              if (!Array.isArray(e.dim)) return \"dim: array expected\";\n              for (var t = 0; t < e.dim.length; ++t) {\n                var n = c.onnx.TensorShapeProto.Dimension.verify(e.dim[t]);\n                if (n) return \"dim.\" + n;\n              }\n            }\n            return null;\n          }, e.fromObject = function (e) {\n            if (e instanceof c.onnx.TensorShapeProto) return e;\n            var t = new c.onnx.TensorShapeProto();\n            if (e.dim) {\n              if (!Array.isArray(e.dim)) throw TypeError(\".onnx.TensorShapeProto.dim: array expected\");\n              t.dim = [];\n              for (var n = 0; n < e.dim.length; ++n) {\n                if (\"object\" != typeof e.dim[n]) throw TypeError(\".onnx.TensorShapeProto.dim: object expected\");\n                t.dim[n] = c.onnx.TensorShapeProto.Dimension.fromObject(e.dim[n]);\n              }\n            }\n            return t;\n          }, e.toObject = function (e, t) {\n            t || (t = {});\n            var n = {};\n            if ((t.arrays || t.defaults) && (n.dim = []), e.dim && e.dim.length) {\n              n.dim = [];\n              for (var r = 0; r < e.dim.length; ++r) n.dim[r] = c.onnx.TensorShapeProto.Dimension.toObject(e.dim[r], t);\n            }\n            return n;\n          }, e.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, e.getTypeUrl = function (e) {\n            return void 0 === e && (e = \"type.googleapis.com\"), e + \"/onnx.TensorShapeProto\";\n          }, e.Dimension = function () {\n            function e(e) {\n              if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n            }\n            var t;\n            return e.prototype.dimValue = null, e.prototype.dimParam = null, e.prototype.denotation = \"\", Object.defineProperty(e.prototype, \"value\", {\n              get: l.oneOfGetter(t = [\"dimValue\", \"dimParam\"]),\n              set: l.oneOfSetter(t)\n            }), e.create = function (t) {\n              return new e(t);\n            }, e.encode = function (e, t) {\n              return t || (t = u.create()), null != e.dimValue && Object.hasOwnProperty.call(e, \"dimValue\") && t.uint32(8).int64(e.dimValue), null != e.dimParam && Object.hasOwnProperty.call(e, \"dimParam\") && t.uint32(18).string(e.dimParam), null != e.denotation && Object.hasOwnProperty.call(e, \"denotation\") && t.uint32(26).string(e.denotation), t;\n            }, e.encodeDelimited = function (e, t) {\n              return this.encode(e, t).ldelim();\n            }, e.decode = function (e, t) {\n              e instanceof s || (e = s.create(e));\n              for (var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.TensorShapeProto.Dimension(); e.pos < n;) {\n                var o = e.uint32();\n                switch (o >>> 3) {\n                  case 1:\n                    r.dimValue = e.int64();\n                    break;\n                  case 2:\n                    r.dimParam = e.string();\n                    break;\n                  case 3:\n                    r.denotation = e.string();\n                    break;\n                  default:\n                    e.skipType(7 & o);\n                }\n              }\n              return r;\n            }, e.decodeDelimited = function (e) {\n              return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n            }, e.verify = function (e) {\n              if (\"object\" != typeof e || null === e) return \"object expected\";\n              var t = {};\n              if (null != e.dimValue && e.hasOwnProperty(\"dimValue\") && (t.value = 1, !(l.isInteger(e.dimValue) || e.dimValue && l.isInteger(e.dimValue.low) && l.isInteger(e.dimValue.high)))) return \"dimValue: integer|Long expected\";\n              if (null != e.dimParam && e.hasOwnProperty(\"dimParam\")) {\n                if (1 === t.value) return \"value: multiple values\";\n                if (t.value = 1, !l.isString(e.dimParam)) return \"dimParam: string expected\";\n              }\n              return null != e.denotation && e.hasOwnProperty(\"denotation\") && !l.isString(e.denotation) ? \"denotation: string expected\" : null;\n            }, e.fromObject = function (e) {\n              if (e instanceof c.onnx.TensorShapeProto.Dimension) return e;\n              var t = new c.onnx.TensorShapeProto.Dimension();\n              return null != e.dimValue && (l.Long ? (t.dimValue = l.Long.fromValue(e.dimValue)).unsigned = !1 : \"string\" == typeof e.dimValue ? t.dimValue = parseInt(e.dimValue, 10) : \"number\" == typeof e.dimValue ? t.dimValue = e.dimValue : \"object\" == typeof e.dimValue && (t.dimValue = new l.LongBits(e.dimValue.low >>> 0, e.dimValue.high >>> 0).toNumber())), null != e.dimParam && (t.dimParam = String(e.dimParam)), null != e.denotation && (t.denotation = String(e.denotation)), t;\n            }, e.toObject = function (e, t) {\n              t || (t = {});\n              var n = {};\n              return t.defaults && (n.denotation = \"\"), null != e.dimValue && e.hasOwnProperty(\"dimValue\") && (\"number\" == typeof e.dimValue ? n.dimValue = t.longs === String ? String(e.dimValue) : e.dimValue : n.dimValue = t.longs === String ? l.Long.prototype.toString.call(e.dimValue) : t.longs === Number ? new l.LongBits(e.dimValue.low >>> 0, e.dimValue.high >>> 0).toNumber() : e.dimValue, t.oneofs && (n.value = \"dimValue\")), null != e.dimParam && e.hasOwnProperty(\"dimParam\") && (n.dimParam = e.dimParam, t.oneofs && (n.value = \"dimParam\")), null != e.denotation && e.hasOwnProperty(\"denotation\") && (n.denotation = e.denotation), n;\n            }, e.prototype.toJSON = function () {\n              return this.constructor.toObject(this, a.util.toJSONOptions);\n            }, e.getTypeUrl = function (e) {\n              return void 0 === e && (e = \"type.googleapis.com\"), e + \"/onnx.TensorShapeProto.Dimension\";\n            }, e;\n          }(), e;\n        }(), i.TypeProto = function () {\n          function e(e) {\n            if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n          }\n          var t;\n          return e.prototype.tensorType = null, e.prototype.sequenceType = null, e.prototype.mapType = null, e.prototype.optionalType = null, e.prototype.sparseTensorType = null, e.prototype.denotation = \"\", Object.defineProperty(e.prototype, \"value\", {\n            get: l.oneOfGetter(t = [\"tensorType\", \"sequenceType\", \"mapType\", \"optionalType\", \"sparseTensorType\"]),\n            set: l.oneOfSetter(t)\n          }), e.create = function (t) {\n            return new e(t);\n          }, e.encode = function (e, t) {\n            return t || (t = u.create()), null != e.tensorType && Object.hasOwnProperty.call(e, \"tensorType\") && c.onnx.TypeProto.Tensor.encode(e.tensorType, t.uint32(10).fork()).ldelim(), null != e.sequenceType && Object.hasOwnProperty.call(e, \"sequenceType\") && c.onnx.TypeProto.Sequence.encode(e.sequenceType, t.uint32(34).fork()).ldelim(), null != e.mapType && Object.hasOwnProperty.call(e, \"mapType\") && c.onnx.TypeProto.Map.encode(e.mapType, t.uint32(42).fork()).ldelim(), null != e.denotation && Object.hasOwnProperty.call(e, \"denotation\") && t.uint32(50).string(e.denotation), null != e.sparseTensorType && Object.hasOwnProperty.call(e, \"sparseTensorType\") && c.onnx.TypeProto.SparseTensor.encode(e.sparseTensorType, t.uint32(66).fork()).ldelim(), null != e.optionalType && Object.hasOwnProperty.call(e, \"optionalType\") && c.onnx.TypeProto.Optional.encode(e.optionalType, t.uint32(74).fork()).ldelim(), t;\n          }, e.encodeDelimited = function (e, t) {\n            return this.encode(e, t).ldelim();\n          }, e.decode = function (e, t) {\n            e instanceof s || (e = s.create(e));\n            for (var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.TypeProto(); e.pos < n;) {\n              var o = e.uint32();\n              switch (o >>> 3) {\n                case 1:\n                  r.tensorType = c.onnx.TypeProto.Tensor.decode(e, e.uint32());\n                  break;\n                case 4:\n                  r.sequenceType = c.onnx.TypeProto.Sequence.decode(e, e.uint32());\n                  break;\n                case 5:\n                  r.mapType = c.onnx.TypeProto.Map.decode(e, e.uint32());\n                  break;\n                case 9:\n                  r.optionalType = c.onnx.TypeProto.Optional.decode(e, e.uint32());\n                  break;\n                case 8:\n                  r.sparseTensorType = c.onnx.TypeProto.SparseTensor.decode(e, e.uint32());\n                  break;\n                case 6:\n                  r.denotation = e.string();\n                  break;\n                default:\n                  e.skipType(7 & o);\n              }\n            }\n            return r;\n          }, e.decodeDelimited = function (e) {\n            return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n          }, e.verify = function (e) {\n            if (\"object\" != typeof e || null === e) return \"object expected\";\n            var t = {};\n            if (null != e.tensorType && e.hasOwnProperty(\"tensorType\") && (t.value = 1, n = c.onnx.TypeProto.Tensor.verify(e.tensorType))) return \"tensorType.\" + n;\n            if (null != e.sequenceType && e.hasOwnProperty(\"sequenceType\")) {\n              if (1 === t.value) return \"value: multiple values\";\n              if (t.value = 1, n = c.onnx.TypeProto.Sequence.verify(e.sequenceType)) return \"sequenceType.\" + n;\n            }\n            if (null != e.mapType && e.hasOwnProperty(\"mapType\")) {\n              if (1 === t.value) return \"value: multiple values\";\n              if (t.value = 1, n = c.onnx.TypeProto.Map.verify(e.mapType)) return \"mapType.\" + n;\n            }\n            if (null != e.optionalType && e.hasOwnProperty(\"optionalType\")) {\n              if (1 === t.value) return \"value: multiple values\";\n              if (t.value = 1, n = c.onnx.TypeProto.Optional.verify(e.optionalType)) return \"optionalType.\" + n;\n            }\n            if (null != e.sparseTensorType && e.hasOwnProperty(\"sparseTensorType\")) {\n              if (1 === t.value) return \"value: multiple values\";\n              var n;\n              if (t.value = 1, n = c.onnx.TypeProto.SparseTensor.verify(e.sparseTensorType)) return \"sparseTensorType.\" + n;\n            }\n            return null != e.denotation && e.hasOwnProperty(\"denotation\") && !l.isString(e.denotation) ? \"denotation: string expected\" : null;\n          }, e.fromObject = function (e) {\n            if (e instanceof c.onnx.TypeProto) return e;\n            var t = new c.onnx.TypeProto();\n            if (null != e.tensorType) {\n              if (\"object\" != typeof e.tensorType) throw TypeError(\".onnx.TypeProto.tensorType: object expected\");\n              t.tensorType = c.onnx.TypeProto.Tensor.fromObject(e.tensorType);\n            }\n            if (null != e.sequenceType) {\n              if (\"object\" != typeof e.sequenceType) throw TypeError(\".onnx.TypeProto.sequenceType: object expected\");\n              t.sequenceType = c.onnx.TypeProto.Sequence.fromObject(e.sequenceType);\n            }\n            if (null != e.mapType) {\n              if (\"object\" != typeof e.mapType) throw TypeError(\".onnx.TypeProto.mapType: object expected\");\n              t.mapType = c.onnx.TypeProto.Map.fromObject(e.mapType);\n            }\n            if (null != e.optionalType) {\n              if (\"object\" != typeof e.optionalType) throw TypeError(\".onnx.TypeProto.optionalType: object expected\");\n              t.optionalType = c.onnx.TypeProto.Optional.fromObject(e.optionalType);\n            }\n            if (null != e.sparseTensorType) {\n              if (\"object\" != typeof e.sparseTensorType) throw TypeError(\".onnx.TypeProto.sparseTensorType: object expected\");\n              t.sparseTensorType = c.onnx.TypeProto.SparseTensor.fromObject(e.sparseTensorType);\n            }\n            return null != e.denotation && (t.denotation = String(e.denotation)), t;\n          }, e.toObject = function (e, t) {\n            t || (t = {});\n            var n = {};\n            return t.defaults && (n.denotation = \"\"), null != e.tensorType && e.hasOwnProperty(\"tensorType\") && (n.tensorType = c.onnx.TypeProto.Tensor.toObject(e.tensorType, t), t.oneofs && (n.value = \"tensorType\")), null != e.sequenceType && e.hasOwnProperty(\"sequenceType\") && (n.sequenceType = c.onnx.TypeProto.Sequence.toObject(e.sequenceType, t), t.oneofs && (n.value = \"sequenceType\")), null != e.mapType && e.hasOwnProperty(\"mapType\") && (n.mapType = c.onnx.TypeProto.Map.toObject(e.mapType, t), t.oneofs && (n.value = \"mapType\")), null != e.denotation && e.hasOwnProperty(\"denotation\") && (n.denotation = e.denotation), null != e.sparseTensorType && e.hasOwnProperty(\"sparseTensorType\") && (n.sparseTensorType = c.onnx.TypeProto.SparseTensor.toObject(e.sparseTensorType, t), t.oneofs && (n.value = \"sparseTensorType\")), null != e.optionalType && e.hasOwnProperty(\"optionalType\") && (n.optionalType = c.onnx.TypeProto.Optional.toObject(e.optionalType, t), t.oneofs && (n.value = \"optionalType\")), n;\n          }, e.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, e.getTypeUrl = function (e) {\n            return void 0 === e && (e = \"type.googleapis.com\"), e + \"/onnx.TypeProto\";\n          }, e.Tensor = function () {\n            function e(e) {\n              if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n            }\n            return e.prototype.elemType = 0, e.prototype.shape = null, e.create = function (t) {\n              return new e(t);\n            }, e.encode = function (e, t) {\n              return t || (t = u.create()), null != e.elemType && Object.hasOwnProperty.call(e, \"elemType\") && t.uint32(8).int32(e.elemType), null != e.shape && Object.hasOwnProperty.call(e, \"shape\") && c.onnx.TensorShapeProto.encode(e.shape, t.uint32(18).fork()).ldelim(), t;\n            }, e.encodeDelimited = function (e, t) {\n              return this.encode(e, t).ldelim();\n            }, e.decode = function (e, t) {\n              e instanceof s || (e = s.create(e));\n              for (var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.TypeProto.Tensor(); e.pos < n;) {\n                var o = e.uint32();\n                switch (o >>> 3) {\n                  case 1:\n                    r.elemType = e.int32();\n                    break;\n                  case 2:\n                    r.shape = c.onnx.TensorShapeProto.decode(e, e.uint32());\n                    break;\n                  default:\n                    e.skipType(7 & o);\n                }\n              }\n              return r;\n            }, e.decodeDelimited = function (e) {\n              return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n            }, e.verify = function (e) {\n              if (\"object\" != typeof e || null === e) return \"object expected\";\n              if (null != e.elemType && e.hasOwnProperty(\"elemType\") && !l.isInteger(e.elemType)) return \"elemType: integer expected\";\n              if (null != e.shape && e.hasOwnProperty(\"shape\")) {\n                var t = c.onnx.TensorShapeProto.verify(e.shape);\n                if (t) return \"shape.\" + t;\n              }\n              return null;\n            }, e.fromObject = function (e) {\n              if (e instanceof c.onnx.TypeProto.Tensor) return e;\n              var t = new c.onnx.TypeProto.Tensor();\n              if (null != e.elemType && (t.elemType = 0 | e.elemType), null != e.shape) {\n                if (\"object\" != typeof e.shape) throw TypeError(\".onnx.TypeProto.Tensor.shape: object expected\");\n                t.shape = c.onnx.TensorShapeProto.fromObject(e.shape);\n              }\n              return t;\n            }, e.toObject = function (e, t) {\n              t || (t = {});\n              var n = {};\n              return t.defaults && (n.elemType = 0, n.shape = null), null != e.elemType && e.hasOwnProperty(\"elemType\") && (n.elemType = e.elemType), null != e.shape && e.hasOwnProperty(\"shape\") && (n.shape = c.onnx.TensorShapeProto.toObject(e.shape, t)), n;\n            }, e.prototype.toJSON = function () {\n              return this.constructor.toObject(this, a.util.toJSONOptions);\n            }, e.getTypeUrl = function (e) {\n              return void 0 === e && (e = \"type.googleapis.com\"), e + \"/onnx.TypeProto.Tensor\";\n            }, e;\n          }(), e.Sequence = function () {\n            function e(e) {\n              if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n            }\n            return e.prototype.elemType = null, e.create = function (t) {\n              return new e(t);\n            }, e.encode = function (e, t) {\n              return t || (t = u.create()), null != e.elemType && Object.hasOwnProperty.call(e, \"elemType\") && c.onnx.TypeProto.encode(e.elemType, t.uint32(10).fork()).ldelim(), t;\n            }, e.encodeDelimited = function (e, t) {\n              return this.encode(e, t).ldelim();\n            }, e.decode = function (e, t) {\n              e instanceof s || (e = s.create(e));\n              for (var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.TypeProto.Sequence(); e.pos < n;) {\n                var o = e.uint32();\n                o >>> 3 == 1 ? r.elemType = c.onnx.TypeProto.decode(e, e.uint32()) : e.skipType(7 & o);\n              }\n              return r;\n            }, e.decodeDelimited = function (e) {\n              return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n            }, e.verify = function (e) {\n              if (\"object\" != typeof e || null === e) return \"object expected\";\n              if (null != e.elemType && e.hasOwnProperty(\"elemType\")) {\n                var t = c.onnx.TypeProto.verify(e.elemType);\n                if (t) return \"elemType.\" + t;\n              }\n              return null;\n            }, e.fromObject = function (e) {\n              if (e instanceof c.onnx.TypeProto.Sequence) return e;\n              var t = new c.onnx.TypeProto.Sequence();\n              if (null != e.elemType) {\n                if (\"object\" != typeof e.elemType) throw TypeError(\".onnx.TypeProto.Sequence.elemType: object expected\");\n                t.elemType = c.onnx.TypeProto.fromObject(e.elemType);\n              }\n              return t;\n            }, e.toObject = function (e, t) {\n              t || (t = {});\n              var n = {};\n              return t.defaults && (n.elemType = null), null != e.elemType && e.hasOwnProperty(\"elemType\") && (n.elemType = c.onnx.TypeProto.toObject(e.elemType, t)), n;\n            }, e.prototype.toJSON = function () {\n              return this.constructor.toObject(this, a.util.toJSONOptions);\n            }, e.getTypeUrl = function (e) {\n              return void 0 === e && (e = \"type.googleapis.com\"), e + \"/onnx.TypeProto.Sequence\";\n            }, e;\n          }(), e.Map = function () {\n            function e(e) {\n              if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n            }\n            return e.prototype.keyType = 0, e.prototype.valueType = null, e.create = function (t) {\n              return new e(t);\n            }, e.encode = function (e, t) {\n              return t || (t = u.create()), null != e.keyType && Object.hasOwnProperty.call(e, \"keyType\") && t.uint32(8).int32(e.keyType), null != e.valueType && Object.hasOwnProperty.call(e, \"valueType\") && c.onnx.TypeProto.encode(e.valueType, t.uint32(18).fork()).ldelim(), t;\n            }, e.encodeDelimited = function (e, t) {\n              return this.encode(e, t).ldelim();\n            }, e.decode = function (e, t) {\n              e instanceof s || (e = s.create(e));\n              for (var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.TypeProto.Map(); e.pos < n;) {\n                var o = e.uint32();\n                switch (o >>> 3) {\n                  case 1:\n                    r.keyType = e.int32();\n                    break;\n                  case 2:\n                    r.valueType = c.onnx.TypeProto.decode(e, e.uint32());\n                    break;\n                  default:\n                    e.skipType(7 & o);\n                }\n              }\n              return r;\n            }, e.decodeDelimited = function (e) {\n              return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n            }, e.verify = function (e) {\n              if (\"object\" != typeof e || null === e) return \"object expected\";\n              if (null != e.keyType && e.hasOwnProperty(\"keyType\") && !l.isInteger(e.keyType)) return \"keyType: integer expected\";\n              if (null != e.valueType && e.hasOwnProperty(\"valueType\")) {\n                var t = c.onnx.TypeProto.verify(e.valueType);\n                if (t) return \"valueType.\" + t;\n              }\n              return null;\n            }, e.fromObject = function (e) {\n              if (e instanceof c.onnx.TypeProto.Map) return e;\n              var t = new c.onnx.TypeProto.Map();\n              if (null != e.keyType && (t.keyType = 0 | e.keyType), null != e.valueType) {\n                if (\"object\" != typeof e.valueType) throw TypeError(\".onnx.TypeProto.Map.valueType: object expected\");\n                t.valueType = c.onnx.TypeProto.fromObject(e.valueType);\n              }\n              return t;\n            }, e.toObject = function (e, t) {\n              t || (t = {});\n              var n = {};\n              return t.defaults && (n.keyType = 0, n.valueType = null), null != e.keyType && e.hasOwnProperty(\"keyType\") && (n.keyType = e.keyType), null != e.valueType && e.hasOwnProperty(\"valueType\") && (n.valueType = c.onnx.TypeProto.toObject(e.valueType, t)), n;\n            }, e.prototype.toJSON = function () {\n              return this.constructor.toObject(this, a.util.toJSONOptions);\n            }, e.getTypeUrl = function (e) {\n              return void 0 === e && (e = \"type.googleapis.com\"), e + \"/onnx.TypeProto.Map\";\n            }, e;\n          }(), e.Optional = function () {\n            function e(e) {\n              if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n            }\n            return e.prototype.elemType = null, e.create = function (t) {\n              return new e(t);\n            }, e.encode = function (e, t) {\n              return t || (t = u.create()), null != e.elemType && Object.hasOwnProperty.call(e, \"elemType\") && c.onnx.TypeProto.encode(e.elemType, t.uint32(10).fork()).ldelim(), t;\n            }, e.encodeDelimited = function (e, t) {\n              return this.encode(e, t).ldelim();\n            }, e.decode = function (e, t) {\n              e instanceof s || (e = s.create(e));\n              for (var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.TypeProto.Optional(); e.pos < n;) {\n                var o = e.uint32();\n                o >>> 3 == 1 ? r.elemType = c.onnx.TypeProto.decode(e, e.uint32()) : e.skipType(7 & o);\n              }\n              return r;\n            }, e.decodeDelimited = function (e) {\n              return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n            }, e.verify = function (e) {\n              if (\"object\" != typeof e || null === e) return \"object expected\";\n              if (null != e.elemType && e.hasOwnProperty(\"elemType\")) {\n                var t = c.onnx.TypeProto.verify(e.elemType);\n                if (t) return \"elemType.\" + t;\n              }\n              return null;\n            }, e.fromObject = function (e) {\n              if (e instanceof c.onnx.TypeProto.Optional) return e;\n              var t = new c.onnx.TypeProto.Optional();\n              if (null != e.elemType) {\n                if (\"object\" != typeof e.elemType) throw TypeError(\".onnx.TypeProto.Optional.elemType: object expected\");\n                t.elemType = c.onnx.TypeProto.fromObject(e.elemType);\n              }\n              return t;\n            }, e.toObject = function (e, t) {\n              t || (t = {});\n              var n = {};\n              return t.defaults && (n.elemType = null), null != e.elemType && e.hasOwnProperty(\"elemType\") && (n.elemType = c.onnx.TypeProto.toObject(e.elemType, t)), n;\n            }, e.prototype.toJSON = function () {\n              return this.constructor.toObject(this, a.util.toJSONOptions);\n            }, e.getTypeUrl = function (e) {\n              return void 0 === e && (e = \"type.googleapis.com\"), e + \"/onnx.TypeProto.Optional\";\n            }, e;\n          }(), e.SparseTensor = function () {\n            function e(e) {\n              if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n            }\n            return e.prototype.elemType = 0, e.prototype.shape = null, e.create = function (t) {\n              return new e(t);\n            }, e.encode = function (e, t) {\n              return t || (t = u.create()), null != e.elemType && Object.hasOwnProperty.call(e, \"elemType\") && t.uint32(8).int32(e.elemType), null != e.shape && Object.hasOwnProperty.call(e, \"shape\") && c.onnx.TensorShapeProto.encode(e.shape, t.uint32(18).fork()).ldelim(), t;\n            }, e.encodeDelimited = function (e, t) {\n              return this.encode(e, t).ldelim();\n            }, e.decode = function (e, t) {\n              e instanceof s || (e = s.create(e));\n              for (var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.TypeProto.SparseTensor(); e.pos < n;) {\n                var o = e.uint32();\n                switch (o >>> 3) {\n                  case 1:\n                    r.elemType = e.int32();\n                    break;\n                  case 2:\n                    r.shape = c.onnx.TensorShapeProto.decode(e, e.uint32());\n                    break;\n                  default:\n                    e.skipType(7 & o);\n                }\n              }\n              return r;\n            }, e.decodeDelimited = function (e) {\n              return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n            }, e.verify = function (e) {\n              if (\"object\" != typeof e || null === e) return \"object expected\";\n              if (null != e.elemType && e.hasOwnProperty(\"elemType\") && !l.isInteger(e.elemType)) return \"elemType: integer expected\";\n              if (null != e.shape && e.hasOwnProperty(\"shape\")) {\n                var t = c.onnx.TensorShapeProto.verify(e.shape);\n                if (t) return \"shape.\" + t;\n              }\n              return null;\n            }, e.fromObject = function (e) {\n              if (e instanceof c.onnx.TypeProto.SparseTensor) return e;\n              var t = new c.onnx.TypeProto.SparseTensor();\n              if (null != e.elemType && (t.elemType = 0 | e.elemType), null != e.shape) {\n                if (\"object\" != typeof e.shape) throw TypeError(\".onnx.TypeProto.SparseTensor.shape: object expected\");\n                t.shape = c.onnx.TensorShapeProto.fromObject(e.shape);\n              }\n              return t;\n            }, e.toObject = function (e, t) {\n              t || (t = {});\n              var n = {};\n              return t.defaults && (n.elemType = 0, n.shape = null), null != e.elemType && e.hasOwnProperty(\"elemType\") && (n.elemType = e.elemType), null != e.shape && e.hasOwnProperty(\"shape\") && (n.shape = c.onnx.TensorShapeProto.toObject(e.shape, t)), n;\n            }, e.prototype.toJSON = function () {\n              return this.constructor.toObject(this, a.util.toJSONOptions);\n            }, e.getTypeUrl = function (e) {\n              return void 0 === e && (e = \"type.googleapis.com\"), e + \"/onnx.TypeProto.SparseTensor\";\n            }, e;\n          }(), e;\n        }(), i.OperatorSetIdProto = function () {\n          function e(e) {\n            if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n          }\n          return e.prototype.domain = \"\", e.prototype.version = l.Long ? l.Long.fromBits(0, 0, !1) : 0, e.create = function (t) {\n            return new e(t);\n          }, e.encode = function (e, t) {\n            return t || (t = u.create()), null != e.domain && Object.hasOwnProperty.call(e, \"domain\") && t.uint32(10).string(e.domain), null != e.version && Object.hasOwnProperty.call(e, \"version\") && t.uint32(16).int64(e.version), t;\n          }, e.encodeDelimited = function (e, t) {\n            return this.encode(e, t).ldelim();\n          }, e.decode = function (e, t) {\n            e instanceof s || (e = s.create(e));\n            for (var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.OperatorSetIdProto(); e.pos < n;) {\n              var o = e.uint32();\n              switch (o >>> 3) {\n                case 1:\n                  r.domain = e.string();\n                  break;\n                case 2:\n                  r.version = e.int64();\n                  break;\n                default:\n                  e.skipType(7 & o);\n              }\n            }\n            return r;\n          }, e.decodeDelimited = function (e) {\n            return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n          }, e.verify = function (e) {\n            return \"object\" != typeof e || null === e ? \"object expected\" : null != e.domain && e.hasOwnProperty(\"domain\") && !l.isString(e.domain) ? \"domain: string expected\" : null != e.version && e.hasOwnProperty(\"version\") && !(l.isInteger(e.version) || e.version && l.isInteger(e.version.low) && l.isInteger(e.version.high)) ? \"version: integer|Long expected\" : null;\n          }, e.fromObject = function (e) {\n            if (e instanceof c.onnx.OperatorSetIdProto) return e;\n            var t = new c.onnx.OperatorSetIdProto();\n            return null != e.domain && (t.domain = String(e.domain)), null != e.version && (l.Long ? (t.version = l.Long.fromValue(e.version)).unsigned = !1 : \"string\" == typeof e.version ? t.version = parseInt(e.version, 10) : \"number\" == typeof e.version ? t.version = e.version : \"object\" == typeof e.version && (t.version = new l.LongBits(e.version.low >>> 0, e.version.high >>> 0).toNumber())), t;\n          }, e.toObject = function (e, t) {\n            t || (t = {});\n            var n = {};\n            if (t.defaults) if (n.domain = \"\", l.Long) {\n              var r = new l.Long(0, 0, !1);\n              n.version = t.longs === String ? r.toString() : t.longs === Number ? r.toNumber() : r;\n            } else n.version = t.longs === String ? \"0\" : 0;\n            return null != e.domain && e.hasOwnProperty(\"domain\") && (n.domain = e.domain), null != e.version && e.hasOwnProperty(\"version\") && (\"number\" == typeof e.version ? n.version = t.longs === String ? String(e.version) : e.version : n.version = t.longs === String ? l.Long.prototype.toString.call(e.version) : t.longs === Number ? new l.LongBits(e.version.low >>> 0, e.version.high >>> 0).toNumber() : e.version), n;\n          }, e.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, e.getTypeUrl = function (e) {\n            return void 0 === e && (e = \"type.googleapis.com\"), e + \"/onnx.OperatorSetIdProto\";\n          }, e;\n        }(), i.OperatorStatus = function () {\n          var e = {},\n            t = Object.create(e);\n          return t[e[0] = \"EXPERIMENTAL\"] = 0, t[e[1] = \"STABLE\"] = 1, t;\n        }(), i.FunctionProto = function () {\n          function e(e) {\n            if (this.input = [], this.output = [], this.attribute = [], this.attributeProto = [], this.node = [], this.opsetImport = [], e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n          }\n          return e.prototype.name = \"\", e.prototype.input = l.emptyArray, e.prototype.output = l.emptyArray, e.prototype.attribute = l.emptyArray, e.prototype.attributeProto = l.emptyArray, e.prototype.node = l.emptyArray, e.prototype.docString = \"\", e.prototype.opsetImport = l.emptyArray, e.prototype.domain = \"\", e.create = function (t) {\n            return new e(t);\n          }, e.encode = function (e, t) {\n            if (t || (t = u.create()), null != e.name && Object.hasOwnProperty.call(e, \"name\") && t.uint32(10).string(e.name), null != e.input && e.input.length) for (var n = 0; n < e.input.length; ++n) t.uint32(34).string(e.input[n]);\n            if (null != e.output && e.output.length) for (n = 0; n < e.output.length; ++n) t.uint32(42).string(e.output[n]);\n            if (null != e.attribute && e.attribute.length) for (n = 0; n < e.attribute.length; ++n) t.uint32(50).string(e.attribute[n]);\n            if (null != e.node && e.node.length) for (n = 0; n < e.node.length; ++n) c.onnx.NodeProto.encode(e.node[n], t.uint32(58).fork()).ldelim();\n            if (null != e.docString && Object.hasOwnProperty.call(e, \"docString\") && t.uint32(66).string(e.docString), null != e.opsetImport && e.opsetImport.length) for (n = 0; n < e.opsetImport.length; ++n) c.onnx.OperatorSetIdProto.encode(e.opsetImport[n], t.uint32(74).fork()).ldelim();\n            if (null != e.domain && Object.hasOwnProperty.call(e, \"domain\") && t.uint32(82).string(e.domain), null != e.attributeProto && e.attributeProto.length) for (n = 0; n < e.attributeProto.length; ++n) c.onnx.AttributeProto.encode(e.attributeProto[n], t.uint32(90).fork()).ldelim();\n            return t;\n          }, e.encodeDelimited = function (e, t) {\n            return this.encode(e, t).ldelim();\n          }, e.decode = function (e, t) {\n            e instanceof s || (e = s.create(e));\n            for (var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.FunctionProto(); e.pos < n;) {\n              var o = e.uint32();\n              switch (o >>> 3) {\n                case 1:\n                  r.name = e.string();\n                  break;\n                case 4:\n                  r.input && r.input.length || (r.input = []), r.input.push(e.string());\n                  break;\n                case 5:\n                  r.output && r.output.length || (r.output = []), r.output.push(e.string());\n                  break;\n                case 6:\n                  r.attribute && r.attribute.length || (r.attribute = []), r.attribute.push(e.string());\n                  break;\n                case 11:\n                  r.attributeProto && r.attributeProto.length || (r.attributeProto = []), r.attributeProto.push(c.onnx.AttributeProto.decode(e, e.uint32()));\n                  break;\n                case 7:\n                  r.node && r.node.length || (r.node = []), r.node.push(c.onnx.NodeProto.decode(e, e.uint32()));\n                  break;\n                case 8:\n                  r.docString = e.string();\n                  break;\n                case 9:\n                  r.opsetImport && r.opsetImport.length || (r.opsetImport = []), r.opsetImport.push(c.onnx.OperatorSetIdProto.decode(e, e.uint32()));\n                  break;\n                case 10:\n                  r.domain = e.string();\n                  break;\n                default:\n                  e.skipType(7 & o);\n              }\n            }\n            return r;\n          }, e.decodeDelimited = function (e) {\n            return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n          }, e.verify = function (e) {\n            if (\"object\" != typeof e || null === e) return \"object expected\";\n            if (null != e.name && e.hasOwnProperty(\"name\") && !l.isString(e.name)) return \"name: string expected\";\n            if (null != e.input && e.hasOwnProperty(\"input\")) {\n              if (!Array.isArray(e.input)) return \"input: array expected\";\n              for (var t = 0; t < e.input.length; ++t) if (!l.isString(e.input[t])) return \"input: string[] expected\";\n            }\n            if (null != e.output && e.hasOwnProperty(\"output\")) {\n              if (!Array.isArray(e.output)) return \"output: array expected\";\n              for (t = 0; t < e.output.length; ++t) if (!l.isString(e.output[t])) return \"output: string[] expected\";\n            }\n            if (null != e.attribute && e.hasOwnProperty(\"attribute\")) {\n              if (!Array.isArray(e.attribute)) return \"attribute: array expected\";\n              for (t = 0; t < e.attribute.length; ++t) if (!l.isString(e.attribute[t])) return \"attribute: string[] expected\";\n            }\n            if (null != e.attributeProto && e.hasOwnProperty(\"attributeProto\")) {\n              if (!Array.isArray(e.attributeProto)) return \"attributeProto: array expected\";\n              for (t = 0; t < e.attributeProto.length; ++t) if (n = c.onnx.AttributeProto.verify(e.attributeProto[t])) return \"attributeProto.\" + n;\n            }\n            if (null != e.node && e.hasOwnProperty(\"node\")) {\n              if (!Array.isArray(e.node)) return \"node: array expected\";\n              for (t = 0; t < e.node.length; ++t) if (n = c.onnx.NodeProto.verify(e.node[t])) return \"node.\" + n;\n            }\n            if (null != e.docString && e.hasOwnProperty(\"docString\") && !l.isString(e.docString)) return \"docString: string expected\";\n            if (null != e.opsetImport && e.hasOwnProperty(\"opsetImport\")) {\n              if (!Array.isArray(e.opsetImport)) return \"opsetImport: array expected\";\n              for (t = 0; t < e.opsetImport.length; ++t) {\n                var n;\n                if (n = c.onnx.OperatorSetIdProto.verify(e.opsetImport[t])) return \"opsetImport.\" + n;\n              }\n            }\n            return null != e.domain && e.hasOwnProperty(\"domain\") && !l.isString(e.domain) ? \"domain: string expected\" : null;\n          }, e.fromObject = function (e) {\n            if (e instanceof c.onnx.FunctionProto) return e;\n            var t = new c.onnx.FunctionProto();\n            if (null != e.name && (t.name = String(e.name)), e.input) {\n              if (!Array.isArray(e.input)) throw TypeError(\".onnx.FunctionProto.input: array expected\");\n              t.input = [];\n              for (var n = 0; n < e.input.length; ++n) t.input[n] = String(e.input[n]);\n            }\n            if (e.output) {\n              if (!Array.isArray(e.output)) throw TypeError(\".onnx.FunctionProto.output: array expected\");\n              for (t.output = [], n = 0; n < e.output.length; ++n) t.output[n] = String(e.output[n]);\n            }\n            if (e.attribute) {\n              if (!Array.isArray(e.attribute)) throw TypeError(\".onnx.FunctionProto.attribute: array expected\");\n              for (t.attribute = [], n = 0; n < e.attribute.length; ++n) t.attribute[n] = String(e.attribute[n]);\n            }\n            if (e.attributeProto) {\n              if (!Array.isArray(e.attributeProto)) throw TypeError(\".onnx.FunctionProto.attributeProto: array expected\");\n              for (t.attributeProto = [], n = 0; n < e.attributeProto.length; ++n) {\n                if (\"object\" != typeof e.attributeProto[n]) throw TypeError(\".onnx.FunctionProto.attributeProto: object expected\");\n                t.attributeProto[n] = c.onnx.AttributeProto.fromObject(e.attributeProto[n]);\n              }\n            }\n            if (e.node) {\n              if (!Array.isArray(e.node)) throw TypeError(\".onnx.FunctionProto.node: array expected\");\n              for (t.node = [], n = 0; n < e.node.length; ++n) {\n                if (\"object\" != typeof e.node[n]) throw TypeError(\".onnx.FunctionProto.node: object expected\");\n                t.node[n] = c.onnx.NodeProto.fromObject(e.node[n]);\n              }\n            }\n            if (null != e.docString && (t.docString = String(e.docString)), e.opsetImport) {\n              if (!Array.isArray(e.opsetImport)) throw TypeError(\".onnx.FunctionProto.opsetImport: array expected\");\n              for (t.opsetImport = [], n = 0; n < e.opsetImport.length; ++n) {\n                if (\"object\" != typeof e.opsetImport[n]) throw TypeError(\".onnx.FunctionProto.opsetImport: object expected\");\n                t.opsetImport[n] = c.onnx.OperatorSetIdProto.fromObject(e.opsetImport[n]);\n              }\n            }\n            return null != e.domain && (t.domain = String(e.domain)), t;\n          }, e.toObject = function (e, t) {\n            t || (t = {});\n            var n = {};\n            if ((t.arrays || t.defaults) && (n.input = [], n.output = [], n.attribute = [], n.node = [], n.opsetImport = [], n.attributeProto = []), t.defaults && (n.name = \"\", n.docString = \"\", n.domain = \"\"), null != e.name && e.hasOwnProperty(\"name\") && (n.name = e.name), e.input && e.input.length) {\n              n.input = [];\n              for (var r = 0; r < e.input.length; ++r) n.input[r] = e.input[r];\n            }\n            if (e.output && e.output.length) for (n.output = [], r = 0; r < e.output.length; ++r) n.output[r] = e.output[r];\n            if (e.attribute && e.attribute.length) for (n.attribute = [], r = 0; r < e.attribute.length; ++r) n.attribute[r] = e.attribute[r];\n            if (e.node && e.node.length) for (n.node = [], r = 0; r < e.node.length; ++r) n.node[r] = c.onnx.NodeProto.toObject(e.node[r], t);\n            if (null != e.docString && e.hasOwnProperty(\"docString\") && (n.docString = e.docString), e.opsetImport && e.opsetImport.length) for (n.opsetImport = [], r = 0; r < e.opsetImport.length; ++r) n.opsetImport[r] = c.onnx.OperatorSetIdProto.toObject(e.opsetImport[r], t);\n            if (null != e.domain && e.hasOwnProperty(\"domain\") && (n.domain = e.domain), e.attributeProto && e.attributeProto.length) for (n.attributeProto = [], r = 0; r < e.attributeProto.length; ++r) n.attributeProto[r] = c.onnx.AttributeProto.toObject(e.attributeProto[r], t);\n            return n;\n          }, e.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, e.getTypeUrl = function (e) {\n            return void 0 === e && (e = \"type.googleapis.com\"), e + \"/onnx.FunctionProto\";\n          }, e;\n        }(), i), e.exports = c;\n      },\n      3474: (e, t, n) => {\n        var _scriptDir,\n          r = (_scriptDir = \"undefined\" != typeof document && document.currentScript ? document.currentScript.src : void 0, \"undefined\" != typeof __filename && (_scriptDir = _scriptDir || __filename), function (e = {}) {\n            function t() {\n              return D.buffer != N.buffer && U(), N;\n            }\n            function r() {\n              return D.buffer != N.buffer && U(), R;\n            }\n            function o() {\n              return D.buffer != N.buffer && U(), L;\n            }\n            function i() {\n              return D.buffer != N.buffer && U(), C;\n            }\n            function a() {\n              return D.buffer != N.buffer && U(), j;\n            }\n            var s,\n              u,\n              l = e;\n            l.ready = new Promise((e, t) => {\n              s = e, u = t;\n            });\n            var c,\n              p,\n              d,\n              f = Object.assign({}, l),\n              h = \"./this.program\",\n              g = (e, t) => {\n                throw t;\n              },\n              b = \"object\" == typeof window,\n              m = \"function\" == typeof importScripts,\n              y = \"object\" == typeof process && \"object\" == typeof process.versions && \"string\" == typeof process.versions.node,\n              v = l.ENVIRONMENT_IS_PTHREAD || !1,\n              _ = \"\";\n            function w(e) {\n              return l.locateFile ? l.locateFile(e, _) : _ + e;\n            }\n            if (y) {\n              var T = n(1384),\n                x = n(908);\n              let t;\n              _ = m ? x.dirname(_) + \"/\" : __dirname + \"/\", c = (e, t) => (e = e.startsWith(\"file://\") ? new URL(e) : x.normalize(e), T.readFileSync(e, t ? void 0 : \"utf8\")), d = e => ((e = c(e, !0)).buffer || (e = new Uint8Array(e)), e), p = (e, t, n, r = !0) => {\n                e = e.startsWith(\"file://\") ? new URL(e) : x.normalize(e), T.readFile(e, r ? void 0 : \"utf8\", (e, o) => {\n                  e ? n(e) : t(r ? o.buffer : o);\n                });\n              }, !l.thisProgram && 1 < process.argv.length && (h = process.argv[1].replace(/\\\\/g, \"/\")), process.argv.slice(2), g = (e, t) => {\n                throw process.exitCode = e, t;\n              }, l.inspect = () => \"[Emscripten Module object]\";\n              try {\n                t = n(9925);\n              } catch (e) {\n                throw console.error('The \"worker_threads\" module is not supported in this node.js build - perhaps a newer version is needed?'), e;\n              }\n              global.Worker = t.Worker;\n            } else (b || m) && (m ? _ = self.location.href : \"undefined\" != typeof document && document.currentScript && (_ = document.currentScript.src), _scriptDir && (_ = _scriptDir), _ = 0 !== _.indexOf(\"blob:\") ? _.substr(0, _.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1) : \"\", y || (c = e => {\n              var t = new XMLHttpRequest();\n              return t.open(\"GET\", e, !1), t.send(null), t.responseText;\n            }, m && (d = e => {\n              var t = new XMLHttpRequest();\n              return t.open(\"GET\", e, !1), t.responseType = \"arraybuffer\", t.send(null), new Uint8Array(t.response);\n            }), p = (e, t, n) => {\n              var r = new XMLHttpRequest();\n              r.open(\"GET\", e, !0), r.responseType = \"arraybuffer\", r.onload = () => {\n                200 == r.status || 0 == r.status && r.response ? t(r.response) : n();\n              }, r.onerror = n, r.send(null);\n            }));\n            y && \"undefined\" == typeof performance && (global.performance = n(6953).performance);\n            var O = console.log.bind(console),\n              S = console.error.bind(console);\n            y && (O = (...e) => T.writeSync(1, e.join(\" \") + \"\\n\"), S = (...e) => T.writeSync(2, e.join(\" \") + \"\\n\"));\n            var A,\n              P = l.print || O,\n              I = l.printErr || S;\n            Object.assign(l, f), f = null, l.thisProgram && (h = l.thisProgram), l.quit && (g = l.quit), l.wasmBinary && (A = l.wasmBinary);\n            var E = l.noExitRuntime || !0;\n            \"object\" != typeof WebAssembly && te(\"no native wasm support detected\");\n            var D,\n              $,\n              k,\n              F,\n              N,\n              R,\n              L,\n              C,\n              j,\n              M = !1;\n            function U() {\n              var e = D.buffer;\n              l.HEAP8 = N = new Int8Array(e), l.HEAP16 = new Int16Array(e), l.HEAP32 = L = new Int32Array(e), l.HEAPU8 = R = new Uint8Array(e), l.HEAPU16 = new Uint16Array(e), l.HEAPU32 = C = new Uint32Array(e), l.HEAPF32 = new Float32Array(e), l.HEAPF64 = j = new Float64Array(e);\n            }\n            var B = l.INITIAL_MEMORY || 16777216;\n            if (5242880 <= B || te(\"INITIAL_MEMORY should be larger than STACK_SIZE, was \" + B + \"! (STACK_SIZE=5242880)\"), v) D = l.wasmMemory;else if (l.wasmMemory) D = l.wasmMemory;else if (!((D = new WebAssembly.Memory({\n              initial: B / 65536,\n              maximum: 65536,\n              shared: !0\n            })).buffer instanceof SharedArrayBuffer)) throw I(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"), y && I(\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)\"), Error(\"bad memory\");\n            U(), B = D.buffer.byteLength;\n            var V,\n              z = [],\n              G = [],\n              H = [],\n              W = 0;\n            function q() {\n              return E || 0 < W;\n            }\n            var X,\n              Y,\n              K = 0,\n              J = null,\n              Z = null;\n            function Q() {\n              K++, l.monitorRunDependencies && l.monitorRunDependencies(K);\n            }\n            function ee() {\n              if (K--, l.monitorRunDependencies && l.monitorRunDependencies(K), 0 == K && (null !== J && (clearInterval(J), J = null), Z)) {\n                var e = Z;\n                Z = null, e();\n              }\n            }\n            function te(e) {\n              throw l.onAbort && l.onAbort(e), I(e = \"Aborted(\" + e + \")\"), M = !0, F = 1, e = new WebAssembly.RuntimeError(e + \". Build with -sASSERTIONS for more info.\"), u(e), e;\n            }\n            function ne(e) {\n              return e.startsWith(\"data:application/octet-stream;base64,\");\n            }\n            function re(e) {\n              if (e == X && A) return new Uint8Array(A);\n              if (d) return d(e);\n              throw \"both async and sync fetching of the wasm failed\";\n            }\n            function oe(e, t, n) {\n              return function (e) {\n                if (!A && (b || m)) {\n                  if (\"function\" == typeof fetch && !e.startsWith(\"file://\")) return fetch(e, {\n                    credentials: \"same-origin\"\n                  }).then(t => {\n                    if (!t.ok) throw \"failed to load wasm binary file at '\" + e + \"'\";\n                    return t.arrayBuffer();\n                  }).catch(() => re(e));\n                  if (p) return new Promise((t, n) => {\n                    p(e, e => t(new Uint8Array(e)), n);\n                  });\n                }\n                return Promise.resolve().then(() => re(e));\n              }(e).then(e => WebAssembly.instantiate(e, t)).then(e => e).then(n, e => {\n                I(\"failed to asynchronously prepare wasm: \" + e), te(e);\n              });\n            }\n            function ie(e) {\n              this.name = \"ExitStatus\", this.message = `Program terminated with exit(${e})`, this.status = e;\n            }\n            function ae(e) {\n              e.terminate(), e.onmessage = () => {};\n            }\n            function se(e) {\n              (e = he.Fa[e]) || te(), he.fb(e);\n            }\n            function ue(e) {\n              var t = he.Za();\n              if (!t) return 6;\n              he.Ia.push(t), he.Fa[e.Ha] = t, t.Ha = e.Ha;\n              var n = {\n                cmd: \"run\",\n                start_routine: e.gb,\n                arg: e.Ya,\n                pthread_ptr: e.Ha\n              };\n              return y && t.unref(), t.postMessage(n, e.mb), 0;\n            }\n            ne(X = \"ort-wasm-threaded.wasm\") || (X = w(X));\n            var le = \"undefined\" != typeof TextDecoder ? new TextDecoder(\"utf8\") : void 0,\n              ce = (e, t, n) => {\n                var r = (t >>>= 0) + n;\n                for (n = t; e[n] && !(n >= r);) ++n;\n                if (16 < n - t && e.buffer && le) return le.decode(e.buffer instanceof SharedArrayBuffer ? e.slice(t, n) : e.subarray(t, n));\n                for (r = \"\"; t < n;) {\n                  var o = e[t++];\n                  if (128 & o) {\n                    var i = 63 & e[t++];\n                    if (192 == (224 & o)) r += String.fromCharCode((31 & o) << 6 | i);else {\n                      var a = 63 & e[t++];\n                      65536 > (o = 224 == (240 & o) ? (15 & o) << 12 | i << 6 | a : (7 & o) << 18 | i << 12 | a << 6 | 63 & e[t++]) ? r += String.fromCharCode(o) : (o -= 65536, r += String.fromCharCode(55296 | o >> 10, 56320 | 1023 & o));\n                    }\n                  } else r += String.fromCharCode(o);\n                }\n                return r;\n              },\n              pe = (e, t) => (e >>>= 0) ? ce(r(), e, t) : \"\";\n            function de(e) {\n              if (v) return qe(1, 1, e);\n              F = e, q() || (he.hb(), l.onExit && l.onExit(e), M = !0), g(e, new ie(e));\n            }\n            var fe = e => {\n                if (F = e, v) throw be(e), \"unwind\";\n                de(e);\n              },\n              he = {\n                La: [],\n                Ia: [],\n                Ta: [],\n                Fa: {},\n                Pa: function () {\n                  v ? he.ab() : he.$a();\n                },\n                $a: function () {\n                  z.unshift(() => {\n                    Q(), he.bb(() => ee());\n                  });\n                },\n                ab: function () {\n                  he.receiveObjectTransfer = he.eb, he.threadInitTLS = he.Sa, he.setExitStatus = he.Ra, E = !1;\n                },\n                Ra: function (e) {\n                  F = e;\n                },\n                rb: [\"$terminateWorker\"],\n                hb: function () {\n                  for (var e of he.Ia) ae(e);\n                  for (e of he.La) ae(e);\n                  he.La = [], he.Ia = [], he.Fa = [];\n                },\n                fb: function (e) {\n                  var t = e.Ha;\n                  delete he.Fa[t], he.La.push(e), he.Ia.splice(he.Ia.indexOf(e), 1), e.Ha = 0, mt(t);\n                },\n                eb: function () {},\n                Sa: function () {\n                  he.Ta.forEach(e => e());\n                },\n                cb: e => new Promise(t => {\n                  e.onmessage = n => {\n                    var r = (n = n.data).cmd;\n                    if (n.targetThread && n.targetThread != dt()) {\n                      var o = he.Fa[n.qb];\n                      o ? o.postMessage(n, n.transferList) : I('Internal error! Worker sent a message \"' + r + '\" to target pthread ' + n.targetThread + \", but that thread no longer exists!\");\n                    } else \"checkMailbox\" === r ? Me() : \"spawnThread\" === r ? ue(n) : \"cleanupThread\" === r ? se(n.thread) : \"killThread\" === r ? (n = n.thread, r = he.Fa[n], delete he.Fa[n], ae(r), mt(n), he.Ia.splice(he.Ia.indexOf(r), 1), r.Ha = 0) : \"cancelThread\" === r ? he.Fa[n.thread].postMessage({\n                      cmd: \"cancel\"\n                    }) : \"loaded\" === r ? (e.loaded = !0, t(e)) : \"alert\" === r ? alert(\"Thread \" + n.threadId + \": \" + n.text) : \"setimmediate\" === n.target ? e.postMessage(n) : \"callHandler\" === r ? l[n.handler](...n.args) : r && I(\"worker sent an unknown command \" + r);\n                  }, e.onerror = e => {\n                    throw I(\"worker sent an error! \" + e.filename + \":\" + e.lineno + \": \" + e.message), e;\n                  }, y && (e.on(\"message\", function (t) {\n                    e.onmessage({\n                      data: t\n                    });\n                  }), e.on(\"error\", function (t) {\n                    e.onerror(t);\n                  }));\n                  var n,\n                    r = [];\n                  for (n of [\"onExit\", \"onAbort\", \"print\", \"printErr\"]) l.hasOwnProperty(n) && r.push(n);\n                  e.postMessage({\n                    cmd: \"load\",\n                    handlers: r,\n                    urlOrBlob: l.mainScriptUrlOrBlob || _scriptDir,\n                    wasmMemory: D,\n                    wasmModule: k\n                  });\n                }),\n                bb: function (e) {\n                  e();\n                },\n                Xa: function () {\n                  var e = w(\"ort-wasm-threaded.worker.js\");\n                  e = new Worker(e), he.La.push(e);\n                },\n                Za: function () {\n                  return 0 == he.La.length && (he.Xa(), he.cb(he.La[0])), he.La.pop();\n                }\n              };\n            l.PThread = he;\n            var ge = e => {\n              for (; 0 < e.length;) e.shift()(l);\n            };\n            function be(e) {\n              if (v) return qe(2, 0, e);\n              fe(e);\n            }\n            l.establishStackSpace = function () {\n              var e = dt(),\n                t = o()[e + 52 >> 2 >>> 0];\n              e = o()[e + 56 >> 2 >>> 0], wt(t, t - e), xt(t);\n            };\n            var me = [];\n            function ye(e) {\n              this.Oa = e - 24, this.Wa = function (e) {\n                i()[this.Oa + 4 >> 2 >>> 0] = e;\n              }, this.Va = function (e) {\n                i()[this.Oa + 8 >> 2 >>> 0] = e;\n              }, this.Pa = function (e, t) {\n                this.Ua(), this.Wa(e), this.Va(t);\n              }, this.Ua = function () {\n                i()[this.Oa + 16 >> 2 >>> 0] = 0;\n              };\n            }\n            function ve(e, t, n, r) {\n              return v ? qe(3, 1, e, t, n, r) : _e(e, t, n, r);\n            }\n            function _e(e, t, n, r) {\n              if (e >>>= 0, t >>>= 0, n >>>= 0, r >>>= 0, \"undefined\" == typeof SharedArrayBuffer) return I(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"), 6;\n              var o = [];\n              return v && 0 === o.length ? ve(e, t, n, r) : (e = {\n                gb: n,\n                Ha: e,\n                Ya: r,\n                mb: o\n              }, v ? (e.ob = \"spawnThread\", postMessage(e, o), 0) : ue(e));\n            }\n            function we(e, t, n) {\n              return v ? qe(4, 1, e, t, n) : 0;\n            }\n            function Te(e, t) {\n              if (v) return qe(5, 1, e, t);\n            }\n            l.invokeEntryPoint = function (e, t) {\n              var n = me[e];\n              n || (e >= me.length && (me.length = e + 1), me[e] = n = V.get(e)), e = n(t), q() ? he.Ra(e) : yt(e);\n            };\n            var xe = e => {\n                for (var t = 0, n = 0; n < e.length; ++n) {\n                  var r = e.charCodeAt(n);\n                  127 >= r ? t++ : 2047 >= r ? t += 2 : 55296 <= r && 57343 >= r ? (t += 4, ++n) : t += 3;\n                }\n                return t;\n              },\n              Oe = (e, t, n, r) => {\n                if (!(0 < r)) return 0;\n                var o = n >>>= 0;\n                r = n + r - 1;\n                for (var i = 0; i < e.length; ++i) {\n                  var a = e.charCodeAt(i);\n                  if (55296 <= a && 57343 >= a && (a = 65536 + ((1023 & a) << 10) | 1023 & e.charCodeAt(++i)), 127 >= a) {\n                    if (n >= r) break;\n                    t[n++ >>> 0] = a;\n                  } else {\n                    if (2047 >= a) {\n                      if (n + 1 >= r) break;\n                      t[n++ >>> 0] = 192 | a >> 6;\n                    } else {\n                      if (65535 >= a) {\n                        if (n + 2 >= r) break;\n                        t[n++ >>> 0] = 224 | a >> 12;\n                      } else {\n                        if (n + 3 >= r) break;\n                        t[n++ >>> 0] = 240 | a >> 18, t[n++ >>> 0] = 128 | a >> 12 & 63;\n                      }\n                      t[n++ >>> 0] = 128 | a >> 6 & 63;\n                    }\n                    t[n++ >>> 0] = 128 | 63 & a;\n                  }\n                }\n                return t[n >>> 0] = 0, n - o;\n              },\n              Se = (e, t, n) => Oe(e, r(), t, n);\n            function Ae(e, t) {\n              if (v) return qe(6, 1, e, t);\n            }\n            function Pe(e, t, n) {\n              if (v) return qe(7, 1, e, t, n);\n            }\n            function Ie(e, t, n) {\n              return v ? qe(8, 1, e, t, n) : 0;\n            }\n            function Ee(e, t) {\n              if (v) return qe(9, 1, e, t);\n            }\n            function De(e, t, n) {\n              if (v) return qe(10, 1, e, t, n);\n            }\n            function $e(e, t, n, r) {\n              if (v) return qe(11, 1, e, t, n, r);\n            }\n            function ke(e, t, n, r) {\n              if (v) return qe(12, 1, e, t, n, r);\n            }\n            function Fe(e, t, n, r) {\n              if (v) return qe(13, 1, e, t, n, r);\n            }\n            function Ne(e) {\n              if (v) return qe(14, 1, e);\n            }\n            function Re(e, t) {\n              if (v) return qe(15, 1, e, t);\n            }\n            function Le(e, t, n) {\n              if (v) return qe(16, 1, e, t, n);\n            }\n            var Ce = e => {\n              if (!M) try {\n                if (e(), !q()) try {\n                  v ? yt(F) : fe(F);\n                } catch (e) {\n                  e instanceof ie || \"unwind\" == e || g(1, e);\n                }\n              } catch (e) {\n                e instanceof ie || \"unwind\" == e || g(1, e);\n              }\n            };\n            function je(e) {\n              e >>>= 0, \"function\" == typeof Atomics.nb && (Atomics.nb(o(), e >> 2, e).value.then(Me), e += 128, Atomics.store(o(), e >> 2, 1));\n            }\n            function Me() {\n              var e = dt();\n              e && (je(e), Ce(() => vt()));\n            }\n            l.__emscripten_thread_mailbox_await = je, l.checkMailbox = Me;\n            var Ue = e => 0 == e % 4 && (0 != e % 100 || 0 == e % 400),\n              Be = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335],\n              Ve = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n            function ze(e, t, n, r, o, i, a, s) {\n              return v ? qe(17, 1, e, t, n, r, o, i, a, s) : -52;\n            }\n            function Ge(e, t, n, r, o, i, a) {\n              if (v) return qe(18, 1, e, t, n, r, o, i, a);\n            }\n            var He = e => {\n                var t = xe(e) + 1,\n                  n = ft(t);\n                return n && Se(e, n, t), n;\n              },\n              We = e => {\n                var t = Tt();\n                return e = e(), xt(t), e;\n              };\n            function qe(e, t) {\n              var n = arguments.length - 2,\n                r = arguments;\n              return We(() => {\n                for (var o = Ot(8 * n), i = o >> 3, s = 0; s < n; s++) {\n                  var u = r[2 + s];\n                  a()[i + s >>> 0] = u;\n                }\n                return bt(e, n, o, t);\n              });\n            }\n            var Xe,\n              Ye = [],\n              Ke = {},\n              Je = () => {\n                if (!Xe) {\n                  var e,\n                    t = {\n                      USER: \"web_user\",\n                      LOGNAME: \"web_user\",\n                      PATH: \"/\",\n                      PWD: \"/\",\n                      HOME: \"/home/web_user\",\n                      LANG: (\"object\" == typeof navigator && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\",\n                      _: h || \"./this.program\"\n                    };\n                  for (e in Ke) void 0 === Ke[e] ? delete t[e] : t[e] = Ke[e];\n                  var n = [];\n                  for (e in t) n.push(`${e}=${t[e]}`);\n                  Xe = n;\n                }\n                return Xe;\n              };\n            function Ze(e, n) {\n              if (v) return qe(19, 1, e, n);\n              e >>>= 0, n >>>= 0;\n              var r = 0;\n              return Je().forEach(function (o, a) {\n                var s = n + r;\n                for (a = i()[e + 4 * a >> 2 >>> 0] = s, s = 0; s < o.length; ++s) t()[a++ >> 0 >>> 0] = o.charCodeAt(s);\n                t()[a >> 0 >>> 0] = 0, r += o.length + 1;\n              }), 0;\n            }\n            function Qe(e, t) {\n              if (v) return qe(20, 1, e, t);\n              e >>>= 0, t >>>= 0;\n              var n = Je();\n              i()[e >> 2 >>> 0] = n.length;\n              var r = 0;\n              return n.forEach(function (e) {\n                r += e.length + 1;\n              }), i()[t >> 2 >>> 0] = r, 0;\n            }\n            function et(e) {\n              return v ? qe(21, 1, e) : 52;\n            }\n            function tt(e, t, n, r) {\n              return v ? qe(22, 1, e, t, n, r) : 52;\n            }\n            function nt(e, t, n, r, o) {\n              return v ? qe(23, 1, e, t, n, r, o) : 70;\n            }\n            var rt = [null, [], []];\n            function ot(e, t, n, o) {\n              if (v) return qe(24, 1, e, t, n, o);\n              t >>>= 0, n >>>= 0, o >>>= 0;\n              for (var a = 0, s = 0; s < n; s++) {\n                var u = i()[t >> 2 >>> 0],\n                  l = i()[t + 4 >> 2 >>> 0];\n                t += 8;\n                for (var c = 0; c < l; c++) {\n                  var p = r()[u + c >>> 0],\n                    d = rt[e];\n                  0 === p || 10 === p ? ((1 === e ? P : I)(ce(d, 0)), d.length = 0) : d.push(p);\n                }\n                a += l;\n              }\n              return i()[o >> 2 >>> 0] = a, 0;\n            }\n            var it = e => (it = (() => {\n                if (\"object\" == typeof crypto && \"function\" == typeof crypto.getRandomValues) return e => (e.set(crypto.getRandomValues(new Uint8Array(e.byteLength))), e);\n                if (y) try {\n                  var e = n(760);\n                  if (e.randomFillSync) return t => e.randomFillSync(t);\n                  var t = e.randomBytes;\n                  return e => (e.set(t(e.byteLength)), e);\n                } catch (e) {}\n                te(\"initRandomDevice\");\n              })())(e),\n              at = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n              st = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n              ut = (e, n) => {\n                t().set(e, n >>> 0);\n              };\n            function lt(e, t, n, r) {\n              function i(e, t, n) {\n                for (e = \"number\" == typeof e ? e.toString() : e || \"\"; e.length < t;) e = n[0] + e;\n                return e;\n              }\n              function a(e, t) {\n                return i(e, t, \"0\");\n              }\n              function s(e, t) {\n                function n(e) {\n                  return 0 > e ? -1 : 0 < e ? 1 : 0;\n                }\n                var r;\n                return 0 === (r = n(e.getFullYear() - t.getFullYear())) && 0 === (r = n(e.getMonth() - t.getMonth())) && (r = n(e.getDate() - t.getDate())), r;\n              }\n              function u(e) {\n                switch (e.getDay()) {\n                  case 0:\n                    return new Date(e.getFullYear() - 1, 11, 29);\n                  case 1:\n                    return e;\n                  case 2:\n                    return new Date(e.getFullYear(), 0, 3);\n                  case 3:\n                    return new Date(e.getFullYear(), 0, 2);\n                  case 4:\n                    return new Date(e.getFullYear(), 0, 1);\n                  case 5:\n                    return new Date(e.getFullYear() - 1, 11, 31);\n                  case 6:\n                    return new Date(e.getFullYear() - 1, 11, 30);\n                }\n              }\n              function l(e) {\n                var t = e.Ja;\n                for (e = new Date(new Date(e.Ka + 1900, 0, 1).getTime()); 0 < t;) {\n                  var n = e.getMonth(),\n                    r = (Ue(e.getFullYear()) ? at : st)[n];\n                  if (!(t > r - e.getDate())) {\n                    e.setDate(e.getDate() + t);\n                    break;\n                  }\n                  t -= r - e.getDate() + 1, e.setDate(1), 11 > n ? e.setMonth(n + 1) : (e.setMonth(0), e.setFullYear(e.getFullYear() + 1));\n                }\n                return n = new Date(e.getFullYear() + 1, 0, 4), t = u(new Date(e.getFullYear(), 0, 4)), n = u(n), 0 >= s(t, e) ? 0 >= s(n, e) ? e.getFullYear() + 1 : e.getFullYear() : e.getFullYear() - 1;\n              }\n              e >>>= 0, t >>>= 0, n >>>= 0, r >>>= 0;\n              var c = o()[r + 40 >> 2 >>> 0];\n              for (var p in r = {\n                kb: o()[r >> 2 >>> 0],\n                jb: o()[r + 4 >> 2 >>> 0],\n                Ma: o()[r + 8 >> 2 >>> 0],\n                Qa: o()[r + 12 >> 2 >>> 0],\n                Na: o()[r + 16 >> 2 >>> 0],\n                Ka: o()[r + 20 >> 2 >>> 0],\n                Ga: o()[r + 24 >> 2 >>> 0],\n                Ja: o()[r + 28 >> 2 >>> 0],\n                sb: o()[r + 32 >> 2 >>> 0],\n                ib: o()[r + 36 >> 2 >>> 0],\n                lb: c ? pe(c) : \"\"\n              }, n = pe(n), c = {\n                \"%c\": \"%a %b %d %H:%M:%S %Y\",\n                \"%D\": \"%m/%d/%y\",\n                \"%F\": \"%Y-%m-%d\",\n                \"%h\": \"%b\",\n                \"%r\": \"%I:%M:%S %p\",\n                \"%R\": \"%H:%M\",\n                \"%T\": \"%H:%M:%S\",\n                \"%x\": \"%m/%d/%y\",\n                \"%X\": \"%H:%M:%S\",\n                \"%Ec\": \"%c\",\n                \"%EC\": \"%C\",\n                \"%Ex\": \"%m/%d/%y\",\n                \"%EX\": \"%H:%M:%S\",\n                \"%Ey\": \"%y\",\n                \"%EY\": \"%Y\",\n                \"%Od\": \"%d\",\n                \"%Oe\": \"%e\",\n                \"%OH\": \"%H\",\n                \"%OI\": \"%I\",\n                \"%Om\": \"%m\",\n                \"%OM\": \"%M\",\n                \"%OS\": \"%S\",\n                \"%Ou\": \"%u\",\n                \"%OU\": \"%U\",\n                \"%OV\": \"%V\",\n                \"%Ow\": \"%w\",\n                \"%OW\": \"%W\",\n                \"%Oy\": \"%y\"\n              }) n = n.replace(new RegExp(p, \"g\"), c[p]);\n              var d = \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n                f = \"January February March April May June July August September October November December\".split(\" \");\n              for (p in c = {\n                \"%a\": e => d[e.Ga].substring(0, 3),\n                \"%A\": e => d[e.Ga],\n                \"%b\": e => f[e.Na].substring(0, 3),\n                \"%B\": e => f[e.Na],\n                \"%C\": e => a((e.Ka + 1900) / 100 | 0, 2),\n                \"%d\": e => a(e.Qa, 2),\n                \"%e\": e => i(e.Qa, 2, \" \"),\n                \"%g\": e => l(e).toString().substring(2),\n                \"%G\": e => l(e),\n                \"%H\": e => a(e.Ma, 2),\n                \"%I\": e => (0 == (e = e.Ma) ? e = 12 : 12 < e && (e -= 12), a(e, 2)),\n                \"%j\": e => {\n                  for (var t = 0, n = 0; n <= e.Na - 1; t += (Ue(e.Ka + 1900) ? at : st)[n++]);\n                  return a(e.Qa + t, 3);\n                },\n                \"%m\": e => a(e.Na + 1, 2),\n                \"%M\": e => a(e.jb, 2),\n                \"%n\": () => \"\\n\",\n                \"%p\": e => 0 <= e.Ma && 12 > e.Ma ? \"AM\" : \"PM\",\n                \"%S\": e => a(e.kb, 2),\n                \"%t\": () => \"\\t\",\n                \"%u\": e => e.Ga || 7,\n                \"%U\": e => a(Math.floor((e.Ja + 7 - e.Ga) / 7), 2),\n                \"%V\": e => {\n                  var t = Math.floor((e.Ja + 7 - (e.Ga + 6) % 7) / 7);\n                  if (2 >= (e.Ga + 371 - e.Ja - 2) % 7 && t++, t) 53 == t && (4 == (n = (e.Ga + 371 - e.Ja) % 7) || 3 == n && Ue(e.Ka) || (t = 1));else {\n                    t = 52;\n                    var n = (e.Ga + 7 - e.Ja - 1) % 7;\n                    (4 == n || 5 == n && Ue(e.Ka % 400 - 1)) && t++;\n                  }\n                  return a(t, 2);\n                },\n                \"%w\": e => e.Ga,\n                \"%W\": e => a(Math.floor((e.Ja + 7 - (e.Ga + 6) % 7) / 7), 2),\n                \"%y\": e => (e.Ka + 1900).toString().substring(2),\n                \"%Y\": e => e.Ka + 1900,\n                \"%z\": e => {\n                  var t = 0 <= (e = e.ib);\n                  return e = Math.abs(e) / 60, (t ? \"+\" : \"-\") + String(\"0000\" + (e / 60 * 100 + e % 60)).slice(-4);\n                },\n                \"%Z\": e => e.lb,\n                \"%%\": () => \"%\"\n              }, n = n.replace(/%%/g, \"\\0\\0\"), c) n.includes(p) && (n = n.replace(new RegExp(p, \"g\"), c[p](r)));\n              return p = function (e) {\n                var t = Array(xe(e) + 1);\n                return Oe(e, t, 0, t.length), t;\n              }(n = n.replace(/\\0\\0/g, \"%\")), p.length > t ? 0 : (ut(p, e), p.length - 1);\n            }\n            he.Pa();\n            var ct = [null, de, be, ve, we, Te, Ae, Pe, Ie, Ee, De, $e, ke, Fe, Ne, Re, Le, ze, Ge, Ze, Qe, et, tt, nt, ot],\n              pt = {\n                b: function (e, t, n) {\n                  throw new ye(e >>>= 0).Pa(t >>> 0, n >>> 0), e;\n                },\n                N: function (e) {\n                  ht(e >>> 0, !m, 1, !b, 131072, !1), he.Sa();\n                },\n                k: function (e) {\n                  e >>>= 0, v ? postMessage({\n                    cmd: \"cleanupThread\",\n                    thread: e\n                  }) : se(e);\n                },\n                I: _e,\n                h: we,\n                T: Te,\n                E: Ae,\n                G: Pe,\n                U: Ie,\n                R: Ee,\n                J: De,\n                Q: $e,\n                o: ke,\n                F: Fe,\n                C: Ne,\n                S: Re,\n                D: Le,\n                q: () => !0,\n                A: function (e, t) {\n                  (e >>>= 0) == t >>> 0 ? setTimeout(() => Me()) : v ? postMessage({\n                    targetThread: e,\n                    cmd: \"checkMailbox\"\n                  }) : (e = he.Fa[e]) && e.postMessage({\n                    cmd: \"checkMailbox\"\n                  });\n                },\n                L: function () {\n                  return -1;\n                },\n                M: je,\n                p: function (e) {\n                  y && he.Fa[e >>> 0].ref();\n                },\n                t: function (e, t, n) {\n                  e = t + 2097152 >>> 0 < 4194305 - !!e ? (e >>> 0) + 4294967296 * t : NaN, n >>>= 0, e = new Date(1e3 * e), o()[n >> 2 >>> 0] = e.getUTCSeconds(), o()[n + 4 >> 2 >>> 0] = e.getUTCMinutes(), o()[n + 8 >> 2 >>> 0] = e.getUTCHours(), o()[n + 12 >> 2 >>> 0] = e.getUTCDate(), o()[n + 16 >> 2 >>> 0] = e.getUTCMonth(), o()[n + 20 >> 2 >>> 0] = e.getUTCFullYear() - 1900, o()[n + 24 >> 2 >>> 0] = e.getUTCDay(), e = (e.getTime() - Date.UTC(e.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0, o()[n + 28 >> 2 >>> 0] = e;\n                },\n                u: function (e, t, n) {\n                  e = t + 2097152 >>> 0 < 4194305 - !!e ? (e >>> 0) + 4294967296 * t : NaN, n >>>= 0, e = new Date(1e3 * e), o()[n >> 2 >>> 0] = e.getSeconds(), o()[n + 4 >> 2 >>> 0] = e.getMinutes(), o()[n + 8 >> 2 >>> 0] = e.getHours(), o()[n + 12 >> 2 >>> 0] = e.getDate(), o()[n + 16 >> 2 >>> 0] = e.getMonth(), o()[n + 20 >> 2 >>> 0] = e.getFullYear() - 1900, o()[n + 24 >> 2 >>> 0] = e.getDay(), t = (Ue(e.getFullYear()) ? Be : Ve)[e.getMonth()] + e.getDate() - 1 | 0, o()[n + 28 >> 2 >>> 0] = t, o()[n + 36 >> 2 >>> 0] = -60 * e.getTimezoneOffset(), t = new Date(e.getFullYear(), 6, 1).getTimezoneOffset();\n                  var r = new Date(e.getFullYear(), 0, 1).getTimezoneOffset();\n                  e = 0 | (t != r && e.getTimezoneOffset() == Math.min(r, t)), o()[n + 32 >> 2 >>> 0] = e;\n                },\n                v: function (e) {\n                  e >>>= 0;\n                  var t = new Date(o()[e + 20 >> 2 >>> 0] + 1900, o()[e + 16 >> 2 >>> 0], o()[e + 12 >> 2 >>> 0], o()[e + 8 >> 2 >>> 0], o()[e + 4 >> 2 >>> 0], o()[e >> 2 >>> 0], 0),\n                    n = o()[e + 32 >> 2 >>> 0],\n                    r = t.getTimezoneOffset(),\n                    i = new Date(t.getFullYear(), 6, 1).getTimezoneOffset(),\n                    a = new Date(t.getFullYear(), 0, 1).getTimezoneOffset(),\n                    s = Math.min(a, i);\n                  return 0 > n ? o()[e + 32 >> 2 >>> 0] = Number(i != a && s == r) : 0 < n != (s == r) && (i = Math.max(a, i), t.setTime(t.getTime() + 6e4 * ((0 < n ? s : i) - r))), o()[e + 24 >> 2 >>> 0] = t.getDay(), n = (Ue(t.getFullYear()) ? Be : Ve)[t.getMonth()] + t.getDate() - 1 | 0, o()[e + 28 >> 2 >>> 0] = n, o()[e >> 2 >>> 0] = t.getSeconds(), o()[e + 4 >> 2 >>> 0] = t.getMinutes(), o()[e + 8 >> 2 >>> 0] = t.getHours(), o()[e + 12 >> 2 >>> 0] = t.getDate(), o()[e + 16 >> 2 >>> 0] = t.getMonth(), o()[e + 20 >> 2 >>> 0] = t.getYear(), e = t.getTime() / 1e3, _t((Y = e, 1 <= +Math.abs(Y) ? 0 < Y ? +Math.floor(Y / 4294967296) >>> 0 : ~~+Math.ceil((Y - +(~~Y >>> 0)) / 4294967296) >>> 0 : 0)), e >>> 0;\n                },\n                r: ze,\n                s: Ge,\n                z: function (e, t, n) {\n                  function r(e) {\n                    return (e = e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/)) ? e[1] : \"GMT\";\n                  }\n                  e >>>= 0, t >>>= 0, n >>>= 0;\n                  var a = new Date().getFullYear(),\n                    s = new Date(a, 0, 1),\n                    u = new Date(a, 6, 1);\n                  a = s.getTimezoneOffset();\n                  var l = u.getTimezoneOffset(),\n                    c = Math.max(a, l);\n                  i()[e >> 2 >>> 0] = 60 * c, o()[t >> 2 >>> 0] = Number(a != l), e = r(s), t = r(u), e = He(e), t = He(t), l < a ? (i()[n >> 2 >>> 0] = e, i()[n + 4 >> 2 >>> 0] = t) : (i()[n >> 2 >>> 0] = t, i()[n + 4 >> 2 >>> 0] = e);\n                },\n                c: () => {\n                  te(\"\");\n                },\n                l: function () {},\n                i: function () {\n                  return Date.now();\n                },\n                V: () => {\n                  throw W += 1, \"unwind\";\n                },\n                B: function () {\n                  return 4294901760;\n                },\n                e: () => performance.timeOrigin + performance.now(),\n                f: function () {\n                  return y ? n(3993).cpus().length : navigator.hardwareConcurrency;\n                },\n                K: function (e, t, n, r) {\n                  for (he.pb = t >>> 0, Ye.length = n, t = r >>> 0 >> 3, r = 0; r < n; r++) Ye[r] = a()[t + r >>> 0];\n                  return ct[e].apply(null, Ye);\n                },\n                y: function (e) {\n                  e >>>= 0;\n                  var t = r().length;\n                  if (e <= t || 4294901760 < e) return !1;\n                  for (var n = 1; 4 >= n; n *= 2) {\n                    var o = t * (1 + .2 / n);\n                    o = Math.min(o, e + 100663296);\n                    var i = Math;\n                    o = Math.max(e, o);\n                    e: {\n                      i = i.min.call(i, 4294901760, o + (65536 - o % 65536) % 65536) - D.buffer.byteLength + 65535 >>> 16;\n                      try {\n                        D.grow(i), U();\n                        var a = 1;\n                        break e;\n                      } catch (e) {}\n                      a = void 0;\n                    }\n                    if (a) return !0;\n                  }\n                  return !1;\n                },\n                O: Ze,\n                P: Qe,\n                j: fe,\n                g: et,\n                n: tt,\n                w: nt,\n                m: ot,\n                x: function (e, t) {\n                  return e >>>= 0, t >>>= 0, it(r().subarray(e >>> 0, e + t >>> 0)), 0;\n                },\n                a: D || l.wasmMemory,\n                H: lt,\n                d: function (e, t, n, r) {\n                  return lt(e >>> 0, t >>> 0, n >>> 0, r >>> 0);\n                }\n              };\n            !function () {\n              function e(e, t) {\n                return e = e.exports, $ = e = function (e) {\n                  var t = e => () => e() >>> 0,\n                    n = e => t => e(t) >>> 0;\n                  return (e = Object.assign({}, e)).__errno_location = t(e.__errno_location), e.pthread_self = t(e.pthread_self), e.malloc = n(e.malloc), e.stackSave = t(e.stackSave), e.stackAlloc = n(e.stackAlloc), e;\n                }(e), he.Ta.push($.sa), V = $.ta, G.unshift($.W), k = t, ee(), e;\n              }\n              var t = {\n                a: pt\n              };\n              if (Q(), l.instantiateWasm) try {\n                return l.instantiateWasm(t, e);\n              } catch (e) {\n                I(\"Module.instantiateWasm callback failed with error: \" + e), u(e);\n              }\n              (function (e, t) {\n                var n = X;\n                return A || \"function\" != typeof WebAssembly.instantiateStreaming || ne(n) || n.startsWith(\"file://\") || y || \"function\" != typeof fetch ? oe(n, e, t) : fetch(n, {\n                  credentials: \"same-origin\"\n                }).then(r => WebAssembly.instantiateStreaming(r, e).then(t, function (r) {\n                  return I(\"wasm streaming compile failed: \" + r), I(\"falling back to ArrayBuffer instantiation\"), oe(n, e, t);\n                }));\n              })(t, function (t) {\n                e(t.instance, t.module);\n              }).catch(u);\n            }(), l._OrtInit = (e, t) => (l._OrtInit = $.X)(e, t), l._OrtGetLastError = (e, t) => (l._OrtGetLastError = $.Y)(e, t), l._OrtCreateSessionOptions = (e, t, n, r, o, i, a, s, u, c) => (l._OrtCreateSessionOptions = $.Z)(e, t, n, r, o, i, a, s, u, c), l._OrtAppendExecutionProvider = (e, t) => (l._OrtAppendExecutionProvider = $._)(e, t), l._OrtAddSessionConfigEntry = (e, t, n) => (l._OrtAddSessionConfigEntry = $.$)(e, t, n), l._OrtReleaseSessionOptions = e => (l._OrtReleaseSessionOptions = $.aa)(e), l._OrtCreateSession = (e, t, n) => (l._OrtCreateSession = $.ba)(e, t, n), l._OrtReleaseSession = e => (l._OrtReleaseSession = $.ca)(e), l._OrtGetInputOutputCount = (e, t, n) => (l._OrtGetInputOutputCount = $.da)(e, t, n), l._OrtGetInputName = (e, t) => (l._OrtGetInputName = $.ea)(e, t), l._OrtGetOutputName = (e, t) => (l._OrtGetOutputName = $.fa)(e, t), l._OrtFree = e => (l._OrtFree = $.ga)(e), l._OrtCreateTensor = (e, t, n, r, o) => (l._OrtCreateTensor = $.ha)(e, t, n, r, o), l._OrtGetTensorData = (e, t, n, r, o) => (l._OrtGetTensorData = $.ia)(e, t, n, r, o), l._OrtReleaseTensor = e => (l._OrtReleaseTensor = $.ja)(e), l._OrtCreateRunOptions = (e, t, n, r) => (l._OrtCreateRunOptions = $.ka)(e, t, n, r), l._OrtAddRunConfigEntry = (e, t, n) => (l._OrtAddRunConfigEntry = $.la)(e, t, n), l._OrtReleaseRunOptions = e => (l._OrtReleaseRunOptions = $.ma)(e), l._OrtRun = (e, t, n, r, o, i, a, s) => (l._OrtRun = $.na)(e, t, n, r, o, i, a, s), l._OrtEndProfiling = e => (l._OrtEndProfiling = $.oa)(e);\n            var dt = l._pthread_self = () => (dt = l._pthread_self = $.pa)(),\n              ft = l._malloc = e => (ft = l._malloc = $.qa)(e);\n            l._free = e => (l._free = $.ra)(e), l.__emscripten_tls_init = () => (l.__emscripten_tls_init = $.sa)();\n            var ht = l.__emscripten_thread_init = (e, t, n, r, o, i) => (ht = l.__emscripten_thread_init = $.ua)(e, t, n, r, o, i);\n            l.__emscripten_thread_crashed = () => (l.__emscripten_thread_crashed = $.va)();\n            var gt,\n              bt = (e, t, n, r) => (bt = $.wa)(e, t, n, r),\n              mt = e => (mt = $.xa)(e),\n              yt = l.__emscripten_thread_exit = e => (yt = l.__emscripten_thread_exit = $.ya)(e),\n              vt = l.__emscripten_check_mailbox = () => (vt = l.__emscripten_check_mailbox = $.za)(),\n              _t = e => (_t = $.Aa)(e),\n              wt = (e, t) => (wt = $.Ba)(e, t),\n              Tt = () => (Tt = $.Ca)(),\n              xt = e => (xt = $.Da)(e),\n              Ot = e => (Ot = $.Ea)(e);\n            function St() {\n              function e() {\n                if (!gt && (gt = !0, l.calledRun = !0, !M) && (v || ge(G), s(l), l.onRuntimeInitialized && l.onRuntimeInitialized(), !v)) {\n                  if (l.postRun) for (\"function\" == typeof l.postRun && (l.postRun = [l.postRun]); l.postRun.length;) {\n                    var e = l.postRun.shift();\n                    H.unshift(e);\n                  }\n                  ge(H);\n                }\n              }\n              if (!(0 < K)) if (v) s(l), v || ge(G), startWorker(l);else {\n                if (l.preRun) for (\"function\" == typeof l.preRun && (l.preRun = [l.preRun]); l.preRun.length;) z.unshift(l.preRun.shift());\n                ge(z), 0 < K || (l.setStatus ? (l.setStatus(\"Running...\"), setTimeout(function () {\n                  setTimeout(function () {\n                    l.setStatus(\"\");\n                  }, 1), e();\n                }, 1)) : e());\n              }\n            }\n            if (l.keepRuntimeAlive = q, l.wasmMemory = D, l.stackAlloc = Ot, l.stackSave = Tt, l.stackRestore = xt, l.UTF8ToString = pe, l.stringToUTF8 = Se, l.lengthBytesUTF8 = xe, l.ExitStatus = ie, l.PThread = he, Z = function e() {\n              gt || St(), gt || (Z = e);\n            }, l.preInit) for (\"function\" == typeof l.preInit && (l.preInit = [l.preInit]); 0 < l.preInit.length;) l.preInit.pop()();\n            return St(), e.ready;\n          });\n        e.exports = r;\n      },\n      932: (e, t, n) => {\n        var _scriptDir,\n          r = (_scriptDir = \"undefined\" != typeof document && document.currentScript ? document.currentScript.src : void 0, \"undefined\" != typeof __filename && (_scriptDir = _scriptDir || __filename), function (e = {}) {\n            var t,\n              r,\n              o = e;\n            o.ready = new Promise((e, n) => {\n              t = e, r = n;\n            });\n            var i,\n              a,\n              s,\n              u = Object.assign({}, o),\n              l = \"./this.program\",\n              c = (e, t) => {\n                throw t;\n              },\n              p = \"object\" == typeof window,\n              d = \"function\" == typeof importScripts,\n              f = \"object\" == typeof process && \"object\" == typeof process.versions && \"string\" == typeof process.versions.node,\n              h = \"\";\n            if (f) {\n              var g = n(1384),\n                b = n(908);\n              h = d ? b.dirname(h) + \"/\" : __dirname + \"/\", i = (e, t) => (e = e.startsWith(\"file://\") ? new URL(e) : b.normalize(e), g.readFileSync(e, t ? void 0 : \"utf8\")), s = e => ((e = i(e, !0)).buffer || (e = new Uint8Array(e)), e), a = (e, t, n, r = !0) => {\n                e = e.startsWith(\"file://\") ? new URL(e) : b.normalize(e), g.readFile(e, r ? void 0 : \"utf8\", (e, o) => {\n                  e ? n(e) : t(r ? o.buffer : o);\n                });\n              }, !o.thisProgram && 1 < process.argv.length && (l = process.argv[1].replace(/\\\\/g, \"/\")), process.argv.slice(2), c = (e, t) => {\n                throw process.exitCode = e, t;\n              }, o.inspect = () => \"[Emscripten Module object]\";\n            } else (p || d) && (d ? h = self.location.href : \"undefined\" != typeof document && document.currentScript && (h = document.currentScript.src), _scriptDir && (h = _scriptDir), h = 0 !== h.indexOf(\"blob:\") ? h.substr(0, h.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1) : \"\", i = e => {\n              var t = new XMLHttpRequest();\n              return t.open(\"GET\", e, !1), t.send(null), t.responseText;\n            }, d && (s = e => {\n              var t = new XMLHttpRequest();\n              return t.open(\"GET\", e, !1), t.responseType = \"arraybuffer\", t.send(null), new Uint8Array(t.response);\n            }), a = (e, t, n) => {\n              var r = new XMLHttpRequest();\n              r.open(\"GET\", e, !0), r.responseType = \"arraybuffer\", r.onload = () => {\n                200 == r.status || 0 == r.status && r.response ? t(r.response) : n();\n              }, r.onerror = n, r.send(null);\n            });\n            var m,\n              y = o.print || console.log.bind(console),\n              v = o.printErr || console.error.bind(console);\n            Object.assign(o, u), u = null, o.thisProgram && (l = o.thisProgram), o.quit && (c = o.quit), o.wasmBinary && (m = o.wasmBinary);\n            var _ = o.noExitRuntime || !0;\n            \"object\" != typeof WebAssembly && j(\"no native wasm support detected\");\n            var w,\n              T,\n              x,\n              O,\n              S,\n              A,\n              P = !1;\n            function I() {\n              var e = w.buffer;\n              o.HEAP8 = x = new Int8Array(e), o.HEAP16 = new Int16Array(e), o.HEAP32 = S = new Int32Array(e), o.HEAPU8 = O = new Uint8Array(e), o.HEAPU16 = new Uint16Array(e), o.HEAPU32 = A = new Uint32Array(e), o.HEAPF32 = new Float32Array(e), o.HEAPF64 = new Float64Array(e);\n            }\n            var E = [],\n              D = [],\n              $ = [];\n            function k() {\n              var e = o.preRun.shift();\n              E.unshift(e);\n            }\n            var F,\n              N,\n              R = 0,\n              L = null,\n              C = null;\n            function j(e) {\n              throw o.onAbort && o.onAbort(e), v(e = \"Aborted(\" + e + \")\"), P = !0, e = new WebAssembly.RuntimeError(e + \". Build with -sASSERTIONS for more info.\"), r(e), e;\n            }\n            function M(e) {\n              return e.startsWith(\"data:application/octet-stream;base64,\");\n            }\n            if (!M(F = \"ort-wasm.wasm\")) {\n              var U = F;\n              F = o.locateFile ? o.locateFile(U, h) : h + U;\n            }\n            function B(e) {\n              if (e == F && m) return new Uint8Array(m);\n              if (s) return s(e);\n              throw \"both async and sync fetching of the wasm failed\";\n            }\n            function V(e, t, n) {\n              return function (e) {\n                if (!m && (p || d)) {\n                  if (\"function\" == typeof fetch && !e.startsWith(\"file://\")) return fetch(e, {\n                    credentials: \"same-origin\"\n                  }).then(t => {\n                    if (!t.ok) throw \"failed to load wasm binary file at '\" + e + \"'\";\n                    return t.arrayBuffer();\n                  }).catch(() => B(e));\n                  if (a) return new Promise((t, n) => {\n                    a(e, e => t(new Uint8Array(e)), n);\n                  });\n                }\n                return Promise.resolve().then(() => B(e));\n              }(e).then(e => WebAssembly.instantiate(e, t)).then(e => e).then(n, e => {\n                v(\"failed to asynchronously prepare wasm: \" + e), j(e);\n              });\n            }\n            function z(e) {\n              this.name = \"ExitStatus\", this.message = `Program terminated with exit(${e})`, this.status = e;\n            }\n            var G = e => {\n              for (; 0 < e.length;) e.shift()(o);\n            };\n            function H(e) {\n              this.qa = e - 24, this.va = function (e) {\n                A[this.qa + 4 >> 2 >>> 0] = e;\n              }, this.ua = function (e) {\n                A[this.qa + 8 >> 2 >>> 0] = e;\n              }, this.sa = function (e, t) {\n                this.ta(), this.va(e), this.ua(t);\n              }, this.ta = function () {\n                A[this.qa + 16 >> 2 >>> 0] = 0;\n              };\n            }\n            var W,\n              q = \"undefined\" != typeof TextDecoder ? new TextDecoder(\"utf8\") : void 0,\n              X = (e, t, n) => {\n                var r = (t >>>= 0) + n;\n                for (n = t; e[n] && !(n >= r);) ++n;\n                if (16 < n - t && e.buffer && q) return q.decode(e.subarray(t, n));\n                for (r = \"\"; t < n;) {\n                  var o = e[t++];\n                  if (128 & o) {\n                    var i = 63 & e[t++];\n                    if (192 == (224 & o)) r += String.fromCharCode((31 & o) << 6 | i);else {\n                      var a = 63 & e[t++];\n                      65536 > (o = 224 == (240 & o) ? (15 & o) << 12 | i << 6 | a : (7 & o) << 18 | i << 12 | a << 6 | 63 & e[t++]) ? r += String.fromCharCode(o) : (o -= 65536, r += String.fromCharCode(55296 | o >> 10, 56320 | 1023 & o));\n                    }\n                  } else r += String.fromCharCode(o);\n                }\n                return r;\n              },\n              Y = (e, t) => (e >>>= 0) ? X(O, e, t) : \"\",\n              K = e => {\n                for (var t = 0, n = 0; n < e.length; ++n) {\n                  var r = e.charCodeAt(n);\n                  127 >= r ? t++ : 2047 >= r ? t += 2 : 55296 <= r && 57343 >= r ? (t += 4, ++n) : t += 3;\n                }\n                return t;\n              },\n              J = (e, t, n, r) => {\n                if (!(0 < r)) return 0;\n                var o = n >>>= 0;\n                r = n + r - 1;\n                for (var i = 0; i < e.length; ++i) {\n                  var a = e.charCodeAt(i);\n                  if (55296 <= a && 57343 >= a && (a = 65536 + ((1023 & a) << 10) | 1023 & e.charCodeAt(++i)), 127 >= a) {\n                    if (n >= r) break;\n                    t[n++ >>> 0] = a;\n                  } else {\n                    if (2047 >= a) {\n                      if (n + 1 >= r) break;\n                      t[n++ >>> 0] = 192 | a >> 6;\n                    } else {\n                      if (65535 >= a) {\n                        if (n + 2 >= r) break;\n                        t[n++ >>> 0] = 224 | a >> 12;\n                      } else {\n                        if (n + 3 >= r) break;\n                        t[n++ >>> 0] = 240 | a >> 18, t[n++ >>> 0] = 128 | a >> 12 & 63;\n                      }\n                      t[n++ >>> 0] = 128 | a >> 6 & 63;\n                    }\n                    t[n++ >>> 0] = 128 | 63 & a;\n                  }\n                }\n                return t[n >>> 0] = 0, n - o;\n              },\n              Z = e => 0 == e % 4 && (0 != e % 100 || 0 == e % 400),\n              Q = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335],\n              ee = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],\n              te = e => {\n                var t = K(e) + 1,\n                  n = ce(t);\n                return n && J(e, O, n, t), n;\n              },\n              ne = {},\n              re = () => {\n                if (!W) {\n                  var e,\n                    t = {\n                      USER: \"web_user\",\n                      LOGNAME: \"web_user\",\n                      PATH: \"/\",\n                      PWD: \"/\",\n                      HOME: \"/home/web_user\",\n                      LANG: (\"object\" == typeof navigator && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\",\n                      _: l || \"./this.program\"\n                    };\n                  for (e in ne) void 0 === ne[e] ? delete t[e] : t[e] = ne[e];\n                  var n = [];\n                  for (e in t) n.push(`${e}=${t[e]}`);\n                  W = n;\n                }\n                return W;\n              },\n              oe = [null, [], []],\n              ie = e => (ie = (() => {\n                if (\"object\" == typeof crypto && \"function\" == typeof crypto.getRandomValues) return e => crypto.getRandomValues(e);\n                if (f) try {\n                  var e = n(760);\n                  if (e.randomFillSync) return t => e.randomFillSync(t);\n                  var t = e.randomBytes;\n                  return e => (e.set(t(e.byteLength)), e);\n                } catch (e) {}\n                j(\"initRandomDevice\");\n              })())(e),\n              ae = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n              se = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n            function ue(e, t, n, r) {\n              function o(e, t, n) {\n                for (e = \"number\" == typeof e ? e.toString() : e || \"\"; e.length < t;) e = n[0] + e;\n                return e;\n              }\n              function i(e, t) {\n                return o(e, t, \"0\");\n              }\n              function a(e, t) {\n                function n(e) {\n                  return 0 > e ? -1 : 0 < e ? 1 : 0;\n                }\n                var r;\n                return 0 === (r = n(e.getFullYear() - t.getFullYear())) && 0 === (r = n(e.getMonth() - t.getMonth())) && (r = n(e.getDate() - t.getDate())), r;\n              }\n              function s(e) {\n                switch (e.getDay()) {\n                  case 0:\n                    return new Date(e.getFullYear() - 1, 11, 29);\n                  case 1:\n                    return e;\n                  case 2:\n                    return new Date(e.getFullYear(), 0, 3);\n                  case 3:\n                    return new Date(e.getFullYear(), 0, 2);\n                  case 4:\n                    return new Date(e.getFullYear(), 0, 1);\n                  case 5:\n                    return new Date(e.getFullYear() - 1, 11, 31);\n                  case 6:\n                    return new Date(e.getFullYear() - 1, 11, 30);\n                }\n              }\n              function u(e) {\n                var t = e.ma;\n                for (e = new Date(new Date(e.na + 1900, 0, 1).getTime()); 0 < t;) {\n                  var n = e.getMonth(),\n                    r = (Z(e.getFullYear()) ? ae : se)[n];\n                  if (!(t > r - e.getDate())) {\n                    e.setDate(e.getDate() + t);\n                    break;\n                  }\n                  t -= r - e.getDate() + 1, e.setDate(1), 11 > n ? e.setMonth(n + 1) : (e.setMonth(0), e.setFullYear(e.getFullYear() + 1));\n                }\n                return n = new Date(e.getFullYear() + 1, 0, 4), t = s(new Date(e.getFullYear(), 0, 4)), n = s(n), 0 >= a(t, e) ? 0 >= a(n, e) ? e.getFullYear() + 1 : e.getFullYear() : e.getFullYear() - 1;\n              }\n              e >>>= 0, t >>>= 0, n >>>= 0;\n              var l = S[40 + (r >>>= 0) >> 2 >>> 0];\n              for (var c in r = {\n                ya: S[r >> 2 >>> 0],\n                xa: S[r + 4 >> 2 >>> 0],\n                oa: S[r + 8 >> 2 >>> 0],\n                ra: S[r + 12 >> 2 >>> 0],\n                pa: S[r + 16 >> 2 >>> 0],\n                na: S[r + 20 >> 2 >>> 0],\n                ha: S[r + 24 >> 2 >>> 0],\n                ma: S[r + 28 >> 2 >>> 0],\n                Aa: S[r + 32 >> 2 >>> 0],\n                wa: S[r + 36 >> 2 >>> 0],\n                za: l ? Y(l) : \"\"\n              }, n = Y(n), l = {\n                \"%c\": \"%a %b %d %H:%M:%S %Y\",\n                \"%D\": \"%m/%d/%y\",\n                \"%F\": \"%Y-%m-%d\",\n                \"%h\": \"%b\",\n                \"%r\": \"%I:%M:%S %p\",\n                \"%R\": \"%H:%M\",\n                \"%T\": \"%H:%M:%S\",\n                \"%x\": \"%m/%d/%y\",\n                \"%X\": \"%H:%M:%S\",\n                \"%Ec\": \"%c\",\n                \"%EC\": \"%C\",\n                \"%Ex\": \"%m/%d/%y\",\n                \"%EX\": \"%H:%M:%S\",\n                \"%Ey\": \"%y\",\n                \"%EY\": \"%Y\",\n                \"%Od\": \"%d\",\n                \"%Oe\": \"%e\",\n                \"%OH\": \"%H\",\n                \"%OI\": \"%I\",\n                \"%Om\": \"%m\",\n                \"%OM\": \"%M\",\n                \"%OS\": \"%S\",\n                \"%Ou\": \"%u\",\n                \"%OU\": \"%U\",\n                \"%OV\": \"%V\",\n                \"%Ow\": \"%w\",\n                \"%OW\": \"%W\",\n                \"%Oy\": \"%y\"\n              }) n = n.replace(new RegExp(c, \"g\"), l[c]);\n              var p = \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n                d = \"January February March April May June July August September October November December\".split(\" \");\n              for (c in l = {\n                \"%a\": e => p[e.ha].substring(0, 3),\n                \"%A\": e => p[e.ha],\n                \"%b\": e => d[e.pa].substring(0, 3),\n                \"%B\": e => d[e.pa],\n                \"%C\": e => i((e.na + 1900) / 100 | 0, 2),\n                \"%d\": e => i(e.ra, 2),\n                \"%e\": e => o(e.ra, 2, \" \"),\n                \"%g\": e => u(e).toString().substring(2),\n                \"%G\": e => u(e),\n                \"%H\": e => i(e.oa, 2),\n                \"%I\": e => (0 == (e = e.oa) ? e = 12 : 12 < e && (e -= 12), i(e, 2)),\n                \"%j\": e => {\n                  for (var t = 0, n = 0; n <= e.pa - 1; t += (Z(e.na + 1900) ? ae : se)[n++]);\n                  return i(e.ra + t, 3);\n                },\n                \"%m\": e => i(e.pa + 1, 2),\n                \"%M\": e => i(e.xa, 2),\n                \"%n\": () => \"\\n\",\n                \"%p\": e => 0 <= e.oa && 12 > e.oa ? \"AM\" : \"PM\",\n                \"%S\": e => i(e.ya, 2),\n                \"%t\": () => \"\\t\",\n                \"%u\": e => e.ha || 7,\n                \"%U\": e => i(Math.floor((e.ma + 7 - e.ha) / 7), 2),\n                \"%V\": e => {\n                  var t = Math.floor((e.ma + 7 - (e.ha + 6) % 7) / 7);\n                  if (2 >= (e.ha + 371 - e.ma - 2) % 7 && t++, t) 53 == t && (4 == (n = (e.ha + 371 - e.ma) % 7) || 3 == n && Z(e.na) || (t = 1));else {\n                    t = 52;\n                    var n = (e.ha + 7 - e.ma - 1) % 7;\n                    (4 == n || 5 == n && Z(e.na % 400 - 1)) && t++;\n                  }\n                  return i(t, 2);\n                },\n                \"%w\": e => e.ha,\n                \"%W\": e => i(Math.floor((e.ma + 7 - (e.ha + 6) % 7) / 7), 2),\n                \"%y\": e => (e.na + 1900).toString().substring(2),\n                \"%Y\": e => e.na + 1900,\n                \"%z\": e => {\n                  var t = 0 <= (e = e.wa);\n                  return e = Math.abs(e) / 60, (t ? \"+\" : \"-\") + String(\"0000\" + (e / 60 * 100 + e % 60)).slice(-4);\n                },\n                \"%Z\": e => e.za,\n                \"%%\": () => \"%\"\n              }, n = n.replace(/%%/g, \"\\0\\0\"), l) n.includes(c) && (n = n.replace(new RegExp(c, \"g\"), l[c](r)));\n              return c = function (e) {\n                var t = Array(K(e) + 1);\n                return J(e, t, 0, t.length), t;\n              }(n = n.replace(/\\0\\0/g, \"%\")), c.length > t ? 0 : (x.set(c, e >>> 0), c.length - 1);\n            }\n            var le = {\n              a: function (e, t, n) {\n                throw new H(e >>>= 0).sa(t >>> 0, n >>> 0), e;\n              },\n              e: function () {\n                return 0;\n              },\n              I: function () {},\n              y: function () {},\n              A: function () {},\n              K: function () {\n                return 0;\n              },\n              G: function () {},\n              B: function () {},\n              F: function () {},\n              g: function () {},\n              z: function () {},\n              w: function () {},\n              H: function () {},\n              x: function () {},\n              k: () => !0,\n              n: function (e, t, n) {\n                e = t + 2097152 >>> 0 < 4194305 - !!e ? (e >>> 0) + 4294967296 * t : NaN, n >>>= 0, e = new Date(1e3 * e), S[n >> 2 >>> 0] = e.getUTCSeconds(), S[n + 4 >> 2 >>> 0] = e.getUTCMinutes(), S[n + 8 >> 2 >>> 0] = e.getUTCHours(), S[n + 12 >> 2 >>> 0] = e.getUTCDate(), S[n + 16 >> 2 >>> 0] = e.getUTCMonth(), S[n + 20 >> 2 >>> 0] = e.getUTCFullYear() - 1900, S[n + 24 >> 2 >>> 0] = e.getUTCDay(), S[n + 28 >> 2 >>> 0] = (e.getTime() - Date.UTC(e.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0;\n              },\n              o: function (e, t, n) {\n                e = t + 2097152 >>> 0 < 4194305 - !!e ? (e >>> 0) + 4294967296 * t : NaN, n >>>= 0, e = new Date(1e3 * e), S[n >> 2 >>> 0] = e.getSeconds(), S[n + 4 >> 2 >>> 0] = e.getMinutes(), S[n + 8 >> 2 >>> 0] = e.getHours(), S[n + 12 >> 2 >>> 0] = e.getDate(), S[n + 16 >> 2 >>> 0] = e.getMonth(), S[n + 20 >> 2 >>> 0] = e.getFullYear() - 1900, S[n + 24 >> 2 >>> 0] = e.getDay(), S[n + 28 >> 2 >>> 0] = (Z(e.getFullYear()) ? Q : ee)[e.getMonth()] + e.getDate() - 1 | 0, S[n + 36 >> 2 >>> 0] = -60 * e.getTimezoneOffset(), t = new Date(e.getFullYear(), 6, 1).getTimezoneOffset();\n                var r = new Date(e.getFullYear(), 0, 1).getTimezoneOffset();\n                S[n + 32 >> 2 >>> 0] = 0 | (t != r && e.getTimezoneOffset() == Math.min(r, t));\n              },\n              p: function (e) {\n                e >>>= 0;\n                var t = new Date(S[e + 20 >> 2 >>> 0] + 1900, S[e + 16 >> 2 >>> 0], S[e + 12 >> 2 >>> 0], S[e + 8 >> 2 >>> 0], S[e + 4 >> 2 >>> 0], S[e >> 2 >>> 0], 0),\n                  n = S[e + 32 >> 2 >>> 0],\n                  r = t.getTimezoneOffset(),\n                  o = new Date(t.getFullYear(), 6, 1).getTimezoneOffset(),\n                  i = new Date(t.getFullYear(), 0, 1).getTimezoneOffset(),\n                  a = Math.min(i, o);\n                return 0 > n ? S[e + 32 >> 2 >>> 0] = Number(o != i && a == r) : 0 < n != (a == r) && (o = Math.max(i, o), t.setTime(t.getTime() + 6e4 * ((0 < n ? a : o) - r))), S[e + 24 >> 2 >>> 0] = t.getDay(), S[e + 28 >> 2 >>> 0] = (Z(t.getFullYear()) ? Q : ee)[t.getMonth()] + t.getDate() - 1 | 0, S[e >> 2 >>> 0] = t.getSeconds(), S[e + 4 >> 2 >>> 0] = t.getMinutes(), S[e + 8 >> 2 >>> 0] = t.getHours(), S[e + 12 >> 2 >>> 0] = t.getDate(), S[e + 16 >> 2 >>> 0] = t.getMonth(), S[e + 20 >> 2 >>> 0] = t.getYear(), e = t.getTime() / 1e3, de((N = e, 1 <= +Math.abs(N) ? 0 < N ? +Math.floor(N / 4294967296) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)), e >>> 0;\n              },\n              l: function () {\n                return -52;\n              },\n              m: function () {},\n              u: function (e, t, n) {\n                function r(e) {\n                  return (e = e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/)) ? e[1] : \"GMT\";\n                }\n                n >>>= 0;\n                var o = new Date().getFullYear(),\n                  i = new Date(o, 0, 1),\n                  a = new Date(o, 6, 1);\n                o = i.getTimezoneOffset();\n                var s = a.getTimezoneOffset();\n                A[e >>> 0 >> 2 >>> 0] = 60 * Math.max(o, s), S[t >>> 0 >> 2 >>> 0] = Number(o != s), e = r(i), t = r(a), e = te(e), t = te(t), s < o ? (A[n >> 2 >>> 0] = e, A[n + 4 >> 2 >>> 0] = t) : (A[n >> 2 >>> 0] = t, A[n + 4 >> 2 >>> 0] = e);\n              },\n              d: () => {\n                j(\"\");\n              },\n              h: function () {\n                return Date.now();\n              },\n              v: function () {\n                return 4294901760;\n              },\n              b: () => performance.now(),\n              J: function (e, t, n) {\n                return t >>>= 0, O.copyWithin(e >>> 0 >>> 0, t >>> 0, t + (n >>> 0) >>> 0);\n              },\n              t: function (e) {\n                e >>>= 0;\n                var t = O.length;\n                if (4294901760 < e) return !1;\n                for (var n = 1; 4 >= n; n *= 2) {\n                  var r = t * (1 + .2 / n);\n                  r = Math.min(r, e + 100663296);\n                  var o = Math;\n                  r = Math.max(e, r);\n                  e: {\n                    o = o.min.call(o, 4294901760, r + (65536 - r % 65536) % 65536) - w.buffer.byteLength + 65535 >>> 16;\n                    try {\n                      w.grow(o), I();\n                      var i = 1;\n                      break e;\n                    } catch (e) {}\n                    i = void 0;\n                  }\n                  if (i) return !0;\n                }\n                return !1;\n              },\n              D: function (e, t) {\n                e >>>= 0, t >>>= 0;\n                var n = 0;\n                return re().forEach(function (r, o) {\n                  var i = t + n;\n                  for (o = A[e + 4 * o >> 2 >>> 0] = i, i = 0; i < r.length; ++i) x[o++ >> 0 >>> 0] = r.charCodeAt(i);\n                  x[o >> 0 >>> 0] = 0, n += r.length + 1;\n                }), 0;\n              },\n              E: function (e, t) {\n                e >>>= 0, t >>>= 0;\n                var n = re();\n                A[e >> 2 >>> 0] = n.length;\n                var r = 0;\n                return n.forEach(function (e) {\n                  r += e.length + 1;\n                }), A[t >> 2 >>> 0] = r, 0;\n              },\n              s: e => {\n                _ || (o.onExit && o.onExit(e), P = !0), c(e, new z(e));\n              },\n              f: () => 52,\n              j: function () {\n                return 52;\n              },\n              q: function () {\n                return 70;\n              },\n              i: function (e, t, n, r) {\n                t >>>= 0, n >>>= 0, r >>>= 0;\n                for (var o = 0, i = 0; i < n; i++) {\n                  var a = A[t >> 2 >>> 0],\n                    s = A[t + 4 >> 2 >>> 0];\n                  t += 8;\n                  for (var u = 0; u < s; u++) {\n                    var l = O[a + u >>> 0],\n                      c = oe[e];\n                    0 === l || 10 === l ? ((1 === e ? y : v)(X(c, 0)), c.length = 0) : c.push(l);\n                  }\n                  o += s;\n                }\n                return A[r >> 2 >>> 0] = o, 0;\n              },\n              r: function (e, t) {\n                return e >>>= 0, ie(O.subarray(e >>> 0, e + (t >>> 0) >>> 0)), 0;\n              },\n              C: ue,\n              c: function (e, t, n, r) {\n                return ue(e >>> 0, t >>> 0, n >>> 0, r >>> 0);\n              }\n            };\n            !function () {\n              function e(e) {\n                if (e = e.exports, T = e = function (e) {\n                  var t = e => () => e() >>> 0,\n                    n = e => t => e(t) >>> 0;\n                  return (e = Object.assign({}, e)).__errno_location = t(e.__errno_location), e.malloc = n(e.malloc), e.stackSave = t(e.stackSave), e.stackAlloc = n(e.stackAlloc), e;\n                }(e), w = T.L, I(), D.unshift(T.M), R--, o.monitorRunDependencies && o.monitorRunDependencies(R), 0 == R && (null !== L && (clearInterval(L), L = null), C)) {\n                  var t = C;\n                  C = null, t();\n                }\n                return e;\n              }\n              var t = {\n                a: le\n              };\n              if (R++, o.monitorRunDependencies && o.monitorRunDependencies(R), o.instantiateWasm) try {\n                return o.instantiateWasm(t, e);\n              } catch (e) {\n                v(\"Module.instantiateWasm callback failed with error: \" + e), r(e);\n              }\n              (function (e, t) {\n                var n = F;\n                return m || \"function\" != typeof WebAssembly.instantiateStreaming || M(n) || n.startsWith(\"file://\") || f || \"function\" != typeof fetch ? V(n, e, t) : fetch(n, {\n                  credentials: \"same-origin\"\n                }).then(r => WebAssembly.instantiateStreaming(r, e).then(t, function (r) {\n                  return v(\"wasm streaming compile failed: \" + r), v(\"falling back to ArrayBuffer instantiation\"), V(n, e, t);\n                }));\n              })(t, function (t) {\n                e(t.instance);\n              }).catch(r);\n            }(), o._OrtInit = (e, t) => (o._OrtInit = T.N)(e, t), o._OrtGetLastError = (e, t) => (o._OrtGetLastError = T.O)(e, t), o._OrtCreateSessionOptions = (e, t, n, r, i, a, s, u, l, c) => (o._OrtCreateSessionOptions = T.P)(e, t, n, r, i, a, s, u, l, c), o._OrtAppendExecutionProvider = (e, t) => (o._OrtAppendExecutionProvider = T.Q)(e, t), o._OrtAddSessionConfigEntry = (e, t, n) => (o._OrtAddSessionConfigEntry = T.R)(e, t, n), o._OrtReleaseSessionOptions = e => (o._OrtReleaseSessionOptions = T.S)(e), o._OrtCreateSession = (e, t, n) => (o._OrtCreateSession = T.T)(e, t, n), o._OrtReleaseSession = e => (o._OrtReleaseSession = T.U)(e), o._OrtGetInputOutputCount = (e, t, n) => (o._OrtGetInputOutputCount = T.V)(e, t, n), o._OrtGetInputName = (e, t) => (o._OrtGetInputName = T.W)(e, t), o._OrtGetOutputName = (e, t) => (o._OrtGetOutputName = T.X)(e, t), o._OrtFree = e => (o._OrtFree = T.Y)(e), o._OrtCreateTensor = (e, t, n, r, i) => (o._OrtCreateTensor = T.Z)(e, t, n, r, i), o._OrtGetTensorData = (e, t, n, r, i) => (o._OrtGetTensorData = T._)(e, t, n, r, i), o._OrtReleaseTensor = e => (o._OrtReleaseTensor = T.$)(e), o._OrtCreateRunOptions = (e, t, n, r) => (o._OrtCreateRunOptions = T.aa)(e, t, n, r), o._OrtAddRunConfigEntry = (e, t, n) => (o._OrtAddRunConfigEntry = T.ba)(e, t, n), o._OrtReleaseRunOptions = e => (o._OrtReleaseRunOptions = T.ca)(e), o._OrtRun = (e, t, n, r, i, a, s, u) => (o._OrtRun = T.da)(e, t, n, r, i, a, s, u), o._OrtEndProfiling = e => (o._OrtEndProfiling = T.ea)(e);\n            var ce = o._malloc = e => (ce = o._malloc = T.fa)(e);\n            o._free = e => (o._free = T.ga)(e);\n            var pe,\n              de = e => (de = T.ia)(e),\n              fe = () => (fe = T.ja)(),\n              he = e => (he = T.ka)(e),\n              ge = e => (ge = T.la)(e);\n            function be() {\n              function e() {\n                if (!pe && (pe = !0, o.calledRun = !0, !P)) {\n                  if (G(D), t(o), o.onRuntimeInitialized && o.onRuntimeInitialized(), o.postRun) for (\"function\" == typeof o.postRun && (o.postRun = [o.postRun]); o.postRun.length;) {\n                    var e = o.postRun.shift();\n                    $.unshift(e);\n                  }\n                  G($);\n                }\n              }\n              if (!(0 < R)) {\n                if (o.preRun) for (\"function\" == typeof o.preRun && (o.preRun = [o.preRun]); o.preRun.length;) k();\n                G(E), 0 < R || (o.setStatus ? (o.setStatus(\"Running...\"), setTimeout(function () {\n                  setTimeout(function () {\n                    o.setStatus(\"\");\n                  }, 1), e();\n                }, 1)) : e());\n              }\n            }\n            if (o.stackAlloc = ge, o.stackSave = fe, o.stackRestore = he, o.UTF8ToString = Y, o.stringToUTF8 = (e, t, n) => J(e, O, t, n), o.lengthBytesUTF8 = K, C = function e() {\n              pe || be(), pe || (C = e);\n            }, o.preInit) for (\"function\" == typeof o.preInit && (o.preInit = [o.preInit]); 0 < o.preInit.length;) o.preInit.pop()();\n            return be(), e.ready;\n          });\n        e.exports = r;\n      },\n      4537: e => {\n        \"use strict\";\n\n        e.exports = function (e, t) {\n          for (var n = new Array(arguments.length - 1), r = 0, o = 2, i = !0; o < arguments.length;) n[r++] = arguments[o++];\n          return new Promise(function (o, a) {\n            n[r] = function (e) {\n              if (i) if (i = !1, e) a(e);else {\n                for (var t = new Array(arguments.length - 1), n = 0; n < t.length;) t[n++] = arguments[n];\n                o.apply(null, t);\n              }\n            };\n            try {\n              e.apply(t || null, n);\n            } catch (e) {\n              i && (i = !1, a(e));\n            }\n          });\n        };\n      },\n      7419: (e, t) => {\n        \"use strict\";\n\n        var n = t;\n        n.length = function (e) {\n          var t = e.length;\n          if (!t) return 0;\n          for (var n = 0; --t % 4 > 1 && \"=\" === e.charAt(t);) ++n;\n          return Math.ceil(3 * e.length) / 4 - n;\n        };\n        for (var r = new Array(64), o = new Array(123), i = 0; i < 64;) o[r[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\n        n.encode = function (e, t, n) {\n          for (var o, i = null, a = [], s = 0, u = 0; t < n;) {\n            var l = e[t++];\n            switch (u) {\n              case 0:\n                a[s++] = r[l >> 2], o = (3 & l) << 4, u = 1;\n                break;\n              case 1:\n                a[s++] = r[o | l >> 4], o = (15 & l) << 2, u = 2;\n                break;\n              case 2:\n                a[s++] = r[o | l >> 6], a[s++] = r[63 & l], u = 0;\n            }\n            s > 8191 && ((i || (i = [])).push(String.fromCharCode.apply(String, a)), s = 0);\n          }\n          return u && (a[s++] = r[o], a[s++] = 61, 1 === u && (a[s++] = 61)), i ? (s && i.push(String.fromCharCode.apply(String, a.slice(0, s))), i.join(\"\")) : String.fromCharCode.apply(String, a.slice(0, s));\n        };\n        var a = \"invalid encoding\";\n        n.decode = function (e, t, n) {\n          for (var r, i = n, s = 0, u = 0; u < e.length;) {\n            var l = e.charCodeAt(u++);\n            if (61 === l && s > 1) break;\n            if (void 0 === (l = o[l])) throw Error(a);\n            switch (s) {\n              case 0:\n                r = l, s = 1;\n                break;\n              case 1:\n                t[n++] = r << 2 | (48 & l) >> 4, r = l, s = 2;\n                break;\n              case 2:\n                t[n++] = (15 & r) << 4 | (60 & l) >> 2, r = l, s = 3;\n                break;\n              case 3:\n                t[n++] = (3 & r) << 6 | l, s = 0;\n            }\n          }\n          if (1 === s) throw Error(a);\n          return n - i;\n        }, n.test = function (e) {\n          return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e);\n        };\n      },\n      9211: e => {\n        \"use strict\";\n\n        function t() {\n          this._listeners = {};\n        }\n        e.exports = t, t.prototype.on = function (e, t, n) {\n          return (this._listeners[e] || (this._listeners[e] = [])).push({\n            fn: t,\n            ctx: n || this\n          }), this;\n        }, t.prototype.off = function (e, t) {\n          if (void 0 === e) this._listeners = {};else if (void 0 === t) this._listeners[e] = [];else for (var n = this._listeners[e], r = 0; r < n.length;) n[r].fn === t ? n.splice(r, 1) : ++r;\n          return this;\n        }, t.prototype.emit = function (e) {\n          var t = this._listeners[e];\n          if (t) {\n            for (var n = [], r = 1; r < arguments.length;) n.push(arguments[r++]);\n            for (r = 0; r < t.length;) t[r].fn.apply(t[r++].ctx, n);\n          }\n          return this;\n        };\n      },\n      945: e => {\n        \"use strict\";\n\n        function t(e) {\n          return \"undefined\" != typeof Float32Array ? function () {\n            var t = new Float32Array([-0]),\n              n = new Uint8Array(t.buffer),\n              r = 128 === n[3];\n            function o(e, r, o) {\n              t[0] = e, r[o] = n[0], r[o + 1] = n[1], r[o + 2] = n[2], r[o + 3] = n[3];\n            }\n            function i(e, r, o) {\n              t[0] = e, r[o] = n[3], r[o + 1] = n[2], r[o + 2] = n[1], r[o + 3] = n[0];\n            }\n            function a(e, r) {\n              return n[0] = e[r], n[1] = e[r + 1], n[2] = e[r + 2], n[3] = e[r + 3], t[0];\n            }\n            function s(e, r) {\n              return n[3] = e[r], n[2] = e[r + 1], n[1] = e[r + 2], n[0] = e[r + 3], t[0];\n            }\n            e.writeFloatLE = r ? o : i, e.writeFloatBE = r ? i : o, e.readFloatLE = r ? a : s, e.readFloatBE = r ? s : a;\n          }() : function () {\n            function t(e, t, n, r) {\n              var o = t < 0 ? 1 : 0;\n              if (o && (t = -t), 0 === t) e(1 / t > 0 ? 0 : 2147483648, n, r);else if (isNaN(t)) e(2143289344, n, r);else if (t > 34028234663852886e22) e((o << 31 | 2139095040) >>> 0, n, r);else if (t < 11754943508222875e-54) e((o << 31 | Math.round(t / 1401298464324817e-60)) >>> 0, n, r);else {\n                var i = Math.floor(Math.log(t) / Math.LN2);\n                e((o << 31 | i + 127 << 23 | 8388607 & Math.round(t * Math.pow(2, -i) * 8388608)) >>> 0, n, r);\n              }\n            }\n            function a(e, t, n) {\n              var r = e(t, n),\n                o = 2 * (r >> 31) + 1,\n                i = r >>> 23 & 255,\n                a = 8388607 & r;\n              return 255 === i ? a ? NaN : o * (1 / 0) : 0 === i ? 1401298464324817e-60 * o * a : o * Math.pow(2, i - 150) * (a + 8388608);\n            }\n            e.writeFloatLE = t.bind(null, n), e.writeFloatBE = t.bind(null, r), e.readFloatLE = a.bind(null, o), e.readFloatBE = a.bind(null, i);\n          }(), \"undefined\" != typeof Float64Array ? function () {\n            var t = new Float64Array([-0]),\n              n = new Uint8Array(t.buffer),\n              r = 128 === n[7];\n            function o(e, r, o) {\n              t[0] = e, r[o] = n[0], r[o + 1] = n[1], r[o + 2] = n[2], r[o + 3] = n[3], r[o + 4] = n[4], r[o + 5] = n[5], r[o + 6] = n[6], r[o + 7] = n[7];\n            }\n            function i(e, r, o) {\n              t[0] = e, r[o] = n[7], r[o + 1] = n[6], r[o + 2] = n[5], r[o + 3] = n[4], r[o + 4] = n[3], r[o + 5] = n[2], r[o + 6] = n[1], r[o + 7] = n[0];\n            }\n            function a(e, r) {\n              return n[0] = e[r], n[1] = e[r + 1], n[2] = e[r + 2], n[3] = e[r + 3], n[4] = e[r + 4], n[5] = e[r + 5], n[6] = e[r + 6], n[7] = e[r + 7], t[0];\n            }\n            function s(e, r) {\n              return n[7] = e[r], n[6] = e[r + 1], n[5] = e[r + 2], n[4] = e[r + 3], n[3] = e[r + 4], n[2] = e[r + 5], n[1] = e[r + 6], n[0] = e[r + 7], t[0];\n            }\n            e.writeDoubleLE = r ? o : i, e.writeDoubleBE = r ? i : o, e.readDoubleLE = r ? a : s, e.readDoubleBE = r ? s : a;\n          }() : function () {\n            function t(e, t, n, r, o, i) {\n              var a = r < 0 ? 1 : 0;\n              if (a && (r = -r), 0 === r) e(0, o, i + t), e(1 / r > 0 ? 0 : 2147483648, o, i + n);else if (isNaN(r)) e(0, o, i + t), e(2146959360, o, i + n);else if (r > 17976931348623157e292) e(0, o, i + t), e((a << 31 | 2146435072) >>> 0, o, i + n);else {\n                var s;\n                if (r < 22250738585072014e-324) e((s = r / 5e-324) >>> 0, o, i + t), e((a << 31 | s / 4294967296) >>> 0, o, i + n);else {\n                  var u = Math.floor(Math.log(r) / Math.LN2);\n                  1024 === u && (u = 1023), e(4503599627370496 * (s = r * Math.pow(2, -u)) >>> 0, o, i + t), e((a << 31 | u + 1023 << 20 | 1048576 * s & 1048575) >>> 0, o, i + n);\n                }\n              }\n            }\n            function a(e, t, n, r, o) {\n              var i = e(r, o + t),\n                a = e(r, o + n),\n                s = 2 * (a >> 31) + 1,\n                u = a >>> 20 & 2047,\n                l = 4294967296 * (1048575 & a) + i;\n              return 2047 === u ? l ? NaN : s * (1 / 0) : 0 === u ? 5e-324 * s * l : s * Math.pow(2, u - 1075) * (l + 4503599627370496);\n            }\n            e.writeDoubleLE = t.bind(null, n, 0, 4), e.writeDoubleBE = t.bind(null, r, 4, 0), e.readDoubleLE = a.bind(null, o, 0, 4), e.readDoubleBE = a.bind(null, i, 4, 0);\n          }(), e;\n        }\n        function n(e, t, n) {\n          t[n] = 255 & e, t[n + 1] = e >>> 8 & 255, t[n + 2] = e >>> 16 & 255, t[n + 3] = e >>> 24;\n        }\n        function r(e, t, n) {\n          t[n] = e >>> 24, t[n + 1] = e >>> 16 & 255, t[n + 2] = e >>> 8 & 255, t[n + 3] = 255 & e;\n        }\n        function o(e, t) {\n          return (e[t] | e[t + 1] << 8 | e[t + 2] << 16 | e[t + 3] << 24) >>> 0;\n        }\n        function i(e, t) {\n          return (e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) >>> 0;\n        }\n        e.exports = t(t);\n      },\n      7199: module => {\n        \"use strict\";\n\n        function inquire(moduleName) {\n          try {\n            var mod = eval(\"quire\".replace(/^/, \"re\"))(moduleName);\n            if (mod && (mod.length || Object.keys(mod).length)) return mod;\n          } catch (e) {}\n          return null;\n        }\n        module.exports = inquire;\n      },\n      6662: e => {\n        \"use strict\";\n\n        e.exports = function (e, t, n) {\n          var r = n || 8192,\n            o = r >>> 1,\n            i = null,\n            a = r;\n          return function (n) {\n            if (n < 1 || n > o) return e(n);\n            a + n > r && (i = e(r), a = 0);\n            var s = t.call(i, a, a += n);\n            return 7 & a && (a = 1 + (7 | a)), s;\n          };\n        };\n      },\n      4997: (e, t) => {\n        \"use strict\";\n\n        var n = t;\n        n.length = function (e) {\n          for (var t = 0, n = 0, r = 0; r < e.length; ++r) (n = e.charCodeAt(r)) < 128 ? t += 1 : n < 2048 ? t += 2 : 55296 == (64512 & n) && 56320 == (64512 & e.charCodeAt(r + 1)) ? (++r, t += 4) : t += 3;\n          return t;\n        }, n.read = function (e, t, n) {\n          if (n - t < 1) return \"\";\n          for (var r, o = null, i = [], a = 0; t < n;) (r = e[t++]) < 128 ? i[a++] = r : r > 191 && r < 224 ? i[a++] = (31 & r) << 6 | 63 & e[t++] : r > 239 && r < 365 ? (r = ((7 & r) << 18 | (63 & e[t++]) << 12 | (63 & e[t++]) << 6 | 63 & e[t++]) - 65536, i[a++] = 55296 + (r >> 10), i[a++] = 56320 + (1023 & r)) : i[a++] = (15 & r) << 12 | (63 & e[t++]) << 6 | 63 & e[t++], a > 8191 && ((o || (o = [])).push(String.fromCharCode.apply(String, i)), a = 0);\n          return o ? (a && o.push(String.fromCharCode.apply(String, i.slice(0, a))), o.join(\"\")) : String.fromCharCode.apply(String, i.slice(0, a));\n        }, n.write = function (e, t, n) {\n          for (var r, o, i = n, a = 0; a < e.length; ++a) (r = e.charCodeAt(a)) < 128 ? t[n++] = r : r < 2048 ? (t[n++] = r >> 6 | 192, t[n++] = 63 & r | 128) : 55296 == (64512 & r) && 56320 == (64512 & (o = e.charCodeAt(a + 1))) ? (r = 65536 + ((1023 & r) << 10) + (1023 & o), ++a, t[n++] = r >> 18 | 240, t[n++] = r >> 12 & 63 | 128, t[n++] = r >> 6 & 63 | 128, t[n++] = 63 & r | 128) : (t[n++] = r >> 12 | 224, t[n++] = r >> 6 & 63 | 128, t[n++] = 63 & r | 128);\n          return n - i;\n        };\n      },\n      3442: (e, t) => {\n        \"use strict\";\n\n        t.__esModule = !0;\n        var n = function () {\n          function e(t) {\n            if (!t) throw new TypeError(\"Invalid argument; `value` has no value.\");\n            this.value = e.EMPTY, t && e.isGuid(t) && (this.value = t);\n          }\n          return e.isGuid = function (t) {\n            var n = t.toString();\n            return t && (t instanceof e || e.validator.test(n));\n          }, e.create = function () {\n            return new e([e.gen(2), e.gen(1), e.gen(1), e.gen(1), e.gen(3)].join(\"-\"));\n          }, e.createEmpty = function () {\n            return new e(\"emptyguid\");\n          }, e.parse = function (t) {\n            return new e(t);\n          }, e.raw = function () {\n            return [e.gen(2), e.gen(1), e.gen(1), e.gen(1), e.gen(3)].join(\"-\");\n          }, e.gen = function (e) {\n            for (var t = \"\", n = 0; n < e; n++) t += (65536 * (1 + Math.random()) | 0).toString(16).substring(1);\n            return t;\n          }, e.prototype.equals = function (t) {\n            return e.isGuid(t) && this.value === t.toString();\n          }, e.prototype.isEmpty = function () {\n            return this.value === e.EMPTY;\n          }, e.prototype.toString = function () {\n            return this.value;\n          }, e.prototype.toJSON = function () {\n            return {\n              value: this.value\n            };\n          }, e.validator = new RegExp(\"^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$\", \"i\"), e.EMPTY = \"00000000-0000-0000-0000-000000000000\", e;\n        }();\n        t.Guid = n;\n      },\n      2100: (e, t, n) => {\n        \"use strict\";\n\n        e.exports = n(9482);\n      },\n      9482: (e, t, n) => {\n        \"use strict\";\n\n        var r = t;\n        function o() {\n          r.util._configure(), r.Writer._configure(r.BufferWriter), r.Reader._configure(r.BufferReader);\n        }\n        r.build = \"minimal\", r.Writer = n(1173), r.BufferWriter = n(3155), r.Reader = n(1408), r.BufferReader = n(593), r.util = n(9693), r.rpc = n(5994), r.roots = n(5054), r.configure = o, o();\n      },\n      1408: (e, t, n) => {\n        \"use strict\";\n\n        e.exports = u;\n        var r,\n          o = n(9693),\n          i = o.LongBits,\n          a = o.utf8;\n        function s(e, t) {\n          return RangeError(\"index out of range: \" + e.pos + \" + \" + (t || 1) + \" > \" + e.len);\n        }\n        function u(e) {\n          this.buf = e, this.pos = 0, this.len = e.length;\n        }\n        var l,\n          c = \"undefined\" != typeof Uint8Array ? function (e) {\n            if (e instanceof Uint8Array || Array.isArray(e)) return new u(e);\n            throw Error(\"illegal buffer\");\n          } : function (e) {\n            if (Array.isArray(e)) return new u(e);\n            throw Error(\"illegal buffer\");\n          },\n          p = function () {\n            return o.Buffer ? function (e) {\n              return (u.create = function (e) {\n                return o.Buffer.isBuffer(e) ? new r(e) : c(e);\n              })(e);\n            } : c;\n          };\n        function d() {\n          var e = new i(0, 0),\n            t = 0;\n          if (!(this.len - this.pos > 4)) {\n            for (; t < 3; ++t) {\n              if (this.pos >= this.len) throw s(this);\n              if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 7 * t) >>> 0, this.buf[this.pos++] < 128) return e;\n            }\n            return e.lo = (e.lo | (127 & this.buf[this.pos++]) << 7 * t) >>> 0, e;\n          }\n          for (; t < 4; ++t) if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 7 * t) >>> 0, this.buf[this.pos++] < 128) return e;\n          if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 28) >>> 0, e.hi = (e.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128) return e;\n          if (t = 0, this.len - this.pos > 4) {\n            for (; t < 5; ++t) if (e.hi = (e.hi | (127 & this.buf[this.pos]) << 7 * t + 3) >>> 0, this.buf[this.pos++] < 128) return e;\n          } else for (; t < 5; ++t) {\n            if (this.pos >= this.len) throw s(this);\n            if (e.hi = (e.hi | (127 & this.buf[this.pos]) << 7 * t + 3) >>> 0, this.buf[this.pos++] < 128) return e;\n          }\n          throw Error(\"invalid varint encoding\");\n        }\n        function f(e, t) {\n          return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16 | e[t - 1] << 24) >>> 0;\n        }\n        function h() {\n          if (this.pos + 8 > this.len) throw s(this, 8);\n          return new i(f(this.buf, this.pos += 4), f(this.buf, this.pos += 4));\n        }\n        u.create = p(), u.prototype._slice = o.Array.prototype.subarray || o.Array.prototype.slice, u.prototype.uint32 = (l = 4294967295, function () {\n          if (l = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128) return l;\n          if (l = (l | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128) return l;\n          if (l = (l | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128) return l;\n          if (l = (l | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128) return l;\n          if (l = (l | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128) return l;\n          if ((this.pos += 5) > this.len) throw this.pos = this.len, s(this, 10);\n          return l;\n        }), u.prototype.int32 = function () {\n          return 0 | this.uint32();\n        }, u.prototype.sint32 = function () {\n          var e = this.uint32();\n          return e >>> 1 ^ -(1 & e) | 0;\n        }, u.prototype.bool = function () {\n          return 0 !== this.uint32();\n        }, u.prototype.fixed32 = function () {\n          if (this.pos + 4 > this.len) throw s(this, 4);\n          return f(this.buf, this.pos += 4);\n        }, u.prototype.sfixed32 = function () {\n          if (this.pos + 4 > this.len) throw s(this, 4);\n          return 0 | f(this.buf, this.pos += 4);\n        }, u.prototype.float = function () {\n          if (this.pos + 4 > this.len) throw s(this, 4);\n          var e = o.float.readFloatLE(this.buf, this.pos);\n          return this.pos += 4, e;\n        }, u.prototype.double = function () {\n          if (this.pos + 8 > this.len) throw s(this, 4);\n          var e = o.float.readDoubleLE(this.buf, this.pos);\n          return this.pos += 8, e;\n        }, u.prototype.bytes = function () {\n          var e = this.uint32(),\n            t = this.pos,\n            n = this.pos + e;\n          if (n > this.len) throw s(this, e);\n          return this.pos += e, Array.isArray(this.buf) ? this.buf.slice(t, n) : t === n ? new this.buf.constructor(0) : this._slice.call(this.buf, t, n);\n        }, u.prototype.string = function () {\n          var e = this.bytes();\n          return a.read(e, 0, e.length);\n        }, u.prototype.skip = function (e) {\n          if (\"number\" == typeof e) {\n            if (this.pos + e > this.len) throw s(this, e);\n            this.pos += e;\n          } else do {\n            if (this.pos >= this.len) throw s(this);\n          } while (128 & this.buf[this.pos++]);\n          return this;\n        }, u.prototype.skipType = function (e) {\n          switch (e) {\n            case 0:\n              this.skip();\n              break;\n            case 1:\n              this.skip(8);\n              break;\n            case 2:\n              this.skip(this.uint32());\n              break;\n            case 3:\n              for (; 4 != (e = 7 & this.uint32());) this.skipType(e);\n              break;\n            case 5:\n              this.skip(4);\n              break;\n            default:\n              throw Error(\"invalid wire type \" + e + \" at offset \" + this.pos);\n          }\n          return this;\n        }, u._configure = function (e) {\n          r = e, u.create = p(), r._configure();\n          var t = o.Long ? \"toLong\" : \"toNumber\";\n          o.merge(u.prototype, {\n            int64: function () {\n              return d.call(this)[t](!1);\n            },\n            uint64: function () {\n              return d.call(this)[t](!0);\n            },\n            sint64: function () {\n              return d.call(this).zzDecode()[t](!1);\n            },\n            fixed64: function () {\n              return h.call(this)[t](!0);\n            },\n            sfixed64: function () {\n              return h.call(this)[t](!1);\n            }\n          });\n        };\n      },\n      593: (e, t, n) => {\n        \"use strict\";\n\n        e.exports = i;\n        var r = n(1408);\n        (i.prototype = Object.create(r.prototype)).constructor = i;\n        var o = n(9693);\n        function i(e) {\n          r.call(this, e);\n        }\n        i._configure = function () {\n          o.Buffer && (i.prototype._slice = o.Buffer.prototype.slice);\n        }, i.prototype.string = function () {\n          var e = this.uint32();\n          return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e, this.len)) : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + e, this.len));\n        }, i._configure();\n      },\n      5054: e => {\n        \"use strict\";\n\n        e.exports = {};\n      },\n      5994: (e, t, n) => {\n        \"use strict\";\n\n        t.Service = n(7948);\n      },\n      7948: (e, t, n) => {\n        \"use strict\";\n\n        e.exports = o;\n        var r = n(9693);\n        function o(e, t, n) {\n          if (\"function\" != typeof e) throw TypeError(\"rpcImpl must be a function\");\n          r.EventEmitter.call(this), this.rpcImpl = e, this.requestDelimited = Boolean(t), this.responseDelimited = Boolean(n);\n        }\n        (o.prototype = Object.create(r.EventEmitter.prototype)).constructor = o, o.prototype.rpcCall = function e(t, n, o, i, a) {\n          if (!i) throw TypeError(\"request must be specified\");\n          var s = this;\n          if (!a) return r.asPromise(e, s, t, n, o, i);\n          if (s.rpcImpl) try {\n            return s.rpcImpl(t, n[s.requestDelimited ? \"encodeDelimited\" : \"encode\"](i).finish(), function (e, n) {\n              if (e) return s.emit(\"error\", e, t), a(e);\n              if (null !== n) {\n                if (!(n instanceof o)) try {\n                  n = o[s.responseDelimited ? \"decodeDelimited\" : \"decode\"](n);\n                } catch (e) {\n                  return s.emit(\"error\", e, t), a(e);\n                }\n                return s.emit(\"data\", n, t), a(null, n);\n              }\n              s.end(!0);\n            });\n          } catch (e) {\n            return s.emit(\"error\", e, t), void setTimeout(function () {\n              a(e);\n            }, 0);\n          } else setTimeout(function () {\n            a(Error(\"already ended\"));\n          }, 0);\n        }, o.prototype.end = function (e) {\n          return this.rpcImpl && (e || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit(\"end\").off()), this;\n        };\n      },\n      1945: (e, t, n) => {\n        \"use strict\";\n\n        e.exports = o;\n        var r = n(9693);\n        function o(e, t) {\n          this.lo = e >>> 0, this.hi = t >>> 0;\n        }\n        var i = o.zero = new o(0, 0);\n        i.toNumber = function () {\n          return 0;\n        }, i.zzEncode = i.zzDecode = function () {\n          return this;\n        }, i.length = function () {\n          return 1;\n        };\n        var a = o.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n        o.fromNumber = function (e) {\n          if (0 === e) return i;\n          var t = e < 0;\n          t && (e = -e);\n          var n = e >>> 0,\n            r = (e - n) / 4294967296 >>> 0;\n          return t && (r = ~r >>> 0, n = ~n >>> 0, ++n > 4294967295 && (n = 0, ++r > 4294967295 && (r = 0))), new o(n, r);\n        }, o.from = function (e) {\n          if (\"number\" == typeof e) return o.fromNumber(e);\n          if (r.isString(e)) {\n            if (!r.Long) return o.fromNumber(parseInt(e, 10));\n            e = r.Long.fromString(e);\n          }\n          return e.low || e.high ? new o(e.low >>> 0, e.high >>> 0) : i;\n        }, o.prototype.toNumber = function (e) {\n          if (!e && this.hi >>> 31) {\n            var t = 1 + ~this.lo >>> 0,\n              n = ~this.hi >>> 0;\n            return t || (n = n + 1 >>> 0), -(t + 4294967296 * n);\n          }\n          return this.lo + 4294967296 * this.hi;\n        }, o.prototype.toLong = function (e) {\n          return r.Long ? new r.Long(0 | this.lo, 0 | this.hi, Boolean(e)) : {\n            low: 0 | this.lo,\n            high: 0 | this.hi,\n            unsigned: Boolean(e)\n          };\n        };\n        var s = String.prototype.charCodeAt;\n        o.fromHash = function (e) {\n          return e === a ? i : new o((s.call(e, 0) | s.call(e, 1) << 8 | s.call(e, 2) << 16 | s.call(e, 3) << 24) >>> 0, (s.call(e, 4) | s.call(e, 5) << 8 | s.call(e, 6) << 16 | s.call(e, 7) << 24) >>> 0);\n        }, o.prototype.toHash = function () {\n          return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);\n        }, o.prototype.zzEncode = function () {\n          var e = this.hi >> 31;\n          return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e) >>> 0, this.lo = (this.lo << 1 ^ e) >>> 0, this;\n        }, o.prototype.zzDecode = function () {\n          var e = -(1 & this.lo);\n          return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e) >>> 0, this.hi = (this.hi >>> 1 ^ e) >>> 0, this;\n        }, o.prototype.length = function () {\n          var e = this.lo,\n            t = (this.lo >>> 28 | this.hi << 4) >>> 0,\n            n = this.hi >>> 24;\n          return 0 === n ? 0 === t ? e < 16384 ? e < 128 ? 1 : 2 : e < 2097152 ? 3 : 4 : t < 16384 ? t < 128 ? 5 : 6 : t < 2097152 ? 7 : 8 : n < 128 ? 9 : 10;\n        };\n      },\n      9693: function (e, t, n) {\n        \"use strict\";\n\n        var r = t;\n        function o(e, t, n) {\n          for (var r = Object.keys(t), o = 0; o < r.length; ++o) void 0 !== e[r[o]] && n || (e[r[o]] = t[r[o]]);\n          return e;\n        }\n        function i(e) {\n          function t(e, n) {\n            if (!(this instanceof t)) return new t(e, n);\n            Object.defineProperty(this, \"message\", {\n              get: function () {\n                return e;\n              }\n            }), Error.captureStackTrace ? Error.captureStackTrace(this, t) : Object.defineProperty(this, \"stack\", {\n              value: new Error().stack || \"\"\n            }), n && o(this, n);\n          }\n          return t.prototype = Object.create(Error.prototype, {\n            constructor: {\n              value: t,\n              writable: !0,\n              enumerable: !1,\n              configurable: !0\n            },\n            name: {\n              get: function () {\n                return e;\n              },\n              set: void 0,\n              enumerable: !1,\n              configurable: !0\n            },\n            toString: {\n              value: function () {\n                return this.name + \": \" + this.message;\n              },\n              writable: !0,\n              enumerable: !1,\n              configurable: !0\n            }\n          }), t;\n        }\n        r.asPromise = n(4537), r.base64 = n(7419), r.EventEmitter = n(9211), r.float = n(945), r.inquire = n(7199), r.utf8 = n(4997), r.pool = n(6662), r.LongBits = n(1945), r.isNode = Boolean(\"undefined\" != typeof global && global && global.process && global.process.versions && global.process.versions.node), r.global = r.isNode && global || \"undefined\" != typeof window && window || \"undefined\" != typeof self && self || this, r.emptyArray = Object.freeze ? Object.freeze([]) : [], r.emptyObject = Object.freeze ? Object.freeze({}) : {}, r.isInteger = Number.isInteger || function (e) {\n          return \"number\" == typeof e && isFinite(e) && Math.floor(e) === e;\n        }, r.isString = function (e) {\n          return \"string\" == typeof e || e instanceof String;\n        }, r.isObject = function (e) {\n          return e && \"object\" == typeof e;\n        }, r.isset = r.isSet = function (e, t) {\n          var n = e[t];\n          return !(null == n || !e.hasOwnProperty(t)) && (\"object\" != typeof n || (Array.isArray(n) ? n.length : Object.keys(n).length) > 0);\n        }, r.Buffer = function () {\n          try {\n            var e = r.inquire(\"buffer\").Buffer;\n            return e.prototype.utf8Write ? e : null;\n          } catch (e) {\n            return null;\n          }\n        }(), r._Buffer_from = null, r._Buffer_allocUnsafe = null, r.newBuffer = function (e) {\n          return \"number\" == typeof e ? r.Buffer ? r._Buffer_allocUnsafe(e) : new r.Array(e) : r.Buffer ? r._Buffer_from(e) : \"undefined\" == typeof Uint8Array ? e : new Uint8Array(e);\n        }, r.Array = \"undefined\" != typeof Uint8Array ? Uint8Array : Array, r.Long = r.global.dcodeIO && r.global.dcodeIO.Long || r.global.Long || r.inquire(\"long\"), r.key2Re = /^true|false|0|1$/, r.key32Re = /^-?(?:0|[1-9][0-9]*)$/, r.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, r.longToHash = function (e) {\n          return e ? r.LongBits.from(e).toHash() : r.LongBits.zeroHash;\n        }, r.longFromHash = function (e, t) {\n          var n = r.LongBits.fromHash(e);\n          return r.Long ? r.Long.fromBits(n.lo, n.hi, t) : n.toNumber(Boolean(t));\n        }, r.merge = o, r.lcFirst = function (e) {\n          return e.charAt(0).toLowerCase() + e.substring(1);\n        }, r.newError = i, r.ProtocolError = i(\"ProtocolError\"), r.oneOfGetter = function (e) {\n          for (var t = {}, n = 0; n < e.length; ++n) t[e[n]] = 1;\n          return function () {\n            for (var e = Object.keys(this), n = e.length - 1; n > -1; --n) if (1 === t[e[n]] && void 0 !== this[e[n]] && null !== this[e[n]]) return e[n];\n          };\n        }, r.oneOfSetter = function (e) {\n          return function (t) {\n            for (var n = 0; n < e.length; ++n) e[n] !== t && delete this[e[n]];\n          };\n        }, r.toJSONOptions = {\n          longs: String,\n          enums: String,\n          bytes: String,\n          json: !0\n        }, r._configure = function () {\n          var e = r.Buffer;\n          e ? (r._Buffer_from = e.from !== Uint8Array.from && e.from || function (t, n) {\n            return new e(t, n);\n          }, r._Buffer_allocUnsafe = e.allocUnsafe || function (t) {\n            return new e(t);\n          }) : r._Buffer_from = r._Buffer_allocUnsafe = null;\n        };\n      },\n      1173: (e, t, n) => {\n        \"use strict\";\n\n        e.exports = p;\n        var r,\n          o = n(9693),\n          i = o.LongBits,\n          a = o.base64,\n          s = o.utf8;\n        function u(e, t, n) {\n          this.fn = e, this.len = t, this.next = void 0, this.val = n;\n        }\n        function l() {}\n        function c(e) {\n          this.head = e.head, this.tail = e.tail, this.len = e.len, this.next = e.states;\n        }\n        function p() {\n          this.len = 0, this.head = new u(l, 0, 0), this.tail = this.head, this.states = null;\n        }\n        var d = function () {\n          return o.Buffer ? function () {\n            return (p.create = function () {\n              return new r();\n            })();\n          } : function () {\n            return new p();\n          };\n        };\n        function f(e, t, n) {\n          t[n] = 255 & e;\n        }\n        function h(e, t) {\n          this.len = e, this.next = void 0, this.val = t;\n        }\n        function g(e, t, n) {\n          for (; e.hi;) t[n++] = 127 & e.lo | 128, e.lo = (e.lo >>> 7 | e.hi << 25) >>> 0, e.hi >>>= 7;\n          for (; e.lo > 127;) t[n++] = 127 & e.lo | 128, e.lo = e.lo >>> 7;\n          t[n++] = e.lo;\n        }\n        function b(e, t, n) {\n          t[n] = 255 & e, t[n + 1] = e >>> 8 & 255, t[n + 2] = e >>> 16 & 255, t[n + 3] = e >>> 24;\n        }\n        p.create = d(), p.alloc = function (e) {\n          return new o.Array(e);\n        }, o.Array !== Array && (p.alloc = o.pool(p.alloc, o.Array.prototype.subarray)), p.prototype._push = function (e, t, n) {\n          return this.tail = this.tail.next = new u(e, t, n), this.len += t, this;\n        }, h.prototype = Object.create(u.prototype), h.prototype.fn = function (e, t, n) {\n          for (; e > 127;) t[n++] = 127 & e | 128, e >>>= 7;\n          t[n] = e;\n        }, p.prototype.uint32 = function (e) {\n          return this.len += (this.tail = this.tail.next = new h((e >>>= 0) < 128 ? 1 : e < 16384 ? 2 : e < 2097152 ? 3 : e < 268435456 ? 4 : 5, e)).len, this;\n        }, p.prototype.int32 = function (e) {\n          return e < 0 ? this._push(g, 10, i.fromNumber(e)) : this.uint32(e);\n        }, p.prototype.sint32 = function (e) {\n          return this.uint32((e << 1 ^ e >> 31) >>> 0);\n        }, p.prototype.uint64 = function (e) {\n          var t = i.from(e);\n          return this._push(g, t.length(), t);\n        }, p.prototype.int64 = p.prototype.uint64, p.prototype.sint64 = function (e) {\n          var t = i.from(e).zzEncode();\n          return this._push(g, t.length(), t);\n        }, p.prototype.bool = function (e) {\n          return this._push(f, 1, e ? 1 : 0);\n        }, p.prototype.fixed32 = function (e) {\n          return this._push(b, 4, e >>> 0);\n        }, p.prototype.sfixed32 = p.prototype.fixed32, p.prototype.fixed64 = function (e) {\n          var t = i.from(e);\n          return this._push(b, 4, t.lo)._push(b, 4, t.hi);\n        }, p.prototype.sfixed64 = p.prototype.fixed64, p.prototype.float = function (e) {\n          return this._push(o.float.writeFloatLE, 4, e);\n        }, p.prototype.double = function (e) {\n          return this._push(o.float.writeDoubleLE, 8, e);\n        };\n        var m = o.Array.prototype.set ? function (e, t, n) {\n          t.set(e, n);\n        } : function (e, t, n) {\n          for (var r = 0; r < e.length; ++r) t[n + r] = e[r];\n        };\n        p.prototype.bytes = function (e) {\n          var t = e.length >>> 0;\n          if (!t) return this._push(f, 1, 0);\n          if (o.isString(e)) {\n            var n = p.alloc(t = a.length(e));\n            a.decode(e, n, 0), e = n;\n          }\n          return this.uint32(t)._push(m, t, e);\n        }, p.prototype.string = function (e) {\n          var t = s.length(e);\n          return t ? this.uint32(t)._push(s.write, t, e) : this._push(f, 1, 0);\n        }, p.prototype.fork = function () {\n          return this.states = new c(this), this.head = this.tail = new u(l, 0, 0), this.len = 0, this;\n        }, p.prototype.reset = function () {\n          return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new u(l, 0, 0), this.len = 0), this;\n        }, p.prototype.ldelim = function () {\n          var e = this.head,\n            t = this.tail,\n            n = this.len;\n          return this.reset().uint32(n), n && (this.tail.next = e.next, this.tail = t, this.len += n), this;\n        }, p.prototype.finish = function () {\n          for (var e = this.head.next, t = this.constructor.alloc(this.len), n = 0; e;) e.fn(e.val, t, n), n += e.len, e = e.next;\n          return t;\n        }, p._configure = function (e) {\n          r = e, p.create = d(), r._configure();\n        };\n      },\n      3155: (e, t, n) => {\n        \"use strict\";\n\n        e.exports = i;\n        var r = n(1173);\n        (i.prototype = Object.create(r.prototype)).constructor = i;\n        var o = n(9693);\n        function i() {\n          r.call(this);\n        }\n        function a(e, t, n) {\n          e.length < 40 ? o.utf8.write(e, t, n) : t.utf8Write ? t.utf8Write(e, n) : t.write(e, n);\n        }\n        i._configure = function () {\n          i.alloc = o._Buffer_allocUnsafe, i.writeBytesBuffer = o.Buffer && o.Buffer.prototype instanceof Uint8Array && \"set\" === o.Buffer.prototype.set.name ? function (e, t, n) {\n            t.set(e, n);\n          } : function (e, t, n) {\n            if (e.copy) e.copy(t, n, 0, e.length);else for (var r = 0; r < e.length;) t[n++] = e[r++];\n          };\n        }, i.prototype.bytes = function (e) {\n          o.isString(e) && (e = o._Buffer_from(e, \"base64\"));\n          var t = e.length >>> 0;\n          return this.uint32(t), t && this._push(i.writeBytesBuffer, t, e), this;\n        }, i.prototype.string = function (e) {\n          var t = o.Buffer.byteLength(e);\n          return this.uint32(t), t && this._push(a, t, e), this;\n        }, i._configure();\n      },\n      4154: e => {\n        \"use strict\";\n\n        e.exports = '\"use strict\";var e={},a=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node;if(a){var r=require(\"worker_threads\"),t=r.parentPort;t.on(\"message\",(e=>onmessage({data:e})));var s=require(\"fs\");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:e=>(0,eval)(s.readFileSync(e,\"utf8\")+\"//# sourceURL=\"+e),postMessage:e=>t.postMessage(e),performance:global.performance||{now:Date.now}})}var o=!1,d=function(){var e=Array.prototype.slice.call(arguments).join(\" \");a?s.writeSync(2,e+\"\\\\n\"):console.error(e)};self.alert=function(){var a=Array.prototype.slice.call(arguments).join(\" \");postMessage({cmd:\"alert\",text:a,threadId:e._pthread_self()})},e.instantiateWasm=(a,r)=>{var t=e.wasmModule;return e.wasmModule=null,r(new WebAssembly.Instance(t,a))},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=function a(r){try{if(\"load\"===r.data.cmd){let s=[];self.onmessage=e=>s.push(e),self.startWorker=r=>{e=r,postMessage({cmd:\"loaded\"});for(let e of s)a(e);self.onmessage=a},e.wasmModule=r.data.wasmModule;for(const a of r.data.handlers)e[a]=(...e)=>{postMessage({cmd:\"callHandler\",handler:a,args:e})};if(e.wasmMemory=r.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,\"string\"==typeof r.data.urlOrBlob)importScripts(r.data.urlOrBlob);else{var t=URL.createObjectURL(r.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(e)}else if(\"run\"===r.data.cmd){e.__emscripten_thread_init(r.data.pthread_ptr,0,0,1),e.__emscripten_thread_mailbox_await(r.data.pthread_ptr),e.establishStackSpace(),e.PThread.receiveObjectTransfer(r.data),e.PThread.threadInitTLS(),o||(o=!0);try{e.invokeEntryPoint(r.data.start_routine,r.data.arg)}catch(e){if(\"unwind\"!=e)throw e}}else\"cancel\"===r.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):\"setimmediate\"===r.data.target||(\"checkMailbox\"===r.data.cmd?o&&e.checkMailbox():r.data.cmd&&(d(\"worker.js received unknown command \"+r.data.cmd),d(r.data)))}catch(a){throw e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),a}};\\n';\n      },\n      7067: () => {},\n      1296: () => {},\n      760: () => {},\n      1384: () => {},\n      3993: () => {},\n      908: () => {},\n      6953: () => {},\n      9925: () => {},\n      2806: () => {},\n      6449: () => {},\n      2850: () => {},\n      5381: () => {},\n      685: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.resolveBackend = t.registerBackend = void 0;\n        const n = {},\n          r = [];\n        t.registerBackend = (e, t, o) => {\n          if (!t || \"function\" != typeof t.init || \"function\" != typeof t.createSessionHandler) throw new TypeError(\"not a valid backend\");\n          {\n            const i = n[e];\n            if (void 0 === i) n[e] = {\n              backend: t,\n              priority: o\n            };else {\n              if (i.priority > o) return;\n              if (i.priority === o && i.backend !== t) throw new Error(`cannot register backend \"${e}\" using priority ${o}`);\n            }\n            if (o >= 0) {\n              const t = r.indexOf(e);\n              -1 !== t && r.splice(t, 1);\n              for (let t = 0; t < r.length; t++) if (n[r[t]].priority <= o) return void r.splice(t, 0, e);\n              r.push(e);\n            }\n          }\n        }, t.resolveBackend = async e => {\n          const t = 0 === e.length ? r : e,\n            o = [];\n          for (const e of t) {\n            const t = n[e];\n            if (t) {\n              if (t.initialized) return t.backend;\n              if (t.aborted) continue;\n              const n = !!t.initPromise;\n              try {\n                return n || (t.initPromise = t.backend.init()), await t.initPromise, t.initialized = !0, t.backend;\n              } catch (r) {\n                n || o.push({\n                  name: e,\n                  err: r\n                }), t.aborted = !0;\n              } finally {\n                delete t.initPromise;\n              }\n            }\n          }\n          throw new Error(`no available backend found. ERR: ${o.map(e => `[${e.name}] ${e.err}`).join(\", \")}`);\n        };\n      },\n      4798: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.registerBackend = void 0;\n        var r = n(685);\n        Object.defineProperty(t, \"registerBackend\", {\n          enumerable: !0,\n          get: function () {\n            return r.registerBackend;\n          }\n        });\n      },\n      3121: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.env = void 0;\n        const r = n(9104);\n        let o = \"warning\";\n        t.env = {\n          wasm: {},\n          webgl: {},\n          webgpu: {},\n          versions: {\n            common: r.version\n          },\n          set logLevel(e) {\n            if (void 0 !== e) {\n              if (\"string\" != typeof e || -1 === [\"verbose\", \"info\", \"warning\", \"error\", \"fatal\"].indexOf(e)) throw new Error(`Unsupported logging level: ${e}`);\n              o = e;\n            }\n          },\n          get logLevel() {\n            return o;\n          }\n        }, Object.defineProperty(t.env, \"logLevel\", {\n          enumerable: !0\n        });\n      },\n      2457: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.env = void 0;\n        const r = n(3121);\n        t.env = r.env;\n      },\n      2235: function (e, t, n) {\n        \"use strict\";\n\n        var r = this && this.__createBinding || (Object.create ? function (e, t, n, r) {\n            void 0 === r && (r = n);\n            var o = Object.getOwnPropertyDescriptor(t, n);\n            o && !(\"get\" in o ? !t.__esModule : o.writable || o.configurable) || (o = {\n              enumerable: !0,\n              get: function () {\n                return t[n];\n              }\n            }), Object.defineProperty(e, r, o);\n          } : function (e, t, n, r) {\n            void 0 === r && (r = n), e[r] = t[n];\n          }),\n          o = this && this.__exportStar || function (e, t) {\n            for (var n in e) \"default\" === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n);\n          };\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), o(n(4798), t), o(n(2457), t), o(n(3974), t), o(n(963), t), o(n(7852), t);\n      },\n      8036: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.InferenceSession = void 0;\n        const r = n(685),\n          o = n(963);\n        class i {\n          constructor(e) {\n            this.handler = e;\n          }\n          async run(e, t, n) {\n            const r = {};\n            let i = {};\n            if (\"object\" != typeof e || null === e || e instanceof o.Tensor || Array.isArray(e)) throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");\n            let a = !0;\n            if (\"object\" == typeof t) {\n              if (null === t) throw new TypeError(\"Unexpected argument[1]: cannot be null.\");\n              if (t instanceof o.Tensor) throw new TypeError(\"'fetches' cannot be a Tensor\");\n              if (Array.isArray(t)) {\n                if (0 === t.length) throw new TypeError(\"'fetches' cannot be an empty array.\");\n                a = !1;\n                for (const e of t) {\n                  if (\"string\" != typeof e) throw new TypeError(\"'fetches' must be a string array or an object.\");\n                  if (-1 === this.outputNames.indexOf(e)) throw new RangeError(`'fetches' contains invalid output name: ${e}.`);\n                  r[e] = null;\n                }\n                if (\"object\" == typeof n && null !== n) i = n;else if (void 0 !== n) throw new TypeError(\"'options' must be an object.\");\n              } else {\n                let e = !1;\n                const s = Object.getOwnPropertyNames(t);\n                for (const n of this.outputNames) if (-1 !== s.indexOf(n)) {\n                  const i = t[n];\n                  (null === i || i instanceof o.Tensor) && (e = !0, a = !1, r[n] = i);\n                }\n                if (e) {\n                  if (\"object\" == typeof n && null !== n) i = n;else if (void 0 !== n) throw new TypeError(\"'options' must be an object.\");\n                } else i = t;\n              }\n            } else if (void 0 !== t) throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");\n            for (const t of this.inputNames) if (void 0 === e[t]) throw new Error(`input '${t}' is missing in 'feeds'.`);\n            if (a) for (const e of this.outputNames) r[e] = null;\n            const s = await this.handler.run(e, r, i),\n              u = {};\n            for (const e in s) Object.hasOwnProperty.call(s, e) && (u[e] = new o.Tensor(s[e].type, s[e].data, s[e].dims));\n            return u;\n          }\n          async release() {\n            return this.handler.dispose();\n          }\n          static async create(e, t, n, o) {\n            let a,\n              s = {};\n            if (\"string\" == typeof e) {\n              if (a = e, \"object\" == typeof t && null !== t) s = t;else if (void 0 !== t) throw new TypeError(\"'options' must be an object.\");\n            } else if (e instanceof Uint8Array) {\n              if (a = e, \"object\" == typeof t && null !== t) s = t;else if (void 0 !== t) throw new TypeError(\"'options' must be an object.\");\n            } else {\n              if (!(e instanceof ArrayBuffer || \"undefined\" != typeof SharedArrayBuffer && e instanceof SharedArrayBuffer)) throw new TypeError(\"Unexpected argument[0]: must be 'path' or 'buffer'.\");\n              {\n                const r = e;\n                let i = 0,\n                  u = e.byteLength;\n                if (\"object\" == typeof t && null !== t) s = t;else if (\"number\" == typeof t) {\n                  if (i = t, !Number.isSafeInteger(i)) throw new RangeError(\"'byteOffset' must be an integer.\");\n                  if (i < 0 || i >= r.byteLength) throw new RangeError(`'byteOffset' is out of range [0, ${r.byteLength}).`);\n                  if (u = e.byteLength - i, \"number\" == typeof n) {\n                    if (u = n, !Number.isSafeInteger(u)) throw new RangeError(\"'byteLength' must be an integer.\");\n                    if (u <= 0 || i + u > r.byteLength) throw new RangeError(`'byteLength' is out of range (0, ${r.byteLength - i}].`);\n                    if (\"object\" == typeof o && null !== o) s = o;else if (void 0 !== o) throw new TypeError(\"'options' must be an object.\");\n                  } else if (void 0 !== n) throw new TypeError(\"'byteLength' must be a number.\");\n                } else if (void 0 !== t) throw new TypeError(\"'options' must be an object.\");\n                a = new Uint8Array(r, i, u);\n              }\n            }\n            const u = (s.executionProviders || []).map(e => \"string\" == typeof e ? e : e.name),\n              l = await (0, r.resolveBackend)(u),\n              c = await l.createSessionHandler(a, s);\n            return new i(c);\n          }\n          startProfiling() {\n            this.handler.startProfiling();\n          }\n          endProfiling() {\n            this.handler.endProfiling();\n          }\n          get inputNames() {\n            return this.handler.inputNames;\n          }\n          get outputNames() {\n            return this.handler.outputNames;\n          }\n        }\n        t.InferenceSession = i;\n      },\n      3974: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.InferenceSession = void 0;\n        const r = n(8036);\n        t.InferenceSession = r.InferenceSession;\n      },\n      7852: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      },\n      2350: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.tensorToImageData = t.tensorToDataURL = void 0, t.tensorToDataURL = (e, t) => {\n          const n = document.createElement(\"canvas\");\n          n.width = e.dims[3], n.height = e.dims[2];\n          const r = n.getContext(\"2d\");\n          if (null != r) {\n            let o, i;\n            void 0 !== t?.tensorLayout && \"NHWC\" === t.tensorLayout ? (o = e.dims[2], i = e.dims[3]) : (o = e.dims[3], i = e.dims[2]);\n            const a = void 0 !== t?.format ? t.format : \"RGB\",\n              s = t?.norm;\n            let u, l;\n            void 0 === s || void 0 === s.mean ? u = [255, 255, 255, 255] : \"number\" == typeof s.mean ? u = [s.mean, s.mean, s.mean, s.mean] : (u = [s.mean[0], s.mean[1], s.mean[2], 0], void 0 !== s.mean[3] && (u[3] = s.mean[3])), void 0 === s || void 0 === s.bias ? l = [0, 0, 0, 0] : \"number\" == typeof s.bias ? l = [s.bias, s.bias, s.bias, s.bias] : (l = [s.bias[0], s.bias[1], s.bias[2], 0], void 0 !== s.bias[3] && (l[3] = s.bias[3]));\n            const c = i * o;\n            let p = 0,\n              d = c,\n              f = 2 * c,\n              h = -1;\n            \"RGBA\" === a ? (p = 0, d = c, f = 2 * c, h = 3 * c) : \"RGB\" === a ? (p = 0, d = c, f = 2 * c) : \"RBG\" === a && (p = 0, f = c, d = 2 * c);\n            for (let t = 0; t < i; t++) for (let n = 0; n < o; n++) {\n              const o = (e.data[p++] - l[0]) * u[0],\n                i = (e.data[d++] - l[1]) * u[1],\n                a = (e.data[f++] - l[2]) * u[2],\n                s = -1 === h ? 255 : (e.data[h++] - l[3]) * u[3];\n              r.fillStyle = \"rgba(\" + o + \",\" + i + \",\" + a + \",\" + s + \")\", r.fillRect(n, t, 1, 1);\n            }\n            return n.toDataURL();\n          }\n          throw new Error(\"Can not access image data\");\n        }, t.tensorToImageData = (e, t) => {\n          const n = document.createElement(\"canvas\").getContext(\"2d\");\n          let r;\n          if (null == n) throw new Error(\"Can not access image data\");\n          {\n            let o, i, a;\n            void 0 !== t?.tensorLayout && \"NHWC\" === t.tensorLayout ? (o = e.dims[2], i = e.dims[1], a = e.dims[3]) : (o = e.dims[3], i = e.dims[2], a = e.dims[1]);\n            const s = void 0 !== t && void 0 !== t.format ? t.format : \"RGB\",\n              u = t?.norm;\n            let l, c;\n            void 0 === u || void 0 === u.mean ? l = [255, 255, 255, 255] : \"number\" == typeof u.mean ? l = [u.mean, u.mean, u.mean, u.mean] : (l = [u.mean[0], u.mean[1], u.mean[2], 255], void 0 !== u.mean[3] && (l[3] = u.mean[3])), void 0 === u || void 0 === u.bias ? c = [0, 0, 0, 0] : \"number\" == typeof u.bias ? c = [u.bias, u.bias, u.bias, u.bias] : (c = [u.bias[0], u.bias[1], u.bias[2], 0], void 0 !== u.bias[3] && (c[3] = u.bias[3]));\n            const p = i * o;\n            if (void 0 !== t && (void 0 !== t.format && 4 === a && \"RGBA\" !== t.format || 3 === a && \"RGB\" !== t.format && \"BGR\" !== t.format)) throw new Error(\"Tensor format doesn't match input tensor dims\");\n            const d = 4;\n            let f = 0,\n              h = 1,\n              g = 2,\n              b = 3,\n              m = 0,\n              y = p,\n              v = 2 * p,\n              _ = -1;\n            \"RGBA\" === s ? (m = 0, y = p, v = 2 * p, _ = 3 * p) : \"RGB\" === s ? (m = 0, y = p, v = 2 * p) : \"RBG\" === s && (m = 0, v = p, y = 2 * p), r = n.createImageData(o, i);\n            for (let t = 0; t < i * o; f += d, h += d, g += d, b += d, t++) r.data[f] = (e.data[m++] - c[0]) * l[0], r.data[h] = (e.data[y++] - c[1]) * l[1], r.data[g] = (e.data[v++] - c[2]) * l[2], r.data[b] = -1 === _ ? 255 : (e.data[_++] - c[3]) * l[3];\n          }\n          return r;\n        };\n      },\n      4866: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.tensorFromImage = t.bufferToTensor = void 0;\n        const r = n(963);\n        t.bufferToTensor = (e, t) => {\n          if (void 0 === e) throw new Error(\"Image buffer must be defined\");\n          if (void 0 === t.height || void 0 === t.width) throw new Error(\"Image height and width must be defined\");\n          if (\"NHWC\" === t.tensorLayout) throw new Error(\"NHWC Tensor layout is not supported yet\");\n          const {\n              height: n,\n              width: o\n            } = t,\n            i = t.norm ?? {\n              mean: 255,\n              bias: 0\n            };\n          let a, s;\n          a = \"number\" == typeof i.mean ? [i.mean, i.mean, i.mean, i.mean] : [i.mean[0], i.mean[1], i.mean[2], i.mean[3] ?? 255], s = \"number\" == typeof i.bias ? [i.bias, i.bias, i.bias, i.bias] : [i.bias[0], i.bias[1], i.bias[2], i.bias[3] ?? 0];\n          const u = void 0 !== t.format ? t.format : \"RGBA\",\n            l = void 0 !== t.tensorFormat && void 0 !== t.tensorFormat ? t.tensorFormat : \"RGB\",\n            c = n * o,\n            p = \"RGBA\" === l ? new Float32Array(4 * c) : new Float32Array(3 * c);\n          let d = 4,\n            f = 0,\n            h = 1,\n            g = 2,\n            b = 3,\n            m = 0,\n            y = c,\n            v = 2 * c,\n            _ = -1;\n          \"RGB\" === u && (d = 3, f = 0, h = 1, g = 2, b = -1), \"RGBA\" === l ? _ = 3 * c : \"RBG\" === l ? (m = 0, v = c, y = 2 * c) : \"BGR\" === l && (v = 0, y = c, m = 2 * c);\n          for (let t = 0; t < c; t++, f += d, g += d, h += d, b += d) p[m++] = (e[f] + s[0]) / a[0], p[y++] = (e[h] + s[1]) / a[1], p[v++] = (e[g] + s[2]) / a[2], -1 !== _ && -1 !== b && (p[_++] = (e[b] + s[3]) / a[3]);\n          return \"RGBA\" === l ? new r.Tensor(\"float32\", p, [1, 4, n, o]) : new r.Tensor(\"float32\", p, [1, 3, n, o]);\n        }, t.tensorFromImage = async (e, n) => {\n          const r = \"undefined\" != typeof HTMLImageElement && e instanceof HTMLImageElement,\n            o = \"undefined\" != typeof ImageData && e instanceof ImageData,\n            i = \"undefined\" != typeof ImageBitmap && e instanceof ImageBitmap,\n            a = \"string\" == typeof e;\n          let s,\n            u = n ?? {};\n          if (r) {\n            const t = document.createElement(\"canvas\");\n            t.width = e.width, t.height = e.height;\n            const r = t.getContext(\"2d\");\n            if (null == r) throw new Error(\"Can not access image data\");\n            {\n              let t = e.height,\n                o = e.width;\n              if (void 0 !== n && void 0 !== n.resizedHeight && void 0 !== n.resizedWidth && (t = n.resizedHeight, o = n.resizedWidth), void 0 !== n) {\n                if (u = n, void 0 !== n.tensorFormat) throw new Error(\"Image input config format must be RGBA for HTMLImageElement\");\n                u.tensorFormat = \"RGBA\", u.height = t, u.width = o;\n              } else u.tensorFormat = \"RGBA\", u.height = t, u.width = o;\n              r.drawImage(e, 0, 0), s = r.getImageData(0, 0, o, t).data;\n            }\n          } else {\n            if (!o) {\n              if (i) {\n                if (void 0 === n) throw new Error(\"Please provide image config with format for Imagebitmap\");\n                const r = document.createElement(\"canvas\");\n                r.width = e.width, r.height = e.height;\n                const o = r.getContext(\"2d\");\n                if (null != o) {\n                  const n = e.height,\n                    r = e.width;\n                  return o.drawImage(e, 0, 0, r, n), s = o.getImageData(0, 0, r, n).data, u.height = n, u.width = r, (0, t.bufferToTensor)(s, u);\n                }\n                throw new Error(\"Can not access image data\");\n              }\n              if (a) return new Promise((n, r) => {\n                const o = document.createElement(\"canvas\"),\n                  i = o.getContext(\"2d\");\n                if (!e || !i) return r();\n                const a = new Image();\n                a.crossOrigin = \"Anonymous\", a.src = e, a.onload = () => {\n                  o.width = a.width, o.height = a.height, i.drawImage(a, 0, 0, o.width, o.height);\n                  const e = i.getImageData(0, 0, o.width, o.height);\n                  u.height = o.height, u.width = o.width, n((0, t.bufferToTensor)(e.data, u));\n                };\n              });\n              throw new Error(\"Input data provided is not supported - aborted tensor creation\");\n            }\n            {\n              let t, r;\n              if (void 0 !== n && void 0 !== n.resizedWidth && void 0 !== n.resizedHeight ? (t = n.resizedHeight, r = n.resizedWidth) : (t = e.height, r = e.width), void 0 !== n && (u = n), u.format = \"RGBA\", u.height = t, u.width = r, void 0 !== n) {\n                const n = document.createElement(\"canvas\");\n                n.width = r, n.height = t;\n                const o = n.getContext(\"2d\");\n                if (null == o) throw new Error(\"Can not access image data\");\n                o.putImageData(e, 0, 0), s = o.getImageData(0, 0, r, t).data;\n              } else s = e.data;\n            }\n          }\n          if (void 0 !== s) return (0, t.bufferToTensor)(s, u);\n          throw new Error(\"Input data provided is not supported - aborted tensor creation\");\n        };\n      },\n      5957: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Tensor = void 0;\n        const r = n(2350),\n          o = n(4866),\n          i = n(106),\n          a = new Map([[\"float32\", Float32Array], [\"uint8\", Uint8Array], [\"int8\", Int8Array], [\"uint16\", Uint16Array], [\"float16\", Uint16Array], [\"int16\", Int16Array], [\"int32\", Int32Array], [\"bool\", Uint8Array], [\"float64\", Float64Array], [\"uint32\", Uint32Array]]),\n          s = new Map([[Float32Array, \"float32\"], [Uint8Array, \"uint8\"], [Int8Array, \"int8\"], [Uint16Array, \"uint16\"], [Int16Array, \"int16\"], [Int32Array, \"int32\"], [Float64Array, \"float64\"], [Uint32Array, \"uint32\"]]);\n        let u = !1;\n        t.Tensor = class {\n          constructor(e, t, n) {\n            let r, o, l;\n            if ((() => {\n              if (!u) {\n                u = !0;\n                const e = \"undefined\" != typeof BigInt64Array && \"function\" == typeof BigInt64Array.from,\n                  t = \"undefined\" != typeof BigUint64Array && \"function\" == typeof BigUint64Array.from;\n                e && (a.set(\"int64\", BigInt64Array), s.set(BigInt64Array, \"int64\")), t && (a.set(\"uint64\", BigUint64Array), s.set(BigUint64Array, \"uint64\"));\n              }\n            })(), \"string\" == typeof e) {\n              if (r = e, l = n, \"string\" === e) {\n                if (!Array.isArray(t)) throw new TypeError(\"A string tensor's data must be a string array.\");\n                o = t;\n              } else {\n                const n = a.get(e);\n                if (void 0 === n) throw new TypeError(`Unsupported tensor type: ${e}.`);\n                if (Array.isArray(t)) {\n                  if (\"float16\" === e) throw new TypeError(\"Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.\");\n                  o = \"uint64\" === e || \"int64\" === e ? n.from(t, BigInt) : n.from(t);\n                } else {\n                  if (!(t instanceof n)) throw new TypeError(`A ${r} tensor's data must be type of ${n}`);\n                  o = t;\n                }\n              }\n            } else if (l = t, Array.isArray(e)) {\n              if (0 === e.length) throw new TypeError(\"Tensor type cannot be inferred from an empty array.\");\n              const t = typeof e[0];\n              if (\"string\" === t) r = \"string\", o = e;else {\n                if (\"boolean\" !== t) throw new TypeError(`Invalid element type of data array: ${t}.`);\n                r = \"bool\", o = Uint8Array.from(e);\n              }\n            } else {\n              const t = s.get(e.constructor);\n              if (void 0 === t) throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);\n              r = t, o = e;\n            }\n            if (void 0 === l) l = [o.length];else if (!Array.isArray(l)) throw new TypeError(\"A tensor's dims must be a number array\");\n            const c = (0, i.calculateSize)(l);\n            if (c !== o.length) throw new Error(`Tensor's size(${c}) does not match data length(${o.length}).`);\n            this.dims = l, this.type = r, this.data = o, this.size = c;\n          }\n          static async fromImage(e, t) {\n            return (0, o.tensorFromImage)(e, t);\n          }\n          toDataURL(e) {\n            return (0, r.tensorToDataURL)(this, e);\n          }\n          toImageData(e) {\n            return (0, r.tensorToImageData)(this, e);\n          }\n          reshape(e) {\n            return (0, i.tensorReshape)(this, e);\n          }\n        };\n      },\n      106: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.tensorReshape = t.calculateSize = void 0;\n        const r = n(963);\n        t.calculateSize = e => {\n          let t = 1;\n          for (let n = 0; n < e.length; n++) {\n            const r = e[n];\n            if (\"number\" != typeof r || !Number.isSafeInteger(r)) throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);\n            if (r < 0) throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);\n            t *= r;\n          }\n          return t;\n        }, t.tensorReshape = (e, t) => new r.Tensor(e.type, e.data, t);\n      },\n      963: (e, t, n) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.Tensor = void 0;\n        const r = n(5957);\n        t.Tensor = r.Tensor;\n      },\n      9104: (e, t) => {\n        \"use strict\";\n\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        }), t.version = void 0, t.version = \"1.16.3\";\n      },\n      1583: (e, t) => {\n        var n,\n          r = function (e) {\n            \"use strict\";\n\n            Object.defineProperty(e, \"__esModule\", {\n              value: !0\n            }), e.default = void 0;\n            var t = null;\n            try {\n              t = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;\n            } catch (e) {}\n            function n(e, t, n) {\n              this.low = 0 | e, this.high = 0 | t, this.unsigned = !!n;\n            }\n            function r(e) {\n              return !0 === (e && e.__isLong__);\n            }\n            function o(e) {\n              var t = Math.clz32(e & -e);\n              return e ? 31 - t : t;\n            }\n            n.prototype.__isLong__, Object.defineProperty(n.prototype, \"__isLong__\", {\n              value: !0\n            }), n.isLong = r;\n            var i = {},\n              a = {};\n            function s(e, t) {\n              var n, r, o;\n              return t ? (o = 0 <= (e >>>= 0) && e < 256) && (r = a[e]) ? r : (n = l(e, 0, !0), o && (a[e] = n), n) : (o = -128 <= (e |= 0) && e < 128) && (r = i[e]) ? r : (n = l(e, e < 0 ? -1 : 0, !1), o && (i[e] = n), n);\n            }\n            function u(e, t) {\n              if (isNaN(e)) return t ? y : m;\n              if (t) {\n                if (e < 0) return y;\n                if (e >= h) return x;\n              } else {\n                if (e <= -g) return O;\n                if (e + 1 >= g) return T;\n              }\n              return e < 0 ? u(-e, t).neg() : l(e % f | 0, e / f | 0, t);\n            }\n            function l(e, t, r) {\n              return new n(e, t, r);\n            }\n            n.fromInt = s, n.fromNumber = u, n.fromBits = l;\n            var c = Math.pow;\n            function p(e, t, n) {\n              if (0 === e.length) throw Error(\"empty string\");\n              if (\"number\" == typeof t ? (n = t, t = !1) : t = !!t, \"NaN\" === e || \"Infinity\" === e || \"+Infinity\" === e || \"-Infinity\" === e) return t ? y : m;\n              if ((n = n || 10) < 2 || 36 < n) throw RangeError(\"radix\");\n              var r;\n              if ((r = e.indexOf(\"-\")) > 0) throw Error(\"interior hyphen\");\n              if (0 === r) return p(e.substring(1), t, n).neg();\n              for (var o = u(c(n, 8)), i = m, a = 0; a < e.length; a += 8) {\n                var s = Math.min(8, e.length - a),\n                  l = parseInt(e.substring(a, a + s), n);\n                if (s < 8) {\n                  var d = u(c(n, s));\n                  i = i.mul(d).add(u(l));\n                } else i = (i = i.mul(o)).add(u(l));\n              }\n              return i.unsigned = t, i;\n            }\n            function d(e, t) {\n              return \"number\" == typeof e ? u(e, t) : \"string\" == typeof e ? p(e, t) : l(e.low, e.high, \"boolean\" == typeof t ? t : e.unsigned);\n            }\n            n.fromString = p, n.fromValue = d;\n            var f = 4294967296,\n              h = f * f,\n              g = h / 2,\n              b = s(1 << 24),\n              m = s(0);\n            n.ZERO = m;\n            var y = s(0, !0);\n            n.UZERO = y;\n            var v = s(1);\n            n.ONE = v;\n            var _ = s(1, !0);\n            n.UONE = _;\n            var w = s(-1);\n            n.NEG_ONE = w;\n            var T = l(-1, 2147483647, !1);\n            n.MAX_VALUE = T;\n            var x = l(-1, -1, !0);\n            n.MAX_UNSIGNED_VALUE = x;\n            var O = l(0, -2147483648, !1);\n            n.MIN_VALUE = O;\n            var S = n.prototype;\n            S.toInt = function () {\n              return this.unsigned ? this.low >>> 0 : this.low;\n            }, S.toNumber = function () {\n              return this.unsigned ? (this.high >>> 0) * f + (this.low >>> 0) : this.high * f + (this.low >>> 0);\n            }, S.toString = function (e) {\n              if ((e = e || 10) < 2 || 36 < e) throw RangeError(\"radix\");\n              if (this.isZero()) return \"0\";\n              if (this.isNegative()) {\n                if (this.eq(O)) {\n                  var t = u(e),\n                    n = this.div(t),\n                    r = n.mul(t).sub(this);\n                  return n.toString(e) + r.toInt().toString(e);\n                }\n                return \"-\" + this.neg().toString(e);\n              }\n              for (var o = u(c(e, 6), this.unsigned), i = this, a = \"\";;) {\n                var s = i.div(o),\n                  l = (i.sub(s.mul(o)).toInt() >>> 0).toString(e);\n                if ((i = s).isZero()) return l + a;\n                for (; l.length < 6;) l = \"0\" + l;\n                a = \"\" + l + a;\n              }\n            }, S.getHighBits = function () {\n              return this.high;\n            }, S.getHighBitsUnsigned = function () {\n              return this.high >>> 0;\n            }, S.getLowBits = function () {\n              return this.low;\n            }, S.getLowBitsUnsigned = function () {\n              return this.low >>> 0;\n            }, S.getNumBitsAbs = function () {\n              if (this.isNegative()) return this.eq(O) ? 64 : this.neg().getNumBitsAbs();\n              for (var e = 0 != this.high ? this.high : this.low, t = 31; t > 0 && 0 == (e & 1 << t); t--);\n              return 0 != this.high ? t + 33 : t + 1;\n            }, S.isZero = function () {\n              return 0 === this.high && 0 === this.low;\n            }, S.eqz = S.isZero, S.isNegative = function () {\n              return !this.unsigned && this.high < 0;\n            }, S.isPositive = function () {\n              return this.unsigned || this.high >= 0;\n            }, S.isOdd = function () {\n              return 1 == (1 & this.low);\n            }, S.isEven = function () {\n              return 0 == (1 & this.low);\n            }, S.equals = function (e) {\n              return r(e) || (e = d(e)), (this.unsigned === e.unsigned || this.high >>> 31 != 1 || e.high >>> 31 != 1) && this.high === e.high && this.low === e.low;\n            }, S.eq = S.equals, S.notEquals = function (e) {\n              return !this.eq(e);\n            }, S.neq = S.notEquals, S.ne = S.notEquals, S.lessThan = function (e) {\n              return this.comp(e) < 0;\n            }, S.lt = S.lessThan, S.lessThanOrEqual = function (e) {\n              return this.comp(e) <= 0;\n            }, S.lte = S.lessThanOrEqual, S.le = S.lessThanOrEqual, S.greaterThan = function (e) {\n              return this.comp(e) > 0;\n            }, S.gt = S.greaterThan, S.greaterThanOrEqual = function (e) {\n              return this.comp(e) >= 0;\n            }, S.gte = S.greaterThanOrEqual, S.ge = S.greaterThanOrEqual, S.compare = function (e) {\n              if (r(e) || (e = d(e)), this.eq(e)) return 0;\n              var t = this.isNegative(),\n                n = e.isNegative();\n              return t && !n ? -1 : !t && n ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1;\n            }, S.comp = S.compare, S.negate = function () {\n              return !this.unsigned && this.eq(O) ? O : this.not().add(v);\n            }, S.neg = S.negate, S.add = function (e) {\n              r(e) || (e = d(e));\n              var t = this.high >>> 16,\n                n = 65535 & this.high,\n                o = this.low >>> 16,\n                i = 65535 & this.low,\n                a = e.high >>> 16,\n                s = 65535 & e.high,\n                u = e.low >>> 16,\n                c = 0,\n                p = 0,\n                f = 0,\n                h = 0;\n              return f += (h += i + (65535 & e.low)) >>> 16, p += (f += o + u) >>> 16, c += (p += n + s) >>> 16, c += t + a, l((f &= 65535) << 16 | (h &= 65535), (c &= 65535) << 16 | (p &= 65535), this.unsigned);\n            }, S.subtract = function (e) {\n              return r(e) || (e = d(e)), this.add(e.neg());\n            }, S.sub = S.subtract, S.multiply = function (e) {\n              if (this.isZero()) return this;\n              if (r(e) || (e = d(e)), t) return l(t.mul(this.low, this.high, e.low, e.high), t.get_high(), this.unsigned);\n              if (e.isZero()) return this.unsigned ? y : m;\n              if (this.eq(O)) return e.isOdd() ? O : m;\n              if (e.eq(O)) return this.isOdd() ? O : m;\n              if (this.isNegative()) return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();\n              if (e.isNegative()) return this.mul(e.neg()).neg();\n              if (this.lt(b) && e.lt(b)) return u(this.toNumber() * e.toNumber(), this.unsigned);\n              var n = this.high >>> 16,\n                o = 65535 & this.high,\n                i = this.low >>> 16,\n                a = 65535 & this.low,\n                s = e.high >>> 16,\n                c = 65535 & e.high,\n                p = e.low >>> 16,\n                f = 65535 & e.low,\n                h = 0,\n                g = 0,\n                v = 0,\n                _ = 0;\n              return v += (_ += a * f) >>> 16, g += (v += i * f) >>> 16, v &= 65535, g += (v += a * p) >>> 16, h += (g += o * f) >>> 16, g &= 65535, h += (g += i * p) >>> 16, g &= 65535, h += (g += a * c) >>> 16, h += n * f + o * p + i * c + a * s, l((v &= 65535) << 16 | (_ &= 65535), (h &= 65535) << 16 | (g &= 65535), this.unsigned);\n            }, S.mul = S.multiply, S.divide = function (e) {\n              if (r(e) || (e = d(e)), e.isZero()) throw Error(\"division by zero\");\n              var n, o, i;\n              if (t) return this.unsigned || -2147483648 !== this.high || -1 !== e.low || -1 !== e.high ? l((this.unsigned ? t.div_u : t.div_s)(this.low, this.high, e.low, e.high), t.get_high(), this.unsigned) : this;\n              if (this.isZero()) return this.unsigned ? y : m;\n              if (this.unsigned) {\n                if (e.unsigned || (e = e.toUnsigned()), e.gt(this)) return y;\n                if (e.gt(this.shru(1))) return _;\n                i = y;\n              } else {\n                if (this.eq(O)) return e.eq(v) || e.eq(w) ? O : e.eq(O) ? v : (n = this.shr(1).div(e).shl(1)).eq(m) ? e.isNegative() ? v : w : (o = this.sub(e.mul(n)), i = n.add(o.div(e)));\n                if (e.eq(O)) return this.unsigned ? y : m;\n                if (this.isNegative()) return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();\n                if (e.isNegative()) return this.div(e.neg()).neg();\n                i = m;\n              }\n              for (o = this; o.gte(e);) {\n                n = Math.max(1, Math.floor(o.toNumber() / e.toNumber()));\n                for (var a = Math.ceil(Math.log(n) / Math.LN2), s = a <= 48 ? 1 : c(2, a - 48), p = u(n), f = p.mul(e); f.isNegative() || f.gt(o);) f = (p = u(n -= s, this.unsigned)).mul(e);\n                p.isZero() && (p = v), i = i.add(p), o = o.sub(f);\n              }\n              return i;\n            }, S.div = S.divide, S.modulo = function (e) {\n              return r(e) || (e = d(e)), t ? l((this.unsigned ? t.rem_u : t.rem_s)(this.low, this.high, e.low, e.high), t.get_high(), this.unsigned) : this.sub(this.div(e).mul(e));\n            }, S.mod = S.modulo, S.rem = S.modulo, S.not = function () {\n              return l(~this.low, ~this.high, this.unsigned);\n            }, S.countLeadingZeros = function () {\n              return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n            }, S.clz = S.countLeadingZeros, S.countTrailingZeros = function () {\n              return this.low ? o(this.low) : o(this.high) + 32;\n            }, S.ctz = S.countTrailingZeros, S.and = function (e) {\n              return r(e) || (e = d(e)), l(this.low & e.low, this.high & e.high, this.unsigned);\n            }, S.or = function (e) {\n              return r(e) || (e = d(e)), l(this.low | e.low, this.high | e.high, this.unsigned);\n            }, S.xor = function (e) {\n              return r(e) || (e = d(e)), l(this.low ^ e.low, this.high ^ e.high, this.unsigned);\n            }, S.shiftLeft = function (e) {\n              return r(e) && (e = e.toInt()), 0 == (e &= 63) ? this : e < 32 ? l(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : l(0, this.low << e - 32, this.unsigned);\n            }, S.shl = S.shiftLeft, S.shiftRight = function (e) {\n              return r(e) && (e = e.toInt()), 0 == (e &= 63) ? this : e < 32 ? l(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : l(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n            }, S.shr = S.shiftRight, S.shiftRightUnsigned = function (e) {\n              return r(e) && (e = e.toInt()), 0 == (e &= 63) ? this : e < 32 ? l(this.low >>> e | this.high << 32 - e, this.high >>> e, this.unsigned) : l(32 === e ? this.high : this.high >>> e - 32, 0, this.unsigned);\n            }, S.shru = S.shiftRightUnsigned, S.shr_u = S.shiftRightUnsigned, S.rotateLeft = function (e) {\n              var t;\n              return r(e) && (e = e.toInt()), 0 == (e &= 63) ? this : 32 === e ? l(this.high, this.low, this.unsigned) : e < 32 ? (t = 32 - e, l(this.low << e | this.high >>> t, this.high << e | this.low >>> t, this.unsigned)) : (t = 32 - (e -= 32), l(this.high << e | this.low >>> t, this.low << e | this.high >>> t, this.unsigned));\n            }, S.rotl = S.rotateLeft, S.rotateRight = function (e) {\n              var t;\n              return r(e) && (e = e.toInt()), 0 == (e &= 63) ? this : 32 === e ? l(this.high, this.low, this.unsigned) : e < 32 ? (t = 32 - e, l(this.high << t | this.low >>> e, this.low << t | this.high >>> e, this.unsigned)) : (t = 32 - (e -= 32), l(this.low << t | this.high >>> e, this.high << t | this.low >>> e, this.unsigned));\n            }, S.rotr = S.rotateRight, S.toSigned = function () {\n              return this.unsigned ? l(this.low, this.high, !1) : this;\n            }, S.toUnsigned = function () {\n              return this.unsigned ? this : l(this.low, this.high, !0);\n            }, S.toBytes = function (e) {\n              return e ? this.toBytesLE() : this.toBytesBE();\n            }, S.toBytesLE = function () {\n              var e = this.high,\n                t = this.low;\n              return [255 & t, t >>> 8 & 255, t >>> 16 & 255, t >>> 24, 255 & e, e >>> 8 & 255, e >>> 16 & 255, e >>> 24];\n            }, S.toBytesBE = function () {\n              var e = this.high,\n                t = this.low;\n              return [e >>> 24, e >>> 16 & 255, e >>> 8 & 255, 255 & e, t >>> 24, t >>> 16 & 255, t >>> 8 & 255, 255 & t];\n            }, n.fromBytes = function (e, t, r) {\n              return r ? n.fromBytesLE(e, t) : n.fromBytesBE(e, t);\n            }, n.fromBytesLE = function (e, t) {\n              return new n(e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24, e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24, t);\n            }, n.fromBytesBE = function (e, t) {\n              return new n(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7], e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3], t);\n            };\n            var A = n;\n            return e.default = A, \"default\" in e ? e.default : e;\n          }({});\n        void 0 === (n = function () {\n          return r;\n        }.apply(t, [])) || (e.exports = n);\n      },\n      5686: (e, t, n) => {\n        \"use strict\";\n\n        n.r(t), n.d(t, {\n          flatbuffers: () => r\n        });\n        var r = {};\n        r.Offset, r.Table, r.SIZEOF_SHORT = 2, r.SIZEOF_INT = 4, r.FILE_IDENTIFIER_LENGTH = 4, r.SIZE_PREFIX_LENGTH = 4, r.Encoding = {\n          UTF8_BYTES: 1,\n          UTF16_STRING: 2\n        }, r.int32 = new Int32Array(2), r.float32 = new Float32Array(r.int32.buffer), r.float64 = new Float64Array(r.int32.buffer), r.isLittleEndian = 1 === new Uint16Array(new Uint8Array([1, 0]).buffer)[0], r.Long = function (e, t) {\n          this.low = 0 | e, this.high = 0 | t;\n        }, r.Long.create = function (e, t) {\n          return 0 == e && 0 == t ? r.Long.ZERO : new r.Long(e, t);\n        }, r.Long.prototype.toFloat64 = function () {\n          return (this.low >>> 0) + 4294967296 * this.high;\n        }, r.Long.prototype.equals = function (e) {\n          return this.low == e.low && this.high == e.high;\n        }, r.Long.ZERO = new r.Long(0, 0), r.Builder = function (e) {\n          if (e) t = e;else var t = 1024;\n          this.bb = r.ByteBuffer.allocate(t), this.space = t, this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1;\n        }, r.Builder.prototype.clear = function () {\n          this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1;\n        }, r.Builder.prototype.forceDefaults = function (e) {\n          this.force_defaults = e;\n        }, r.Builder.prototype.dataBuffer = function () {\n          return this.bb;\n        }, r.Builder.prototype.asUint8Array = function () {\n          return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n        }, r.Builder.prototype.prep = function (e, t) {\n          e > this.minalign && (this.minalign = e);\n          for (var n = 1 + ~(this.bb.capacity() - this.space + t) & e - 1; this.space < n + e + t;) {\n            var o = this.bb.capacity();\n            this.bb = r.Builder.growByteBuffer(this.bb), this.space += this.bb.capacity() - o;\n          }\n          this.pad(n);\n        }, r.Builder.prototype.pad = function (e) {\n          for (var t = 0; t < e; t++) this.bb.writeInt8(--this.space, 0);\n        }, r.Builder.prototype.writeInt8 = function (e) {\n          this.bb.writeInt8(this.space -= 1, e);\n        }, r.Builder.prototype.writeInt16 = function (e) {\n          this.bb.writeInt16(this.space -= 2, e);\n        }, r.Builder.prototype.writeInt32 = function (e) {\n          this.bb.writeInt32(this.space -= 4, e);\n        }, r.Builder.prototype.writeInt64 = function (e) {\n          this.bb.writeInt64(this.space -= 8, e);\n        }, r.Builder.prototype.writeFloat32 = function (e) {\n          this.bb.writeFloat32(this.space -= 4, e);\n        }, r.Builder.prototype.writeFloat64 = function (e) {\n          this.bb.writeFloat64(this.space -= 8, e);\n        }, r.Builder.prototype.addInt8 = function (e) {\n          this.prep(1, 0), this.writeInt8(e);\n        }, r.Builder.prototype.addInt16 = function (e) {\n          this.prep(2, 0), this.writeInt16(e);\n        }, r.Builder.prototype.addInt32 = function (e) {\n          this.prep(4, 0), this.writeInt32(e);\n        }, r.Builder.prototype.addInt64 = function (e) {\n          this.prep(8, 0), this.writeInt64(e);\n        }, r.Builder.prototype.addFloat32 = function (e) {\n          this.prep(4, 0), this.writeFloat32(e);\n        }, r.Builder.prototype.addFloat64 = function (e) {\n          this.prep(8, 0), this.writeFloat64(e);\n        }, r.Builder.prototype.addFieldInt8 = function (e, t, n) {\n          (this.force_defaults || t != n) && (this.addInt8(t), this.slot(e));\n        }, r.Builder.prototype.addFieldInt16 = function (e, t, n) {\n          (this.force_defaults || t != n) && (this.addInt16(t), this.slot(e));\n        }, r.Builder.prototype.addFieldInt32 = function (e, t, n) {\n          (this.force_defaults || t != n) && (this.addInt32(t), this.slot(e));\n        }, r.Builder.prototype.addFieldInt64 = function (e, t, n) {\n          !this.force_defaults && t.equals(n) || (this.addInt64(t), this.slot(e));\n        }, r.Builder.prototype.addFieldFloat32 = function (e, t, n) {\n          (this.force_defaults || t != n) && (this.addFloat32(t), this.slot(e));\n        }, r.Builder.prototype.addFieldFloat64 = function (e, t, n) {\n          (this.force_defaults || t != n) && (this.addFloat64(t), this.slot(e));\n        }, r.Builder.prototype.addFieldOffset = function (e, t, n) {\n          (this.force_defaults || t != n) && (this.addOffset(t), this.slot(e));\n        }, r.Builder.prototype.addFieldStruct = function (e, t, n) {\n          t != n && (this.nested(t), this.slot(e));\n        }, r.Builder.prototype.nested = function (e) {\n          if (e != this.offset()) throw new Error(\"FlatBuffers: struct must be serialized inline.\");\n        }, r.Builder.prototype.notNested = function () {\n          if (this.isNested) throw new Error(\"FlatBuffers: object serialization must not be nested.\");\n        }, r.Builder.prototype.slot = function (e) {\n          this.vtable[e] = this.offset();\n        }, r.Builder.prototype.offset = function () {\n          return this.bb.capacity() - this.space;\n        }, r.Builder.growByteBuffer = function (e) {\n          var t = e.capacity();\n          if (3221225472 & t) throw new Error(\"FlatBuffers: cannot grow buffer beyond 2 gigabytes.\");\n          var n = t << 1,\n            o = r.ByteBuffer.allocate(n);\n          return o.setPosition(n - t), o.bytes().set(e.bytes(), n - t), o;\n        }, r.Builder.prototype.addOffset = function (e) {\n          this.prep(r.SIZEOF_INT, 0), this.writeInt32(this.offset() - e + r.SIZEOF_INT);\n        }, r.Builder.prototype.startObject = function (e) {\n          this.notNested(), null == this.vtable && (this.vtable = []), this.vtable_in_use = e;\n          for (var t = 0; t < e; t++) this.vtable[t] = 0;\n          this.isNested = !0, this.object_start = this.offset();\n        }, r.Builder.prototype.endObject = function () {\n          if (null == this.vtable || !this.isNested) throw new Error(\"FlatBuffers: endObject called without startObject\");\n          this.addInt32(0);\n          for (var e = this.offset(), t = this.vtable_in_use - 1; t >= 0 && 0 == this.vtable[t]; t--);\n          for (var n = t + 1; t >= 0; t--) this.addInt16(0 != this.vtable[t] ? e - this.vtable[t] : 0);\n          this.addInt16(e - this.object_start);\n          var o = (n + 2) * r.SIZEOF_SHORT;\n          this.addInt16(o);\n          var i = 0,\n            a = this.space;\n          e: for (t = 0; t < this.vtables.length; t++) {\n            var s = this.bb.capacity() - this.vtables[t];\n            if (o == this.bb.readInt16(s)) {\n              for (var u = r.SIZEOF_SHORT; u < o; u += r.SIZEOF_SHORT) if (this.bb.readInt16(a + u) != this.bb.readInt16(s + u)) continue e;\n              i = this.vtables[t];\n              break;\n            }\n          }\n          return i ? (this.space = this.bb.capacity() - e, this.bb.writeInt32(this.space, i - e)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - e, this.offset() - e)), this.isNested = !1, e;\n        }, r.Builder.prototype.finish = function (e, t, n) {\n          var o = n ? r.SIZE_PREFIX_LENGTH : 0;\n          if (t) {\n            var i = t;\n            if (this.prep(this.minalign, r.SIZEOF_INT + r.FILE_IDENTIFIER_LENGTH + o), i.length != r.FILE_IDENTIFIER_LENGTH) throw new Error(\"FlatBuffers: file identifier must be length \" + r.FILE_IDENTIFIER_LENGTH);\n            for (var a = r.FILE_IDENTIFIER_LENGTH - 1; a >= 0; a--) this.writeInt8(i.charCodeAt(a));\n          }\n          this.prep(this.minalign, r.SIZEOF_INT + o), this.addOffset(e), o && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);\n        }, r.Builder.prototype.finishSizePrefixed = function (e, t) {\n          this.finish(e, t, !0);\n        }, r.Builder.prototype.requiredField = function (e, t) {\n          var n = this.bb.capacity() - e,\n            r = n - this.bb.readInt32(n);\n          if (0 == this.bb.readInt16(r + t)) throw new Error(\"FlatBuffers: field \" + t + \" must be set\");\n        }, r.Builder.prototype.startVector = function (e, t, n) {\n          this.notNested(), this.vector_num_elems = t, this.prep(r.SIZEOF_INT, e * t), this.prep(n, e * t);\n        }, r.Builder.prototype.endVector = function () {\n          return this.writeInt32(this.vector_num_elems), this.offset();\n        }, r.Builder.prototype.createString = function (e) {\n          if (e instanceof Uint8Array) var t = e;else {\n            t = [];\n            for (var n = 0; n < e.length;) {\n              var r,\n                o = e.charCodeAt(n++);\n              (r = o < 55296 || o >= 56320 ? o : (o << 10) + e.charCodeAt(n++) + -56613888) < 128 ? t.push(r) : (r < 2048 ? t.push(r >> 6 & 31 | 192) : (r < 65536 ? t.push(r >> 12 & 15 | 224) : t.push(r >> 18 & 7 | 240, r >> 12 & 63 | 128), t.push(r >> 6 & 63 | 128)), t.push(63 & r | 128));\n            }\n          }\n          this.addInt8(0), this.startVector(1, t.length, 1), this.bb.setPosition(this.space -= t.length), n = 0;\n          for (var i = this.space, a = this.bb.bytes(); n < t.length; n++) a[i++] = t[n];\n          return this.endVector();\n        }, r.Builder.prototype.createLong = function (e, t) {\n          return r.Long.create(e, t);\n        }, r.ByteBuffer = function (e) {\n          this.bytes_ = e, this.position_ = 0;\n        }, r.ByteBuffer.allocate = function (e) {\n          return new r.ByteBuffer(new Uint8Array(e));\n        }, r.ByteBuffer.prototype.clear = function () {\n          this.position_ = 0;\n        }, r.ByteBuffer.prototype.bytes = function () {\n          return this.bytes_;\n        }, r.ByteBuffer.prototype.position = function () {\n          return this.position_;\n        }, r.ByteBuffer.prototype.setPosition = function (e) {\n          this.position_ = e;\n        }, r.ByteBuffer.prototype.capacity = function () {\n          return this.bytes_.length;\n        }, r.ByteBuffer.prototype.readInt8 = function (e) {\n          return this.readUint8(e) << 24 >> 24;\n        }, r.ByteBuffer.prototype.readUint8 = function (e) {\n          return this.bytes_[e];\n        }, r.ByteBuffer.prototype.readInt16 = function (e) {\n          return this.readUint16(e) << 16 >> 16;\n        }, r.ByteBuffer.prototype.readUint16 = function (e) {\n          return this.bytes_[e] | this.bytes_[e + 1] << 8;\n        }, r.ByteBuffer.prototype.readInt32 = function (e) {\n          return this.bytes_[e] | this.bytes_[e + 1] << 8 | this.bytes_[e + 2] << 16 | this.bytes_[e + 3] << 24;\n        }, r.ByteBuffer.prototype.readUint32 = function (e) {\n          return this.readInt32(e) >>> 0;\n        }, r.ByteBuffer.prototype.readInt64 = function (e) {\n          return new r.Long(this.readInt32(e), this.readInt32(e + 4));\n        }, r.ByteBuffer.prototype.readUint64 = function (e) {\n          return new r.Long(this.readUint32(e), this.readUint32(e + 4));\n        }, r.ByteBuffer.prototype.readFloat32 = function (e) {\n          return r.int32[0] = this.readInt32(e), r.float32[0];\n        }, r.ByteBuffer.prototype.readFloat64 = function (e) {\n          return r.int32[r.isLittleEndian ? 0 : 1] = this.readInt32(e), r.int32[r.isLittleEndian ? 1 : 0] = this.readInt32(e + 4), r.float64[0];\n        }, r.ByteBuffer.prototype.writeInt8 = function (e, t) {\n          this.bytes_[e] = t;\n        }, r.ByteBuffer.prototype.writeUint8 = function (e, t) {\n          this.bytes_[e] = t;\n        }, r.ByteBuffer.prototype.writeInt16 = function (e, t) {\n          this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8;\n        }, r.ByteBuffer.prototype.writeUint16 = function (e, t) {\n          this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8;\n        }, r.ByteBuffer.prototype.writeInt32 = function (e, t) {\n          this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8, this.bytes_[e + 2] = t >> 16, this.bytes_[e + 3] = t >> 24;\n        }, r.ByteBuffer.prototype.writeUint32 = function (e, t) {\n          this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8, this.bytes_[e + 2] = t >> 16, this.bytes_[e + 3] = t >> 24;\n        }, r.ByteBuffer.prototype.writeInt64 = function (e, t) {\n          this.writeInt32(e, t.low), this.writeInt32(e + 4, t.high);\n        }, r.ByteBuffer.prototype.writeUint64 = function (e, t) {\n          this.writeUint32(e, t.low), this.writeUint32(e + 4, t.high);\n        }, r.ByteBuffer.prototype.writeFloat32 = function (e, t) {\n          r.float32[0] = t, this.writeInt32(e, r.int32[0]);\n        }, r.ByteBuffer.prototype.writeFloat64 = function (e, t) {\n          r.float64[0] = t, this.writeInt32(e, r.int32[r.isLittleEndian ? 0 : 1]), this.writeInt32(e + 4, r.int32[r.isLittleEndian ? 1 : 0]);\n        }, r.ByteBuffer.prototype.getBufferIdentifier = function () {\n          if (this.bytes_.length < this.position_ + r.SIZEOF_INT + r.FILE_IDENTIFIER_LENGTH) throw new Error(\"FlatBuffers: ByteBuffer is too short to contain an identifier.\");\n          for (var e = \"\", t = 0; t < r.FILE_IDENTIFIER_LENGTH; t++) e += String.fromCharCode(this.readInt8(this.position_ + r.SIZEOF_INT + t));\n          return e;\n        }, r.ByteBuffer.prototype.__offset = function (e, t) {\n          var n = e - this.readInt32(e);\n          return t < this.readInt16(n) ? this.readInt16(n + t) : 0;\n        }, r.ByteBuffer.prototype.__union = function (e, t) {\n          return e.bb_pos = t + this.readInt32(t), e.bb = this, e;\n        }, r.ByteBuffer.prototype.__string = function (e, t) {\n          e += this.readInt32(e);\n          var n = this.readInt32(e),\n            o = \"\",\n            i = 0;\n          if (e += r.SIZEOF_INT, t === r.Encoding.UTF8_BYTES) return this.bytes_.subarray(e, e + n);\n          for (; i < n;) {\n            var a,\n              s = this.readUint8(e + i++);\n            if (s < 192) a = s;else {\n              var u = this.readUint8(e + i++);\n              if (s < 224) a = (31 & s) << 6 | 63 & u;else {\n                var l = this.readUint8(e + i++);\n                a = s < 240 ? (15 & s) << 12 | (63 & u) << 6 | 63 & l : (7 & s) << 18 | (63 & u) << 12 | (63 & l) << 6 | 63 & this.readUint8(e + i++);\n              }\n            }\n            a < 65536 ? o += String.fromCharCode(a) : (a -= 65536, o += String.fromCharCode(55296 + (a >> 10), 56320 + (1023 & a)));\n          }\n          return o;\n        }, r.ByteBuffer.prototype.__indirect = function (e) {\n          return e + this.readInt32(e);\n        }, r.ByteBuffer.prototype.__vector = function (e) {\n          return e + this.readInt32(e) + r.SIZEOF_INT;\n        }, r.ByteBuffer.prototype.__vector_len = function (e) {\n          return this.readInt32(e + this.readInt32(e));\n        }, r.ByteBuffer.prototype.__has_identifier = function (e) {\n          if (e.length != r.FILE_IDENTIFIER_LENGTH) throw new Error(\"FlatBuffers: file identifier must be length \" + r.FILE_IDENTIFIER_LENGTH);\n          for (var t = 0; t < r.FILE_IDENTIFIER_LENGTH; t++) if (e.charCodeAt(t) != this.readInt8(this.position_ + r.SIZEOF_INT + t)) return !1;\n          return !0;\n        }, r.ByteBuffer.prototype.createLong = function (e, t) {\n          return r.Long.create(e, t);\n        };\n      }\n    },\n    __webpack_module_cache__ = {};\n  function __webpack_require__(e) {\n    var t = __webpack_module_cache__[e];\n    if (void 0 !== t) return t.exports;\n    var n = __webpack_module_cache__[e] = {\n      exports: {}\n    };\n    return __webpack_modules__[e].call(n.exports, n, n.exports, __webpack_require__), n.exports;\n  }\n  __webpack_require__.n = e => {\n    var t = e && e.__esModule ? () => e.default : () => e;\n    return __webpack_require__.d(t, {\n      a: t\n    }), t;\n  }, __webpack_require__.d = (e, t) => {\n    for (var n in t) __webpack_require__.o(t, n) && !__webpack_require__.o(e, n) && Object.defineProperty(e, n, {\n      enumerable: !0,\n      get: t[n]\n    });\n  }, __webpack_require__.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), __webpack_require__.r = e => {\n    \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n      value: \"Module\"\n    }), Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n  };\n  var __webpack_exports__ = __webpack_require__(1057);\n  return __webpack_exports__;\n})());","map":{"version":3,"names":["e","t","exports","module","define","amd","ort","self","r","n","o","R","init","createSessionHandler","Session","loadModel","OnnxjsSessionHandler","i","a","rX","env","wasm","initTimeout","simd","proxy","numThreads","Number","isInteger","navigator","cpus","length","hardwareConcurrency","Math","min","ceil","c8","initializeWebAssemblyInstance","OnnxruntimeWebAssemblySessionHandler","Promise","resolve","registerBackend","versions","web","version","constructor","Object","assign","cacheKey","_cacheKey","getOwnPropertyNames","sort","map","join","createAttributeWithCacheKey","s","onnxruntime","experimental","fbs","u","_attributes","Map","onnx","AttributeProto","set","name","getValue","getType","Attribute","size","Error","delete","getFloat","get","getInt","getString","getTensor","getFloats","getInts","getStrings","getTensors","type","AttributeType","FLOAT","INT","STRING","TENSOR","FLOATS","INTS","STRINGS","TENSORS","GRAPH","GRAPHS","getValueNoCheck","LongUtil","isLong","longToNumber","Array","Tensor","fromProto","fromOrtTensor","decodeUtf8String","getValueNoCheckFromOnnxFormat","getValueNoCheckFromOrtFormat","f","g","floats","ints","strings","tensors","graphs","floatsArray","intsLength","push","stringsLength","tensorsLength","backend","initialize","dispose","webgl","WebGLBackend","resolveBackend","contextId","matmulMaxBatchSize","textureCacheMode","pack","async","glContext","createWebGLContext","Logger","setWithEnv","verbose","warning","WebGLSessionHandler","GlslLib","getFunctions","offsetToCoords","coordsToOffset","toVec","valueFrom","getCommonUtilFuncs","getInputsSamplingSnippets","getOutputSamplingSnippet","getCustomTypes","GlslLibRoutine","context","outputTextureLayout","isPacked","getPackedOutputSamplingSnippet","getUnpackedOutputSamplingSnippet","unpackedShape","width","height","getOutputScalarCoords","getOutputPacked1DCoords","getOutputPacked2DCoords","getOutputPacked3DCoords","getOutputPackedNDCoords","getGlsl","output","floatTextureSetRGBA","getOutputUnpacked1DCoords","getOutputUnpacked2DCoords","getOutputUnpacked3DCoords","getOutputUnpacked4DCoords","getOutputUnpacked5DCoords","getOutputUnpacked6DCoords","floatTextureSetR","ArrayUtil","arraysEqual","l","texture2D","programInfo","inputNames","forEach","inputTextureLayouts","generateShaderFuncNameFromInputSamplerName","getPackedSamplerFromInput","getUnpackedSamplerFromInput","generateShaderFuncNameFromInputSamplerNameAtOutCoords","getPackedSamplerAtOutputCoords","getUnpackedSamplerAtOutputCoords","c","p","d","BroadcastUtil","getBroadcastDims","h","getCoordsDataType","b","m","getGlChannels","y","v","_","ShapeUtil","w","indexOf","T","getPackedSamplerScalar","getPackedSampler1D","getPackedSampler2D","getPackedSampler3D","getPackedSamplerND","getUnpackedSamplerScalar","getUnpackedSampler1D","getUnpackedSampler2D","getUnpackedSampler3D","getUnpackedSampler4D","getUnpackedSampler5D","getUnpackedSampler6D","slice","squeezeInputShape","JSON","parse","stringify","routineBody","getSqueezedParams","dependencies","newShape","keptDims","squeezeShape","reverse","shape","strides","getValueFromSingle","getPackedValueFrom","CoordsGlslLib","FunctionType","ValueBased","Positional","GlslContext","GlslLibRoutineNode","addDependency","TopologicalSortGlslRoutines","returnOrderedNodes","Set","createOrderedNodes","dfsTraverse","has","add","encodeFloat32","decodeFloat32","encode","decode","encodeUint8","isLittleEndian","decodeUint8","ArrayBuffer","Uint32Array","Uint8Array","EncodingGlslLib","setFragColor","getColorAsFloat","FragColorGlslLib","replaceInlines","exec","split","trim","filter","params","body","replace","RegExp","GlslPreprocessor","libs","glslLibRoutineDependencyGraph","keys","glslRegistry","preprocess","shaderSource","hasMain","getDefaultFragShaderMain","getFragShaderPreamble","getUniforms","variables","getImports","selectGlslLibRoutinesToBeIncluded","arrayLength","encoding","fragcolor","vec","VecGlslLib","shapeUtils","ShapeUtilsGlslLib","coordinates","bcastIndex","bcastMatmulIndex","offsetToIndices","indicesToOffset","incrementIndices","indexToOffsetSingle","offsetToIndicesSingle","attribute","varyingVertex","varyingFrag","outputDeclaration","getVertexShaderSource","binaryVecFunctions","copyVec","setVecItem","getVecItem","sub","mul","div","WebGLInferenceHandler","session","packedTextureDataCache","unpackedTextureDataCache","calculateTextureWidthAndHeight","layoutStrategy","executeProgram","inputTypes","getOrCreateTextureData","cacheHint","programManager","getArtifact","createTextureLayoutFromTextureType","dims","textureType","createTextureData","build","setArtifact","runProgram","run","tensor","TextureType","packed","getTextureData","dataId","unpack","packedLastDimension","numberData","Float32Array","subarray","createTextureLayoutFromShape","reverseWH","createTextureDataFromLayoutBindTensor","textureManager","createTextureFromLayout","createTextureDataFromTexture","reshapeUnpacked","unpacked","channels","computeStrides","texture","reshapePacked","isReshapeCheap","processDims3D","createPackedReshape3DProgramInfoLoader","cast","readTexture","readTextureAsync","setTextureData","isInitializer","isTextureLayoutCached","clearActiveTextures","releaseTexture","isFloat32DownloadSupported","readUint8TextureAsFloat","encodeAsUint8","createPackProgramInfoLoader","createUnpackProgramInfoLoader","x","O","S","A","P","I","E","D","$","k","F","N","WEBGL_OP_RESOLVE_RULES","abs","acos","and","asin","atan","averagePool","parseAveragePoolAttributes","batchNormalization","parseBatchNormalizationAttributes","parseCastAttributes","clip","parseClipAttributes","clipV11","concat","parseConcatAttributes","conv","parseConvAttributes","convTranspose","parseConvTransposeAttributes","cos","identity","depthToSpace","parseDepthToSpaceAttributes","equal","elu","parseEluAttributes","exp","flatten","parseFlattenAttributes","floor","gather","parseGatherAttributes","gemm","parseGemmAttributesV7","parseGemmAttributesV11","globalAveragePool","parseGlobalAveragePoolAttributes","globalMaxPool","greater","imageScaler","parseImageScalerAttributes","instanceNormalization","parseInstanceNormalizationAttributes","leakyRelu","parseLeakyReluAttributes","less","lrn","parseLrnAttributes","log","matMul","parseMatMulAttributes","maxPool","parseMaxPoolAttributes","neg","not","or","padV2","parsePadAttributesV2","padV11","parsePadAttributesV11","pow","pRelu","reduceLogSum","parseReduceAttributes","reduceMax","reduceMean","reduceMin","reduceProd","reduceSum","reduceLogSumSquare","relu","reshape","resize","parseResizeAttributesV10","parseResizeAttributesV11","sigmoid","sin","sliceV10","parseSliceAttributes","softmax","parseSoftmaxAttributes","softmaxV13","parseSoftmaxAttributesV13","parseSplitAttributes","sqrt","squeeze","parseSqueezeAttributes","squeezeV13","sum","tan","tanh","tile","transpose","parseTransposeAttributes","upsample","parseUpsampleAttributesV7","parseUpsampleAttributesV9","unsqueeze","parseUnsqueezeAttributes","unsqueezeV13","xor","attributes","epsilon","momentum","spatial","createBatchNormalizationProgramInfo","glslAdd","glslDiv","glslMul","glslSub","glslEqual","glslGreater","glslLess","glslAnd","glslOr","glslXor","glslPow","glslPRelu","createBinaryProgramInfoLoader","createBinaryProgramInfo","areEqual","calcShape","ProtoUtil","tensorDataTypeFromProto","createPackedConcatProgramInfoLoader","from","fill","getChannels","unpackFromChannel","axis","getShiftedChannelsSnippet","createUnpackedConcatProgramInfoLoader","getFetchDataFromCorrectTextureMethod","createUnpackedGroupedConvProgramInfoLoader","group","autoPad","dilations","kernelShape","pads","calculateOutputShape","activationFunction","applyActivation","getActivationSnippet","conv2DPackedPointwise","createPackedMatmulProgramInfoLoader","conv2DPacked","createPackedIm2ColProgramInfoLoader","computeTotalPad","distributePadding","convTranspose2d","convTranspose2DUnpacked","outputShape","getAdjustedConvTransposeAttributes","outputPadding","parseInternalActivationAttributes","validateInputs","conv2d","conv2DUnpackedPointwise","createMatmulProgramInfoLoader","conv2DUnpacked","createIm2ColProgramInfoLoader","createDotProductProgramInfoLoader","getAdjustedConvAttributes","PoolConvUtil","adjustPadsBasedOnAutoPad","blocksize","mode","perm","TypeError","activationCacheKey","calculateIm2ColDims","flattenShape","activation","glslRelu","glslSigmoid","glslClip","clipMin","clipMax","MIN_CLIP","MAX_CLIP","createGatherProgramInfoLoader","normalizeAxis","NUMBER_TYPES","parseGemmAttributes","transA","transB","alpha","beta","isOptionalC","createGemmProgramInfoLoader","key","createGemmProgramInfo","GemmUtil","getShapeOfGemmResult","data","scale","bias","createImageScalerProgramInfoLoader","createComputeOutputProgramInfoLoader","createLrnProgramInfoLoader","getBiasForMatmul","createMatmulProgramMetadata","unpackedReversed","getVecChannels","value","generatePadAttributesFromInputs","integerData","floatData","createPadProgramInfo","padShape","getPadFunction","getPadConstant","getPadReflect","getPadEdge","ceilMode","countIncludePad","createAveragePoolProgramInfo","storageOrder","createMaxPoolProgramInfo","getAdjustedPoolAttributesAndOutputShape","hasOwnProperty","call","adjustPoolAttributes","computePoolOutputShape","generatePoolingCode","reduce","copyArray","axes","keepDims","createReduceProgramInfo","normalizeAxes","calculateReshapedDims","parseUpsampleAttributes","createPackedResizeProgramInfo","every","coordinateTransformMode","prepareInputs","scales","scalesInputIdx","sizesInputIdx","isResize","parseScalesData","scalesValidation","parseScalesDataFromOutputSize","Int32Array","starts","ends","createSliceProgramInfo","generateSliceAttributesFromInputs","some","sizeToDimension","sizeFromDimension","computeSoftmax","createComputeMaxProgramInfo","createComputScaleProgramInfo","createSoftMaxProgramInfo","outputs","numOutputs","getProgramCount","SplitUtil","splitShape","createSplitProgramInfo","createSumProgramInfo","createTileProgramInfo","createTransposeProgramInfo","getAdjustedPerm","getOutputShape","sortBasedOnPerm","getPermFunctionBody","downloadUint8AsFloat","glslAbs","glslAcos","glslAsin","glslAtan","glslCeil","glslCos","glslElu","glslExp","glslFloor","glslIdentity","glslLeakyRelu","glslLog","glslNeg","glslNot","glslSin","glslSqrt","glslTan","glslTanh","createElementwiseProgramInfoLoader","max","generateClipAttributesFromInputs","createUnpackProgramInfo","unsqueezeShape","inputs","opset","extrapolationValue","useExtrapolation","needRoiInput","nearestMode","cubicCoefficientA","excludeOutside","useNearest2xOptimization","roiInputIdx","createUpsampleProgramInfo","ProgramManager","profiler","textureLayoutStrategy","repo","attributesBound","event","gl","program","useProgram","bindOutput","bindAttributes","attribLocations","bindUniforms","uniformLocations","error","draw","vertexShader","deleteShader","deleteProgram","compile","getUniformLocations","getAttribLocations","compileShader","VERTEX_SHADER","debug","FRAGMENT_SHADER","createProgram","attachFramebuffer","position","textureCoord","setVertexAttributes","location","find","bindTexture","uniform1fv","uniform1f","uniform1iv","uniform1i","bindTextureToUniform","getAttribLocation","getUniformLocation","PreferLogicalStrategy","maxTextureSize","TextureManager","reuseTextures","pack2unpackMap","unpack2packMap","createInferenceHandler","onGraphInitialized","getValues","initializers","addInitializer","resolveOperator","impl","opImpl","opInit","RedFloat32DataEncoder","internalFormat","R32F","format","RED","channelSize","RGBA32F","RGBA","allocate","RGBAFloatDataEncoder","Uint8DataEncoder","ALPHA","UNSIGNED_BYTE","buffer","byteOffset","byteLength","isArray","assert","AlwaysKeepOriginalSizeStrategy","computeTextureWH","breakAxis","computeTexture","parseAxisParam","isInt","sizeFromShape","getRowsCols","sizeToSquarishShape","getBatchDim","reversedWH","config","pendingRead","inUseTextures","idleTextures","textureLookup","toEncoderType","getEncoder","pop","updateTexture","toTextureData","allocateTexture","toTensorData","createAndWaitForFence","splice","deleteTexture","Int16Array","Int8Array","Uint16Array","Float64Array","getPackedShape","repeatedTry","tryFn","setTimeout","charAt","toUpperCase","depth","antialias","stencil","preserveDrawingBuffer","premultipliedAlpha","failIfMajorPerformanceCaveat","getContext","WebGLContext","webgl2","OffscreenCanvas","document","createElement","isContextLost","disable","DEPTH_TEST","STENCIL_TEST","BLEND","DITHER","POLYGON_OFFSET_FILL","SAMPLE_COVERAGE","enable","SCISSOR_TEST","CULL_FACE","cullFace","BACK","createNewWebGLContext","linearSearchLastTrue","frameBufferBound","itemsToPoll","getExtensions","vertexbuffer","createVertexbuffer","framebuffer","createFramebuffer","queryVitalParameters","createTexture","TEXTURE_2D","texParameteri","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","texImage2D","checkError","texSubImage2D","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","viewport","scissor","readPixels","isFramebufferReady","getActiveTexture","getParameter","ACTIVE_TEXTURE","TEXTURE0","getTextureBinding","TEXTURE_BINDING_2D","getFramebufferBinding","FRAMEBUFFER_BINDING","vertexAttribPointer","enableVertexAttribArray","attachShader","linkProgram","createShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","activeTexture","drawArrays","TRIANGLE_STRIP","getError","NO_ERROR","INVALID_ENUM","INVALID_VALUE","INVALID_OPERATION","INVALID_FRAMEBUFFER_OPERATION","OUT_OF_MEMORY","CONTEXT_LOST_WEBGL","toString","isRenderFloat32Supported","textureHalfFloatExtension","HALF_FLOAT_OES","maxTextureImageUnits","disposed","deleteFramebuffer","bindBuffer","ARRAY_BUFFER","deleteBuffer","ELEMENT_ARRAY_BUFFER","finish","createDefaultGeometry","createBuffer","bufferData","STATIC_DRAW","isFloatTextureAttachableToFrameBuffer","checkFloatTextureAttachableToFrameBuffer","checkRenderFloat32","checkFloat32Download","isBlendSupported","checkFloat32Blend","MAX_TEXTURE_SIZE","MAX_TEXTURE_IMAGE_UNITS","colorBufferFloatExtension","getExtension","disjointTimerQueryWebgl2Extension","textureFloatExtension","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","POINTS","beginTimer","createQuery","beginQuery","TIME_ELAPSED_EXT","endTimer","endQuery","isTimerResultAvailable","getQueryParameter","QUERY_RESULT_AVAILABLE","GPU_DISJOINT_EXT","getTimerResult","QUERY_RESULT","deleteQuery","waitForQueryAndGetTime","createFence","pollFence","fenceSync","SYNC_GPU_COMMANDS_COMPLETE","flush","clientWaitSync","ALREADY_SIGNALED","CONDITION_SATISFIED","query","isFencePassed","addItemToPoll","pollItems","isDoneFn","resolveFn","op","node","ExecutionPlan","graph","getNodes","_ops","reset","_starter","_values","getInputIndices","execute","to","getOutputIndices","getData","Graph","_from","_to","tensorValueTypeFromProto","tensorType","NodeProto","opType","Node","tensorAttributesFromORTFormat","executeNode","buildGraph","transformGraph","checkIsAcyclic","_allInputIndices","getInputNames","_allInputNames","_allOutputIndices","getOutputNames","_allOutputNames","_allData","_nodes","GraphProto","buildGraphFromOnnxFormat","buildGraphFromOrtFormat","input","initializer","tensorDimsFromProto","dataType","inputsLength","nodeArgsLength","nodeArgs","valueType","TypeInfoValue","tensor_type","TensorTypeAndShape","elemType","dimLength","dim","dimValue","initializersLength","tensorDimsFromORTFormat","outputsLength","nodes","nodesLength","attributesLength","removeAllIdentityNodes","removeAllDropoutNodes","fuseConvActivationNodes","finalizeGraph","deleteNode","isActivation","info","fatal","none","console","color","provider","minimalSeverity","logDateTime","logSourceLocation","bind","Date","toISOString","logLevel","category","startTime","endCallback","timer","ctx","end","checkTimer","endTime","Profiler","create","maxNumberEvents","flushBatchSize","flushIntervalInMilliseconds","_started","_flushPointer","_maxNumberEvents","_flushBatchSize","_flushIntervalInMilliseconds","start","_timingEvents","_flushTime","now","stop","logOneEvent","begin","then","endSync","toFixed","started","performance","Model","load","loadFromOnnxFormat","loadFromOrtFormat","ModelProto","irVersion","_opsets","opsetImport","domain","_graph","flatbuffers","ByteBuffer","InferenceSession","getRootAsInferenceSession","model","opsetImportLength","opsets","INT_TYPES","FLOAT_TYPES","endsWith","parseInt","substring","isNaN","UNDEFINED","SPARSE_TENSOR","SPARSE_TENSORS","UNKNOWN","VALUE","PARAM","DimensionValueType","UINT8","INT8","UINT16","INT16","INT32","INT64","BOOL","FLOAT16","DOUBLE","UINT32","UINT64","COMPLEX64","COMPLEX128","BFLOAT16","FLOAT8E4M3FN","FLOAT8E4M3FNUZ","FLOAT8E5M2","FLOAT8E5M2FNUZ","TensorDataType","Primitive","Fused","NodeType","NONE","sequence_type","map_type","bb","bb_pos","__init","getRootAsShape","readInt32","getSizePrefixedRootAsShape","setPosition","SIZE_PREFIX_LENGTH","__offset","Dimension","__indirect","__vector","__vector_len","startShape","startObject","addDim","addFieldOffset","createDimVector","startVector","addOffset","endVector","startDimVector","endShape","endObject","createShape","Shape","getRootAsDimension","getSizePrefixedRootAsDimension","DimensionValue","denotation","__string","startDimension","addValue","addDenotation","endDimension","createDimension","getRootAsDimensionValue","getSizePrefixedRootAsDimensionValue","dimType","readInt8","readInt64","createLong","dimParam","startDimensionValue","addDimType","addFieldInt8","addDimValue","addFieldInt64","addDimParam","endDimensionValue","createDimensionValue","getRootAsTensorTypeAndShape","getSizePrefixedRootAsTensorTypeAndShape","startTensorTypeAndShape","addElemType","addFieldInt32","addShape","endTensorTypeAndShape","createTensorTypeAndShape","getRootAsMapType","getSizePrefixedRootAsMapType","keyType","TypeInfo","startMapType","addKeyType","addValueType","endMapType","createMapType","MapType","getRootAsSequenceType","getSizePrefixedRootAsSequenceType","startSequenceType","endSequenceType","createSequenceType","SequenceType","EdgeEnd","nodeIndex","readUint32","srcArgIndex","dstArgIndex","createEdgeEnd","prep","writeInt32","offset","getRootAsNodeEdge","getSizePrefixedRootAsNodeEdge","inputEdges","inputEdgesLength","outputEdges","outputEdgesLength","startNodeEdge","addNodeIndex","addInputEdges","startInputEdgesVector","addOutputEdges","startOutputEdgesVector","endNodeEdge","createNodeEdge","NodeEdge","getRootAsNode","getSizePrefixedRootAsNode","docString","sinceVersion","index","executionProviderType","inputArgCounts","inputArgCountsLength","inputArgCountsArray","bytes","implicitInputs","implicitInputsLength","startNode","addName","addDocString","addDomain","addSinceVersion","addIndex","addOpType","addType","addExecutionProviderType","addInputs","createInputsVector","startInputsVector","addOutputs","createOutputsVector","startOutputsVector","addAttributes","createAttributesVector","startAttributesVector","addInputArgCounts","createInputArgCountsVector","addInt32","startInputArgCountsVector","addImplicitInputs","createImplicitInputsVector","startImplicitInputsVector","endNode","createNode","getRootAsValueInfo","getSizePrefixedRootAsValueInfo","startValueInfo","endValueInfo","createValueInfo","ValueInfo","getRootAsTypeInfo","getSizePrefixedRootAsTypeInfo","readUint8","__union","startTypeInfo","endTypeInfo","createTypeInfo","getRootAsOperatorSetId","getSizePrefixedRootAsOperatorSetId","startOperatorSetId","addVersion","endOperatorSetId","createOperatorSetId","OperatorSetId","getRootAsTensor","getSizePrefixedRootAsTensor","dimsLength","rawData","rawDataLength","rawDataArray","stringData","stringDataLength","startTensor","addDims","createDimsVector","addInt64","startDimsVector","addDataType","addRawData","createRawDataVector","addInt8","startRawDataVector","addStringData","createStringDataVector","startStringDataVector","endTensor","createTensor","getRootAsSparseTensor","getSizePrefixedRootAsSparseTensor","values","indices","startSparseTensor","addValues","addIndices","endSparseTensor","createSparseTensor","SparseTensor","getRootAsAttribute","getSizePrefixedRootAsAttribute","readFloat32","floatsLength","graphsLength","startAttribute","addF","addFieldFloat32","addI","addS","addT","addG","addFloats","createFloatsVector","addFloat32","startFloatsVector","addInts","createIntsVector","startIntsVector","addStrings","createStringsVector","startStringsVector","addTensors","createTensorsVector","startTensorsVector","addGraphs","createGraphsVector","startGraphsVector","endAttribute","createAttribute","getRootAsGraph","getSizePrefixedRootAsGraph","maxNodeIndex","nodeEdges","nodeEdgesLength","sparseInitializers","sparseInitializersLength","startGraph","addInitializers","createInitializersVector","startInitializersVector","addNodeArgs","createNodeArgsVector","startNodeArgsVector","addNodes","createNodesVector","startNodesVector","addMaxNodeIndex","addNodeEdges","createNodeEdgesVector","startNodeEdgesVector","addSparseInitializers","createSparseInitializersVector","startSparseInitializersVector","endGraph","createGraph","getRootAsModel","getSizePrefixedRootAsModel","producerName","producerVersion","modelVersion","graphDocString","startModel","addIrVersion","addOpsetImport","createOpsetImportVector","startOpsetImportVector","addProducerName","addProducerVersion","addModelVersion","addGraph","addGraphDocString","endModel","createModel","getRootAsKernelCreateInfos","getSizePrefixedRootAsKernelCreateInfos","nodeIndices","nodeIndicesLength","nodeIndicesArray","kernelDefHashes","readUint64","kernelDefHashesLength","startKernelCreateInfos","addNodeIndices","createNodeIndicesVector","startNodeIndicesVector","addKernelDefHashes","createKernelDefHashesVector","startKernelDefHashesVector","endKernelCreateInfos","createKernelCreateInfos","KernelCreateInfos","getRootAsSubGraphSessionState","getSizePrefixedRootAsSubGraphSessionState","graphId","sessionState","SessionState","startSubGraphSessionState","addGraphId","addSessionState","endSubGraphSessionState","requiredField","createSubGraphSessionState","SubGraphSessionState","getRootAsSessionState","getSizePrefixedRootAsSessionState","kernels","subGraphSessionStates","subGraphSessionStatesLength","startSessionState","addKernels","addSubGraphSessionStates","createSubGraphSessionStatesVector","startSubGraphSessionStatesVector","endSessionState","createSessionState","getSizePrefixedRootAsInferenceSession","bufferHasIdentifier","__has_identifier","ortVersion","startInferenceSession","addOrtVersion","addModel","endInferenceSession","finishInferenceSessionBuffer","finishSizePrefixedInferenceSessionBuffer","createInferenceSession","outputNames","startProfiling","endProfiling","_initialized","backendHint","graphInputTypes","graphInputDims","_model","sessionHandler","process","promisify","readFile","fetch","arrayBuffer","isView","initializeOps","_executionPlan","normalizeAndValidateInputs","createOutput","validateInputTensorDims","validateInputTensorTypes","compareTensorDims","cache","dataProvider","asyncDataProvider","_strides","Guid","validateDimsAndCalcSize","RangeError","DataView","TensorProto","DataType","int32Data","int64Data","doubleData","uint64Data","default","fromData","BigInt64Array","greaterThanOrEqual","lessThan","toNumber","getUint8","getInt8","getUint16","getInt16","getFloat32","getInt32","getUint32","fromBits","getFloat64","checkInputsShape","preprocessInputShapes","postprocessOutputShape","calcMatMulShape","MatMulUtil","fillIndex","calc","isValidBroadcast","unshift","arrayCopyHelper","tensorDataTypeStringToEnum","Long","fromValue","low","high","unsigned","getSizeFromDimensionRange","incrementIndex","MathUtil","sqr","axpy","powx","determineSplit","calcReduce","calcReduceShape","calcReduceByAxis","ReduceUtil","adjustPadAndReturnShape","computeShapeHelper","computeConvOutputShape","TextDecoder","isProxy","ensureWorker","err","shift","out","currentScript","src","wasmPaths","substr","lastIndexOf","terminate","Z","onmessage","in","postMessage","initializeWebAssembly","initializeRuntime","initRuntime","createSessionAllocate","createSessionFinalize","modeldata","options","createSession","releaseSession","sessionId","inputIndices","outputIndices","extractTransferableBuffers","setRunOptions","getInstance","logSeverityLevel","logVerbosityLevel","tag","allocWasmString","_OrtCreateRunOptions","checkLastError","extra","iterateExtraOptions","WeakSet","_OrtAddRunConfigEntry","_OrtReleaseRunOptions","_free","status","entries","setSessionOptions","use_ort_model_bytes_directly","executionProviders","enableMemPattern","graphOptimizationLevel","executionMode","logId","optimizedModelFilePath","_OrtCreateSessionOptions","enableCpuMemArena","enableProfiling","deviceType","_OrtAddSessionConfigEntry","powerPreference","_OrtAppendExecutionProvider","_OrtReleaseSessionOptions","tensorDataTypeEnumToString","getTensorElementSize","tensorTypeToTypedArrayConstructor","BigUint64Array","logLevelStringToEnum","_OrtInit","_malloc","HEAPU8","_OrtCreateSession","stackSave","stackAlloc","_OrtGetInputOutputCount","HEAP32","stackRestore","_OrtGetInputName","UTF8ToString","_OrtGetOutputName","_OrtFree","_OrtReleaseSession","HEAPU32","_OrtCreateTensor","_OrtRun","jsepRunPromise","_OrtGetTensorData","_OrtReleaseTensor","_OrtEndProfiling","SharedArrayBuffer","MessageChannel","port1","WebAssembly","validate","locateFile","Blob","URL","createObjectURL","mainScriptUrlOrBlob","__dirname","race","PThread","terminateAllThreads","lengthBytesUTF8","stringToUTF8","_OrtGetLastError","window","BlobBuilder","WebKitBlobBuilder","MozBlobBuilder","MSBlobBuilder","append","getBlob","webkitURL","revokeObjectURL","encodeURIComponent","Reader","Writer","util","roots","Version","sparseTensors","typeProtos","prototype","refAttrName","newBuffer","sparseTensor","tp","emptyArray","uint32","string","float","int64","fork","ldelim","TypeProto","int32","SparseTensorProto","encodeDelimited","len","pos","skipType","decodeDelimited","verify","isString","fromObject","String","LongBits","base64","toObject","arrays","defaults","longs","enums","json","isFinite","toJSON","toJSONOptions","getTypeUrl","ValueInfoProto","TrainingInfoProto","initializationBinding","updateBinding","initialization","algorithm","StringStringEntryProto","metadataProps","trainingInfo","functions","OperatorSetIdProto","FunctionProto","TensorAnnotation","quantParameterTensorNames","tensorName","sparseInitializer","valueInfo","quantizationAnnotation","externalData","segment","dataLocation","Segment","double","uint64","DataLocation","TensorShapeProto","defineProperty","oneOfGetter","oneOfSetter","oneofs","sequenceType","mapType","optionalType","sparseTensorType","Sequence","Optional","OperatorStatus","attributeProto","_scriptDir","__filename","U","L","C","j","ready","importScripts","ENVIRONMENT_IS_PTHREAD","dirname","startsWith","normalize","readFileSync","thisProgram","argv","exitCode","inspect","global","Worker","href","XMLHttpRequest","open","send","responseText","responseType","response","onload","onerror","M","writeSync","print","printErr","quit","wasmBinary","noExitRuntime","te","HEAP8","HEAP16","HEAPU16","HEAPF32","HEAPF64","B","INITIAL_MEMORY","wasmMemory","Memory","initial","maximum","shared","V","z","G","H","W","q","X","Y","K","J","Q","monitorRunDependencies","ee","clearInterval","onAbort","RuntimeError","ne","re","oe","credentials","ok","catch","instantiate","ie","message","ae","se","he","Fa","fb","ue","Za","Ia","Ha","cmd","start_routine","gb","arg","Ya","pthread_ptr","unref","mb","le","ce","fe","fromCharCode","pe","de","qe","hb","onExit","be","La","Ta","Pa","ab","$a","receiveObjectTransfer","eb","threadInitTLS","Sa","setExitStatus","Ra","rb","mt","cb","targetThread","dt","qb","transferList","Me","thread","loaded","alert","threadId","text","target","handler","args","filename","lineno","on","handlers","urlOrBlob","wasmModule","Xa","ge","establishStackSpace","wt","xt","me","ye","Oa","Wa","Va","Ua","ve","_e","ob","we","Te","invokeEntryPoint","yt","xe","charCodeAt","Oe","Se","Ae","Pe","Ie","Ee","De","$e","ke","Fe","Ne","Re","Le","Ce","je","Atomics","nb","store","vt","__emscripten_thread_mailbox_await","checkMailbox","Ue","Be","Ve","ze","Ge","He","ft","We","Tt","arguments","Ot","bt","Xe","Ye","Ke","Je","USER","LOGNAME","PATH","PWD","HOME","LANG","languages","Ze","Qe","et","tt","nt","rt","ot","it","crypto","getRandomValues","randomFillSync","randomBytes","at","st","ut","lt","getFullYear","getMonth","getDate","getDay","Ja","Ka","getTime","setDate","setMonth","setFullYear","kb","jb","Ma","Qa","Na","Ga","sb","ib","lb","%n","%t","%%","includes","ct","pt","ht","ref","NaN","getUTCSeconds","getUTCMinutes","getUTCHours","getUTCDate","getUTCMonth","getUTCFullYear","getUTCDay","UTC","getSeconds","getMinutes","getHours","getTimezoneOffset","setTime","getYear","_t","toTimeString","match","timeOrigin","pb","apply","grow","__errno_location","pthread_self","malloc","sa","ta","instantiateWasm","instantiateStreaming","instance","aa","ba","ca","da","ea","fa","ga","ha","ia","ja","ka","la","ma","na","oa","_pthread_self","pa","qa","ra","__emscripten_tls_init","__emscripten_thread_init","ua","__emscripten_thread_crashed","va","gt","wa","xa","__emscripten_thread_exit","ya","__emscripten_check_mailbox","za","Aa","Ba","Ca","Da","Ea","St","calledRun","onRuntimeInitialized","postRun","startWorker","preRun","setStatus","keepRuntimeAlive","ExitStatus","preInit","copyWithin","test","_listeners","fn","off","emit","writeFloatLE","writeFloatBE","readFloatLE","readFloatBE","round","LN2","writeDoubleLE","writeDoubleBE","readDoubleLE","readDoubleBE","inquire","moduleName","mod","eval","read","write","__esModule","EMPTY","isGuid","validator","gen","createEmpty","raw","random","equals","isEmpty","_configure","BufferWriter","BufferReader","rpc","configure","utf8","buf","Buffer","isBuffer","lo","hi","_slice","sint32","bool","fixed32","sfixed32","skip","merge","sint64","zzDecode","fixed64","sfixed64","utf8Slice","Service","EventEmitter","rpcImpl","requestDelimited","Boolean","responseDelimited","rpcCall","asPromise","zero","zzEncode","zeroHash","fromNumber","fromString","toLong","fromHash","toHash","captureStackTrace","stack","writable","enumerable","configurable","pool","isNode","freeze","emptyObject","isObject","isset","isSet","utf8Write","_Buffer_from","_Buffer_allocUnsafe","dcodeIO","key2Re","key32Re","key64Re","longToHash","longFromHash","lcFirst","toLowerCase","newError","ProtocolError","allocUnsafe","next","val","head","tail","states","alloc","_push","writeBytesBuffer","copy","priority","initialized","aborted","initPromise","webgpu","common","__createBinding","getOwnPropertyDescriptor","__exportStar","release","isSafeInteger","tensorToImageData","tensorToDataURL","tensorLayout","norm","mean","fillStyle","fillRect","toDataURL","createImageData","tensorFromImage","bufferToTensor","tensorFormat","HTMLImageElement","ImageData","ImageBitmap","resizedHeight","resizedWidth","drawImage","getImageData","Image","crossOrigin","putImageData","BigInt","calculateSize","fromImage","toImageData","tensorReshape","Instance","Module","__isLong__","clz32","fromInt","ZERO","UZERO","ONE","UONE","NEG_ONE","MAX_VALUE","MAX_UNSIGNED_VALUE","MIN_VALUE","toInt","isZero","isNegative","eq","getHighBits","getHighBitsUnsigned","getLowBits","getLowBitsUnsigned","getNumBitsAbs","eqz","isPositive","isOdd","isEven","notEquals","neq","comp","lessThanOrEqual","lte","greaterThan","gte","compare","negate","subtract","multiply","get_high","divide","div_u","div_s","toUnsigned","shru","shr","shl","modulo","rem_u","rem_s","rem","countLeadingZeros","clz","countTrailingZeros","ctz","shiftLeft","shiftRight","shiftRightUnsigned","shr_u","rotateLeft","rotl","rotateRight","rotr","toSigned","toBytes","toBytesLE","toBytesBE","fromBytes","fromBytesLE","fromBytesBE","Offset","Table","SIZEOF_SHORT","SIZEOF_INT","FILE_IDENTIFIER_LENGTH","Encoding","UTF8_BYTES","UTF16_STRING","float32","float64","toFloat64","Builder","space","minalign","vtable","vtable_in_use","isNested","object_start","vtables","vector_num_elems","force_defaults","clear","capacity","forceDefaults","dataBuffer","asUint8Array","growByteBuffer","pad","writeInt8","writeInt16","writeInt64","writeFloat32","writeFloat64","addInt16","addFloat64","slot","addFieldInt16","addFieldFloat64","addFieldStruct","nested","notNested","readInt16","finishSizePrefixed","createString","bytes_","position_","readUint16","readFloat64","writeUint8","writeUint16","writeUint32","writeUint64","getBufferIdentifier","__webpack_module_cache__","__webpack_require__","__webpack_modules__","Symbol","toStringTag","__webpack_exports__"],"sources":["webpack://ort/webpack/universalModuleDefinition","webpack://ort/lib/backend-onnxjs.ts","webpack://ort/lib/backend-wasm.ts","webpack://ort/lib/index.ts","webpack://ort/lib/onnxjs/attribute-with-cache-key.ts","webpack://ort/lib/onnxjs/attribute.ts","webpack://ort/lib/onnxjs/backend.ts","webpack://ort/lib/onnxjs/backends/backend-webgl.ts","webpack://ort/lib/onnxjs/backends/webgl/glsl-coordinate-lib.ts","webpack://ort/lib/onnxjs/backends/webgl/glsl-definitions.ts","webpack://ort/lib/onnxjs/backends/webgl/glsl-encoding-lib.ts","webpack://ort/lib/onnxjs/backends/webgl/glsl-fragcolor-lib.ts","webpack://ort/lib/onnxjs/backends/webgl/glsl-function-inliner.ts","webpack://ort/lib/onnxjs/backends/webgl/glsl-preprocessor.ts","webpack://ort/lib/onnxjs/backends/webgl/glsl-registered-libs.ts","webpack://ort/lib/onnxjs/backends/webgl/glsl-shape-utils-lib.ts","webpack://ort/lib/onnxjs/backends/webgl/glsl-source.ts","webpack://ort/lib/onnxjs/backends/webgl/glsl-vec-lib.ts","webpack://ort/lib/onnxjs/backends/webgl/inference-handler.ts","webpack://ort/lib/onnxjs/backends/webgl/op-resolve-rules.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/batch-normalization.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/binary-op.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/cast.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/concat-packed.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/concat.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/conv-grouped.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/conv-pack.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/conv-transpose.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/conv.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/depth-to-space.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/dot-product.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/flatten.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/fuse-utils.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/gather.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/gemm.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/im2col-pack.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/im2col.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/image-scaler.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/instance-normalization.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/lrn.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/matmul-pack.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/matmul.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/pack.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/packing-utils.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/pad.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/pool.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/reduce.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/reshape-packed.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/reshape.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/resize-packed.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/shape.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/slice.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/softmax.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/split.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/squeeze.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/sum.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/tile.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/transpose.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/uint8-encode.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/unary-op.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/unpack.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/unsqueeze.ts","webpack://ort/lib/onnxjs/backends/webgl/ops/upsample.ts","webpack://ort/lib/onnxjs/backends/webgl/program-manager.ts","webpack://ort/lib/onnxjs/backends/webgl/session-handler.ts","webpack://ort/lib/onnxjs/backends/webgl/texture-data-encoder.ts","webpack://ort/lib/onnxjs/backends/webgl/texture-layout-strategy.ts","webpack://ort/lib/onnxjs/backends/webgl/texture-layout.ts","webpack://ort/lib/onnxjs/backends/webgl/texture-manager.ts","webpack://ort/lib/onnxjs/backends/webgl/types.ts","webpack://ort/lib/onnxjs/backends/webgl/utils.ts","webpack://ort/lib/onnxjs/backends/webgl/webgl-context-factory.ts","webpack://ort/lib/onnxjs/backends/webgl/webgl-context.ts","webpack://ort/lib/onnxjs/execution-plan.ts","webpack://ort/lib/onnxjs/graph.ts","webpack://ort/lib/onnxjs/instrument.ts","webpack://ort/lib/onnxjs/model.ts","webpack://ort/lib/onnxjs/operators.ts","webpack://ort/lib/onnxjs/opset.ts","webpack://ort/lib/onnxjs/ort-schema/flatbuffers/ort-generated.ts","webpack://ort/lib/onnxjs/session-handler.ts","webpack://ort/lib/onnxjs/session.ts","webpack://ort/lib/onnxjs/tensor.ts","webpack://ort/lib/onnxjs/util.ts","webpack://ort/lib/version.ts","webpack://ort/lib/wasm/proxy-wrapper.ts","webpack://ort/lib/wasm/run-options.ts","webpack://ort/lib/wasm/session-handler.ts","webpack://ort/lib/wasm/session-options.ts","webpack://ort/lib/wasm/wasm-common.ts","webpack://ort/lib/wasm/wasm-core-impl.ts","webpack://ort/lib/wasm/wasm-factory.ts","webpack://ort/lib/wasm/wasm-utils.ts","webpack://ort/lib/wasm/proxy-worker/main.ts","webpack://ort/node_modules/worker-loader/dist/runtime/inline.js","webpack://ort/lib/onnxjs/ort-schema/protobuf/onnx.js","webpack://ort/lib/wasm/binding/ort-wasm-threaded.min.js","webpack://ort/lib/wasm/binding/ort-wasm.js","webpack://ort/node_modules/@protobufjs/aspromise/index.js","webpack://ort/node_modules/@protobufjs/base64/index.js","webpack://ort/node_modules/@protobufjs/eventemitter/index.js","webpack://ort/node_modules/@protobufjs/float/index.js","webpack://ort/node_modules/@protobufjs/inquire/index.js","webpack://ort/node_modules/@protobufjs/pool/index.js","webpack://ort/node_modules/@protobufjs/utf8/index.js","webpack://ort/node_modules/guid-typescript/dist/guid.js","webpack://ort/node_modules/protobufjs/minimal.js","webpack://ort/node_modules/protobufjs/src/index-minimal.js","webpack://ort/node_modules/protobufjs/src/reader.js","webpack://ort/node_modules/protobufjs/src/reader_buffer.js","webpack://ort/node_modules/protobufjs/src/roots.js","webpack://ort/node_modules/protobufjs/src/rpc.js","webpack://ort/node_modules/protobufjs/src/rpc/service.js","webpack://ort/node_modules/protobufjs/src/util/longbits.js","webpack://ort/node_modules/protobufjs/src/util/minimal.js","webpack://ort/node_modules/protobufjs/src/writer.js","webpack://ort/node_modules/protobufjs/src/writer_buffer.js","webpack://ort/common/dist/cjs/backend-impl.js","webpack://ort/common/dist/cjs/backend.js","webpack://ort/common/dist/cjs/env-impl.js","webpack://ort/common/dist/cjs/env.js","webpack://ort/common/dist/cjs/index.js","webpack://ort/common/dist/cjs/inference-session-impl.js","webpack://ort/common/dist/cjs/inference-session.js","webpack://ort/common/dist/cjs/onnx-value.js","webpack://ort/common/dist/cjs/tensor-conversion-impl.js","webpack://ort/common/dist/cjs/tensor-factory-impl.js","webpack://ort/common/dist/cjs/tensor-impl.js","webpack://ort/common/dist/cjs/tensor-utils-impl.js","webpack://ort/common/dist/cjs/tensor.js","webpack://ort/common/dist/cjs/version.js","webpack://ort/node_modules/long/umd/index.js","webpack://ort/node_modules/flatbuffers/js/flatbuffers.mjs","webpack://ort/webpack/bootstrap","webpack://ort/webpack/runtime/compat get default export","webpack://ort/webpack/runtime/define property getters","webpack://ort/webpack/runtime/hasOwnProperty shorthand","webpack://ort/webpack/runtime/make namespace object","webpack://ort/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ort\"] = factory();\n\telse\n\t\troot[\"ort\"] = factory();\n})(self, () => {\nreturn ","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/* eslint-disable import/no-internal-modules */\nimport {Backend, InferenceSession, SessionHandler} from 'onnxruntime-common';\n\nimport {Session} from './onnxjs/session';\nimport {OnnxjsSessionHandler} from './onnxjs/session-handler';\n\nclass OnnxjsBackend implements Backend {\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  async init(): Promise<void> {}\n\n  async createSessionHandler(pathOrBuffer: string|Uint8Array, options?: InferenceSession.SessionOptions):\n      Promise<SessionHandler> {\n    // NOTE: Session.Config(from onnx.js) is not compatible with InferenceSession.SessionOptions(from\n    // onnxruntime-common).\n    //       In future we should remove Session.Config and use InferenceSession.SessionOptions.\n    //       Currently we allow this to happen to make test runner work.\n    const session = new Session(options as unknown as Session.Config);\n\n    // typescript cannot merge method override correctly (so far in 4.2.3). need if-else to call the method.\n    if (typeof pathOrBuffer === 'string') {\n      await session.loadModel(pathOrBuffer);\n    } else {\n      await session.loadModel(pathOrBuffer);\n    }\n\n    return new OnnxjsSessionHandler(session);\n  }\n}\n\nexport const onnxjsBackend = new OnnxjsBackend();\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Backend, env, InferenceSession, SessionHandler} from 'onnxruntime-common';\nimport {cpus} from 'os';\n\nimport {initializeWebAssemblyInstance} from './wasm/proxy-wrapper';\nimport {OnnxruntimeWebAssemblySessionHandler} from './wasm/session-handler';\n\n/**\n * This function initializes all flags for WebAssembly.\n *\n * Those flags are accessible from `ort.env.wasm`. Users are allow to set those flags before the first inference session\n * being created, to override default value.\n */\nexport const initializeFlags = (): void => {\n  if (typeof env.wasm.initTimeout !== 'number' || env.wasm.initTimeout < 0) {\n    env.wasm.initTimeout = 0;\n  }\n\n  if (typeof env.wasm.simd !== 'boolean') {\n    env.wasm.simd = true;\n  }\n\n  if (typeof env.wasm.proxy !== 'boolean') {\n    env.wasm.proxy = false;\n  }\n\n  if (typeof env.wasm.numThreads !== 'number' || !Number.isInteger(env.wasm.numThreads) || env.wasm.numThreads <= 0) {\n    const numCpuLogicalCores = typeof navigator === 'undefined' ? cpus().length : navigator.hardwareConcurrency;\n    env.wasm.numThreads = Math.min(4, Math.ceil((numCpuLogicalCores || 1) / 2));\n  }\n};\n\nclass OnnxruntimeWebAssemblyBackend implements Backend {\n  async init(): Promise<void> {\n    // populate wasm flags\n    initializeFlags();\n\n    // init wasm\n    await initializeWebAssemblyInstance();\n  }\n  createSessionHandler(path: string, options?: InferenceSession.SessionOptions): Promise<SessionHandler>;\n  createSessionHandler(buffer: Uint8Array, options?: InferenceSession.SessionOptions): Promise<SessionHandler>;\n  async createSessionHandler(pathOrBuffer: string|Uint8Array, options?: InferenceSession.SessionOptions):\n      Promise<SessionHandler> {\n    const handler = new OnnxruntimeWebAssemblySessionHandler();\n    await handler.loadModel(pathOrBuffer, options);\n    return Promise.resolve(handler);\n  }\n}\n\nexport const wasmBackend = new OnnxruntimeWebAssemblyBackend();\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/* eslint-disable @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports */\n// We use \"require\" instead of \"import\" here because import statement must be put in top level. Our current code does\n// not allow terser to tree-shaking code as expected because some codes are treated as having side effects.\n// So we import code inside the if-clause to allow terser remove the code safely.\n\nexport * from 'onnxruntime-common';\nimport {registerBackend, env} from 'onnxruntime-common';\nimport {version} from './version';\n\nif (!BUILD_DEFS.DISABLE_WEBGL) {\n  const onnxjsBackend = require('./backend-onnxjs').onnxjsBackend;\n  registerBackend('webgl', onnxjsBackend, -10);\n}\n\nif (!BUILD_DEFS.DISABLE_WASM) {\n  const wasmBackend = require('./backend-wasm').wasmBackend;\n  if (!BUILD_DEFS.DISABLE_WEBGPU && typeof navigator !== 'undefined' && navigator.gpu) {\n    registerBackend('webgpu', wasmBackend, 5);\n  }\n  registerBackend('cpu', wasmBackend, 10);\n  registerBackend('wasm', wasmBackend, 10);\n  registerBackend('xnnpack', wasmBackend, 9);\n  registerBackend('webnn', wasmBackend, 9);\n}\n\nenv.versions.web = version;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nclass AttributeWithCacheKeyImpl {\n  constructor(attribute: Record<string, unknown>) {\n    Object.assign(this, attribute);\n  }\n\n  private _cacheKey: string;\n  public get cacheKey(): string {\n    if (!this._cacheKey) {\n      this._cacheKey =\n          Object.getOwnPropertyNames(this).sort().map(name => `${(this as Record<string, unknown>)[name]}`).join(';');\n    }\n    return this._cacheKey;\n  }\n}\n\nexport interface AttributeWithCacheKey {\n  readonly cacheKey: string;\n}\n\nexport const createAttributeWithCacheKey = <T extends Record<string, unknown>>(attribute: T): T&AttributeWithCacheKey =>\n    new AttributeWithCacheKeyImpl(attribute) as unknown as T & AttributeWithCacheKey;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport Long from 'long';\n\nimport {onnxruntime} from './ort-schema/flatbuffers/ort-generated';\nimport {onnx} from './ort-schema/protobuf/onnx';\nimport {Tensor} from './tensor';\nimport {decodeUtf8String, LongUtil} from './util';\n\nimport ortFbs = onnxruntime.experimental.fbs;\n\nexport declare namespace Attribute {\n  export interface DataTypeMap {\n    float: number;\n    int: number;\n    string: string;\n    tensor: Tensor;\n    floats: number[];\n    ints: number[];\n    strings: string[];\n    tensors: Tensor[];\n  }\n\n  export type DataType = keyof DataTypeMap;\n}\n\ntype ValueTypes = Attribute.DataTypeMap[Attribute.DataType];\n\ntype Value = [ValueTypes, Attribute.DataType];\n\nexport class Attribute {\n  constructor(attributes: onnx.IAttributeProto[]|ortFbs.Attribute[]|null|undefined) {\n    this._attributes = new Map();\n    if (attributes !== null && attributes !== undefined) {\n      for (const attr of attributes) {\n        if (attr instanceof onnx.AttributeProto) {\n          this._attributes.set(attr.name, [Attribute.getValue(attr), Attribute.getType(attr)]);\n        } else if (attr instanceof ortFbs.Attribute) {\n          this._attributes.set(attr.name()!, [Attribute.getValue(attr), Attribute.getType(attr)]);\n        }\n      }\n      if (this._attributes.size < attributes.length) {\n        throw new Error('duplicated attribute names');\n      }\n    }\n  }\n\n  set(key: string, type: Attribute.DataType, value: ValueTypes): void {\n    this._attributes.set(key, [value, type]);\n  }\n  delete(key: string): void {\n    this._attributes.delete(key);\n  }\n  getFloat(key: string, defaultValue?: Attribute.DataTypeMap['float']) {\n    return this.get(key, 'float', defaultValue);\n  }\n\n  getInt(key: string, defaultValue?: Attribute.DataTypeMap['int']) {\n    return this.get(key, 'int', defaultValue);\n  }\n\n  getString(key: string, defaultValue?: Attribute.DataTypeMap['string']) {\n    return this.get(key, 'string', defaultValue);\n  }\n\n  getTensor(key: string, defaultValue?: Attribute.DataTypeMap['tensor']) {\n    return this.get(key, 'tensor', defaultValue);\n  }\n\n  getFloats(key: string, defaultValue?: Attribute.DataTypeMap['floats']) {\n    return this.get(key, 'floats', defaultValue);\n  }\n\n  getInts(key: string, defaultValue?: Attribute.DataTypeMap['ints']) {\n    return this.get(key, 'ints', defaultValue);\n  }\n\n  getStrings(key: string, defaultValue?: Attribute.DataTypeMap['strings']) {\n    return this.get(key, 'strings', defaultValue);\n  }\n\n  getTensors(key: string, defaultValue?: Attribute.DataTypeMap['tensors']) {\n    return this.get(key, 'tensors', defaultValue);\n  }\n\n  private get<V extends Attribute.DataTypeMap[Attribute.DataType]>(\n      key: string, type: Attribute.DataType, defaultValue?: V): V {\n    const valueAndType = this._attributes.get(key);\n    if (valueAndType === undefined) {\n      if (defaultValue !== undefined) {\n        return defaultValue;\n      }\n      throw new Error(`required attribute not found: ${key}`);\n    }\n    if (valueAndType[1] !== type) {\n      throw new Error(`type mismatch: expected ${type} but got ${valueAndType[1]}`);\n    }\n    return valueAndType[0] as V;\n  }\n\n  private static getType(attr: onnx.IAttributeProto|ortFbs.Attribute): Attribute.DataType {\n    const type = attr instanceof onnx.AttributeProto ? (attr).type : (attr as ortFbs.Attribute).type();\n    switch (type) {\n      case onnx.AttributeProto.AttributeType.FLOAT:\n        return 'float';\n      case onnx.AttributeProto.AttributeType.INT:\n        return 'int';\n      case onnx.AttributeProto.AttributeType.STRING:\n        return 'string';\n      case onnx.AttributeProto.AttributeType.TENSOR:\n        return 'tensor';\n      case onnx.AttributeProto.AttributeType.FLOATS:\n        return 'floats';\n      case onnx.AttributeProto.AttributeType.INTS:\n        return 'ints';\n      case onnx.AttributeProto.AttributeType.STRINGS:\n        return 'strings';\n      case onnx.AttributeProto.AttributeType.TENSORS:\n        return 'tensors';\n      default:\n        throw new Error(`attribute type is not supported yet: ${onnx.AttributeProto.AttributeType[type]}`);\n    }\n  }\n\n  private static getValue(attr: onnx.IAttributeProto|ortFbs.Attribute) {\n    const attrType = attr instanceof onnx.AttributeProto ? attr.type : (attr as ortFbs.Attribute).type();\n    if (attrType === onnx.AttributeProto.AttributeType.GRAPH || attrType === onnx.AttributeProto.AttributeType.GRAPHS) {\n      throw new Error('graph attribute is not supported yet');\n    }\n\n    const value = this.getValueNoCheck(attr);\n\n    // cast LONG to number\n    if (attrType === onnx.AttributeProto.AttributeType.INT && LongUtil.isLong(value)) {\n      return LongUtil.longToNumber(value as Long | flatbuffers.Long);\n    }\n\n    // cast LONG[] to number[]\n    if (attrType === onnx.AttributeProto.AttributeType.INTS) {\n      const arr = (value as Array<number|Long|flatbuffers.Long>);\n      const numberValue: number[] = new Array<number>(arr.length);\n\n      for (let i = 0; i < arr.length; i++) {\n        const maybeLong = arr[i];\n        numberValue[i] = LongUtil.longToNumber(maybeLong);\n      }\n\n      return numberValue;\n    }\n\n    // cast onnx.TensorProto to onnxjs.Tensor\n    if (attrType === onnx.AttributeProto.AttributeType.TENSOR) {\n      return attr instanceof onnx.AttributeProto ? Tensor.fromProto(value as onnx.ITensorProto) :\n                                                   Tensor.fromOrtTensor(value as ortFbs.Tensor);\n    }\n\n    // cast onnx.TensorProto[] to onnxjs.Tensor[]\n    if (attrType === onnx.AttributeProto.AttributeType.TENSORS) {\n      if (attr instanceof onnx.AttributeProto) {\n        const tensorProtos = value as onnx.ITensorProto[];\n        return tensorProtos.map(value => Tensor.fromProto(value));\n      } else if (attr instanceof ortFbs.Attribute) {\n        const tensorProtos = value as ortFbs.Tensor[];\n        return tensorProtos.map(value => Tensor.fromOrtTensor(value));\n      }\n    }\n\n    // cast Uint8Array to string\n    if (attrType === onnx.AttributeProto.AttributeType.STRING) {\n      // string in onnx attribute is of uint8array type, so we need to convert it to string below. While in ort format,\n      // string attributes are returned as string, so no conversion is needed.\n      if (attr instanceof onnx.AttributeProto) {\n        const utf8String = value as Uint8Array;\n        return decodeUtf8String(utf8String);\n      }\n    }\n\n    // cast Uint8Array[] to string[]\n    if (attrType === onnx.AttributeProto.AttributeType.STRINGS) {\n      // strings in onnx attribute is returned as uint8array[], so we need to convert it to string[] below. While in ort\n      // format strings attributes are returned as string[], so no conversion is needed.\n      if (attr instanceof onnx.AttributeProto) {\n        const utf8Strings = value as Uint8Array[];\n        return utf8Strings.map(decodeUtf8String);\n      }\n    }\n\n    return value as ValueTypes;\n  }\n\n  private static getValueNoCheck(attr: onnx.IAttributeProto|ortFbs.Attribute) {\n    return attr instanceof (onnx.AttributeProto) ? this.getValueNoCheckFromOnnxFormat(attr) :\n                                                   this.getValueNoCheckFromOrtFormat(attr as ortFbs.Attribute);\n  }\n\n  private static getValueNoCheckFromOnnxFormat(attr: onnx.IAttributeProto) {\n    switch (attr.type!) {\n      case onnx.AttributeProto.AttributeType.FLOAT:\n        return attr.f;\n      case onnx.AttributeProto.AttributeType.INT:\n        return attr.i;\n      case onnx.AttributeProto.AttributeType.STRING:\n        return attr.s;\n      case onnx.AttributeProto.AttributeType.TENSOR:\n        return attr.t;\n      case onnx.AttributeProto.AttributeType.GRAPH:\n        return attr.g;\n      case onnx.AttributeProto.AttributeType.FLOATS:\n        return attr.floats;\n      case onnx.AttributeProto.AttributeType.INTS:\n        return attr.ints;\n      case onnx.AttributeProto.AttributeType.STRINGS:\n        return attr.strings;\n      case onnx.AttributeProto.AttributeType.TENSORS:\n        return attr.tensors;\n      case onnx.AttributeProto.AttributeType.GRAPHS:\n        return attr.graphs;\n      default:\n        throw new Error(`unsupported attribute type: ${onnx.AttributeProto.AttributeType[attr.type!]}`);\n    }\n  }\n\n  private static getValueNoCheckFromOrtFormat(attr: ortFbs.Attribute) {\n    switch (attr.type()) {\n      case ortFbs.AttributeType.FLOAT:\n        return attr.f();\n      case ortFbs.AttributeType.INT:\n        return attr.i();\n      case ortFbs.AttributeType.STRING:\n        return attr.s();\n      case ortFbs.AttributeType.TENSOR:\n        return attr.t();\n      case ortFbs.AttributeType.GRAPH:\n        return attr.g();\n      case ortFbs.AttributeType.FLOATS:\n        return attr.floatsArray();\n      case ortFbs.AttributeType.INTS: {\n        const ints = [];\n        for (let i = 0; i < attr.intsLength(); i++) {\n          ints.push(attr.ints(i)!);\n        }\n        return ints;\n      }\n      case ortFbs.AttributeType.STRINGS: {\n        const strings = [];\n        for (let i = 0; i < attr.stringsLength(); i++) {\n          strings.push(attr.strings(i));\n        }\n        return strings;\n      }\n      case ortFbs.AttributeType.TENSORS: {\n        const tensors = [];\n        for (let i = 0; i < attr.tensorsLength(); i++) {\n          tensors.push(attr.tensors(i)!);\n        }\n        return tensors;\n      }\n      // case ortFbs.AttributeType.GRAPHS:\n      // TODO: Subgraph not supported yet.\n      // const graphs = [];\n      // for (let i = 0; i < attr.graphsLength(); i++) {\n      //   graphs.push(attr.graphs(i)!);\n      // }\n      // return graphs;\n      default:\n        throw new Error(`unsupported attribute type: ${ortFbs.AttributeType[attr.type()]}`);\n    }\n  }\n\n  protected _attributes: Map<string, Value>;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {WebGLBackend} from './backends/backend-webgl';\nimport {Graph} from './graph';\nimport {Operator} from './operators';\nimport {OpSet} from './opset';\nimport {Session} from './session';\n\nexport interface InferenceHandler {\n  /**\n   * dispose the inference handler. it will be called as the last step in Session.run()\n   */\n  dispose(): void;\n}\n\nexport interface SessionHandler {\n  /**\n   * transform the graph at initialization time\n   * @param graphTransformer the graph transformer to manipulate the model graph\n   */\n  transformGraph?(graphTransformer: Graph.Transformer): void;\n\n  /**\n   * create an instance of InferenceHandler to use in a Session.run() call\n   */\n  createInferenceHandler(): InferenceHandler;\n\n  /**\n   * dispose the session handler. it will be called when a session is being disposed explicitly\n   */\n  dispose(): void;\n\n  /**\n   * Resolves the operator from the name and opset version; backend specific\n   * @param node the node to resolve\n   * @param opsets a list of opsets that exported from the model\n   * @param graph the completely initialized graph\n   */\n  resolve(node: Graph.Node, opsets: readonly OpSet[], graph: Graph): Operator;\n\n  /**\n   * This method let's the sessionHandler know that the graph initialization is complete\n   * @param graph the completely initialized graph\n   */\n  onGraphInitialized?(graph: Graph): void;\n\n  /**\n   * a reference to the corresponding backend\n   */\n  readonly backend: Backend;\n\n  /**\n   * a reference to the session context\n   */\n  readonly context: Session.Context;\n}\n\nexport interface Backend {\n  /**\n   * initialize the backend. will be called only once, when the first time the\n   * backend it to be used\n   */\n  initialize(): boolean|Promise<boolean>;\n\n  /**\n   * create an instance of SessionHandler to use in a Session object's lifecycle\n   */\n  createSessionHandler(context: Session.Context): SessionHandler;\n\n  /**\n   * dispose the backend. currently this will not be called\n   */\n  dispose(): void;\n}\n\n// caches all initialized backend instances\nconst backendsCache: Map<string, Backend> = new Map();\n\nexport const backend: {[name: string]: Backend} = {\n  webgl: new WebGLBackend()\n};\n\n/**\n * Resolve a reference to the backend. If a hint is specified, the corresponding\n * backend will be used.\n */\nexport async function resolveBackend(hint?: string|readonly string[]): Promise<Backend> {\n  if (!hint) {\n    return resolveBackend(['webgl']);\n  } else {\n    const hints = typeof hint === 'string' ? [hint] : hint;\n\n    for (const backendHint of hints) {\n      const cache = backendsCache.get(backendHint);\n      if (cache) {\n        return cache;\n      }\n\n      const backend = await tryLoadBackend(backendHint);\n      if (backend) {\n        return backend;\n      }\n    }\n  }\n\n  throw new Error('no available backend to use');\n}\n\nasync function tryLoadBackend(backendHint: string): Promise<Backend|undefined> {\n  const backendObj = backend;\n\n  if (typeof backendObj[backendHint] !== 'undefined' && isBackend(backendObj[backendHint])) {\n    const backend = backendObj[backendHint];\n    let init = backend.initialize();\n    if (typeof init === 'object' && 'then' in init) {\n      init = await init;\n    }\n    if (init) {\n      backendsCache.set(backendHint, backend);\n      return backend;\n    }\n  }\n\n  return undefined;\n}\n\nfunction isBackend(obj: unknown) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const o = obj as any;\n\n  // check if an object is a Backend instance\n  if (\n      'initialize' in o && typeof o.initialize === 'function' &&                      // initialize()\n      'createSessionHandler' in o && typeof o.createSessionHandler === 'function' &&  // createSessionHandler()\n      'dispose' in o && typeof o.dispose === 'function'                               // dispose()\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nexport type BackendType = Backend;\nexport type SessionHandlerType = ReturnType<BackendType['createSessionHandler']>;\nexport type InferenceHandlerType = ReturnType<SessionHandlerType['createInferenceHandler']>;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {env} from 'onnxruntime-common';\n\nimport {Backend, SessionHandler} from '../backend';\nimport {Logger} from '../instrument';\nimport {Session} from '../session';\n\nimport {WebGLSessionHandler} from './webgl/session-handler';\nimport {WebGLContext} from './webgl/webgl-context';\nimport {createWebGLContext} from './webgl/webgl-context-factory';\n\n/**\n * WebGLBackend is the entry point for all WebGL opeartions\n * When it starts it created the WebGLRenderingContext\n * and other main framework components such as Program and Texture Managers\n */\nexport class WebGLBackend implements Backend {\n  glContext: WebGLContext;\n\n  get contextId(): 'webgl'|'webgl2'|undefined {\n    return env.webgl.contextId;\n  }\n  set contextId(value: 'webgl'|'webgl2'|undefined) {\n    env.webgl.contextId = value;\n  }\n\n  get matmulMaxBatchSize(): number|undefined {\n    return env.webgl.matmulMaxBatchSize;\n  }\n  set matmulMaxBatchSize(value: number|undefined) {\n    env.webgl.matmulMaxBatchSize = value;\n  }\n\n  get textureCacheMode(): 'initializerOnly'|'full'|undefined {\n    return env.webgl.textureCacheMode;\n  }\n  set textureCacheMode(value: 'initializerOnly'|'full'|undefined) {\n    env.webgl.textureCacheMode = value;\n  }\n\n  get pack(): boolean|undefined {\n    return env.webgl.pack;\n  }\n  set pack(value: boolean|undefined) {\n    env.webgl.pack = value;\n  }\n\n  get async(): boolean|undefined {\n    return env.webgl.async;\n  }\n  set async(value: boolean|undefined) {\n    env.webgl.async = value;\n  }\n\n  initialize(): boolean {\n    try {\n      this.glContext = createWebGLContext(this.contextId);\n      if (typeof this.matmulMaxBatchSize !== 'number') {\n        this.matmulMaxBatchSize = 16;\n      }\n      if (typeof this.textureCacheMode !== 'string') {\n        this.textureCacheMode = 'full';\n      }\n      if (typeof this.pack !== 'boolean') {\n        this.pack = false;\n      }\n      if (typeof this.async !== 'boolean') {\n        this.async = false;\n      }\n\n      Logger.setWithEnv(env);\n\n      Logger.verbose(\n          'WebGLBackend',\n          `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${\n              this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${\n              this.async}.`);\n      return true;\n    } catch (e) {\n      Logger.warning('WebGLBackend', `Unable to initialize WebGLBackend. ${e}`);\n      return false;\n    }\n  }\n  createSessionHandler(context: Session.Context): SessionHandler {\n    return new WebGLSessionHandler(this, context);\n  }\n  dispose(): void {\n    this.glContext.dispose();\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {ArrayUtil, BroadcastUtil, ShapeUtil} from '../../util';\n\nimport {GlslContext, GlslLib, GlslLibRoutine} from './glsl-definitions';\nimport {getGlsl} from './glsl-source';\nimport {squeezeShape} from './texture-layout-strategy';\nimport {TextureLayout} from './types';\nimport {generateShaderFuncNameFromInputSamplerName, generateShaderFuncNameFromInputSamplerNameAtOutCoords, getCoordsDataType, getGlChannels, getSqueezedParams, squeezeInputShape} from './utils';\n\n/**\n * GLSL Library responsible for data types and routines for manipulating\n * coordinates and mapping to/from tensor indices\n */\nexport class CoordsGlslLib extends GlslLib {\n  returnType: string;\n\n  constructor(context: GlslContext) {\n    super(context);\n  }\n  getFunctions(): {[name: string]: GlslLibRoutine} {\n    return {\n      ...this.offsetToCoords(),\n      ...this.coordsToOffset(),\n      ...this.toVec(),\n      ...this.valueFrom(),\n      // TODO return these only when packing is enabled.\n      ...this.getCommonUtilFuncs(),\n      ...this.getInputsSamplingSnippets(),\n      ...this.getOutputSamplingSnippet()\n    };\n  }\n  getCustomTypes() {\n    return {};\n  }\n  /**\n   * Produces a function that can map from\n   * 2D normalzied coordinates (s,t) to a flat offset\n   */\n  protected offsetToCoords(): {[name: string]: GlslLibRoutine} {\n    const funcName = 'offsetToCoords';\n    return {\n      offsetToCoords: new GlslLibRoutine(`\n      vec2 ${funcName}(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      `)\n    };\n  }\n\n  /**\n   * Produces a function that can map from\n   * 2D normalzied coordinates (s,t) to a flat offset\n   */\n  protected coordsToOffset(): {[name: string]: GlslLibRoutine} {\n    const funcName = 'coordsToOffset';\n    return {\n      coordsToOffset: new GlslLibRoutine(`\n      int ${funcName}(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      `)\n    };\n  }\n\n  /**\n   * Generates code for output sampler.\n   */\n\n  protected getOutputSamplingSnippet(): {[name: string]: GlslLibRoutine} {\n    const outputLayout = this.context.outputTextureLayout;\n    if (outputLayout.isPacked) {\n      return this.getPackedOutputSamplingSnippet(outputLayout);\n    } else {\n      return this.getUnpackedOutputSamplingSnippet(outputLayout);\n    }\n  }\n\n  /**\n   * Generates code for packed output sampler.\n   */\n  protected getPackedOutputSamplingSnippet(outputLayout: TextureLayout): {[name: string]: GlslLibRoutine} {\n    const outShape = outputLayout.unpackedShape;\n    const outTexShape = [outputLayout.width, outputLayout.height];\n    const result: {[name: string]: GlslLibRoutine} = {};\n    const funcName = 'getOutputCoords';\n    switch (outShape.length) {\n      case 0:\n        result[funcName] = this.getOutputScalarCoords();\n        break;\n      case 1:\n        result[funcName] = this.getOutputPacked1DCoords(outShape as [number], outTexShape as [number, number]);\n        break;\n      case 2:\n        result[funcName] = this.getOutputPacked2DCoords(outShape as [number, number], outTexShape as [number, number]);\n        break;\n      case 3:\n        result[funcName] =\n            this.getOutputPacked3DCoords(outShape as [number, number, number], outTexShape as [number, number]);\n        break;\n      default:\n        result[funcName] = this.getOutputPackedNDCoords(outShape, outTexShape as [number, number]);\n    }\n    const glsl = getGlsl(this.context.glContext.version);\n    // TODO we need this to properly return a packed vec4 from kernels.\n    // Replace all '{glsl.output} = result' with 'setOutput(result)' in all kernels.\n    const floatTextureSetRGBASource = `\n      void setOutput(vec4 val) {\n        ${glsl.output} = val;\n      }\n    `;\n    const floatTextureSetRGBAFuncName = 'floatTextureSetRGBA';\n    result[floatTextureSetRGBAFuncName] = new GlslLibRoutine(floatTextureSetRGBASource);\n    return result;\n  }\n\n  /**\n   * Generates code for unpacked output sampler.\n   */\n  protected getUnpackedOutputSamplingSnippet(outputLayout: TextureLayout): {[name: string]: GlslLibRoutine} {\n    const outShape = outputLayout.unpackedShape;\n    const outTexShape = [outputLayout.width, outputLayout.height];\n    const result: {[name: string]: GlslLibRoutine} = {};\n    const funcName = 'getOutputCoords';\n    switch (outShape.length) {\n      case 0:\n        result[funcName] = this.getOutputScalarCoords();\n        break;\n      case 1:\n        result[funcName] = this.getOutputUnpacked1DCoords(outShape as [number], outTexShape as [number, number]);\n        break;\n      case 2:\n        result[funcName] =\n            this.getOutputUnpacked2DCoords(outShape as [number, number], outTexShape as [number, number]);\n        break;\n      case 3:\n        result[funcName] =\n            this.getOutputUnpacked3DCoords(outShape as [number, number, number], outTexShape as [number, number]);\n        break;\n      case 4:\n        result[funcName] = this.getOutputUnpacked4DCoords(\n            outShape as [number, number, number, number], outTexShape as [number, number]);\n        break;\n      case 5:\n        result[funcName] = this.getOutputUnpacked5DCoords(\n            outShape as [number, number, number, number, number], outTexShape as [number, number]);\n        break;\n      case 6:\n        result[funcName] = this.getOutputUnpacked6DCoords(\n            outShape as [number, number, number, number, number, number], outTexShape as [number, number]);\n        break;\n      default:\n        throw new Error(`Unsupported output dimensionality: ${outShape.length}`);\n    }\n    const glsl = getGlsl(this.context.glContext.version);\n    // TODO we need this to properly return a packed vec4 from kernels.\n    // Replace all '{glsl.output} = result' with 'setOutput(result)' in all kernels.\n    const floatTextureSetRSource = `\n        void setOutput(float val) {\n          ${glsl.output} = vec4(val, 0, 0, 0);\n        }\n    `;\n    const floatTextureSetRFuncName = 'floatTextureSetR';\n    result[floatTextureSetRFuncName] = new GlslLibRoutine(floatTextureSetRSource);\n    return result;\n  }\n\n  /**\n   * Scalar output coordinates.\n   */\n  protected getOutputScalarCoords(): GlslLibRoutine {\n    return new GlslLibRoutine(`\n      int getOutputCoords() {\n        return 0;\n      }\n    `);\n  }\n\n  /**\n   * 1D packed output coordinates.\n   */\n  protected getOutputPacked1DCoords(shape: [number], texShape: [number, number]): GlslLibRoutine {\n    const packedTexShape = texShape;\n    let source = '';\n    if (packedTexShape[0] === 1) {\n      source = `\n          int getOutputCoords() {\n            return 2 * int(TexCoords.y * ${packedTexShape[1]}.0);\n          }\n        `;\n      return new GlslLibRoutine(source);\n    }\n\n    if (packedTexShape[1] === 1) {\n      source = `\n          int getOutputCoords() {\n            return 2 * int(TexCoords.x * ${packedTexShape[0]}.0);\n          }\n        `;\n      return new GlslLibRoutine(source);\n    }\n\n    source = `\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                 vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n          return 2 * (resTexRC.y * ${packedTexShape[0]} + resTexRC.x);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * 2D packed output coordinates.\n   */\n  protected getOutputPacked2DCoords(shape: [number, number], texShape: [number, number]): GlslLibRoutine {\n    let source = '';\n    if (ArrayUtil.arraysEqual(shape, texShape)) {\n      source = `\n        ivec2 getOutputCoords() {\n          return 2 * ivec2(TexCoords.xy * vec2(${texShape[0]}, ${texShape[1]}));\n        }\n      `;\n      return new GlslLibRoutine(source);\n    }\n\n    const packedTexShape = texShape;\n    // texels needed to accommodate a logical row\n    const texelsInLogicalRow = Math.ceil(shape[1] / 2);\n\n    /**\n     * getOutputCoords\n     *\n     * resTexRC: The rows and columns of the texels. If you move over one\n     * texel to the right in the packed texture, you are moving over one column\n     * (not two).\n     *\n     * index: The texel index\n     */\n    source = `\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n\n          int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${texelsInLogicalRow}) * 2;\n          int c = 2 * (index / ${texelsInLogicalRow});\n\n          return ivec2(r, c);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * 3D packed output coordinates.\n   */\n  protected getOutputPacked3DCoords(shape: [number, number, number], texShape: [number, number]): GlslLibRoutine {\n    const packedTexShape = [texShape[0], texShape[1]];\n    const texelsInLogicalRow = Math.ceil(shape[2] / 2);\n    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);\n    const source = `\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n          int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;\n\n          int b = index / ${texelsInBatch};\n          index -= b * ${texelsInBatch};\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${texelsInLogicalRow}) * 2;\n          int c = 2 * (index / ${texelsInLogicalRow});\n\n          return ivec3(b, r, c);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * ND packed output coordinates.\n   */\n  protected getOutputPackedNDCoords(shape: readonly number[], texShape: [number, number]): GlslLibRoutine {\n    const packedTexShape = [texShape[0], texShape[1]];\n\n    const texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);\n    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);\n    let texelsInBatchN = texelsInBatch;\n    let batches = '';\n    let coords = 'b, r, c';\n\n    for (let b = 2; b < shape.length - 1; b++) {\n      texelsInBatchN *= shape[shape.length - b - 1];\n      batches = `\n      int b${b} = index / ${texelsInBatchN};\n      index -= b${b} * ${texelsInBatchN};\n    ` + batches;\n      coords = `b${b}, ` + coords;\n    }\n    const source = `\n      ivec${shape.length} getOutputCoords() {\n        ivec2 resTexRC = ivec2(TexCoords.xy *\n                              vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n        int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;\n\n        ${batches}\n\n        int b = index / ${texelsInBatch};\n        index -= b * ${texelsInBatch};\n\n        // reverse r and c order for packed texture\n        int r = imod(index, ${texelsInLogicalRow}) * 2;\n        int c = 2 * (index / ${texelsInLogicalRow});\n\n        return ivec${shape.length}(${coords});\n      }\n    `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 1D output coordinates.\n   */\n  protected getOutputUnpacked1DCoords(shape: [number], texShape: [number, number]): GlslLibRoutine {\n    const source = `\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          return resTexRC.y * ${texShape[0]} + resTexRC.x;\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 2D output coordinates.\n   */\n  protected getOutputUnpacked2DCoords(shape: [number, number], texShape: [number, number]): GlslLibRoutine {\n    const source = `\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n          int r = index / ${shape[1]};\n          int c = index - r * ${shape[1]};\n          return ivec2(r, c);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 3D output coordinates.\n   */\n  protected getOutputUnpacked3DCoords(shape: [number, number, number], texShape: [number, number]): GlslLibRoutine {\n    let source = '';\n    const rank = shape.length;\n\n    let strides = null;\n    if (rank < 2) {\n      strides = [];\n    }\n\n    strides = new Array(rank - 1);\n    strides[rank - 2] = shape[rank - 1];\n    for (let i = rank - 3; i >= 0; --i) {\n      strides[i] = strides[i + 1] * shape[i + 1];\n    }\n    const coordsToCompute = ['r', 'c', 'd'];\n    const coordsFromIndexSnippet =\n        strides\n            .map((stride, i) => {\n              const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;\n              const line2 = i === strides.length - 1 ?\n                  `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` :\n                  `index -= ${coordsToCompute[i]} * ${stride}`;\n              return `${line1}; ${line2};`;\n            })\n            .join('');\n\n    source = `\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n          ${coordsFromIndexSnippet}\n          return ivec3(r, c, d);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 4D output coordinates.\n   */\n  protected getOutputUnpacked4DCoords(shape: [number, number, number, number], texShape: [number, number]):\n      GlslLibRoutine {\n    let source = '';\n    const rank = shape.length;\n\n    let strides = null;\n    if (rank < 2) {\n      strides = [];\n    }\n\n    strides = new Array(rank - 1);\n    strides[rank - 2] = shape[rank - 1];\n    for (let i = rank - 3; i >= 0; --i) {\n      strides[i] = strides[i + 1] * shape[i + 1];\n    }\n    const coordsToCompute = ['r', 'c', 'd', 'd2'];\n    const coordsFromIndexSnippet =\n        strides\n            .map((stride, i) => {\n              const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;\n              const line2 = i === strides.length - 1 ?\n                  `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` :\n                  `index -= ${coordsToCompute[i]} * ${stride}`;\n              return `${line1}; ${line2};`;\n            })\n            .join('');\n\n    source = `\n      ivec4 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n          ${coordsFromIndexSnippet}\n          return ivec4(r, c, d, d2);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 5D output coordinates.\n   */\n  protected getOutputUnpacked5DCoords(shape: [number, number, number, number, number], texShape: [number, number]):\n      GlslLibRoutine {\n    let source = '';\n    const rank = shape.length;\n\n    let strides = null;\n    if (rank < 2) {\n      strides = [];\n    }\n\n    strides = new Array(rank - 1);\n    strides[rank - 2] = shape[rank - 1];\n    for (let i = rank - 3; i >= 0; --i) {\n      strides[i] = strides[i + 1] * shape[i + 1];\n    }\n    const coordsToCompute = ['r', 'c', 'd', 'd2', 'd3'];\n    const coordsFromIndexSnippet =\n        strides\n            .map((stride, i) => {\n              const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;\n              const line2 = i === strides.length - 1 ?\n                  `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` :\n                  `index -= ${coordsToCompute[i]} * ${stride}`;\n              return `${line1}; ${line2};`;\n            })\n            .join('');\n\n    source = `\n      ivec5 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n          ${coordsFromIndexSnippet}\n          return ivec5(r, c, d, d2, d3);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 6D output coordinates.\n   */\n  protected getOutputUnpacked6DCoords(shape: [number, number, number, number, number, number], texShape: [\n    number, number\n  ]): GlslLibRoutine {\n    let source = '';\n    const rank = shape.length;\n\n    let strides = null;\n    if (rank < 2) {\n      strides = [];\n    }\n\n    strides = new Array(rank - 1);\n    strides[rank - 2] = shape[rank - 1];\n    for (let i = rank - 3; i >= 0; --i) {\n      strides[i] = strides[i + 1] * shape[i + 1];\n    }\n    const coordsToCompute = ['r', 'c', 'd', 'd2', 'd3', 'd4'];\n    const coordsFromIndexSnippet =\n        strides\n            .map((stride, i) => {\n              const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;\n              const line2 = i === strides.length - 1 ?\n                  `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` :\n                  `index -= ${coordsToCompute[i]} * ${stride}`;\n              return `${line1}; ${line2};`;\n            })\n            .join('');\n\n    source = `\n     ivec6 getOutputCoords() {\n         ivec2 resTexRC = ivec2(TexCoords.xy *\n                               vec2(${texShape[0]}, ${texShape[1]}));\n         int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n         ${coordsFromIndexSnippet}\n         return ivec6(r, c, d, d2, d3, d4);\n       }\n     `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Generates code for common UV coords computation utility functions.\n   */\n  protected getCommonUtilFuncs(): {[name: string]: GlslLibRoutine} {\n    const result: {[name: string]: GlslLibRoutine} = {};\n    let funcName = 'uvFromFlat';\n    result[funcName] = new GlslLibRoutine(`\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    `);\n    funcName = 'packedUVfrom1D';\n    result[funcName] = new GlslLibRoutine(`\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      `);\n    funcName = 'packedUVfrom2D';\n    result[funcName] = new GlslLibRoutine(`\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      `);\n    funcName = 'packedUVfrom3D';\n    result[funcName] = new GlslLibRoutine(`\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      `);\n    funcName = 'sampleTexture';\n    const glsl = getGlsl(this.context.glContext.version);\n    result[funcName] = new GlslLibRoutine(`\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\n            return ${glsl.texture2D}(textureSampler, uv).r;\n        }`);\n    return result;\n  }\n\n  /**\n   * Constructing snippets for inputs\n   */\n  protected getInputsSamplingSnippets(): {[name: string]: GlslLibRoutine} {\n    const result: {[name: string]: GlslLibRoutine} = {};\n    const outputLayout = this.context.outputTextureLayout;\n    this.context.programInfo.inputNames.forEach((samplerName, i) => {\n      const inputLayout = this.context.inputTextureLayouts[i];\n      const funcName = generateShaderFuncNameFromInputSamplerName(samplerName);\n      if (inputLayout.isPacked) {\n        result[funcName] = this.getPackedSamplerFromInput(funcName, samplerName, inputLayout);\n      } else {\n        result[funcName] = this.getUnpackedSamplerFromInput(funcName, samplerName, inputLayout);\n      }\n\n      const outCoordFuncName = generateShaderFuncNameFromInputSamplerNameAtOutCoords(samplerName);\n      if (inputLayout.unpackedShape.length <= outputLayout.unpackedShape.length) {\n        if (inputLayout.isPacked) {\n          result[outCoordFuncName] =\n              this.getPackedSamplerAtOutputCoords(outCoordFuncName, inputLayout, outputLayout, samplerName);\n        } else {\n          result[outCoordFuncName] =\n              this.getUnpackedSamplerAtOutputCoords(outCoordFuncName, inputLayout, outputLayout, samplerName);\n        }\n      }\n    });\n\n    return result;\n  }\n\n  /**\n   * Constructing snippets for output coordinates of samplers\n   */\n  protected getPackedSamplerAtOutputCoords(\n      funcName: string, inputLayout: TextureLayout, outputLayout: TextureLayout, name: string): GlslLibRoutine {\n    const inShape = inputLayout.unpackedShape;\n    const outShape = outputLayout.unpackedShape;\n    const texName = name;\n    const texFuncSnippet = generateShaderFuncNameFromInputSamplerName(texName);\n\n    const inRank = inShape.length;\n    const outRank = outShape.length;\n\n    const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);\n\n    const type = getCoordsDataType(outRank);\n    const rankDiff = outRank - inRank;\n    let coordsSnippet: string;\n    const fields = getGlChannels();\n\n    if (inRank === 0) {\n      coordsSnippet = '';\n    } else if (outRank < 2 && broadcastDims.length >= 1) {\n      coordsSnippet = 'coords = 0;';\n    } else {\n      coordsSnippet = broadcastDims.map(d => `coords.${fields[d + rankDiff]} = 0;`).join('\\n');\n    }\n    let unpackedCoordsSnippet = '';\n    if (outRank < 2 && inRank > 0) {\n      unpackedCoordsSnippet = 'coords';\n    } else {\n      unpackedCoordsSnippet = inShape.map((s, i) => `coords.${fields[i + rankDiff]}`).join(', ');\n    }\n\n    let output = 'return outputValue;';\n    const inSize = ShapeUtil.size(inShape);\n    const isInputScalar = inSize === 1;\n    const outSize = ShapeUtil.size(outShape);\n    const isOutputScalar = outSize === 1;\n\n    if (inRank === 1 && !isInputScalar && !isOutputScalar) {\n      output = `\n        return vec4(outputValue.xy, outputValue.xy);\n      `;\n    } else if (isInputScalar && !isOutputScalar) {\n      if (outRank === 1) {\n        output = `\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        `;\n      } else {\n        output = `\n          return vec4(outputValue.x);\n        `;\n      }\n    } else if (broadcastDims.length) {\n      const rows = inRank - 2;\n      const cols = inRank - 1;\n\n      if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {\n        output = 'return vec4(outputValue.x);';\n      } else if (broadcastDims.indexOf(rows) > -1) {\n        output = 'return vec4(outputValue.x, outputValue.y, ' +\n            'outputValue.x, outputValue.y);';\n      } else if (broadcastDims.indexOf(cols) > -1) {\n        output = 'return vec4(outputValue.xx, outputValue.zz);';\n      }\n    }\n\n    const swapLastDimsSnippet = `\n        int lastDim = coords.${fields[outRank - 1]};\n        coords.${fields[outRank - 1]} = coords.${fields[outRank - 2]};\n        coords.${fields[outRank - 2]} = lastDim;\n      `;\n    const source = `\n      vec4 ${funcName}() {\n        ${type} coords = getOutputCoords();\n        ${swapLastDimsSnippet}\n        ${coordsSnippet}\n        vec4 outputValue = ${texFuncSnippet}(${unpackedCoordsSnippet});\n        ${output}\n      }\n    `;\n    return new GlslLibRoutine(source, ['coordinates.getOutputCoords']);\n  }\n\n  /**\n   * Constructing snippets for unpacked output coordinates of samplers\n   */\n  protected getUnpackedSamplerAtOutputCoords(\n      funcName: string, inputLayout: TextureLayout, outputLayout: TextureLayout, name: string): GlslLibRoutine {\n    const outTexShape = [outputLayout.width, outputLayout.height];\n    const inTexShape = [inputLayout.width, inputLayout.height];\n    const inRank = inputLayout.unpackedShape.length;\n    const outRank = outputLayout.unpackedShape.length;\n    const inShape = inputLayout.unpackedShape;\n    const outShape = outputLayout.unpackedShape;\n    const texFuncSnippet = generateShaderFuncNameFromInputSamplerName(name);\n\n    if (inRank === outRank && ArrayUtil.arraysEqual(inTexShape, outTexShape)) {\n      const source = `\n          float ${funcName}() {\n            return sampleTexture(${name}, TexCoords);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n\n    const type = getCoordsDataType(outRank);\n    const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);\n    const rankDiff = outRank - inRank;\n    let coordsSnippet: string;\n    const fields = getGlChannels();\n\n    if (inRank === 0) {\n      coordsSnippet = '';\n    } else if (outRank < 2 && broadcastDims.length >= 1) {\n      coordsSnippet = 'coords = 0;';\n    } else {\n      coordsSnippet = broadcastDims.map(d => `coords.${fields[d + rankDiff]} = 0;`).join('\\n');\n    }\n    let unpackedCoordsSnippet = '';\n    if (outRank < 2 && inRank > 0) {\n      unpackedCoordsSnippet = 'coords';\n    } else {\n      unpackedCoordsSnippet = inputLayout.unpackedShape.map((s, i) => `coords.${fields[i + rankDiff]}`).join(', ');\n    }\n    const source = `\n        float ${funcName}() {\n          ${type} coords = getOutputCoords();\n          ${coordsSnippet}\n          return ${texFuncSnippet}(${unpackedCoordsSnippet});\n        }\n      `;\n    return new GlslLibRoutine(source, ['coordinates.getOutputCoords']);\n  }\n\n  /**\n   * Constructing snippets for packed operations.\n   */\n  protected getPackedSamplerFromInput(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    switch (inputLayout.unpackedShape.length) {\n      case 0:\n        return this.getPackedSamplerScalar(funcName, name);\n      case 1:\n        return this.getPackedSampler1D(funcName, name, inputLayout);\n      case 2:\n        return this.getPackedSampler2D(funcName, name, inputLayout);\n      case 3:\n        return this.getPackedSampler3D(funcName, name, inputLayout);\n      default:\n        return this.getPackedSamplerND(funcName, name, inputLayout);\n    }\n  }\n\n  /**\n   * Constructing snippets for unpacked operations.\n   */\n  protected getUnpackedSamplerFromInput(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    switch (shape.length) {\n      case 0:\n        return this.getUnpackedSamplerScalar(funcName, name, inputLayout);\n      case 1:\n        return this.getUnpackedSampler1D(funcName, name, inputLayout);\n      case 2:\n        return this.getUnpackedSampler2D(funcName, name, inputLayout);\n      case 3:\n        return this.getUnpackedSampler3D(funcName, name, inputLayout);\n      case 4:\n        return this.getUnpackedSampler4D(funcName, name, inputLayout);\n      case 5:\n        return this.getUnpackedSampler5D(funcName, name, inputLayout);\n      case 6:\n        return this.getUnpackedSampler6D(funcName, name, inputLayout);\n      default:\n        // TODO support more dimensionalities\n        throw new Error(`Unsupported dimension ${shape.length}-D`);\n    }\n  }\n\n  /**\n   * Packed scalar snippet.\n   */\n  protected getPackedSamplerScalar(funcName: string, name: string): GlslLibRoutine {\n    const glsl = getGlsl(this.context.glContext.version);\n    const source = `\n          vec4 ${funcName}() {\n            return ${glsl.texture2D}(${name}, halfCR);\n          }\n        `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Packed 1D snippet.\n   */\n  protected getPackedSampler1D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const texShape = [inputLayout.width, inputLayout.height];\n    const packedTexShape = [texShape[1], texShape[0]];\n    const glsl = getGlsl(this.context.glContext.version);\n\n    const packedSampler = `vec4 ${funcName}(int index) {\n      vec2 uv = packedUVfrom1D(\n      ${packedTexShape[0]}, ${packedTexShape[1]}, index);\n      return ${glsl.texture2D}(${name}, uv);\n    }`;\n    const source = packedSampler;\n    return new GlslLibRoutine(source, ['coordinates.packedUVfrom1D']);\n  }\n\n  /**\n   * Packed 2D snippet.\n   */\n  protected getPackedSampler2D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const texShape = [inputLayout.width, inputLayout.height];\n    const glsl = getGlsl(this.context.glContext.version);\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n\n    if (texShape != null && ArrayUtil.arraysEqual(shape, texShape)) {\n      const packedSampler = `vec4 ${funcName}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n        return ${glsl.texture2D}(${name}, uv);\n      }`;\n\n      return new GlslLibRoutine(packedSampler);\n    }\n    const packedTexShape = texShape;\n    const valuesPerRow = Math.ceil(shape[1] / 2);\n    const packedSampler = `vec4 ${funcName}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${packedTexShape[1]}, ${packedTexShape[0]}, ${valuesPerRow}, row, col);\n      return ${glsl.texture2D}(${name}, uv);\n    }`;\n    const source = packedSampler;\n    return new GlslLibRoutine(source, ['coordinates.packedUVfrom2D']);\n  }\n\n  /**\n   * Packed 3D snippet.\n   */\n  protected getPackedSampler3D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const texShape = [inputLayout.width, inputLayout.height];\n    const packedTexShape = [texShape[0], texShape[1]];\n    const glsl = getGlsl(this.context.glContext.version);\n\n    if (shape[0] === 1) {\n      const squeezedShape = shape.slice(1);\n      const keptDims = [1, 2];\n      const newInputShape = squeezeInputShape(shape, squeezedShape);\n      const params = ['b', 'row', 'col'];\n      // Deep copy of input texture layout.\n      const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n      newInputLayout.unpackedShape = newInputShape;\n      const samplerRoutine = this.getPackedSamplerFromInput(funcName, name, newInputLayout);\n      const packedSampler = `${samplerRoutine.routineBody}\n      vec4 ${funcName}(int b, int row, int col) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      } `;\n      const source = packedSampler;\n      return new GlslLibRoutine(source, samplerRoutine.dependencies);\n    }\n    const texNumR = packedTexShape[0];\n    const texNumC = packedTexShape[1];\n\n    const valuesPerRow = Math.ceil(shape[2] / 2);\n    const texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);\n\n    const packedSampler = `vec4 ${funcName}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${texNumC}, ${texNumR}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);\n      return ${glsl.texture2D}(${name}, uv);}`;\n    const source = packedSampler;\n    return new GlslLibRoutine(source, ['coordinates.packedUVfrom3D']);\n  }\n  /*\n   * Packed ND snippet.\n   */\n  protected getPackedSamplerND(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const rank = shape.length;\n    const texShape = [inputLayout.width, inputLayout.height];\n    const glsl = getGlsl(this.context.glContext.version);\n\n    const packedTexShape = [texShape[0], texShape[1]];\n    const texNumR = packedTexShape[1];\n    const texNumC = packedTexShape[0];\n    const valuesPerRow = Math.ceil(shape[rank - 1] / 2);\n    let texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);\n    let params = 'int b, int row, int col';\n    let index = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;\n    for (let b = 2; b < rank - 1; b++) {\n      params = `int b${b}, ` + params;\n      texelsInBatch *= shape[rank - b - 1];\n      index = `b${b} * ${texelsInBatch} + ` + index;\n    }\n    const packedSampler = `vec4 ${funcName}(${params}) {\n      int index = ${index};\n      int texR = index / ${texNumC};\n      int texC = index - texR * ${texNumC};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});\n      return ${glsl.texture2D}(${name}, uv);\n    }`;\n    const source = packedSampler;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked scalar snippet.\n   */\n  protected getUnpackedSamplerScalar(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const [texNumR, texNumC] = [inputLayout.width, inputLayout.height];\n    if (texNumR === 1 && texNumC === 1) {\n      const source = `\n          float ${funcName}() {\n            return sampleTexture(${name}, halfCR);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n\n    const source = `\n        float ${funcName}() {\n          int offset_${name} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});\n          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, offset_${name});\n          return sampleTexture(${name}, uv);\n        }\n      `;\n    return new GlslLibRoutine(\n        source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture', 'coordinates.coordsToOffset']);\n  }\n\n  /**\n   * Unpacked 1D snippet.\n   */\n  protected getUnpackedSampler1D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const tNumR = inputLayout.width;\n    const tNumC = inputLayout.height;\n\n    if (tNumC === 1 && tNumR === 1) {\n      const source = `\n        float ${funcName}(int index) {\n          return sampleTexture(${name}, halfCR);\n        }\n      `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n\n    if (tNumC === 1) {\n      const source = `\n          float ${funcName}(int index) {\n            vec2 uv = vec2((float(index) + 0.5) / ${tNumR}.0, 0.5);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n    if (tNumR === 1) {\n      const source = `\n          float ${funcName}(int index) {\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${tNumC}.0);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n    const source = `\n        float ${funcName}(int index) {\n          vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index);\n          return sampleTexture(${name}, uv);\n        }\n      `;\n    return new GlslLibRoutine(source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture']);\n  }\n\n  /**\n   * Unpacked 2D snippet.\n   */\n\n  protected getUnpackedSampler2D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n\n    // TODO: modify row/col order for other dimensions.\n    const texShape = [inputLayout.height, inputLayout.width];\n\n    if (texShape != null && ArrayUtil.arraysEqual(shape, texShape)) {\n      const texNumR = texShape[1];\n      const texNumC = texShape[0];\n      const source = `\n          float ${funcName}(int row, int col) {\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${texNumR}.0, ${texNumC}.0);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n\n    const {newShape, keptDims} = squeezeShape(shape as number[]);\n    const squeezedShape = newShape;\n    if (squeezedShape.length < shape.length) {\n      const newInputShape = squeezeInputShape(shape, squeezedShape);\n      // Deep copy of input texture layout.\n      const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n      newInputLayout.unpackedShape = newInputShape;\n\n      const params = ['col', 'row'];\n      const source = `\n          ${this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody}\n          float ${funcName}(int row, int col) {\n            return ${funcName}(${getSqueezedParams(params, keptDims)});\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n\n    const texNumR = texShape[1];\n    const texNumC = texShape[0];\n    if (texNumC === 1) {\n      const source = `\n          float ${funcName}(int row, int col) {\n            int offset_${name} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});\n            float index = dot(vec3(row, col, offset_${name}), vec3(${shape[1]}, 1, 1));\n            vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.coordsToOffset']);\n    }\n\n    if (texNumR === 1) {\n      const source = `\n          float ${funcName}(int row, int col) {\n            int offset_${name} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});\n            float index = dot(vec3(row, col, offset_${name}), vec3(${shape[1]}, 1, 1));\n            vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.coordsToOffset']);\n    }\n\n    const source = `\n        float ${funcName}(int row, int col) {\n          int index = col * ${shape[1]} + row;\n          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n          return sampleTexture(${name}, uv);\n        }\n      `;\n    return new GlslLibRoutine(\n        source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture', 'coordinates.coordsToOffset']);\n  }\n\n  /**\n   * Unpacked 3D snippet.\n   */\n\n  protected getUnpackedSampler3D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const stride0 = shape[1] * shape[2];\n    const stride1 = shape[2];\n\n    const {newShape, keptDims} = squeezeShape(shape as number[]);\n    const squeezedShape = newShape;\n    if (squeezedShape.length < shape.length) {\n      const newInputShape = squeezeInputShape(shape, squeezedShape);\n      const params = ['batch', 'col', 'row'];\n      // Deep copy of input texture layout.\n      const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n      newInputLayout.unpackedShape = newInputShape;\n      const routine = this.getUnpackedSamplerFromInput(funcName, name, newInputLayout);\n      // TODO: revisit the logic here to make it simpler\n      const revDims = keptDims.reverse();\n      const source = `\n          ${routine.routineBody}\n          float ${funcName}(int batch, int row, int col) {\n            return ${funcName}(${getSqueezedParams(params, revDims)});\n          }\n        `;\n      return new GlslLibRoutine(source, routine.dependencies);\n    }\n\n    const texNumR = inputLayout.width;\n    const texNumC = inputLayout.height;\n    const source = `\n          float ${funcName}(int depth, int row, int col) {\n            // Explicitly use integer operations as dot() only works on floats.\n            int index = depth * ${stride0} + col * ${stride1} + row;\n            vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n            return sampleTexture(${name}, uv);\n          }\n      `;\n    return new GlslLibRoutine(\n        source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture', 'coordinates.coordsToOffset']);\n  }\n\n  /**\n   * Unpacked 4D snippet.\n   */\n\n  protected getUnpackedSampler4D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const stride2 = shape[3];\n    const stride1 = shape[2] * stride2;\n    const stride0 = shape[1] * stride1;\n\n    //\n    // TODO: re-enable this shortcut once the index calculation bug is fixed.\n    //\n    // const {newShape, keptDims} = squeezeShape(shape as number[]);\n    // if (newShape.length < shape.length) {\n    //   const newInputShape = squeezeInputShape(shape, newShape);\n    //   const params = ['row', 'col', 'depth', 'depth2'];\n    //   // Deep copy of input texture layout.\n    //   const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n    //   newInputLayout.unpackedShape = newInputShape;\n    //   const source = `\n    //       ${this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody}\n    //       float ${funcName}(int row, int col, int depth, int depth2) {\n    //         return ${funcName}(${getSqueezedParams(params, keptDims)});\n    //       }\n    //     `;\n    //   return new GlslLibRoutine(\n    //       source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture', 'coordinates.coordsToOffset']);\n    // }\n\n    const texNumR = inputLayout.width;\n    const texNumC = inputLayout.height;\n    const source = `\n        float ${funcName}(int row, int col, int depth, int depth2) {\n          int index = row * ${stride0} + col * ${stride1} +\n              depth2 * ${stride2} + depth;\n          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n          return sampleTexture(${name}, uv);\n        }\n      `;\n    return new GlslLibRoutine(source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture']);\n  }\n\n  /**\n   * Unpacked 5D snippet.\n   */\n  protected getUnpackedSampler5D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const stride3 = shape[4];\n    const stride2 = shape[3] * stride3;\n    const stride1 = shape[2] * stride2;\n    const stride0 = shape[1] * stride1;\n\n    const {newShape, keptDims} = squeezeShape(shape as number[]);\n    if (newShape.length < shape.length) {\n      const newInputShape = squeezeInputShape(shape, newShape);\n      const params = ['row', 'col', 'depth', 'depth2', 'depth3'];\n      // Deep copy of input texture layout.\n      const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n      newInputLayout.unpackedShape = newInputShape;\n\n      const source = `\n          ${this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody}\n          float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n            return ${funcName}(${getSqueezedParams(params, keptDims)});\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.uvFromFlat']);\n    }\n\n    const texNumR = inputLayout.width;\n    const texNumC = inputLayout.height;\n    const source = `\n        float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n          int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n          depth3 * ${stride3} + depth2;\n          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n          return sampleTexture(${name}, uv);\n        }\n      `;\n    return new GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.uvFromFlat']);\n  }\n\n  /**\n   * Unpacked 6D snippet.\n   */\n  protected getUnpackedSampler6D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const stride4 = shape[5];\n    const stride3 = shape[4] * stride4;\n    const stride2 = shape[3] * stride3;\n    const stride1 = shape[2] * stride2;\n    const stride0 = shape[1] * stride1;\n\n    const {newShape, keptDims} = squeezeShape(shape as number[]);\n    if (newShape.length < shape.length) {\n      const newInputShape = squeezeInputShape(shape, newShape);\n      const params = ['row', 'col', 'depth', 'depth2', 'depth3', 'depth4'];\n      // Deep copy of input texture layout.\n      const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n      newInputLayout.unpackedShape = newInputShape;\n\n      const source = `\n            ${this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody}\n            float ${funcName}(int row, int col, int depth,\n              int depth2, int depth3, int depth4) {\n              return ${funcName}(${getSqueezedParams(params, keptDims)});\n            }\n          `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.uvFromFlat']);\n    }\n\n    const texNumR = inputLayout.width;\n    const texNumC = inputLayout.height;\n    const source = `\n          float ${funcName}(int row, int col, int depth,\n            int depth2, int depth3, int depth4) {\n            int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n            depth2 * ${stride3} + depth3 * ${stride4} + depth4;\n            vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n    return new GlslLibRoutine(\n        source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture', 'coordinates.coordsToOffset']);\n  }\n\n  /**\n   * This is the main function to map from the given texture coordiantes (s,t)\n   * to logical indices for the output\n   * There will only be one single variation of this\n   * Also see coordsToOffset and offsetToIndices for input-specific versions\n   */\n  protected toVec(): {[name: string]: GlslLibRoutine} {\n    const output = this.context.outputTextureLayout;\n    const rank = output.shape.length;\n    const strides = output.strides;\n    const xScale = output.width;\n    const yScale = output.height;\n\n    const stridesBlock = [];\n    for (let i = 0; i < rank - 1; ++i) {\n      stridesBlock.push(`\n        c[${i}] = offset / ${strides[i]};`);\n      stridesBlock.push(`\n        offset -= c[${i}] * ${strides[i]};`);\n    }\n    stridesBlock.push(`\n        c[${rank - 1}] = offset;`);\n    const body = `\n      void toVec(vec2 texCoords, out int c[${rank}]) {\n        int offset = coordsToOffset(texCoords, ${xScale}, ${yScale});\n        ${stridesBlock.join('')}\n      }\n      void toVec(int offset, out int c[${rank}]) {\n        ${stridesBlock.join('')}\n      }\n    `;\n    return {toVec: new GlslLibRoutine(body, ['coordinates.coordsToOffset'])};\n  }\n  /**\n   * These are value getter functions generated for each input\n   * Each function is hardwired to the name and dimensions of the input\n   * An '_T' variation is also produced which accesses values as if the\n   * input was transposed\n   */\n  protected valueFrom(): {[name: string]: GlslLibRoutine} {\n    const result: {[name: string]: GlslLibRoutine} = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const layout = this.context.inputTextureLayouts[i];\n      const shape = layout.unpackedShape.length > 0 ? layout.unpackedShape : layout.shape;\n      const rank = shape.length;\n      let funcName = `_${name}`;\n      result[funcName] = new GlslLibRoutine(\n          this.getValueFromSingle(name, rank, layout.width, layout.height, false),\n          [`shapeUtils.indicesToOffset${funcName}`, 'coordinates.offsetToCoords', 'fragcolor.getColorAsFloat']);\n      funcName = funcName + '_T';\n      result[funcName] = new GlslLibRoutine(\n          this.getValueFromSingle(name, rank, layout.width, layout.height, true),\n          [`shapeUtils.indicesToOffset${funcName}`, 'coordinates.offsetToCoords', 'fragcolor.getColorAsFloat']);\n    });\n    return result;\n  }\n  /**\n   * Produces one value getter function for the name and rank given\n   * If a transpose is set proper offsetToCoords mapping will be used\n   * @param name name of the function\n   * @param rank rank of the input\n   * @param transpose whether or not should generate a transpose variation\n   */\n  protected getValueFromSingle(varName: string, rank: number, width: number, height: number, transpose: boolean):\n      string {\n    let name = `_${varName}`;\n    if (transpose) {\n      name = name + '_T';\n    }\n    const glsl = getGlsl(this.context.glContext.version);\n    return `\n        float ${name}(int m[${rank}]) {\n          int offset = indicesToOffset${name}(m);\n          vec2 coords = offsetToCoords(offset, ${width}, ${height});\n          float value = getColorAsFloat(${glsl.texture2D}(${varName}, coords));\n          return value;\n        }\n        `;\n  }\n\n  /**\n   * Produces a packed value getter function for the name and rank given\n   * If a transpose is set proper offsetToCoords mapping will be used\n   * @param name name of the function\n   * @param rank rank of the input\n   * @param transpose whether or not should generate a transpose variation\n   */\n  protected getPackedValueFrom(varName: string, rank: number, width: number, height: number, transpose: boolean):\n      string {\n    let name = `_${varName}_Pack`;\n    if (transpose) {\n      name = name + '_T';\n    }\n    const glsl = getGlsl(this.context.glContext.version);\n    return `\n        vec4 ${name}(int m[${rank}]) {\n          int offset = indicesToOffset_${varName}(m);\n          vec2 coords = offsetToCoords(offset, ${width}, ${height});\n          return ${glsl.texture2D}(${varName}, coords);\n        }\n        `;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {ProgramInfo, TextureLayout} from './types';\nimport {WebGLContext} from './webgl-context';\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum FunctionType {\n  ValueBased,\n  Positional\n}\nexport interface GlslFunction<T extends FunctionType> {\n  body: string;\n  name: string;\n  type: T;\n}\nexport type GlslValueFunction = GlslFunction<FunctionType.ValueBased>;\nexport interface GlslPositionalFunction extends GlslFunction<FunctionType.Positional> {\n  inputShape: readonly number[];\n  outputShape: readonly number[];\n}\n\nexport class GlslContext {\n  constructor(\n      public glContext: WebGLContext, public programInfo: ProgramInfo, public inputTextureLayouts: TextureLayout[],\n      public outputTextureLayout: TextureLayout) {}\n}\nexport abstract class GlslLib {\n  constructor(public context: GlslContext) {}\n  abstract getFunctions(): {[name: string]: GlslLibRoutine};\n  abstract getCustomTypes(): {[name: string]: string};\n}\n\n// abstraction to represent a GLSL library routine and it's dependencies\nexport class GlslLibRoutine {\n  constructor(public routineBody: string, public dependencies?: string[]) {}\n}\n\n// abstraction to represent a GLSL library routine and it's dependencies AS GRAPH Nodes\n// this level of abstraction is used to topologically sort routines before fragment shade inclusion\nexport class GlslLibRoutineNode {\n  dependencies: GlslLibRoutineNode[];\n  routineBody: string;\n  constructor(public name: string, routineBody?: string, dependencies?: GlslLibRoutineNode[]) {\n    if (dependencies) {\n      this.dependencies = dependencies;\n    } else {\n      this.dependencies = [];\n    }\n\n    if (routineBody) {\n      this.routineBody = routineBody;\n    }\n  }\n  addDependency(node: GlslLibRoutineNode) {\n    if (node) {\n      this.dependencies.push(node);\n    }\n  }\n}\n\n// topologically sort GLSL library routines (graph nodes abstraction) before shader script inclusion\nexport class TopologicalSortGlslRoutines {\n  static returnOrderedNodes(nodes: GlslLibRoutineNode[]): GlslLibRoutineNode[] {\n    if (!nodes || nodes.length === 0) {\n      return [];\n    }\n\n    if (nodes.length === 1) {\n      return nodes;\n    }\n\n    const cycleCheck = new Set<string>();\n    const alreadyTraversed = new Set<string>();\n    const result = new Array<GlslLibRoutineNode>();\n\n    this.createOrderedNodes(nodes, cycleCheck, alreadyTraversed, result);\n    return result;\n  }\n\n  private static createOrderedNodes(\n      graphNodes: GlslLibRoutineNode[], cycleCheck: Set<string>, alreadyTraversed: Set<string>,\n      result: GlslLibRoutineNode[]) {\n    for (let i = 0; i < graphNodes.length; ++i) {\n      this.dfsTraverse(graphNodes[i], cycleCheck, alreadyTraversed, result);\n    }\n  }\n\n  private static dfsTraverse(\n      root: GlslLibRoutineNode, cycleCheck: Set<string>, alreadyTraversed: Set<string>, result: GlslLibRoutineNode[]) {\n    // if this root has already been traversed return\n    if (!root || alreadyTraversed.has(root.name)) {\n      return;\n    }\n\n    // cyclic dependency has been detected\n    if (cycleCheck.has(root.name)) {\n      throw new Error('Cyclic dependency detected. Can\\'t topologically sort routines needed for shader.');\n    }\n\n    // hold this node to detect cycles if any\n    cycleCheck.add(root.name);\n\n    // traverse children in a dfs fashion\n    const dependencies = root.dependencies;\n    if (dependencies && dependencies.length > 0) {\n      for (let i = 0; i < dependencies.length; ++i) {\n        this.dfsTraverse(dependencies[i], cycleCheck, alreadyTraversed, result);\n      }\n    }\n\n    // add to result holder\n    result.push(root);\n\n    // mark this node as traversed so that we don't traverse from this again\n    alreadyTraversed.add(root.name);\n\n    // release the hold\n    cycleCheck.delete(root.name);\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {GlslContext, GlslLib, GlslLibRoutine} from './glsl-definitions';\n\n/**\n * This GLSL library handles routines converting\n * float32 to/from Unsigned byte or float 16\n */\nexport class EncodingGlslLib extends GlslLib {\n  constructor(context: GlslContext) {\n    super(context);\n  }\n  getFunctions(): {[name: string]: GlslLibRoutine} {\n    return {...this.encodeFloat32(), ...this.decodeFloat32()};\n  }\n  getCustomTypes(): {[name: string]: string} {\n    return {};\n  }\n  protected encodeFloat32(): {[name: string]: GlslLibRoutine} {\n    return {\n      encode: new GlslLibRoutine(`highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        `)\n    };\n  }\n  protected decodeFloat32(): {[name: string]: GlslLibRoutine} {\n    return {\n      decode: new GlslLibRoutine(`highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        `)\n    };\n  }\n  /**\n   * returns the routine to encode encode a 32bit float to a vec4 (of unsigned bytes)\n   * @credit: https://stackoverflow.com/questions/7059962/how-do-i-convert-a-vec4-rgba-value-to-a-float\n   */\n  protected encodeUint8(): {[name: string]: GlslLibRoutine} {\n    const endianness = EncodingGlslLib.isLittleEndian() ? 'rgba.rgba=rgba.abgr;' : '';\n    return {\n      encode: new GlslLibRoutine(`\n      highp vec4 encode(highp float f) {\n        highp float F = abs(f);\n        highp float Sign = step(0.0,-f);\n        highp float Exponent = floor(log2(F));\n        highp float Mantissa = (exp2(- Exponent) * F);\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n        highp vec4 rgba;\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n        ${endianness}\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\n        return rgba;\n    }\n        `)\n    };\n  }\n  /**\n   * returns the routine to encode a vec4 of unsigned bytes to float32\n   * @credit: https://stackoverflow.com/questions/7059962/how-do-i-convert-a-vec4-rgba-value-to-a-float\n   */\n  protected decodeUint8(): {[name: string]: GlslLibRoutine} {\n    const endianness = EncodingGlslLib.isLittleEndian() ? 'rgba.rgba=rgba.abgr;' : '';\n    return {\n      decode: new GlslLibRoutine(`\n        highp float decode(highp vec4 rgba) {\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\n          ${endianness}\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n          return Result;\n      }\n        `)\n    };\n  }\n  /**\n   * Determines if the machine is little endian or not\n   * @credit: https://gist.github.com/TooTallNate/4750953\n   */\n  static isLittleEndian(): boolean {\n    const b = new ArrayBuffer(4);\n    const a = new Uint32Array(b);\n    const c = new Uint8Array(b);\n    a[0] = 0xdeadbeef;\n    if (c[0] === 0xef) {\n      return true;\n    }\n    if (c[0] === 0xde) {\n      return false;\n    }\n    throw new Error('unknown endianness');\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {GlslContext, GlslLib, GlslLibRoutine} from './glsl-definitions';\nimport {getGlsl} from './glsl-source';\n\n/**\n * This GLSL library handles routines around reading a texlet and writing to it\n * Reading and writing could be more than just dealing with one channel\n * It may require encoding/decoding to/from 4 channels into one\n */\nexport class FragColorGlslLib extends GlslLib {\n  constructor(context: GlslContext) {\n    super(context);\n  }\n  getFunctions(): {[name: string]: GlslLibRoutine} {\n    return {...this.setFragColor(), ...this.getColorAsFloat()};\n  }\n  getCustomTypes(): {[name: string]: string} {\n    return {};\n  }\n  protected setFragColor(): {[name: string]: GlslLibRoutine} {\n    const glsl = getGlsl(this.context.glContext.version);\n    return {\n      setFragColor: new GlslLibRoutine(\n          `\n        void setFragColor(float value) {\n            ${glsl.output} = encode(value);\n        }\n        `,\n          ['encoding.encode'])\n    };\n  }\n  protected getColorAsFloat(): {[name: string]: GlslLibRoutine} {\n    return {\n      getColorAsFloat: new GlslLibRoutine(\n          `\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        `,\n          ['encoding.decode'])\n    };\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nconst INLINE_FUNC_DEF_REGEX = /@inline[\\s\\n\\r]+(\\w+)[\\s\\n\\r]+([0-9a-zA-Z_]+)\\s*\\(([^)]*)\\)\\s*{(([^}]|[\\n\\r])*)}/gm;\nconst FUNC_CALL_REGEX = '(\\\\w+)?\\\\s+([_0-9a-zA-Z]+)\\\\s+=\\\\s+__FUNC__\\\\((.*)\\\\)\\\\s*;';\n/**\n * GLSL preprocessor responsible for resolving @inline directives\n */\nexport function replaceInlines(script: string): string {\n  const inlineDefs: {[name: string]: {params: Array<{type: string; name: string}|null>; body: string}} = {};\n  let match;\n  while ((match = INLINE_FUNC_DEF_REGEX.exec(script)) !== null) {\n    const params = match[3]\n                       .split(',')\n                       .map(s => {\n                         const tokens = s.trim().split(' ');\n                         if (tokens && tokens.length === 2) {\n                           return {type: tokens[0], name: tokens[1]};\n                         }\n                         return null;\n                       })\n                       .filter(v => v !== null);\n    inlineDefs[match[2]] = {params, body: match[4]};\n  }\n  for (const name in inlineDefs) {\n    const regexString = FUNC_CALL_REGEX.replace('__FUNC__', name);\n    const regex = new RegExp(regexString, 'gm');\n    while ((match = regex.exec(script)) !== null) {\n      const type = match[1];\n      const variable = match[2];\n      const params = match[3].split(',');\n      const declLine = (type) ? `${type} ${variable};` : '';\n      let newBody: string = inlineDefs[name].body;\n      let paramRedecLine = '';\n      inlineDefs[name].params.forEach((v, i) => {\n        if (v) {\n          paramRedecLine += `${v.type} ${v.name} = ${params[i]};\\n`;\n        }\n      });\n      newBody = `${paramRedecLine}\\n ${newBody}`;\n      newBody = newBody.replace('return', `${variable} = `);\n      const replacement = `\n      ${declLine}\n      {\n        ${newBody}\n      }\n      `;\n      script = script.replace(match[0], replacement);\n    }\n  }\n  script = script.replace(INLINE_FUNC_DEF_REGEX, '');\n  return script;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {GlslContext, GlslLib, GlslLibRoutineNode, TopologicalSortGlslRoutines} from './glsl-definitions';\nimport {replaceInlines} from './glsl-function-inliner';\nimport {glslRegistry} from './glsl-registered-libs';\nimport {getDefaultFragShaderMain, getFragShaderPreamble} from './glsl-source';\nimport {ProgramInfo, TextureLayout, VariableInfo} from './types';\nimport {WebGLContext} from './webgl-context';\n\n/**\n * Preprocessor for the additions to the GLSL language\n * It deals with:\n *  @include directives\n *  @inline\n *  Loop unrolling (not implemented)\n *  Macro resolution (not implemented)\n */\nexport class GlslPreprocessor {\n  readonly context: GlslContext;\n  readonly libs: {[name: string]: GlslLib} = {};\n  readonly glslLibRoutineDependencyGraph: {[routineName: string]: GlslLibRoutineNode} = {};\n\n  constructor(\n      glContext: WebGLContext, programInfo: ProgramInfo, inputTextureLayouts: TextureLayout[],\n      outputTextureLayout: TextureLayout) {\n    this.context = new GlslContext(glContext, programInfo, inputTextureLayouts, outputTextureLayout);\n\n    // construct GlslLibs\n    Object.keys(glslRegistry).forEach((name: string) => {\n      const lib = new glslRegistry[name](this.context);\n      this.libs[name] = lib;\n    });\n\n    // construct GlslRoutineDependencyGraph\n    const map = this.glslLibRoutineDependencyGraph;\n    for (const libName in this.libs) {\n      const lib = this.libs[libName];\n      const routinesInLib = lib.getFunctions();\n      for (const routine in routinesInLib) {\n        const key = libName + '.' + routine;\n        let currentNode: GlslLibRoutineNode;\n        if (map[key]) {\n          currentNode = map[key];\n          currentNode.routineBody = routinesInLib[routine].routineBody;\n        } else {\n          currentNode = new GlslLibRoutineNode(key, routinesInLib[routine].routineBody);\n          map[key] = currentNode;\n        }\n        const dependencies = routinesInLib[routine].dependencies;\n        if (dependencies) {\n          for (let i = 0; i < dependencies.length; ++i) {\n            if (!map[dependencies[i]]) {\n              const node = new GlslLibRoutineNode(dependencies[i]);\n              map[dependencies[i]] = node;\n              currentNode.addDependency(node);\n            } else {\n              currentNode.addDependency(map[dependencies[i]]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  preprocess(): string {\n    const programInfo = this.context.programInfo;\n    let source = programInfo.shaderSource;\n\n    // append main() function\n    if (!this.context.programInfo.hasMain) {\n      source = `${source}\n      ${getDefaultFragShaderMain(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`;\n    }\n    // replace inlines\n    source = replaceInlines(source);\n\n    // concat final source string\n    return `${getFragShaderPreamble(this.context.glContext.version)}\n    ${this.getUniforms(programInfo.inputNames, programInfo.variables)}\n    ${this.getImports(source)}\n    ${source}`;\n  }\n\n  protected getImports(script: string): string {\n    const routinesIncluded = this.selectGlslLibRoutinesToBeIncluded(script);\n\n    if (routinesIncluded.length === 0) {\n      return '';\n    }\n\n    let routines = '';\n    for (let i = 0; i < routinesIncluded.length; ++i) {\n      if (routinesIncluded[i].routineBody) {\n        routines += routinesIncluded[i].routineBody + '\\n';\n      } else {\n        throw new Error(`Missing body for the Glsl Library routine: ${routinesIncluded[i].name}`);\n      }\n    }\n\n    return routines;\n  }\n  private selectGlslLibRoutinesToBeIncluded(script: string): GlslLibRoutineNode[] {\n    const nodes: GlslLibRoutineNode[] = [];\n\n    Object.keys(this.glslLibRoutineDependencyGraph).forEach(classAndRoutine => {\n      const routine = classAndRoutine.split('.')[1];\n      if (script.indexOf(routine) !== -1) {\n        nodes.push(this.glslLibRoutineDependencyGraph[classAndRoutine]);\n      }\n    });\n\n    return TopologicalSortGlslRoutines.returnOrderedNodes(nodes);\n  }\n\n  protected getUniforms(samplers?: string[], variables?: VariableInfo[]): string {\n    const uniformLines: string[] = [];\n    if (samplers) {\n      for (const sampler of samplers) {\n        uniformLines.push(`uniform sampler2D ${sampler};`);\n      }\n    }\n    if (variables) {\n      for (const variable of variables) {\n        uniformLines.push(\n            `uniform ${variable.type} ${variable.name}${variable.arrayLength ? `[${variable.arrayLength}]` : ''};`);\n      }\n    }\n    return uniformLines.join('\\n');\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {CoordsGlslLib} from './glsl-coordinate-lib';\nimport {GlslContext, GlslLib} from './glsl-definitions';\nimport {EncodingGlslLib} from './glsl-encoding-lib';\nimport {FragColorGlslLib} from './glsl-fragcolor-lib';\nimport {ShapeUtilsGlslLib} from './glsl-shape-utils-lib';\nimport {VecGlslLib} from './glsl-vec-lib';\n\nexport const glslRegistry: {[name: string]: new (context: GlslContext) => GlslLib} = {\n  'encoding': EncodingGlslLib,\n  'fragcolor': FragColorGlslLib,\n  'vec': VecGlslLib,\n  'shapeUtils': ShapeUtilsGlslLib,\n  'coordinates': CoordsGlslLib,\n  //  'arrays': ArrayGlslSLib\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {GlslContext, GlslLib, GlslLibRoutine} from './glsl-definitions';\n\n/**\n * GLSL Library responsible for data types and routines for manipulating\n * coordinates and mapping to/from tensor indices\n */\nexport class ShapeUtilsGlslLib extends GlslLib {\n  constructor(context: GlslContext) {\n    super(context);\n  }\n  getFunctions(): {[name: string]: GlslLibRoutine} {\n    return {\n      ...this.bcastIndex(),\n      ...this.bcastMatmulIndex(),\n      ...this.offsetToIndices(),\n      ...this.indicesToOffset(),\n      ...this.incrementIndices()\n    };\n  }\n  getCustomTypes() {\n    return {};\n  }\n  protected bcastIndex(): {[name: string]: GlslLibRoutine} {\n    const outputRank = this.context.outputTextureLayout.shape.length;\n    const result: {[name: string]: GlslLibRoutine} = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const shape = this.context.inputTextureLayouts[i].unpackedShape;\n      if (shape.length <= outputRank) {\n        const rank = shape.length;\n        const dimOffset = outputRank - rank;\n        const funcName = `bcastIndices_${name}`;\n        let block = '';\n        for (let i = 0; i < rank; ++i) {\n          block += `\n          realIndices[${i}] = int( mod(float(bcastedIndices[${dimOffset + i}]), ${shape[i]}.0) );\n          `;\n        }\n        const body = `\n        void ${funcName} (int bcastedIndices[${outputRank}], out int realIndices[${rank}]) {\n          ${block}\n        }\n        `;\n        result[funcName] = new GlslLibRoutine(body);\n      }\n    });\n    return result;\n  }\n  protected bcastMatmulIndex(): {[name: string]: GlslLibRoutine} {\n    const outputRank = this.context.outputTextureLayout.shape.length;\n    const result: {[name: string]: GlslLibRoutine} = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const shape = this.context.inputTextureLayouts[i].shape;\n      if (!(shape.length < 2 || shape.length > outputRank)) {\n        const rank = shape.length;\n        const dimOffset = outputRank - rank;\n        const funcName = `bcastMatmulIndices_${name}`;\n        let block = '';\n        for (let i = 0; i < rank - 2; ++i) {\n          block += `\n          realIndices[${i}] = int( mod(float(bcastedIndices[${dimOffset + i}]), ${shape[i]}.0) );\n          `;\n        }\n        const body = `\n        void ${funcName}(int bcastedIndices[${outputRank}], out int realIndices[${rank}]) {\n          ${block}\n          realIndices[${rank - 1}] = bcastedIndices[${outputRank - 1}];\n          realIndices[${rank - 2}] = bcastedIndices[${outputRank - 2}];\n        }\n        `;\n        result[funcName] = new GlslLibRoutine(body);\n      }\n    });\n    return result;\n  }\n  protected indicesToOffset(): {[name: string]: GlslLibRoutine} {\n    const result: {[name: string]: GlslLibRoutine} = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const shape = this.context.inputTextureLayouts[i].shape;\n      const strides = this.context.inputTextureLayouts[i].strides;\n      const rank = shape.length;\n      let funcName = `indicesToOffset_${name}`;\n      result[funcName] = new GlslLibRoutine(ShapeUtilsGlslLib.indexToOffsetSingle(funcName, rank, strides));\n      funcName = `indicesToOffset_${name}_T`;\n      result[funcName] =\n          new GlslLibRoutine(ShapeUtilsGlslLib.indexToOffsetSingle(funcName, rank, strides.slice().reverse()));\n    });\n    return result;\n  }\n  static indexToOffsetSingle(name: string, rank: number, strides: readonly number[]): string {\n    let block = '';\n    for (let i = rank - 1; i >= 0; --i) {\n      block += `\n        offset += indices[${i}] * ${strides[i]};\n        `;\n    }\n    return `\n      int ${name}(int indices[${rank}]) {\n        int offset = 0;\n        ${block}\n        return offset;\n      }\n      `;\n  }\n  protected offsetToIndices(): {[name: string]: GlslLibRoutine} {\n    const result: {[name: string]: GlslLibRoutine} = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const shape = this.context.inputTextureLayouts[i].shape;\n      const strides = this.context.inputTextureLayouts[i].strides;\n      const rank = shape.length;\n      let funcName = `offsetToIndices_${name}`;\n      result[funcName] = new GlslLibRoutine(ShapeUtilsGlslLib.offsetToIndicesSingle(funcName, rank, strides));\n      funcName = `offsetToIndices_${name}_T`;\n      result[funcName] =\n          new GlslLibRoutine(ShapeUtilsGlslLib.offsetToIndicesSingle(funcName, rank, strides.slice().reverse()));\n    });\n    return result;\n  }\n  static offsetToIndicesSingle(name: string, rank: number, strides: readonly number[]): string {\n    const stridesBlock = [];\n    for (let i = 0; i < rank - 1; ++i) {\n      stridesBlock.push(`\n      indices[${i}] = offset / ${strides[i]};`);\n      stridesBlock.push(`\n        offset -= indices[${i}] * ${strides[i]};`);\n    }\n    stridesBlock.push(`\n      indices[${rank - 1}] = offset;`);\n    return `\n      void ${name}(int offset, out int indices[${rank}]) {\n        ${stridesBlock.join('')}\n      }\n      `;\n  }\n  protected incrementIndices(): {[name: string]: GlslLibRoutine} {\n    const result: {[name: string]: GlslLibRoutine} = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const shape = this.context.inputTextureLayouts[i].shape;\n      const rank = shape.length;\n      const funcName = `incrementIndices_${name}`;\n      let shapeInit = '';\n      for (let i = 0; i < rank; ++i) {\n        shapeInit += `\n        shape[${i}] = ${shape[i]};`;\n      }\n      const body = `\n        void ${funcName}(int axis, out int indices[${rank}]) {\n          int shape[${rank}];\n          ${shapeInit};\n          for(int i = ${rank} -1 ; i >= 0; --i) {\n            if(i > axis) continue;\n            indices[i] += 1;\n            if(indices[i] < shape[i]) {\n              break;\n            }\n            indices[i] = 0;\n          }\n        }\n        `;\n      result[funcName] = new GlslLibRoutine(body);\n    });\n    return result;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/**\n * represent a version irrelevant abstraction of for GLSL source code\n */\nexport interface Glsl {\n  readonly version: string;\n  readonly attribute: string;\n  readonly varyingVertex: string;\n  readonly varyingFrag: string;\n  readonly texture2D: string;\n  readonly output: string;\n  readonly outputDeclaration: string;\n}\n\nconst GLSL_ES_2_0: Glsl = {\n  version: '',\n  attribute: 'attribute',\n  varyingVertex: 'varying',\n  varyingFrag: 'varying',\n  texture2D: 'texture2D',\n  output: 'gl_FragColor',\n  outputDeclaration: '',\n};\nconst GLSL_ES_3_0: Glsl = {\n  version: '#version 300 es',\n  attribute: 'in',\n  varyingVertex: 'out',\n  varyingFrag: 'in',\n  texture2D: 'texture',\n  output: 'outputColor',\n  outputDeclaration: 'out vec4 outputColor;',\n};\n\nexport function getGlsl(version: 1|2) {\n  return version === 1 ? GLSL_ES_2_0 : GLSL_ES_3_0;\n}\n\nexport function getVertexShaderSource(version: 1|2): string {\n  const glsl = getGlsl(version);\n  return `${glsl.version}\n      precision highp float;\n      ${glsl.attribute} vec3 position;\n      ${glsl.attribute} vec2 textureCoord;\n\n      ${glsl.varyingVertex} vec2 TexCoords;\n\n      void main()\n      {\n          gl_Position = vec4(position, 1.0);\n          TexCoords = textureCoord;\n      }`;\n}\n\nexport function getFragShaderPreamble(version: 1|2): string {\n  const glsl = getGlsl(version);\n  return `${glsl.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${glsl.varyingFrag} vec2 TexCoords;\n    ${glsl.outputDeclaration}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    // Custom vector types to handle higher dimenalities.\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    `;\n}\n\nexport function getDefaultFragShaderMain(version: 1|2, outputShapeLength: number): string {\n  const glsl = getGlsl(version);\n  return `\n  void main() {\n    int indices[${outputShapeLength}];\n    toVec(TexCoords, indices);\n    vec4 result = vec4(process(indices));\n    ${glsl.output} = result;\n  }\n  `;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {GlslContext, GlslLib, GlslLibRoutine} from './glsl-definitions';\n\n/**\n * GLSL Library responsible for vec routines\n * Vec is an varible length int array. The length is fixed at the time of\n * generating the library functions from the dimensions of the output.\n */\nexport class VecGlslLib extends GlslLib {\n  constructor(context: GlslContext) {\n    super(context);\n  }\n  getCustomTypes(): {[name: string]: string} {\n    return {};\n  }\n  getFunctions(): {[name: string]: GlslLibRoutine} {\n    return {...this.binaryVecFunctions(), ...this.copyVec(), ...this.setVecItem(), ...this.getVecItem()};\n  }\n  protected binaryVecFunctions(): {[name: string]: GlslLibRoutine} {\n    const outputLayout = this.context.outputTextureLayout;\n    const rank = outputLayout.shape.length;\n    const nameOp: {[name: string]: string} = {add: '+=', sub: '-=', mul: '*=', div: '/='};\n    const result: {[name: string]: GlslLibRoutine} = {};\n    for (const name in nameOp) {\n      const fname = `${name}Vec`;\n      let assignmentBlock = '';\n      for (let i = 0; i < rank; ++i) {\n        assignmentBlock += `\n          dest[${i}] ${nameOp[name]} src[${i}];\n          `;\n      }\n      const body = `\n        void ${fname}(int src[${rank}], out int dest[${rank}]) {\n          ${assignmentBlock}\n        }\n        `;\n      result[fname] = new GlslLibRoutine(body);\n    }\n\n    return result;\n  }\n  protected copyVec(): {[name: string]: GlslLibRoutine} {\n    const outputLayout = this.context.outputTextureLayout;\n    const rank = outputLayout.shape.length;\n    let assignmentBlock = '';\n    for (let i = 0; i < rank; ++i) {\n      assignmentBlock += `\n        dest[${i}] = src[${i}];\n        `;\n    }\n    const body = `\n      void copyVec(int src[${rank}], out int dest[${rank}]) {\n        ${assignmentBlock}\n      }\n      `;\n    return {copyVec: new GlslLibRoutine(body)};\n  }\n\n  protected setVecItem(): {[name: string]: GlslLibRoutine} {\n    const outputLayout = this.context.outputTextureLayout;\n    const rank = outputLayout.shape.length;\n    let block = `\n        if(index < 0)\n            index =${rank} + index;\n        if (index == 0)\n            m[0] = value;\n        `;\n    for (let i = 1; i < rank - 1; ++i) {\n      block += `\n        else if (index == ${i})\n            m[${i}] = value;\n            `;\n    }\n    block += `\n        else\n            m[${rank - 1}] = value;\n        `;\n    const body = `\n      void setVecItem(out int m[${rank}], int index, int value) {\n        ${block}\n      }\n        `;\n    return {setVecItem: new GlslLibRoutine(body)};\n  }\n  protected getVecItem(): {[name: string]: GlslLibRoutine} {\n    const outputLayout = this.context.outputTextureLayout;\n    const rank = outputLayout.shape.length;\n    let block = `\n        if(index < 0)\n            index = ${rank} + index;\n        if (index == 0)\n            return m[0];\n      `;\n    for (let i = 1; i < rank - 1; ++i) {\n      block += `\n        else if (index == ${i})\n            return m[${i}];\n      `;\n    }\n    block += `\n        else\n            return m[${rank - 1}];\n        `;\n    const body = `\n      int getVecItem(int m[${rank}], int index) {\n        ${block}\n      }\n    `;\n    return {getVecItem: new GlslLibRoutine(body)};\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {InferenceHandler} from '../../backend';\nimport {Logger} from '../../instrument';\nimport {Tensor} from '../../tensor';\nimport {ShapeUtil} from '../../util';\n\nimport {createPackProgramInfoLoader} from './ops/pack';\nimport {createPackedReshape3DProgramInfoLoader, isReshapeCheap, processDims3D} from './ops/reshape-packed';\nimport {encodeAsUint8} from './ops/uint8-encode';\nimport {createUnpackProgramInfoLoader} from './ops/unpack';\nimport {WebGLSessionHandler} from './session-handler';\nimport {Encoder} from './texture-data-encoder';\nimport {calculateTextureWidthAndHeight, createTextureLayoutFromShape, createTextureLayoutFromTextureType} from './texture-layout';\nimport {Artifact, ProgramInfo, ProgramInfoLoader, TextureData, TextureLayout, TextureType} from './types';\n\nconst getProgramInfoUniqueKey =\n    (programInfo: ProgramInfo|ProgramInfoLoader, inputTextureDatas: TextureData[]): string => {\n      const inputs =\n          inputTextureDatas.map(texture => `${texture.unpackedShape.join(',')};${texture.width}x${texture.height}`)\n              .join('_');\n      let key = programInfo.name;\n      if (programInfo.cacheHint) {\n        key += '[' + programInfo.cacheHint + ']';\n      }\n      key += ':' + inputs;\n      return key;\n    };\n\nexport class WebGLInferenceHandler implements InferenceHandler {\n  private packedTextureDataCache: Map<Tensor.Id, TextureData>;\n  private unpackedTextureDataCache: Map<Tensor.Id, TextureData>;\n  constructor(public session: WebGLSessionHandler) {\n    this.packedTextureDataCache = new Map();\n    this.unpackedTextureDataCache = new Map();\n  }\n\n  /**\n   * @returns [width, height]\n   */\n  calculateTextureWidthAndHeight(shape: readonly number[], textureType: TextureType): [number, number] {\n    return calculateTextureWidthAndHeight(this.session.layoutStrategy, shape, textureType);\n  }\n\n  executeProgram(program: ProgramInfo|ProgramInfoLoader, inputs: readonly Tensor[]): TextureData {\n    if (inputs.length < program.inputNames.length) {\n      throw new Error(`Input size mustn't be less than ${program.inputNames.length}.`);\n    }\n    if (program.inputNames.length !== program.inputTypes.length) {\n      throw new Error('input names size does not match input types');\n    }\n\n    // create texture info for input\n    const inputTextureDatas: TextureData[] = [];\n    for (let i = 0; i < program.inputNames.length; ++i) {\n      inputTextureDatas[i] = this.getOrCreateTextureData(inputs[i], program.inputTypes[i]);\n    }\n\n    const key = getProgramInfoUniqueKey(program, inputTextureDatas);\n    let artifact = this.session.programManager.getArtifact(key);\n    const programInfo = artifact ?\n        artifact.programInfo :\n        (typeof (program as ProgramInfoLoader).get === 'function' ? (program as ProgramInfoLoader).get() :\n                                                                    (program as ProgramInfo));\n\n    // create texture info for output\n    const outputTextureLayout = createTextureLayoutFromTextureType(\n        this.session.layoutStrategy, programInfo.output.dims, programInfo.output.textureType);\n    const outputTextureData = this.createTextureData(outputTextureLayout, programInfo.output.type);\n\n    if (!artifact) {\n      artifact = this.session.programManager.build(programInfo, inputTextureDatas, outputTextureData);\n      this.session.programManager.setArtifact(key, artifact);\n    }\n\n    this.runProgram(artifact, inputTextureDatas, outputTextureData);\n    return outputTextureData;\n  }\n\n  run(program: ProgramInfoLoader, inputs: readonly Tensor[]): Tensor {\n    const outputTextureData = this.executeProgram(program, inputs);\n    return outputTextureData.tensor;\n  }\n\n  private runProgram(artifact: Artifact, inputs: TextureData[], output: TextureData): void {\n    // input should match\n    for (let i = 0; i < inputs.length; ++i) {\n      if (!!inputs[i].isPacked !== (artifact.programInfo.inputTypes[i] === TextureType.packed)) {\n        throw new Error(`input[${i}] property packed inconsistent`);\n      }\n    }\n\n    // output should match\n    if (!!output.isPacked !== (artifact.programInfo.output.textureType === TextureType.packed)) {\n      throw new Error('output property packed inconsistent');\n    }\n\n    this.session.programManager.run(artifact, inputs, output);\n  }\n\n  /**\n   * Create a TextureData object from a tensor.\n   * Usage = Encoder.Usage.UploadOnly.\n   * If a related texture data is found in cache, returns it;\n   * Otherwise:\n   *   Creates a new texture layout if not provided;\n   *   Creates WebGLTexture with the layout;\n   *   Upload tensor data to the texture;\n   *   Creates a texture data object associated with the given tensor.\n   * @param tensor the tensor with data to upload\n   */\n  private getOrCreateTextureData(tensor: Tensor, textureType: TextureType) {\n    let td = this.getTextureData(tensor.dataId, textureType === TextureType.packed);\n\n    if (!td) {\n      // check if we have texture data in different type\n      td = this.getTextureData(tensor.dataId, textureType !== TextureType.packed);\n      if (td) {\n        if (textureType === TextureType.packed) {\n          return this.pack(td);\n        } else {\n          return this.unpack(td);\n        }\n      }\n    }\n\n    if (!td) {\n      const layout = createTextureLayoutFromTextureType(this.session.layoutStrategy, tensor.dims, textureType);\n\n      if (textureType === TextureType.packedLastDimension) {\n        const group = 1;\n        const channels = 4;\n        const shape = tensor.dims;\n        if (shape.length === 4) {\n          // pre-processing for kernel data of Conv.\n          //\n          // TODO: currently this is a hacking to overwrite Conv's weight. The correct way to do this should be:\n          // 1. implement texture based const-folding\n          // 2. create a WebGL program \"preprocessConvWeight\" to do the same work as below\n          // 3. run the program before dotProduct.\n          //\n          const adjustedKernelShape = [shape[0], Math.ceil((shape[1] * shape[2] * shape[3]) / channels)];\n          const adjustedLayout =\n              createTextureLayoutFromTextureType(this.session.layoutStrategy, adjustedKernelShape, textureType);\n          let buffer = tensor.numberData;\n          if (shape[1] * shape[2] * shape[3] % channels !== 0) {\n            const numFeatureMaps = shape[0];\n            const oldRowSize = shape[1] * shape[2] * shape[3];\n            const newRowSize = Math.ceil(oldRowSize * group / channels) * channels;\n            const newSize = numFeatureMaps * newRowSize;\n            buffer = new Float32Array(newSize);\n            for (let f = 0; f < numFeatureMaps; ++f) {\n              const oldOffset = f * oldRowSize;\n              const newOffset = f * newRowSize + f % group * oldRowSize;\n              buffer.set(tensor.numberData.subarray(oldOffset, oldOffset + oldRowSize), newOffset);\n            }\n          }\n          return this.createTextureData(adjustedLayout, tensor.type, buffer, tensor, Encoder.Usage.UploadOnly);\n        }\n      }\n\n      if (textureType === TextureType.packed) {\n        const unpackedTextureLayout =\n            createTextureLayoutFromShape(this.session.layoutStrategy, tensor.dims, 1, [], {reverseWH: true});\n        const unpackedTextureData = this.createTextureData(\n            unpackedTextureLayout, tensor.type, tensor.numberData, tensor, Encoder.Usage.UploadOnly);\n        td = this.pack(unpackedTextureData);\n      } else {\n        td = this.createTextureData(layout, tensor.type, tensor.numberData, tensor, Encoder.Usage.UploadOnly);\n      }\n    }\n    return td;\n  }\n\n  /**\n   * Create a TextureData object using the given data and bind to the given tensor.\n   * Usage = Encoder.Usage.UploadOnly.\n   * NOTE: this function is a hack for Conv implementation. should remove this function, after rewriting Conv\n   * implementation by Graph.Transformer\n   * @param dataType the tensor data type\n   * @param data the actual data to upload\n   * @param tensor the tensor to bind. tensor's data is ignored.\n   */\n  createTextureDataFromLayoutBindTensor(\n      layout: TextureLayout, dataType: Tensor.DataType, data: Tensor.NumberType, tensor: Tensor): TextureData {\n    return this.createTextureData(layout, dataType, data, tensor, Encoder.Usage.UploadOnly);\n  }\n\n  private createTextureData(\n      layout: TextureLayout, dataType: Tensor.DataType, data?: Tensor.NumberType, tensor?: Tensor,\n      usage?: Encoder.Usage): TextureData {\n    Logger.verbose('InferenceHandler', `Creating TextureData: layout:[${JSON.stringify(layout)}]`);\n    const texture = this.session.textureManager.createTextureFromLayout(dataType, layout, data, usage);\n    return this.createTextureDataFromTexture(layout, dataType, texture, tensor);\n  }\n\n  reshapeUnpacked(input: Tensor, reshapedDims: readonly number[]): Tensor {\n    const inputTD = this.getOrCreateTextureData(input, TextureType.unpacked);\n    const newTextureLayout: TextureLayout = {\n      channels: inputTD.channels,\n      height: inputTD.height,\n      width: inputTD.width,\n      // handle reshaping into scalar Tensors\n      shape: reshapedDims.length !== 0 ? reshapedDims : [1],\n      strides: ShapeUtil.computeStrides(reshapedDims),\n      unpackedShape: reshapedDims,\n    };\n    const newTextureData = this.createTextureDataFromTexture(newTextureLayout, input.type, inputTD.texture);\n    return newTextureData.tensor;\n  }\n\n  reshapePacked(input: Tensor, reshapedDims: readonly number[]): Tensor {\n    const inputTD = this.getOrCreateTextureData(input, TextureType.packed);\n\n    // check if the reshape is 'cheap'\n    if (isReshapeCheap(input.dims, reshapedDims)) {\n      const newTextureLayout: TextureLayout = {\n        channels: inputTD.channels,\n        height: inputTD.height,\n        width: inputTD.width,\n        // handle reshaping into scalar Tensors\n        shape: reshapedDims.length !== 0 ? reshapedDims : [1],\n        strides: ShapeUtil.computeStrides(reshapedDims),\n        unpackedShape: reshapedDims,\n        isPacked: true\n      };\n      const newTextureData = this.createTextureDataFromTexture(newTextureLayout, input.type, inputTD.texture);\n      return newTextureData.tensor;\n    }\n\n    const squeezedInputShape = processDims3D(input.dims);\n    const squeezedOutputShape = processDims3D(reshapedDims);\n\n    const squeezedInputTensor = this.reshapePacked(input, squeezedInputShape);\n    const squeezedOutputTensor = this.run(\n        createPackedReshape3DProgramInfoLoader(this, squeezedInputTensor, squeezedOutputShape), [squeezedInputTensor]);\n    const outputTensor = this.reshapePacked(squeezedOutputTensor, reshapedDims);\n    return outputTensor;\n  }\n\n  cast(input: Tensor, type: Tensor.DataType): Tensor {\n    const inputTD = this.getOrCreateTextureData(input, TextureType.unpacked);\n    const newTextureData = this.createTextureDataFromTexture(inputTD as TextureLayout, type, inputTD.texture);\n    return newTextureData.tensor;\n  }\n\n  private createTextureDataFromTexture(\n      layout: TextureLayout, dataType: Tensor.DataType, texture: WebGLTexture, tensor?: Tensor, tensorId?: Tensor.Id) {\n    const textureData: TextureData = {\n      ...layout,\n      tensor: tensor ||\n          new Tensor(\n                  layout.unpackedShape, dataType, (_id: Tensor.Id) => this.readTexture(textureData),\n                  async (_id: Tensor.Id) => this.readTextureAsync(textureData), undefined, tensorId),\n      texture\n    };\n    this.setTextureData(textureData.tensor.dataId, textureData, layout.isPacked);\n    return textureData;\n  }\n\n  private getTextureData(tensorId: Tensor.Id, isPacked = false): TextureData|undefined {\n    return this.session.isInitializer(tensorId) ? this.session.getTextureData(tensorId, isPacked) :\n        isPacked                                ? this.packedTextureDataCache.get(tensorId) :\n                                                  this.unpackedTextureDataCache.get(tensorId);\n  }\n  setTextureData(tensorId: Tensor.Id, td: TextureData, isPacked = false): void {\n    if (this.session.isInitializer(tensorId)) {\n      this.session.setTextureData(tensorId, td, isPacked);\n    } else {\n      (isPacked ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(tensorId, td);\n    }\n  }\n  isTextureLayoutCached(tensor: Tensor, isPacked = false): boolean {\n    return !!this.getTextureData(tensor.dataId, isPacked);\n  }\n\n  dispose(): void {\n    this.session.textureManager.clearActiveTextures();\n    this.packedTextureDataCache.forEach(td => this.session.textureManager.releaseTexture(td));\n    this.packedTextureDataCache = new Map();\n    this.unpackedTextureDataCache.forEach(td => this.session.textureManager.releaseTexture(td));\n    this.unpackedTextureDataCache = new Map();\n  }\n\n  readTexture(textureData: TextureData): Tensor.NumberType {\n    if (textureData.isPacked) {\n      return this.readTexture(this.unpack(textureData));\n    }\n    if (!this.session.backend.glContext.isFloat32DownloadSupported) {\n      return this.session.textureManager.readUint8TextureAsFloat(encodeAsUint8(this, textureData));\n    }\n    return this.session.textureManager.readTexture(textureData, textureData.tensor.type, textureData.channels);\n  }\n\n  async readTextureAsync(textureData: TextureData): Promise<Tensor.NumberType> {\n    if (textureData.isPacked) {\n      return this.readTextureAsync(this.unpack(textureData));\n    }\n    if (!this.session.backend.glContext.isFloat32DownloadSupported) {\n      return this.session.textureManager.readUint8TextureAsFloat(encodeAsUint8(this, textureData));\n    }\n    return this.session.textureManager.readTextureAsync(textureData, textureData.tensor.type, textureData.channels);\n  }\n\n  pack(input: TextureData): TextureData {\n    const outputTextureData = this.executeProgram(createPackProgramInfoLoader(this, input.tensor), [input.tensor]);\n    return outputTextureData;\n  }\n\n  unpack(input: TextureData): TextureData {\n    const outputTextureData = this.executeProgram(createUnpackProgramInfoLoader(this, input.tensor), [input.tensor]);\n    return outputTextureData;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {OpSet} from '../../opset';\n\nimport {batchNormalization, parseBatchNormalizationAttributes} from './ops/batch-normalization';\nimport * as binaryOps from './ops/binary-op';\nimport {cast, parseCastAttributes} from './ops/cast';\nimport {concat, parseConcatAttributes} from './ops/concat';\nimport {conv, parseConvAttributes} from './ops/conv';\nimport {convTranspose, parseConvTransposeAttributes} from './ops/conv-transpose';\nimport {depthToSpace, parseDepthToSpaceAttributes} from './ops/depth-to-space';\nimport {flatten, parseFlattenAttributes} from './ops/flatten';\nimport {gather, parseGatherAttributes} from './ops/gather';\nimport {gemm, parseGemmAttributesV11, parseGemmAttributesV7} from './ops/gemm';\nimport {imageScaler, parseImageScalerAttributes} from './ops/image-scaler';\nimport {instanceNormalization, parseInstanceNormalizationAttributes} from './ops/instance-normalization';\nimport {lrn, parseLrnAttributes} from './ops/lrn';\nimport {matMul, parseMatMulAttributes} from './ops/matmul';\nimport {padV11, padV2, parsePadAttributesV11, parsePadAttributesV2} from './ops/pad';\nimport {averagePool, globalAveragePool, globalMaxPool, maxPool, parseAveragePoolAttributes, parseGlobalAveragePoolAttributes, parseMaxPoolAttributes} from './ops/pool';\nimport {parseReduceAttributes, reduceLogSum, reduceLogSumSquare, reduceMax, reduceMean, reduceMin, reduceProd, reduceSum} from './ops/reduce';\nimport {reshape} from './ops/reshape';\nimport {parseResizeAttributesV10, parseResizeAttributesV11, resize} from './ops/resize-packed';\nimport {shape} from './ops/shape';\nimport {parseSliceAttributes, slice, sliceV10} from './ops/slice';\nimport {parseSoftmaxAttributes, parseSoftmaxAttributesV13, softmax, softmaxV13} from './ops/softmax';\nimport {parseSplitAttributes, split} from './ops/split';\nimport {parseSqueezeAttributes, squeeze, squeezeV13} from './ops/squeeze';\nimport {sum} from './ops/sum';\nimport {tile} from './ops/tile';\nimport {parseTransposeAttributes, transpose} from './ops/transpose';\nimport * as unaryOps from './ops/unary-op';\nimport {parseUnsqueezeAttributes, unsqueeze, unsqueezeV13} from './ops/unsqueeze';\nimport {parseUpsampleAttributesV7, parseUpsampleAttributesV9, upsample} from './ops/upsample';\n\nexport const WEBGL_OP_RESOLVE_RULES: readonly OpSet.ResolveRule[] = [\n  ['Abs', '', '6+', unaryOps.abs],\n  ['Acos', '', '7+', unaryOps.acos],\n  ['Add', '', '7+', binaryOps.add],\n  ['And', '', '7+', binaryOps.and],\n  ['Asin', '', '7+', unaryOps.asin],\n  ['Atan', '', '7+', unaryOps.atan],\n  // TODO: support new attributes for AveragePool-10\n  ['AveragePool', '', '7+', averagePool, parseAveragePoolAttributes],\n  ['BatchNormalization', '', '7+', batchNormalization, parseBatchNormalizationAttributes],\n  ['Cast', '', '6+', cast, parseCastAttributes],\n  ['Ceil', '', '6+', unaryOps.ceil],\n  ['Clip', '', '6-10', unaryOps.clip, unaryOps.parseClipAttributes],\n  ['Clip', '', '11+', unaryOps.clipV11],\n  ['Concat', '', '4+', concat, parseConcatAttributes],\n  ['Conv', '', '1+', conv, parseConvAttributes],\n  ['ConvTranspose', '', '1+', convTranspose, parseConvTransposeAttributes],\n  ['Cos', '', '7+', unaryOps.cos],\n  ['Div', '', '7+', binaryOps.div],\n  ['Dropout', '', '7+', unaryOps.identity],\n  ['DepthToSpace', '', '1+', depthToSpace, parseDepthToSpaceAttributes],\n  ['Equal', '', '7+', binaryOps.equal],\n  ['Elu', '', '6+', unaryOps.elu, unaryOps.parseEluAttributes],\n  ['Exp', '', '6+', unaryOps.exp],\n  ['Flatten', '', '1+', flatten, parseFlattenAttributes],\n  ['Floor', '', '6+', unaryOps.floor],\n  ['FusedConv', 'com.microsoft', '1+', conv, parseConvAttributes],\n  ['Gather', '', '1+', gather, parseGatherAttributes],\n  ['Gemm', '', '7-10', gemm, parseGemmAttributesV7],\n  ['Gemm', '', '11+', gemm, parseGemmAttributesV11],\n  ['GlobalAveragePool', '', '1+', globalAveragePool, parseGlobalAveragePoolAttributes],\n  ['GlobalMaxPool', '', '1+', globalMaxPool],\n  ['Greater', '', '7+', binaryOps.greater],\n  ['Identity', '', '1+', unaryOps.identity],\n  ['ImageScaler', '', '1+', imageScaler, parseImageScalerAttributes],\n  ['InstanceNormalization', '', '6+', instanceNormalization, parseInstanceNormalizationAttributes],\n  ['LeakyRelu', '', '6+', unaryOps.leakyRelu, unaryOps.parseLeakyReluAttributes],\n  ['Less', '', '7+', binaryOps.less],\n  ['LRN', '', '1+', lrn, parseLrnAttributes],\n  ['Log', '', '6+', unaryOps.log],\n  ['MatMul', '', '1+', matMul, parseMatMulAttributes],\n  // TODO: support new attributes for MaxPool-8 and MaxPool-10\n  ['MaxPool', '', '1+', maxPool, parseMaxPoolAttributes],\n  ['Mul', '', '7+', binaryOps.mul],\n  ['Neg', '', '6+', unaryOps.neg],\n  ['Not', '', '1+', unaryOps.not],\n  ['Or', '', '7+', binaryOps.or],\n  ['Pad', '', '2-10', padV2, parsePadAttributesV2],\n  ['Pad', '', '11+', padV11, parsePadAttributesV11],\n  ['Pow', '', '7+', binaryOps.pow],\n  ['PRelu', '', '7+', binaryOps.pRelu],\n  ['ReduceLogSum', '', '1+', reduceLogSum, parseReduceAttributes],\n  ['ReduceMax', '', '1+', reduceMax, parseReduceAttributes],\n  ['ReduceMean', '', '1+', reduceMean, parseReduceAttributes],\n  ['ReduceMin', '', '1+', reduceMin, parseReduceAttributes],\n  ['ReduceProd', '', '1+', reduceProd, parseReduceAttributes],\n  ['ReduceSum', '', '1-12', reduceSum, parseReduceAttributes],\n  ['ReduceSumSquare', '', '1+', reduceLogSumSquare, parseReduceAttributes],\n  ['Relu', '', '6+', unaryOps.relu],\n  ['Reshape', '', '5+', reshape],\n  ['Resize', '', '10', resize, parseResizeAttributesV10],\n  ['Resize', '', '11+', resize, parseResizeAttributesV11],\n  ['Shape', '', '1+', shape],\n  ['Sigmoid', '', '6+', unaryOps.sigmoid],\n  ['Sin', '', '7+', unaryOps.sin],\n  ['Slice', '', '10+', sliceV10],  // TODO: support 'steps' for Slice-10\n  ['Slice', '', '1-9', slice, parseSliceAttributes],\n  // The \"semantic\" meaning of axis has changed in opset-13.\n  ['Softmax', '', '1-12', softmax, parseSoftmaxAttributes],\n  ['Softmax', '', '13+', softmaxV13, parseSoftmaxAttributesV13],\n  // 'Split' operator has an optional attribute 'split'\n  // this attribute determines how the specified axis of input data is split.\n  // When the attribute is missing, we need the count of number of outputs\n  // so that we can determine the 'split' attribute from the runtime input to the Operator\n  ['Split', '', '2-12', split, parseSplitAttributes],\n  ['Sqrt', '', '6+', unaryOps.sqrt],\n  ['Squeeze', '', '1-12', squeeze, parseSqueezeAttributes],\n  ['Squeeze', '', '13+', squeezeV13],\n  ['Sub', '', '7+', binaryOps.sub],\n  ['Sum', '', '6+', sum],\n  ['Tan', '', '7+', unaryOps.tan],\n  ['Tanh', '', '6+', unaryOps.tanh],\n  ['Tile', '', '6+', tile],\n  ['Transpose', '', '1+', transpose, parseTransposeAttributes],\n  ['Upsample', '', '7-8', upsample, parseUpsampleAttributesV7],\n  ['Upsample', '', '9', upsample, parseUpsampleAttributesV9],\n  ['Unsqueeze', '', '1-12', unsqueeze, parseUnsqueezeAttributes],\n  ['Unsqueeze', '', '13+', unsqueezeV13],\n  ['Xor', '', '7+', binaryOps.xor],\n];\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, TextureType} from '../types';\n\nexport interface BatchNormalizationAttributes extends AttributeWithCacheKey {\n  epsilon: number;\n  momentum: number;\n  spatial: number;\n}\n\nconst batchNormalizationProgramMetadata = {\n  name: 'BatchNormalization',\n  inputNames: ['A', 'Scale', 'B', 'Mean', 'Variance'],\n  inputTypes:\n      [TextureType.unpacked, TextureType.unpacked, TextureType.unpacked, TextureType.unpacked, TextureType.unpacked]\n};\n\nexport const batchNormalization: OperatorImplementation<BatchNormalizationAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: BatchNormalizationAttributes): Tensor[] => {\n      validateInputs(inputs);\n      const output = inferenceHandler.run(\n          {\n            ...batchNormalizationProgramMetadata,\n            cacheHint: attributes.cacheKey,\n            get: () => createBatchNormalizationProgramInfo(inferenceHandler, inputs, attributes)\n          },\n          inputs);\n      return [output];\n    };\n\nexport const parseBatchNormalizationAttributes: OperatorInitialization<BatchNormalizationAttributes> =\n    (node: Graph.Node): BatchNormalizationAttributes => {\n      const epsilon = node.attributes.getFloat('epsilon', 1e-5);\n      const momentum = node.attributes.getFloat('momentum', 0.9);\n      const spatial = node.attributes.getInt('spatial', 1);\n      return createAttributeWithCacheKey({epsilon, momentum, spatial});\n    };\n\nconst createBatchNormalizationProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: BatchNormalizationAttributes):\n        ProgramInfo => {\n          const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n          const rank = inputs[0].dims.length;\n          const [scaleWidth, scaleHeight] =\n              inferenceHandler.calculateTextureWidthAndHeight(inputs[1].dims, TextureType.unpacked);\n          const shaderSource = `\n  float process(int[${rank}] indices) {\n    vec2 position = offsetToCoords(indices[1], ${scaleWidth}, ${scaleHeight});\n    float scale = getColorAsFloat(${glsl.texture2D}(Scale, position));\n    float mean = getColorAsFloat(${glsl.texture2D}(Mean, position));\n    float variance = getColorAsFloat(${glsl.texture2D}(Variance, position));\n    float b = getColorAsFloat(${glsl.texture2D}(B, position));\n\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${attributes.epsilon})) ) + b;\n  }`;\n          return {\n            ...batchNormalizationProgramMetadata,\n            output: {dims: inputs[0].dims, type: inputs[0].type, textureType: TextureType.unpacked},\n            shaderSource\n          };\n        };\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 5) {\n    throw new Error('BatchNormalization requires 5 inputs.');\n  }\n\n  const X = inputs[0];\n  const scale = inputs[1];\n  const B = inputs[2];\n  const mean = inputs[3];\n  const var_ = inputs[4];\n\n  // input should atleast have three dimensions - N,C,dim1,...,dimn\n  // other inputs can have only one dimensions\n  if (X.dims.length < 3 || scale.dims.length !== 1 || B.dims.length !== 1 || mean.dims.length !== 1 ||\n      var_.dims.length !== 1) {\n    throw new Error('invalid input shape.');\n  }\n  if (scale.dims[0] !== X.dims[1] || B.dims[0] !== X.dims[1] || mean.dims[0] !== X.dims[1] ||\n      var_.dims[0] !== X.dims[1]) {\n    throw new Error('invalid input shape.');\n  }\n  if ((X.type !== 'float32' && X.type !== 'float64') || (scale.type !== 'float32' && scale.type !== 'float64') ||\n      (B.type !== 'float32' && B.type !== 'float64') || (mean.type !== 'float32' && mean.type !== 'float64') ||\n      (var_.type !== 'float32' && var_.type !== 'float64')) {\n    throw new Error('invalid input tensor types.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {BroadcastUtil, ShapeUtil} from '../../../util';\nimport {FunctionType, GlslValueFunction} from '../glsl-definitions';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, TextureType} from '../types';\n\nexport function glslAdd(): GlslValueFunction {\n  const name = 'add_';\n  const body = `\n  float ${name}(float a, float b) {\n    return a + b;\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return v1 + v2;\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslDiv(): GlslValueFunction {\n  const name = 'div_';\n  const body = `\n  float ${name}(float a, float b) {\n    return a / b;\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return v1 / v2;\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslMul(): GlslValueFunction {\n  const name = 'mul_';\n  const body = `\n  float ${name}(float a, float b) {\n    return a * b;\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return v1 * v2;\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslSub(): GlslValueFunction {\n  const name = 'sub_';\n  const body = `\n  float ${name}(float a, float b) {\n    return a - b;\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return v1 - v2;\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslEqual(): GlslValueFunction {\n  const name = 'equal_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float(a == b);\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return vec4(equal(v1, v2));\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslGreater(): GlslValueFunction {\n  const name = 'greater_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float(a > b);\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return vec4( v1.r > v2.r ,\n      v1.g > v2.g,\n      v1.b > v2.b,\n      v1.a > v2.a );\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslLess(): GlslValueFunction {\n  const name = 'less_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float(a < b);\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return vec4( v1.r < v2.r ,\n                v1.g < v2.g,\n                v1.b < v2.b,\n                v1.a < v2.a );\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslAnd(): GlslValueFunction {\n  const name = 'and_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float( bool(a) && bool(b) );\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r && b2.r ,\n                b1.g && b2.g,\n                b1.b && b2.b,\n                b1.a && b2.a );\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslOr(): GlslValueFunction {\n  const name = 'or_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float( bool(a) || bool(b) );\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r || b2.r ,\n                b1.g || b2.g,\n                b1.b || b2.b,\n                b1.a || b2.a );\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslXor(): GlslValueFunction {\n  const name = 'xor_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float( bool(a) ^^ bool(b) );\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r ^^ b2.r ,\n                b1.g ^^ b2.g,\n                b1.b ^^ b2.b,\n                b1.a ^^ b2.a );\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslPow(): GlslValueFunction {\n  return glslBuiltinBinary('pow');\n}\nexport function glslPRelu(): GlslValueFunction {\n  const name = 'prelu_';\n  const body = `\n  float ${name}(float a, float b) {\n    return a < 0.0 ? a * b: a;\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return vec4(\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\n      );\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\n\nfunction glslBuiltinBinary(fname: string): GlslValueFunction {\n  const name = `${fname}_`;\n  const body = `\n  float ${name}(float a, float b) {\n    return ${fname}(a, b);\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return ${fname}(v1, v2);\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\n\nconst createBinaryProgramInfoLoader =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], glslFunc: GlslValueFunction,\n     outputTensorType: Tensor.DataType = inputs[0].type, cacheKey?: string): ProgramInfoLoader => {\n      const textureType = handler.session.pack ? TextureType.packed : TextureType.unpacked;\n      return {\n        name: glslFunc.name,\n        inputNames: ['A', 'B'],\n        inputTypes: [textureType, textureType],\n        cacheHint: cacheKey,\n        get: () => createBinaryProgramInfo(handler, inputs, glslFunc, outputTensorType)\n      };\n    };\n\nconst createBinaryProgramInfo =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], glslFunc: GlslValueFunction,\n     outputTensorType: Tensor.DataType = inputs[0].type): ProgramInfo => {\n      const textureType = handler.session.pack ? TextureType.packed : TextureType.unpacked;\n      const isBroadcast = !ShapeUtil.areEqual(inputs[0].dims, inputs[1].dims);\n      let outputShape = inputs[0].dims;\n\n      const usePackedTexture = handler.session.pack;\n\n      if (isBroadcast) {\n        const calculatedShape = BroadcastUtil.calcShape(inputs[0].dims, inputs[1].dims, false);\n        if (!calculatedShape) {\n          throw new Error('Can\\'t perform binary op on the given tensors');\n        }\n        outputShape = calculatedShape;\n        const outputRank = outputShape.length;\n        const aRank = inputs[0].dims.length !== 0 ? inputs[0].dims.length : 1;\n        const bRank = inputs[1].dims.length !== 0 ? inputs[1].dims.length : 1;\n        const aBcast = inputs[0].dims.length !== 0 ? 'bcastIndices_A(indices, aindices);' : 'aindices[0] = 0;';\n        const bBcast = inputs[1].dims.length !== 0 ? 'bcastIndices_B(indices, bindices);' : 'bindices[0] = 0;';\n\n        const glsl = getGlsl(handler.session.backend.glContext.version);\n        const shaderSource = usePackedTexture ? `\n      ${glslFunc.body}\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n        vec4 result = ${glslFunc.name}(a, b);\n        ${glsl.output} = result;\n      }` :\n                                                `\n      ${glslFunc.body}\n      float process(int indices[${outputRank}]) {\n        int aindices[${aRank}];\n        int bindices[${bRank}];\n        ${aBcast}\n        ${bBcast}\n        return ${glslFunc.name}(_A(aindices), _B(bindices));\n      }`;\n\n        return {\n          name: glslFunc.name,\n          inputNames: ['A', 'B'],\n          inputTypes: [textureType, textureType],\n          output: {dims: outputShape, type: outputTensorType, textureType},\n          shaderSource,\n          hasMain: usePackedTexture\n        };\n      }\n      const glsl = getGlsl(handler.session.backend.glContext.version);\n      const shaderSource = `\n    ${glslFunc.body}\n    void main() {\n      vec4 v1 = ${glsl.texture2D}(A, TexCoords);\n      vec4 v2 = ${glsl.texture2D}(B, TexCoords);\n      vec4 result = ${glslFunc.name}(v1, v2);\n      ${glsl.output} = result;\n    }\n    `;\n\n      return {\n        name: glslFunc.name,\n        inputNames: ['A', 'B'],\n        inputTypes: [textureType, textureType],\n        output: {dims: inputs[0].dims, type: outputTensorType, textureType},\n        shaderSource,\n        hasMain: true\n      };\n    };\n\nexport const add = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslAdd()), inputs)];\n\nexport const and = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslAnd(), 'bool'), inputs)];\n\nexport const div = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslDiv()), inputs)];\n\nexport const equal = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslEqual(), 'bool'), inputs)];\n\nexport const greater = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslGreater(), 'bool'), inputs)];\n\nexport const less = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslLess(), 'bool'), inputs)];\n\nexport const mul = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslMul()), inputs)];\n\nexport const or = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslOr(), 'bool'), inputs)];\n\nexport const pow = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslPow()), inputs)];\n\nexport const pRelu = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslPRelu()), inputs)];\n\nexport const sub = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslSub()), inputs)];\n\nexport const xor = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslXor(), 'bool'), inputs)];\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {ProtoUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\n\nexport const cast: OperatorImplementation<Tensor.DataType> =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], to: Tensor.DataType): Tensor[] => {\n      validateInputs(inputs);\n      return [handler.cast(inputs[0], to)];\n    };\n\nexport const parseCastAttributes: OperatorInitialization<Tensor.DataType> = (node: Graph.Node): Tensor.DataType =>\n    ProtoUtil.tensorDataTypeFromProto(node.attributes.getInt('to'));\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Cast requires 1 input.');\n  }\n\n  if (inputs[0].type === 'string') {\n    throw new Error('Invalid input type.');\n  }\n};","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\nimport {getCoordsDataType, getGlChannels} from '../utils';\n\nimport {ConcatAttributes} from './concat';\nimport {getChannels, unpackFromChannel} from './packing-utils';\n\nconst createPackedConcatProgramMetadata = (inputCount: number, cacheHint: string) => ({\n  name: 'Concat (packed)',\n  inputNames: Array.from({length: inputCount}, (v, i) => `X${i}`),\n  inputTypes: Array(inputCount).fill(TextureType.packed),\n  cacheHint\n});\n\nconst createPackedConcatProgramInfo =\n    (handler: WebGLInferenceHandler, metadata: ProgramMetadata, inputs: Tensor[], axis: number): ProgramInfo => {\n      const inputShape = inputs[0].dims.slice();\n      if (axis >= inputShape.length || axis < (-1 * inputShape.length)) {\n        throw new Error('axis specified for concat doesn\\'t match input dimensionality');\n      }\n      if (axis < 0) {\n        axis = inputShape.length + axis;\n      }\n      // ensure all of the non-concatenated axes match each other\n      // calculate the shape of the output tensor while we do that\n      const outputShape = inputShape.slice(0);\n      for (let i = 1; i < inputs.length; i++) {\n        const dataNShape = inputs[i].dims.slice();\n        for (let axisIndex = 0; axisIndex < inputShape.length; axisIndex++) {\n          // add to the placeholder for computing output shape\n          if (axisIndex === axis) {\n            outputShape[axis] += dataNShape[axisIndex];\n          }\n          // ensure all non-cancatenated axes match each other\n          else if (inputShape[axisIndex] !== dataNShape[axisIndex]) {\n            throw new Error('non concat dimensions must match');\n          }\n        }\n      }\n\n      const rank = outputShape.length;\n      const coords = getChannels('coords', rank);\n      const dtype = getCoordsDataType(rank);\n      const unpackChannel = unpackFromChannel();\n\n      const shapes = inputs.map(i => i.dims);\n      const channels = getGlChannels(rank);\n      const offsets: number[] = new Array(shapes.length - 1);\n\n      offsets[0] = shapes[0][axis];\n      for (let i = 1; i < offsets.length; i++) {\n        offsets[i] = offsets[i - 1] + shapes[i][axis];\n      }\n\n      const channel = channels[axis];\n      const lastChannels = channels.slice(-2);\n      const allChannels = channels.join();\n\n      let getValueSnippet = `if (${channel} < ${offsets[0]}) {\n        return getChannel(\n            getX0(${allChannels}), vec2(${lastChannels.join()}));\n        }`;\n      for (let i = 1; i < offsets.length; i++) {\n        const shift = offsets[i - 1];\n        getValueSnippet += `\n            if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {\n              return getChannel(\n                getX${i}(${getShiftedChannelsSnippet(channels, channel, shift)}),\n                vec2(${getShiftedChannelsSnippet(lastChannels, channel, shift)}));\n            }`;\n      }\n      const lastIndex = offsets.length;\n      const shift = offsets[offsets.length - 1];\n      getValueSnippet += `\n            return getChannel(\n              getX${lastIndex}(${getShiftedChannelsSnippet(channels, channel, shift)}),\n              vec2(${getShiftedChannelsSnippet(lastChannels, channel, shift)}));`;\n\n      const glsl = getGlsl(handler.session.backend.glContext.version);\n\n      const shaderSource = `\n          ${unpackChannel}\n          float getValue(${channels.map(x => 'int ' + x)}) {\n            ${getValueSnippet}\n          }\n\n          void main() {\n            ${dtype} coords = getOutputCoords();\n            int lastDim = coords.${channels[rank - 1]};\n            coords.${channels[rank - 1]} = coords.${channels[rank - 2]};\n            coords.${channels[rank - 2]} = lastDim;\n\n            vec4 result = vec4(getValue(${coords}), 0., 0., 0.);\n\n            ${coords[rank - 1]} = ${coords[rank - 1]} + 1;\n            if (${coords[rank - 1]} < ${outputShape[rank - 1]}) {\n              result.g = getValue(${coords});\n            }\n\n            ${coords[rank - 2]} = ${coords[rank - 2]} + 1;\n            if (${coords[rank - 2]} < ${outputShape[rank - 2]}) {\n              result.a = getValue(${coords});\n            }\n\n            ${coords[rank - 1]} = ${coords[rank - 1]} - 1;\n            if (${coords[rank - 2]} < ${outputShape[rank - 2]} &&\n                ${coords[rank - 1]} < ${outputShape[rank - 1]}) {\n              result.b = getValue(${coords});\n            }\n            ${glsl.output} = result;\n          }\n        `;\n\n      return {\n        ...metadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.packed},\n        shaderSource,\n        hasMain: true,\n      };\n    };\n\nexport const createPackedConcatProgramInfoLoader =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], attributes: ConcatAttributes): ProgramInfoLoader => {\n      const metadata = createPackedConcatProgramMetadata(inputs.length, attributes.cacheKey);\n      return {...metadata, get: () => createPackedConcatProgramInfo(handler, metadata, inputs, attributes.axis)};\n    };\n\nconst getShiftedChannelsSnippet = (channels: string[], channel: string, shift: number): string => {\n  const channelIdx = channels.indexOf(channel);\n  const res = channels.map((c, idx) => {\n    if (idx === channelIdx) {\n      return `${c} - ${shift}`;\n    } else {\n      return c;\n    }\n  });\n  return res.join();\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\nimport {createPackedConcatProgramInfoLoader} from './concat-packed';\n\nexport interface ConcatAttributes extends AttributeWithCacheKey {\n  readonly axis: number;\n}\n\nexport const concat: OperatorImplementation<ConcatAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ConcatAttributes): Tensor[] => {\n      validateInputs(inputs);\n      if (inferenceHandler.session.pack && inputs[0].dims.length > 1) {\n        const output =\n            inferenceHandler.run(createPackedConcatProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);\n        return [output];\n      } else {\n        const output =\n            inferenceHandler.run(createUnpackedConcatProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);\n        return [output];\n      }\n    };\n\nconst createUnpackedConcatProgramMetadata = (inputCount: number, cacheHint: string) => ({\n  name: 'Concat',\n  inputNames: Array.from({length: inputCount}, (v, i) => `X${i}`),\n  inputTypes: Array(inputCount).fill(TextureType.unpacked),\n  cacheHint\n});\n\nconst createUnpackedConcatProgramInfo =\n    (handler: WebGLInferenceHandler, metadata: ProgramMetadata, inputs: Tensor[], axis: number): ProgramInfo => {\n      const inputShape = inputs[0].dims.slice();\n      if (axis >= inputShape.length || axis < (-1 * inputShape.length)) {\n        throw new Error('axis specified for concat doesn\\'t match input dimensionality');\n      }\n      if (axis < 0) {\n        axis = inputShape.length + axis;\n      }\n      // ensure all of the non-concatenated axes match each other\n      // calculate the shape of the output tensor while we do that\n      const outputShape = inputShape.slice(0);\n      for (let i = 1; i < inputs.length; i++) {\n        const dataNShape = inputs[i].dims.slice();\n        for (let axisIndex = 0; axisIndex < inputShape.length; axisIndex++) {\n          // add to the placeholder for computing output shape\n          if (axisIndex === axis) {\n            outputShape[axis] += dataNShape[axisIndex];\n          }\n          // ensure all non-cancatenated axes match each other\n          else if (inputShape[axisIndex] !== dataNShape[axisIndex]) {\n            throw new Error('non concat dimensions must match');\n          }\n        }\n      }\n\n      const rank = outputShape.length;\n\n      const sizeInConcatAxis = new Array<number>(inputs.length);\n      let previousSum = 0;\n      for (let i = 0; i < sizeInConcatAxis.length; ++i) {\n        previousSum += inputs[i].dims[axis];\n        sizeInConcatAxis[i] = previousSum;\n      }\n\n      let getTextureIndexWhereDataResidesMethod = '';\n      // in most cases linear search is sufficient, as in most scenarios, only 2 tensors are concatenated\n      if (inputs.length < 5) {\n        getTextureIndexWhereDataResidesMethod = getTextureIndexWhereDataResidesLinearSearch(sizeInConcatAxis);\n      } else {\n        getTextureIndexWhereDataResidesMethod = getTextureIndexWhereDataResidesBinarySearch(sizeInConcatAxis);\n      }\n\n      const fetchDataFromCorrectTextureMethod = getFetchDataFromCorrectTextureMethod(inputs.length, rank);\n      const getSizeInConcatAxisValueFromIndexMethod = getGetSizeInConcatAxisValueFromIndexMethod(sizeInConcatAxis);\n      const shaderSource = `\n        ${fetchDataFromCorrectTextureMethod}\n        ${getSizeInConcatAxisValueFromIndexMethod}\n        ${getTextureIndexWhereDataResidesMethod}\n        float process(int indices[${rank}]) {\n          int textureIndex = getTextureWhereDataResides (indices[${axis}]);\n\n          if(textureIndex != 0) {\n            indices[${axis}] = indices[${axis}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\n          }\n\n          return fetchDataFromCorrectTexture(textureIndex, indices);\n        }`;\n      return {\n        ...metadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n        shaderSource,\n      };\n    };\n\nconst createUnpackedConcatProgramInfoLoader =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], attributes: ConcatAttributes): ProgramInfoLoader => {\n      const metadata = createUnpackedConcatProgramMetadata(inputs.length, attributes.cacheKey);\n      return {...metadata, get: () => createUnpackedConcatProgramInfo(handler, metadata, inputs, attributes.axis)};\n    };\n\nconst getTextureIndexWhereDataResidesLinearSearch = (sizeInConcatAxis: number[]): string => {\n  const searchAxis = sizeInConcatAxis.map((size, i) => `if(index<${size}) {return ${i};}\n`);\n  return `int getTextureWhereDataResides(int index) {\n      ${searchAxis.join('')}\n    }`;\n};\n\n// TODO: Implement BinarySearch in GLSL\nconst getTextureIndexWhereDataResidesBinarySearch = (sizeInConcatAxis: number[]): string =>\n    getTextureIndexWhereDataResidesLinearSearch(sizeInConcatAxis);\n\nconst getFetchDataFromCorrectTextureMethod = (numberOfTensors: number, tensorRank: number) => {\n  const codeLines: string[] = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${tensorRank}]) {`];\n  for (let i = 0; i < numberOfTensors; ++i) {\n    if (i === 0) {\n      codeLines.push(\n          '\\t' +\n          `if (textureIndex == ${i}) { return _X${i}(indices); }`);\n    } else if (i === numberOfTensors - 1) {\n      codeLines.push(\n          '\\t' +\n          `else { return _X${i}(indices); }`);\n    } else {\n      codeLines.push(\n          '\\t' +\n          `else if (textureIndex == ${i}) { return _X${i}(indices); }`);\n    }\n  }\n  codeLines.push(\n      '\\t' +\n      '}');\n  return codeLines.join('\\n');\n};\n\nconst getGetSizeInConcatAxisValueFromIndexMethod = (sizeInConcatAxis: number[]): string => {\n  const codeLines: string[] = ['int getSizeInConcatAxisValueFromIndex(int index) {'];\n  for (let i = 0; i < sizeInConcatAxis.length; ++i) {\n    if (i === 0) {\n      codeLines.push(\n          '\\t' +\n          `if (index == ${i}) { return ${sizeInConcatAxis[i]}; }`);\n    } else if (i === sizeInConcatAxis.length - 1) {\n      codeLines.push(\n          '\\t' +\n          `else { return ${sizeInConcatAxis[i]}; }`);\n    } else {\n      codeLines.push(\n          '\\t' +\n          `else if (index == ${i}) { return ${sizeInConcatAxis[i]}; }`);\n    }\n  }\n  codeLines.push(\n      '\\t' +\n      '}');\n\n  return codeLines.join('\\n');\n};\n\nexport const parseConcatAttributes: OperatorInitialization<ConcatAttributes> = (node: Graph.Node): ConcatAttributes =>\n    createAttributeWithCacheKey({axis: node.attributes.getInt('axis')});\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length < 1) {\n    throw new Error('too few inputs');\n  }\n\n  const inputType = inputs[0].type;\n  const inputDimensionality = inputs[0].dims.length;\n\n  // TODO: Support string concat\n  if (inputType === 'string') {\n    throw new Error('string tensor is not supported yet');\n  }\n\n  for (const input of inputs) {\n    // make sure types of all inputs match\n    if (input.type !== inputType) {\n      throw new Error('input tensors should be one type');\n    }\n\n    // make sure the dimensionality of all inputs are the same\n    if (input.dims.length !== inputDimensionality) {\n      throw new Error('input tensors should have the same shape');\n    }\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Logger} from '../../../instrument';\nimport {Tensor} from '../../../tensor';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\nimport {calculateOutputShape, ConvAttributes} from './conv';\nimport {getActivationSnippet} from './fuse-utils';\n\nconst createUnpackedGroupedConvProgramMetadata = (hasBias: boolean, cacheHint: string): ProgramMetadata => ({\n  name: 'GroupedConv',\n  inputNames: hasBias ? ['X', 'W', 'Bias'] : ['X', 'W'],\n  inputTypes: hasBias ? [TextureType.unpacked, TextureType.unpacked, TextureType.unpacked] :\n                        [TextureType.unpacked, TextureType.unpacked],\n  cacheHint\n});\n\nconst createUnpackedGroupedConvProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, inputs: readonly Tensor[], metadata: ProgramMetadata,\n     attributes: ConvAttributes): ProgramInfo => {\n      const hasBias = inputs.length > 2;\n      const processBias = hasBias ? 'value += getBias(output_channel);' : '';\n      const xShape = inputs[0].dims.slice();\n      const wShape = inputs[1].dims.slice();\n      const outputChannelsPerGroup = wShape[0] / attributes.group;\n      Logger.verbose(\n          'GroupedConv',\n          `autpPad:${attributes.autoPad}, dilations:${attributes.dilations}, group:${attributes.group}, kernelShape:${\n              attributes.kernelShape}, pads:${attributes.pads}, strides:${attributes.strides}`);\n      const outputShape =\n          calculateOutputShape(xShape, wShape, attributes.dilations, attributes.pads, attributes.strides);\n      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n      const {activationFunction, applyActivation} = getActivationSnippet(attributes);\n\n      const shaderSource = `\n  const ivec2 strides = ivec2(${attributes.strides[0]}, ${attributes.strides[1]});\n  const ivec2 pads = ivec2(${attributes.pads[0]}, ${attributes.pads[1]});\n  ${activationFunction}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n    ivec2 xRCCorner = coords.zw * strides - pads;\n    int group_id = output_channel / ${outputChannelsPerGroup};\n\n    float value = 0.0;\n    for (int wInChannel = 0; wInChannel < ${wShape[1]}; wInChannel++) {\n      int input_channel = group_id * ${wShape[1]} + wInChannel;\n      for (int wHeight = 0; wHeight < ${wShape[2]}; wHeight++) {\n        int xHeight = xRCCorner.x + wHeight * ${attributes.dilations[0]};\n\n        if (xHeight < 0 || xHeight >= ${xShape[2]}) {\n          continue;\n        }\n\n        for (int wWidth = 0; wWidth < ${wShape[3]}; wWidth++) {\n          int xWidth = xRCCorner.y + wWidth * ${attributes.dilations[1]};\n          if (xWidth < 0 || xWidth >= ${xShape[3]}) {\n            continue;\n          }\n\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${processBias}\n    ${applyActivation}\n    ${glsl.output} = vec4(value, .0, .0, .0);\n  }\n`;\n      return {\n        ...metadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n        shaderSource,\n        hasMain: true,\n      };\n    };\n\nexport const createUnpackedGroupedConvProgramInfoLoader =\n    (inferenceHandler: WebGLInferenceHandler, inputs: readonly Tensor[], attributes: ConvAttributes):\n        ProgramInfoLoader => {\n          const metadata = createUnpackedGroupedConvProgramMetadata(inputs.length > 2, attributes.cacheKey);\n          return {\n            ...metadata,\n            get: () => createUnpackedGroupedConvProgramInfo(inferenceHandler, inputs, metadata, attributes)\n          };\n        };\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {WebGLInferenceHandler} from '../inference-handler';\n\nimport {calculateOutputShape, ConvAttributes} from './conv';\nimport {createPackedIm2ColProgramInfoLoader} from './im2col-pack';\nimport {createPackedMatmulProgramInfoLoader} from './matmul-pack';\n\nexport const conv2DPackedPointwise =\n    (inferenceHandler: WebGLInferenceHandler, inputs: readonly Tensor[], attributes: ConvAttributes): Tensor => {\n      const xshape = inputs[0].dims;\n      const kshape = inputs[1].dims;\n      const outputShape =\n          calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);\n      const reshapedX = inferenceHandler.reshapePacked(inputs[0], [xshape[1], xshape[2] * xshape[3]]);\n      const reshapedK = inferenceHandler.reshapePacked(inputs[1], [kshape[0], kshape[1]]);\n\n      const matmulInputs = inputs.length > 2 ? [reshapedK, reshapedX, inputs[2]] : [reshapedK, reshapedX];\n      const matmulOutput = inferenceHandler.run(\n          createPackedMatmulProgramInfoLoader(inferenceHandler, matmulInputs, attributes), matmulInputs);\n      return inferenceHandler.reshapePacked(matmulOutput, outputShape);\n    };\n\nexport const conv2DPacked =\n    (inferenceHandler: WebGLInferenceHandler, inputs: readonly Tensor[], attributes: ConvAttributes): Tensor => {\n      const xshape = inputs[0].dims;\n      const kshape = inputs[1].dims;\n      const outputShape =\n          calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);\n\n      // run im2col\n      const im2colOutput = inferenceHandler.run(\n          createPackedIm2ColProgramInfoLoader(inferenceHandler, inputs[0], inputs[1], outputShape, attributes),\n          [inputs[0]]);\n\n      // reshape kernel\n      const kernelReshaped = inferenceHandler.reshapePacked(inputs[1], [kshape[0], kshape[1] * kshape[2] * kshape[3]]);\n\n      // run matmul\n      const matmulInputs =\n          (inputs.length === 3) ? [kernelReshaped, im2colOutput, inputs[2]] : [kernelReshaped, im2colOutput];\n      const matmulOutput = inferenceHandler.run(\n          createPackedMatmulProgramInfoLoader(inferenceHandler, matmulInputs, attributes), matmulInputs);\n\n      // reshape output\n      const outputReshaped = inferenceHandler.reshapePacked(matmulOutput, outputShape);\n      return outputReshaped;\n    };\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {InferenceHandler} from '../../../backend';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\nimport {ConvAttributes} from './conv';\nimport {getActivationSnippet, parseInternalActivationAttributes} from './fuse-utils';\n\nconst computeTotalPad =\n    (inDim: number, stride: number, adj: number, kernel: number, dilation: number, outSize: number) =>\n        (inDim - 1) * stride + adj + (kernel - 1) * dilation + 1 - outSize;\n\nconst distributePadding = (totalPad: number, autoPad: string, pads: number[], head: number, tail: number) => {\n  const smallPad = Math.floor(totalPad / 2);\n  if (autoPad === 'SAME_UPPER') {\n    pads[head] = smallPad;\n    pads[tail] = totalPad - smallPad;\n  } else if (autoPad === 'SAME_LOWER') {\n    pads[head] = totalPad - smallPad;\n    pads[tail] = smallPad;\n  }\n};\n\nconst calculateOutputShapeAndPads =\n    (inputShape: readonly number[], kernelShape: readonly number[], dilations: readonly number[], autoPad: string,\n     pads: number[], strides: readonly number[], outputPadding: readonly number[], outputShape: number[]) => {\n      const spatialRank = inputShape.length - 2;\n      const updateShape = outputShape.length === 0;\n      for (let i = 0; i < spatialRank; ++i) {\n        const outSize = updateShape ? inputShape[i + 2] * strides[i] : outputShape[i];\n        const totalPad = computeTotalPad(inputShape[i + 2], strides[i], pads[i], kernelShape[i], dilations[i], outSize);\n        distributePadding(totalPad, autoPad, pads, i, i + spatialRank);\n        if (updateShape) {\n          outputShape.push(\n              strides[i] * (inputShape[i + 2] - 1) + outputPadding[i] + (kernelShape[i] - 1) * dilations[i] + 1 -\n              pads[i] - pads[i + spatialRank]);\n        }\n      }\n    };\n\nexport interface ConvTransposeAttributes extends ConvAttributes {\n  readonly outputPadding: readonly number[];\n  readonly outputShape: readonly number[];\n}\n\nexport const convTranspose: OperatorImplementation<ConvTransposeAttributes> =\n    (inferenceHandler: InferenceHandler, inputs: Tensor[], attributes: ConvTransposeAttributes): Tensor[] => {\n      validateInputs(inputs, attributes);  // currently will fail if not convTranspose2D\n      return convTranspose2d(inferenceHandler, inputs, attributes);\n    };\n\nconst convTranspose2d: OperatorImplementation<ConvTransposeAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ConvTransposeAttributes): Tensor[] => {\n      const adjustedAttributes = getAdjustedConvTransposeAttributes(attributes, inputs);\n      return [convTranspose2DUnpacked(inferenceHandler, inputs, adjustedAttributes)];\n    };\n\nconst createConvTransposeProgramMetadata = (hasBias: boolean, cacheHint: string) => ({\n  name: 'ConvTranspose',\n  inputNames: hasBias ? ['X', 'W', 'B'] : ['X', 'W'],\n  inputTypes: hasBias ? [TextureType.unpacked, TextureType.unpacked, TextureType.unpacked] :\n                        [TextureType.unpacked, TextureType.unpacked],\n  cacheHint\n});\n\nconst createUnpackedConvTransposeProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, inputs: readonly Tensor[], metadata: ProgramMetadata,\n     attributes: ConvTransposeAttributes): ProgramInfo => {\n      const hasBias = inputs.length > 2;\n      const valueInit = hasBias ? 'getB(output_channel)' : '0.0';\n      const xShape = inputs[0].dims;\n      const wShape = inputs[1].dims;\n      const outputChannelsPerGroup = wShape[1];\n      const inputChannelsPerGroup = wShape[0] / attributes.group;\n      const outputShape = [inputs[0].dims[0], inputs[1].dims[1] * attributes.group, ...attributes.outputShape];\n      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n      const {activationFunction, applyActivation} = getActivationSnippet(attributes);\n\n      const shaderSource = `\n  const ivec2 strides = ivec2(${attributes.strides[0]}, ${attributes.strides[1]});\n  const ivec2 pads = ivec2(${attributes.pads[0]}, ${attributes.pads[1]});\n  ${activationFunction}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n\n    ivec2 loc = coords.zw + pads;\n\n    int group_id = output_channel / ${outputChannelsPerGroup};\n    int wOutChannel = output_channel - group_id * ${outputChannelsPerGroup};\n\n    float value = ${valueInit};\n    for (int inChannelOffset = 0; inChannelOffset < ${inputChannelsPerGroup}; inChannelOffset++) {\n      int input_channel = group_id * ${inputChannelsPerGroup} + inChannelOffset;\n      for (int wWOff = 0; wWOff < ${wShape[2]}; wWOff++) {\n        for (int wHOff = 0; wHOff < ${wShape[3]}; wHOff++) {\n          ivec2 wOff = ivec2(wWOff * ${attributes.dilations[0]}, wHOff * ${attributes.dilations[1]});\n          ivec2 wLoc = loc - wOff;\n          ivec2 wLocIn = wLoc / strides;\n          if (\n            wLocIn * strides == wLoc &&\n            wLocIn.x >= 0 && wLocIn.x < ${xShape[2]} &&\n            wLocIn.y >= 0 && wLocIn.y < ${xShape[3]}\n          ) {\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\n            value += xVal * wVal;\n          }\n        }\n      }\n    }\n    ${applyActivation}\n    ${glsl.output} = vec4(value, .0, .0, .0);\n  }\n`;\n      return {\n        ...metadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n        shaderSource,\n        hasMain: true,\n      };\n    };\n\nconst createUnpackedConvTransposeProgramInfoLoader =\n    (inferenceHandler: WebGLInferenceHandler, inputs: readonly Tensor[], attributes: ConvTransposeAttributes):\n        ProgramInfoLoader => {\n          const metadata = createConvTransposeProgramMetadata(inputs.length > 2, attributes.cacheKey);\n          return {\n            ...metadata,\n            get: () => createUnpackedConvTransposeProgramInfo(inferenceHandler, inputs, metadata, attributes)\n          };\n        };\n\n\nconst convTranspose2DUnpacked =\n    (inferenceHandler: WebGLInferenceHandler, inputs: readonly Tensor[], attributes: ConvTransposeAttributes):\n        Tensor => {\n          const result = inferenceHandler.run(\n              createUnpackedConvTransposeProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);\n          return result;\n        };\n\nconst getAdjustedConvTransposeAttributes = <T extends ConvTransposeAttributes>(attributes: T, inputs: Tensor[]): T => {\n  const kernelShape = attributes.kernelShape.slice();\n  // if kernelShape is not specified in the attributes of this op, infer it from the weight tensor dims\n  if (attributes.kernelShape.length === 0) {\n    for (let i = 2; i < inputs[1].dims.length; ++i) {\n      kernelShape.push(inputs[1].dims[i]);\n    }\n  }\n\n  const pads = attributes.pads.slice();\n  const outputShape = attributes.outputShape.slice();\n  const inputShape = inputs[0].dims;\n  // If outputShape is not specified in the attributes of this op, infer it from the parameters\n  // Similarly, automatically infer pads if not specified\n  calculateOutputShapeAndPads(\n      inputShape, kernelShape, attributes.dilations, attributes.autoPad, pads, attributes.strides,\n      attributes.outputPadding, outputShape);\n\n  // always return a new object so does not modify the original attributes\n  const newAttributes: T = Object.assign({}, attributes);\n  Object.assign(newAttributes, {kernelShape, pads, outputShape, cacheKey: attributes.cacheKey});\n  return newAttributes;\n};\n\nexport const parseConvTransposeAttributes: OperatorInitialization<ConvTransposeAttributes> =\n    (node: Graph.Node): ConvTransposeAttributes => {\n      const attributes = node.attributes;\n      const activationAttributes = parseInternalActivationAttributes(attributes);\n      // TODO : Make this generic enough to compute default attributes for multi-dimensional conv\n      const autoPad = attributes.getString('auto_pad', 'NOTSET');\n      const dilations = attributes.getInts('dilations', [1, 1]);\n      const group = attributes.getInt('group', 1);\n      const kernelShape = attributes.getInts('kernel_shape', []);\n      const outputPadding = attributes.getInts('output_padding', [0, 0]);\n      const outputShape = attributes.getInts('output_shape', []);\n      const pads = attributes.getInts('pads', [0, 0, 0, 0]);\n      const strides = attributes.getInts('strides', [1, 1]);\n\n      return createAttributeWithCacheKey(\n          {autoPad, dilations, group, kernelShape, outputPadding, outputShape, pads, strides, ...activationAttributes});\n    };\n\nconst validateInputs = (inputs: Tensor[], attributes: ConvTransposeAttributes): void => {\n  // Refer to the below link for all input checks\n  // https://github.com/onnx/onnx/blob/main/docs/Operators.md#Conv\n  if (!inputs || (inputs.length !== 2 && inputs.length !== 3)) {\n    throw new Error('Conv requires 2 or 3 inputs');\n  }\n\n  // TODO : Need to add support for multi-dimensional conv\n  if (inputs[0].dims.length !== 4 || inputs[1].dims.length !== 4) {\n    throw new Error('currently only support 2-dimensional conv');\n  }\n\n  // FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\n  const dataChannel = inputs[0].dims[1];\n  const filterInChannel = inputs[1].dims[0];\n  if (dataChannel !== filterInChannel) {\n    throw new Error('FILTER_IN_CHANNEL should be equal to DATA_CHANNEL');\n  }\n\n  const featureMaps = inputs[1].dims[1] * attributes.group;\n\n  // if bias is provided it should be 1D and the number of elements should be equal to the number of feature maps\n  if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[2].dims[0] !== featureMaps)) {\n    throw new Error('invalid bias');\n  }\n\n  const spatialRank = inputs[0].dims.length - 2;\n  // wrong dilations dimension\n  if (attributes.dilations.length !== spatialRank) {\n    throw new Error(`dilations should be ${spatialRank}D`);\n  }\n\n  // Wrong strides dimension\n  if (attributes.strides.length !== spatialRank) {\n    throw new Error(`strides should be ${spatialRank}D`);\n  }\n\n  // Wrong pads dimension\n  if (attributes.pads.length !== spatialRank * 2) {\n    throw new Error(`pads should be ${spatialRank * 2}D`);\n  }\n\n  // Wrong output padding dimension\n  if (attributes.outputPadding.length !== spatialRank) {\n    throw new Error(`output_padding should be ${spatialRank}D`);\n  }\n\n  // if kernelShape is specified, it's data length must be 2 less than dims length of the weights tensor\n  // (the first 2 dims are batch_size and channels)\n  if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {\n    throw new Error('invalid kernel shape');\n  }\n\n  // as with kernelShape, must have same number of spatial dims as input\n  if (attributes.outputShape.length !== 0 && attributes.outputShape.length !== inputs[0].dims.length - 2) {\n    throw new Error('invalid output shape');\n  }\n\n  // TODO : Need to add support for float64\n  if (inputs[0].type !== 'float32' || inputs[1].type !== 'float32') {\n    throw new Error('ConvTranspose input(X,W) should be float tensor');\n  }\n\n  if (inputs.length === 3 && inputs[2].type !== 'float32') {\n    throw new Error('ConvTranspose input(bias) should be float tensor');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {InferenceHandler} from '../../../backend';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {PoolConvUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\n\nimport {createUnpackedGroupedConvProgramInfoLoader} from './conv-grouped';\nimport {conv2DPacked} from './conv-pack';\nimport {createDotProductProgramInfoLoader} from './dot-product';\nimport {InternalActivationAttributes, parseInternalActivationAttributes} from './fuse-utils';\nimport {createIm2ColProgramInfoLoader} from './im2col';\nimport {createMatmulProgramInfoLoader} from './matmul';\n\n\nexport const calculateOutputShape =\n    (inputShape: readonly number[], kernelShape: readonly number[], dilations: readonly number[],\n     adjustPads: readonly number[], strides: readonly number[]): number[] => {\n      const batchSize = inputShape[0];\n      const inputSpatialShape = inputShape.slice(2);\n      const spatialRank = inputSpatialShape.length;\n      const outChannels = kernelShape[0];\n      const kernelSpatialShape = kernelShape.slice(2);\n      const dilatedKernelShape = kernelSpatialShape.map((v, i) => v + (v - 1) * (dilations[i] - 1));\n      const inputSpatialShapeWithPad = inputSpatialShape.map((v, i) => v + adjustPads[i] + adjustPads[i + spatialRank]);\n      const outputSpatialShape =\n          inputSpatialShapeWithPad.map((v, i) => Math.floor((v - dilatedKernelShape[i] + strides[i]) / strides[i]));\n      const outputShape = [batchSize, outChannels].concat(...outputSpatialShape);\n      return outputShape;\n    };\n\nexport interface ConvAttributes extends InternalActivationAttributes, AttributeWithCacheKey {\n  readonly autoPad: string;\n  readonly dilations: readonly number[];\n  readonly group: number;\n  readonly kernelShape: readonly number[];\n  readonly pads: readonly number[];\n  readonly strides: readonly number[];\n}\n\nexport const conv: OperatorImplementation<ConvAttributes> =\n    (inferenceHandler: InferenceHandler, inputs: Tensor[], attributes: ConvAttributes): Tensor[] => {\n      validateInputs(inputs, attributes);  // currently will fail if not conv2D\n      return conv2d(inferenceHandler, inputs, attributes);\n    };\n\nconst conv2d: OperatorImplementation<ConvAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ConvAttributes): Tensor[] => {\n      const adjustedAttributes = getAdjustedConvAttributes(attributes, inputs);\n      const packMode = inferenceHandler.session.pack;\n      const isPointwise = adjustedAttributes.kernelShape[0] === 1 && adjustedAttributes.kernelShape[1] === 1;\n      if (adjustedAttributes.group > 1) {\n        const result = inferenceHandler.run(\n            createUnpackedGroupedConvProgramInfoLoader(inferenceHandler, inputs, adjustedAttributes), inputs);\n        return [result];\n      } else if (isPointwise && packMode) {\n        return [conv2DUnpackedPointwise(inferenceHandler, inputs, adjustedAttributes)];\n      } else if (packMode && inputs[0].dims.length === 4 && inputs[0].dims[0] === 1 && !isPointwise) {\n        return [conv2DPacked(inferenceHandler, inputs, adjustedAttributes)];\n      } else {\n        return [conv2DUnpacked(inferenceHandler, inputs, adjustedAttributes)];\n      }\n    };\n\nconst conv2DUnpackedPointwise =\n    (inferenceHandler: WebGLInferenceHandler, inputs: readonly Tensor[], attributes: ConvAttributes): Tensor => {\n      const xshape = inputs[0].dims;\n      const kshape = inputs[1].dims;\n      const outputShape =\n          calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);\n      const reshapedX = inferenceHandler.reshapeUnpacked(inputs[0], [xshape[1], xshape[2] * xshape[3]]);\n      const reshapedK = inferenceHandler.reshapeUnpacked(inputs[1], [kshape[0], kshape[1]]);\n\n      const matmulInputs = inputs.length > 2 ? [reshapedK, reshapedX, inputs[2]] : [reshapedK, reshapedX];\n      const matmulOutput = inferenceHandler.run(createMatmulProgramInfoLoader(matmulInputs, attributes), matmulInputs);\n      return inferenceHandler.reshapeUnpacked(matmulOutput, outputShape);\n    };\n\nconst conv2DUnpacked =\n    (inferenceHandler: WebGLInferenceHandler, inputs: readonly Tensor[], attributes: ConvAttributes): Tensor => {\n      const xshape = inputs[0].dims;\n      const kshape = inputs[1].dims;\n      const outputShape =\n          calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);\n      const xIm2Col = inferenceHandler.run(\n          createIm2ColProgramInfoLoader(inferenceHandler, inputs[0], inputs[1], outputShape, attributes), [inputs[0]]);\n\n      const dotProductInputs = inputs.length === 3 ? [xIm2Col, inputs[1], inputs[2]] : [xIm2Col, inputs[1]];\n      const output = inferenceHandler.run(\n          createDotProductProgramInfoLoader(inferenceHandler, inputs, outputShape, attributes), dotProductInputs);\n      return output;\n    };\n\nconst getAdjustedConvAttributes = <T extends ConvAttributes>(attributes: T, inputs: Tensor[]): T => {\n  const kernelShape = attributes.kernelShape.slice();\n  // if kernelShape is not specified in the attributes of this op, infer it from the weight tensor dims\n  if (attributes.kernelShape.length === 0) {\n    for (let i = 2; i < inputs[1].dims.length; ++i) {\n      kernelShape.push(inputs[1].dims[i]);\n    }\n  }\n  const pads = attributes.pads.slice();\n  PoolConvUtil.adjustPadsBasedOnAutoPad(\n      inputs[0].dims, attributes.strides, attributes.dilations, kernelShape, pads, attributes.autoPad);\n\n  // always return a new object so does not modify the original attributes\n  const newAttributes: T = Object.assign({}, attributes);\n  Object.assign(newAttributes, {kernelShape, pads, cacheKey: attributes.cacheKey});\n  return newAttributes;\n};\n\nexport const parseConvAttributes: OperatorInitialization<ConvAttributes> = (node: Graph.Node): ConvAttributes => {\n  const attributes = node.attributes;\n  const activationAttributes = parseInternalActivationAttributes(attributes);\n  // TODO : Make this generic enough to compute default attributes for multi-dimensional conv\n  const autoPad = attributes.getString('auto_pad', 'NOTSET');\n  const dilations = attributes.getInts('dilations', [1, 1]);\n  const group = attributes.getInt('group', 1);\n  const kernelShape = attributes.getInts('kernel_shape', []);\n  const pads = attributes.getInts('pads', [0, 0, 0, 0]);\n  const strides = attributes.getInts('strides', [1, 1]);\n\n  return createAttributeWithCacheKey({autoPad, dilations, group, kernelShape, pads, strides, ...activationAttributes});\n};\n\nconst validateInputs = (inputs: Tensor[], attributes: ConvAttributes): void => {\n  // Refer to the below link for all input checks\n  // https://github.com/onnx/onnx/blob/main/docs/Operators.md#Conv\n  if (!inputs || (inputs.length !== 2 && inputs.length !== 3)) {\n    throw new Error('Conv requires 2 or 3 inputs');\n  }\n\n  // TODO : Need to add support for multi-dimensional conv\n  if (inputs[0].dims.length !== 4 || inputs[1].dims.length !== 4) {\n    throw new Error('currently only support 2-dimensional conv');\n  }\n\n  // FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\n  const dataChannel = inputs[0].dims[1];\n  const filterInChannel = inputs[1].dims[1] * attributes.group;\n  if (dataChannel !== filterInChannel) {\n    throw new Error('FILTER_IN_CHANNEL should be equal to DATA_CHANNEL');\n  }\n\n  // if bias is provided it should be 1D and the number of elements should be equal to the number of feature maps\n  if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[1].dims[0] !== inputs[2].dims[0])) {\n    throw new Error('invalid bias');\n  }\n\n  const spatialRank = inputs[0].dims.length - 2;\n  // wrong dilations dimension\n  if (attributes.dilations.length !== spatialRank) {\n    throw new Error(`dilations should be ${spatialRank}D`);\n  }\n\n  // Wrong strides dimension\n  if (attributes.strides.length !== spatialRank) {\n    throw new Error(`strides should be ${spatialRank}D`);\n  }\n\n  // Wrong pads dimension\n  if (attributes.pads.length !== spatialRank * 2) {\n    throw new Error(`pads should be ${spatialRank * 2}D`);\n  }\n\n  // if kernelShape is specified, it's data length must be 2 less than dims length of the weights tensor\n  // (the first 2 dims are batch_size and channels)\n  if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {\n    throw new Error('invalid kernel shape');\n  }\n\n  // TODO : Need to add support for float64\n  if (inputs[0].type !== 'float32' || inputs[1].type !== 'float32') {\n    throw new Error('Conv input(X,W) should be float tensor');\n  }\n\n  if (inputs.length === 3 && inputs[2].type !== 'float32') {\n    throw new Error('Conv input(bias) should be float tensor');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {WebGLInferenceHandler} from '../inference-handler';\n\nimport {transpose, TransposeAttributes} from './transpose';\n\nexport interface DepthToSpaceAttributes {\n  mode: 'DCR'|'CRD';\n  blocksize: number;\n}\n\nexport const depthToSpace: OperatorImplementation<DepthToSpaceAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: DepthToSpaceAttributes): Tensor[] => {\n      validateInputs(inputs);\n      const blocksize = attributes.blocksize;\n      const blocksizeSqr = blocksize * blocksize;\n      const transposePerm = attributes.mode === 'DCR' ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3];\n      const firstReshapeShape = attributes.mode === 'DCR' ?\n          [\n            inputs[0].dims[0], blocksize, blocksize, inputs[0].dims[1] / blocksizeSqr, inputs[0].dims[2],\n            inputs[0].dims[3]\n          ] :\n          [\n            inputs[0].dims[0], inputs[0].dims[1] / blocksizeSqr, blocksize, blocksize, inputs[0].dims[2],\n            inputs[0].dims[3]\n          ];\n\n      // const transpose = new WebGLTranspose();\n      // const attributes = new Attribute(undefined);\n      // attributes.set('perm', 'ints', transposePerm);\n      // transpose.initialize(attributes);\n\n      // First reshape\n      const firstReshapedTensor = inferenceHandler.reshapeUnpacked(inputs[0], firstReshapeShape);\n\n      // transpose\n      const transposeAttributes: TransposeAttributes = {perm: transposePerm, cacheKey: `${transposePerm}`};\n      const [transposeOutput] = transpose(inferenceHandler, [firstReshapedTensor], transposeAttributes);\n\n      // Second reshape\n      const secondReshapeShape = [\n        inputs[0].dims[0], inputs[0].dims[1] / blocksizeSqr, inputs[0].dims[2] * blocksize,\n        inputs[0].dims[3] * blocksize\n      ];\n      const result = inferenceHandler.reshapeUnpacked(transposeOutput, secondReshapeShape);\n      return [result];\n    };\n\nexport const parseDepthToSpaceAttributes: OperatorInitialization<DepthToSpaceAttributes> =\n    (node: Graph.Node): DepthToSpaceAttributes => {\n      // processing node attributes\n      const blocksize = node.attributes.getInt('blocksize');\n      if (blocksize < 1) {\n        throw new Error(`blocksize must be >= 1, but got : ${blocksize} for DepthToSpace`);\n      }\n      const mode = node.attributes.getString('mode', 'DCR');\n      if (mode !== 'DCR' && mode !== 'CRD') {\n        throw new Error(`unrecognized mode: ${mode} for DepthToSpace`);\n      }\n      return {mode, blocksize};\n    };\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (inputs.length !== 1) {\n    throw new Error(`DepthToSpace expect 1 inputs, but got ${inputs.length}`);\n  }\n\n  // Input has to be a 4-D tensor\n  // TODO: Support string depth-to-space.\n  if (inputs[0].type === 'string' || inputs[0].dims.length !== 4) {\n    throw new TypeError('DepthToSpace input should be a 4-D numeric tensor');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\nimport {getActivationSnippet, InternalActivationAttributes} from './fuse-utils';\nimport {calculateIm2ColDims} from './im2col';\n\nconst createDotProductProgramMetadata = (hasBias: boolean, attributes: InternalActivationAttributes) => ({\n  name: 'ConvDotProduct',\n  inputNames: hasBias ? ['Im2Col', 'K', 'B'] : ['Im2Col', 'K'],\n  inputTypes: hasBias ? [TextureType.unpacked, TextureType.packedLastDimension, TextureType.unpacked] :\n                        [TextureType.unpacked, TextureType.packedLastDimension],\n  cacheKey: attributes.activationCacheKey\n});\n\nconst createDotProductProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, metadata: ProgramMetadata, inputs: readonly Tensor[],\n     outputShape: number[], attributes: InternalActivationAttributes): ProgramInfo => {\n      const xshape = inputs[0].dims;\n      const kshape = inputs[1].dims;\n      const adjustedKernelShape = [kshape[0], Math.ceil((xshape[1] * kshape[2] * kshape[3]) / 4)];\n      const im2colShape = calculateIm2ColDims(xshape, kshape, outputShape);\n      const [kWidth, kHeight] =\n          inferenceHandler.calculateTextureWidthAndHeight(adjustedKernelShape, TextureType.packedLastDimension);\n\n      const im2colStrides = ShapeUtil.computeStrides(im2colShape);\n      const [im2colWidth, im2colHeight] =\n          inferenceHandler.calculateTextureWidthAndHeight(im2colShape, TextureType.packedLastDimension);\n      const rank = outputShape.length;\n\n      const initValue = (inputs.length < 3) ? '0.0' : '_B(b)';\n      const sharedDim = Math.ceil(xshape[1] * kshape[2] * kshape[3] / 4);\n      const {activationFunction, applyActivation} = getActivationSnippet(attributes);\n      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n      const shaderSource = `\n${activationFunction}\nfloat process(int indices[${rank}]) {\n  int b[1];\n  b[0] = indices[1];\n  int im2col[4];\n  im2col[0] = indices[0];\n  im2col[1] = indices[2];\n  im2col[2] = indices[3];\n  int im2colOffset = im2col[0] * ${im2colStrides[0]} + im2col[1] * ${im2colStrides[1]} + im2col[2] * ${\n          im2colStrides[2]};\n  int kernelOffset = indices[1] * ${adjustedKernelShape[1]};\n  float value = ${initValue};\n  for (int i = 0; i < ${sharedDim}; ++i) {\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${im2colWidth}, ${im2colHeight});\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${kWidth}, ${kHeight});\n    value += dot(${glsl.texture2D}(Im2Col, im2colCoords), ${glsl.texture2D}(K, kernelCoords));\n    ++im2colOffset;\n    ++kernelOffset;\n  }\n  ${applyActivation}\n  return value;\n}`;\n      return {\n        ...metadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n        shaderSource\n      };\n    };\n\nexport const createDotProductProgramInfoLoader =\n    (inferenceHandler: WebGLInferenceHandler, inputs: readonly Tensor[], outputShape: number[],\n     attributes: InternalActivationAttributes): ProgramInfoLoader => {\n      const metadata = createDotProductProgramMetadata(inputs.length > 2, attributes);\n      return {\n        ...metadata,\n        get: () => createDotProductProgramInfo(inferenceHandler, metadata, inputs, outputShape, attributes)\n      };\n    };\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\n\nexport const flatten: OperatorImplementation<number> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], axis: number): Tensor[] => {\n      validateInputs(inputs, axis);\n\n      const outputDims = ShapeUtil.flattenShape(inputs[0].dims, axis);\n      return [inferenceHandler.reshapeUnpacked(inputs[0], outputDims)];\n    };\n\nexport const parseFlattenAttributes: OperatorInitialization<number> = (node: Graph.Node): number =>\n    node.attributes.getInt('axis', 1);  // default axis is 1\n\nconst validateInputs = (inputs: Tensor[], axis: number): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Flatten requires 1 input.');\n  }\n\n  const r = inputs[0].dims.length;\n  if (r === 0) {\n    throw new Error('scalar tensor is not supported.');\n  }\n\n  if (axis < -r || axis > r) {\n    throw new Error('Invalid axis');\n  }\n\n  // TODO: Support string type\n  if (inputs[0].type === 'string') {\n    throw new Error('string tensor is not supported.');\n  }\n};","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Attribute} from '../../../attribute';\nimport {MAX_CLIP, MIN_CLIP} from '../../../util';\nimport {GlslValueFunction} from '../glsl-definitions';\n\nimport {glslClip, glslRelu, glslSigmoid} from './unary-op';\n\nexport interface InternalActivationAttributes {\n  readonly activation: string;\n  readonly clipMin?: number;\n  readonly clipMax?: number;\n  readonly activationCacheKey: string;\n}\n\nexport function getActivationSnippet(attributes: InternalActivationAttributes) {\n  let func: GlslValueFunction;\n  switch (attributes.activation) {\n    case 'Relu':\n      func = glslRelu();\n      break;\n    case 'Sigmoid':\n      func = glslSigmoid();\n      break;\n    case 'Clip':\n      func = glslClip(attributes.clipMin!, attributes.clipMax!);\n      break;\n    // TODO: adding other activations that can be fused.\n    default:\n      return {activationFunction: '', applyActivation: ''};\n  }\n\n  const activationName = func.name;\n  const activationFunction = func.body;\n  const applyActivation = `value = ${activationName}_(value);`;\n  return {activationFunction, applyActivation};\n}\n\nexport const parseInternalActivationAttributes = (attributes: Attribute): InternalActivationAttributes => {\n  const activation = attributes.getString('activation', '');\n\n  if (activation === 'Clip') {\n    const [clipMin, clipMax] = attributes.getFloats('activation_params', [MIN_CLIP, MAX_CLIP]);\n    return {activation, clipMax, clipMin, activationCacheKey: `${activation}:${clipMin},${clipMax}`};\n  }\n  return {activation, activationCacheKey: activation};\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {NUMBER_TYPES, OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\ninterface GatherAttributes extends AttributeWithCacheKey {\n  readonly axis: number;\n}\n\nexport const gather: OperatorImplementation<GatherAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: GatherAttributes): Tensor[] => {\n      validateInputs(inputs, attributes.axis);\n      const output = inferenceHandler.run(createGatherProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);\n      return [output];\n    };\n\nexport const parseGatherAttributes: OperatorInitialization<GatherAttributes> = (node: Graph.Node): GatherAttributes =>\n    createAttributeWithCacheKey({axis: node.attributes.getInt('axis', 0)});\n\nconst gatherProgramMetadata = {\n  name: 'Gather',\n  inputNames: ['A', 'B'],\n  inputTypes: [TextureType.unpacked, TextureType.unpacked],\n};\n\nconst createGatherProgramInfo =\n    (handler: WebGLInferenceHandler, metadata: ProgramMetadata, inputs: Tensor[], axis: number): ProgramInfo => {\n      const inputShape = inputs[0].dims.slice();\n      const indexDataShape = inputs[1].dims.slice();\n      const outputShape = new Array(inputShape.length + indexDataShape.length - 1);\n\n      axis = ShapeUtil.normalizeAxis(axis, inputShape.length);\n      const indexCopyOps: string[] = [];\n      for (let i = 0; i < outputShape.length; i++) {\n        // outputShape is divided into three parts: A, B, C\n        // |0        axis|  axis + indexDataShape.length |          end|\n        // |     A       |             B                 |      C      |\n        //\n        // inputIdx: [A, inputs[1][B], C]\n        if (i < axis) {  // A\n          outputShape[i] = inputShape[i];\n          indexCopyOps.push(`inputIdx[${i}] = outputIdx[${i}];`);\n        } else {\n          if (i < axis + indexDataShape.length) {  // B\n            outputShape[i] = indexDataShape[i - axis];\n            indexCopyOps.push(`indexDataIdx[${i - axis}] = outputIdx[${i}];`);\n          } else {                                                       // C\n            outputShape[i] = inputShape[i - indexDataShape.length + 1];  // skip 1 for axis\n            indexCopyOps.push(`inputIdx[${i - indexDataShape.length + 1}] = outputIdx[${i}];`);\n          }\n        }\n      }\n\n      const orank = outputShape.length || 1;\n      const irank = inputShape.length;\n      const iDrank = indexDataShape.length || 1;\n      const shaderSource = `\n      float process(int outputIdx[${orank}]) {\n        int inputIdx[${irank}];\n        int indexDataIdx[${iDrank}];\n        indexDataIdx[0] = 0;\n        ${indexCopyOps.join('\\n        ')}\n        int idx = int(_B(indexDataIdx));\n        inputIdx[${axis}] = idx < 0 ? idx + ${inputShape[axis]} : idx;\n        return _A(inputIdx);\n      }`;\n      return {\n        ...metadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n        shaderSource\n      };\n    };\n\nconst createGatherProgramInfoLoader =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], attributes: GatherAttributes): ProgramInfoLoader => {\n      const metadata = {...gatherProgramMetadata, cacheHint: attributes.cacheKey};\n      return {...metadata, get: () => createGatherProgramInfo(handler, metadata, inputs, attributes.axis)};\n    };\n\nconst validateInputs = (inputs: Tensor[], axis: number): void => {\n  if (!inputs || inputs.length !== 2) {\n    throw new Error('Gather requires 2 inputs.');\n  }\n  const tensorRank = inputs[0].dims.length;\n  if (tensorRank < 1) {\n    throw new Error('Invalid input shape.');\n  }\n  if (axis < -tensorRank || axis > tensorRank - 1) {\n    throw new Error('Invalid axis.');\n  }\n  if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {\n    throw new Error('Invaid input type.');\n  }\n  if (inputs[1].type !== 'int32' && inputs[1].type !== 'int16') {\n    throw new Error('Invaid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {GemmUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\nexport interface GemmAttributes extends AttributeWithCacheKey {\n  transA: boolean;\n  transB: boolean;\n  alpha: number;\n  beta: number;\n  isOptionalC: boolean;  // in opset 11, C becomes optional\n}\n\nexport const gemm: OperatorImplementation<GemmAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: GemmAttributes): Tensor[] => {\n      validateInputs(inputs, attributes);\n      const output = inferenceHandler.run(createGemmProgramInfoLoader(inputs, attributes), inputs);\n      return [output];\n    };\n\nconst parseGemmAttributes = (node: Graph.Node, isOptionalC: boolean): GemmAttributes => {\n  const transA = node.attributes.getInt('transA', 0) !== 0;\n  const transB = node.attributes.getInt('transB', 0) !== 0;\n  const alpha = node.attributes.getFloat('alpha', 1.0);\n  const beta = node.attributes.getFloat('beta', 1.0);\n  return createAttributeWithCacheKey({transA, transB, alpha, beta, isOptionalC});\n};\n\nexport const parseGemmAttributesV7: OperatorInitialization<GemmAttributes> = (node: Graph.Node): GemmAttributes =>\n    parseGemmAttributes(node, false);\n\nexport const parseGemmAttributesV11: OperatorInitialization<GemmAttributes> = (node: Graph.Node): GemmAttributes =>\n    parseGemmAttributes(node, true);\n\nconst createGemmProgramInfoLoader = (inputs: Tensor[], attributes: GemmAttributes): ProgramInfoLoader => {\n  const metadata = {\n    name: 'Gemm',\n    inputNames: inputs.length === 3 ? ['A', 'B', 'C'] : ['A', 'B'],\n    inputTypes: inputs.length === 3 ? [TextureType.unpacked, TextureType.unpacked, TextureType.unpacked] :\n                                      [TextureType.unpacked, TextureType.unpacked],\n    key: attributes.cacheKey\n  };\n\n  return {...metadata, get: () => createGemmProgramInfo(metadata, inputs, attributes)};\n};\n\nconst createGemmProgramInfo =\n    (metadata: ProgramMetadata, inputs: Tensor[], attributes: GemmAttributes): ProgramInfo => {\n      const aShape = inputs[0].dims.slice();\n      const bShape = inputs[1].dims.slice();\n      const [M, N] = GemmUtil.getShapeOfGemmResult(\n          aShape, attributes.transA, bShape, attributes.transB, inputs.length === 3 ? inputs[2].dims : undefined);\n      const outputShape = [M, N];\n      if (!outputShape) {\n        throw new Error('Can\\'t use gemm on the given tensors');\n      }\n      let sharedDim = aShape[aShape.length - 1];\n      let line = '';\n      if (attributes.transA) {\n        sharedDim = aShape[0];\n      }\n      if (attributes.transA && attributes.transB) {\n        line = 'value += _A_T(a) * _B_T(b);';\n      } else if (attributes.transA && !attributes.transB) {\n        line = 'value += _A_T(a) * _B(b);';\n      } else if (!attributes.transA && attributes.transB) {\n        line = 'value += _A(a) * _B_T(b);';\n      } else if (!attributes.transA && !attributes.transB) {\n        line = 'value += _A(a) * _B(b);';\n      }\n      const rank = outputShape.length;\n      const declareC = inputs.length === 3 ? `int c[${inputs[2].dims.length}];` : '';\n      const broadcastC = inputs.length === 3 ? 'bcastIndices_C(indices, c);' : '';\n      const calculateC = inputs.length === 3 ? 'value += beta * _C(c);' : '';\n      const shaderSource = `\n      float process(int indices[${rank}]) {\n          int a[${rank}];\n          int b[${rank}];\n          ${declareC}\n\n          copyVec(indices, a);\n          copyVec(indices, b);\n          ${broadcastC}\n\n          float value = 0.0;\n          for (int k=0; k<${sharedDim}; ++k) {\n              a[${rank - 1}] = k;\n              b[${rank - 2}] = k;\n              ${line}\n          }\n\n          value = value * alpha;\n          ${calculateC}\n          return value;\n      }`;\n      return {\n        ...metadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n        variables: [\n          {name: 'alpha', type: 'float', data: attributes.alpha}, {name: 'beta', type: 'float', data: attributes.beta}\n        ],\n        shaderSource\n      };\n    };\n\nconst validateInputs = (inputs: Tensor[], attributes: GemmAttributes): void => {\n  if (!inputs) {\n    throw new Error('Input is missing');\n  }\n  if (attributes.isOptionalC && (inputs.length < 2 || inputs.length > 3)) {\n    throw new Error('Invaid input shape.');\n  }\n  if (!attributes.isOptionalC && inputs.length !== 3) {\n    throw new Error('Gemm requires 3 inputs');\n  }\n\n  // 'C' can be of dimensionality 1 or 2 only\n  if (inputs.length === 3 && inputs[2].dims.length !== 1 && inputs[2].dims.length !== 2) {\n    throw new Error('Invalid input shape of C');\n  }\n\n  if ((inputs[0].type !== 'float32' && inputs[0].type !== 'float64') ||\n      (inputs[1].type !== 'float32' && inputs[1].type !== 'float64') ||\n      (inputs.length === 3 && inputs[2].type !== 'float32' && inputs[2].type !== 'float64')) {\n    throw new Error('Invalid input type.');\n  }\n\n  if ((inputs[0].type !== inputs[1].type) || (inputs.length === 3 && inputs[0].type !== inputs[2].type)) {\n    throw new Error('Input types are mismatched');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\nimport {ConvAttributes} from './conv';\nimport {unpackFromChannel} from './packing-utils';\n\nconst createPackedIm2ColProgramMetadata = (cacheHint: string) => ({\n  name: 'Im2Col (packed)',\n  inputNames: ['A'],\n  inputTypes: [TextureType.packed],\n  cacheHint,\n});\n\nconst createPackedIm2ColProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, metadata: ProgramMetadata, x: Tensor, w: Tensor,\n     outputShape: readonly number[], attributes: ConvAttributes): ProgramInfo => {\n      const xshape = x.dims;\n      const wshape = w.dims;\n      const rowDim = 2;\n      const colDim = 3;\n      const rank = outputShape.length;\n      const im2colShape = [wshape[1] * wshape[2] * wshape[3], outputShape[2] * outputShape[3]];\n      const kernelSize = wshape[2] * wshape[3];\n      const unpackChannel = unpackFromChannel();\n      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n      let unrolled = '';\n\n      for (let row = 0; row <= 1; row++) {\n        for (let col = 0; col <= 1; col++) {\n          unrolled += `\n            blockIndex = rc.x + ${col};\n            pos = rc.y + ${row};\n\n            if(blockIndex < ${im2colShape[1]} && pos < ${im2colShape[0]}) {\n              offsetY = int(blockIndex / (${outputShape[rank - 1]})) * ${attributes.strides[0]} -\n                ${attributes.pads[0]};\n              d0 = offsetY + ${attributes.dilations[0]} * (imod(pos, ${kernelSize}) / ${wshape[2]});\n\n              if(d0 < ${xshape[rowDim]} && d0 >= 0) {\n                offsetX = imod(blockIndex, ${outputShape[rank - 1]}) * ${attributes.strides[1]} -\n                  ${attributes.pads[1]};\n                d1 = offsetX + ${attributes.dilations[1]} * imod(imod(pos, ${kernelSize}), ${wshape[2]});\n\n                if(d1 < ${xshape[colDim]} && d1 >= 0) {\n\n                  ch = int(float(pos)/ ${kernelSize}.);\n                    innerDims = vec2(d0, d1);\n                    result[${row * 2 + col}] = getChannel(\n                      getA(0, ch, int(innerDims.x),\n                      int(innerDims.y)), innerDims);\n                }\n              }\n            }\n\n          `;\n        }\n      }\n\n      const shaderSource = `\n      ${unpackChannel}\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n          vec4 result = vec4(0.0);\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n          vec2 innerDims;\n          ${unrolled}\n          ${glsl.output} = result;\n      }\n            `;\n      return {\n        ...metadata,\n        output: {dims: im2colShape, type: x.type, textureType: TextureType.packed},\n        shaderSource,\n        hasMain: true\n      };\n    };\n\nexport const createPackedIm2ColProgramInfoLoader =\n    (inferenceHandler: WebGLInferenceHandler, x: Tensor, w: Tensor, outputShape: readonly number[],\n     attributes: ConvAttributes): ProgramInfoLoader => {\n      const metadata = createPackedIm2ColProgramMetadata(attributes.cacheKey);\n      return {\n        ...metadata,\n        get: () => createPackedIm2ColProgramInfo(inferenceHandler, metadata, x, w, outputShape, attributes)\n      };\n    };\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\nimport {ConvAttributes} from './conv';\n\nconst createIm2ColProgramMetadata = (cacheHint: string) => ({\n  name: 'Im2Col',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked],\n  cacheHint,\n});\n\nconst createIm2ColProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, metadata: ProgramMetadata, x: Tensor, w: Tensor,\n     outputShape: readonly number[], attributes: ConvAttributes): ProgramInfo => {\n      const xshape = x.dims;\n      const wshape = w.dims;\n\n      const rank = outputShape.length;\n      const im2colDims = calculateIm2ColDims(xshape, wshape, outputShape, 4);\n\n      const shaderSource = `\n        const int XC = ${xshape[1]};\n        const int XH = ${xshape[2]};\n        const int XW = ${xshape[3]};\n        const int KH = ${attributes.kernelShape[0]};\n        const int KW = ${attributes.kernelShape[1]};\n        const int dilationH = ${attributes.dilations[0]};\n        const int dilationW = ${attributes.dilations[1]};\n        const int strideH = ${attributes.strides[0]};\n        const int strideW = ${attributes.strides[1]};\n        const int padH = ${attributes.pads[0]};\n        const int padW = ${attributes.pads[1]};\n        const int KHKW = KH*KW;\n        const int XCKHKW = XC * KHKW;\n        const int outputChannels = 4;\n        vec4 process(int indices[${rank}]) {\n          int b  = indices[0]; // batch size\n          int oh = indices[1] * strideH - padH; //output height\n          int ow = indices[2] * strideW - padW; //output width\n          int p = indices[3] * outputChannels; //patch\n          vec4 value = vec4(0.0);\n          for(int i=0; i < outputChannels; ++i) {\n            if(p < XCKHKW) {\n              int patchC = p / KHKW;\n              int patchH = (p - patchC*KHKW) / KW;\n              int patchW = (p - patchC*KHKW) - patchH * KW;\n              int xh2 = oh + patchH * dilationH;\n              int xw2 = ow + patchW * dilationW;\n              int x[${xshape.length}];\n              x[0] = b;\n              x[1] = patchC;\n              x[2] = xh2;\n              x[3] = xw2;\n              if(xh2 >= 0 &&\n                  xh2 < XH &&\n                  xw2 >= 0 &&\n                  xw2 < XW) {\n                value[i] = _X(x);\n              }\n            }\n            ++p;\n          }\n          return value;\n        }\n        `;\n      return {\n        ...metadata,\n        output: {dims: im2colDims, type: x.type, textureType: TextureType.packedLastDimension},\n        shaderSource\n      };\n    };\n\nexport const createIm2ColProgramInfoLoader =\n    (inferenceHandler: WebGLInferenceHandler, x: Tensor, w: Tensor, outputShape: readonly number[],\n     attributes: ConvAttributes): ProgramInfoLoader => {\n      const metadata = createIm2ColProgramMetadata(attributes.cacheKey);\n      return {\n        ...metadata,\n        get: () => createIm2ColProgramInfo(inferenceHandler, metadata, x, w, outputShape, attributes)\n      };\n    };\n\n\nexport const calculateIm2ColDims =\n    (inputShape: readonly number[], kernelShape: readonly number[], outputShape: readonly number[], channels = 4):\n        number[] =>\n            [outputShape[0], outputShape[2], outputShape[3],\n             Math.ceil(inputShape[1] * kernelShape[2] * kernelShape[3] / channels)];\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\nexport interface ImageScalerAttributes extends AttributeWithCacheKey {\n  scale: number;\n  bias: number[];\n}\n\nexport const imageScaler: OperatorImplementation<ImageScalerAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ImageScalerAttributes): Tensor[] => {\n      validateInputs(inputs);\n      const output =\n          inferenceHandler.run(createImageScalerProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);\n      return [output];\n    };\n\nexport const parseImageScalerAttributes: OperatorInitialization<ImageScalerAttributes> =\n    (node: Graph.Node): ImageScalerAttributes => {\n      const scale = node.attributes.getFloat('scale');\n      const bias = node.attributes.getFloats('bias');\n      return createAttributeWithCacheKey({scale, bias});\n    };\n\nconst imageScalerProgramMetadata = {\n  name: 'ImageScaler',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked],\n};\n\nconst createImageScalerProgramInfo =\n    (handler: WebGLInferenceHandler, metadata: ProgramMetadata, inputs: Tensor[], attributes: ImageScalerAttributes):\n        ProgramInfo => {\n          const outputShape = inputs[0].dims.slice();\n          const rank = outputShape.length;\n          const getBiasMethod = createGetBiasMethod(attributes.bias.length);\n          const shaderSource = `\n      ${getBiasMethod}\n      float process(int indices[${rank}]) {\n        return _X(indices) * scale + getBias(bias, indices[1]);\n      }`;\n          return {\n            ...metadata,\n            output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n            variables: [\n              {name: 'bias', type: 'float', arrayLength: attributes.bias.length, data: attributes.bias},\n              {name: 'scale', type: 'float', data: attributes.scale}\n            ],\n            shaderSource\n          };\n        };\n\nconst createImageScalerProgramInfoLoader =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], attributes: ImageScalerAttributes): ProgramInfoLoader => {\n      const metadata = {...imageScalerProgramMetadata, cacheHint: attributes.cacheKey};\n      return {...metadata, get: () => createImageScalerProgramInfo(handler, metadata, inputs, attributes)};\n    };\n\nconst createGetBiasMethod = (numChannels: number): string => {\n  const codeLines: string[] = [`float getBias(float bias[${numChannels}], int channel) {`];\n  for (let i = 0; i < numChannels; ++i) {\n    if (i === 0) {\n      codeLines.push(\n          '\\t' +\n          `if (channel == ${i}) { return bias[${i}]; }`);\n    } else if (i === numChannels - 1) {\n      codeLines.push(\n          '\\t' +\n          `else { return bias[${i}]; }`);\n    } else {\n      codeLines.push(\n          '\\t' +\n          `else if (channel == ${i}) { return bias[${i}]; }`);\n    }\n  }\n  codeLines.push(\n      '\\t' +\n      '}');\n  return codeLines.join('\\n');\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('ImageScaler requires 1 input.');\n  }\n  if (inputs[0].dims.length !== 4) {\n    throw new Error('Invalid input shape.');\n  }\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('Invalid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\nexport const instanceNormalization: OperatorImplementation<number> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], epsilon: number): Tensor[] => {\n      validateInputs(inputs);\n\n      const meanAndVariance = inferenceHandler.run(createMeanAndVarianceProgramInfoLoader(inputs[0]), inputs);\n      const output = inferenceHandler.run(\n          createComputeOutputProgramInfoLoader(inferenceHandler, inputs[0], epsilon, meanAndVariance.dims),\n          [inputs[0], meanAndVariance, inputs[1], inputs[2]]);\n      return [output];\n    };\n\nexport const parseInstanceNormalizationAttributes: OperatorInitialization<number> = (node: Graph.Node): number =>\n    node.attributes.getFloat('epsilon', 1e-5);\n\nconst meanAndVarianceProgramMetadata = {\n  name: 'InstanceNormalization_MeanAndVariance',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked],\n};\n\nconst createMeanAndVarianceProgramInfo = (metadata: ProgramMetadata, input: Tensor): ProgramInfo => {\n  const xDims = input.dims.slice();\n  const channel = xDims[1];\n  const channelSize = xDims[2] * xDims[3];\n  const outputShape = [xDims[0], channel];\n\n  const shaderSource = `\n      vec4 process(int[2] indices) {\n        vec4 v = vec4(0.0);\n        int a[4];\n        a[0] = indices[0];\n        a[1] = indices[1];\n        float temp = 0.0;\n        for(int a2=0; a2<${xDims[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${xDims[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += x;\n          }\n        }\n        float mean = temp / float(${channelSize});\n        temp = 0.0;\n        for(int a2=0; a2<${xDims[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${xDims[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += (x - mean) * (x - mean);\n          }\n        }\n        v.r = mean;\n        v.g = temp / float(${channelSize});\n\n        return v;\n      }`;\n  return {\n    ...metadata,\n    output: {dims: outputShape, type: input.type, textureType: TextureType.packedLastDimension},\n    shaderSource\n  };\n};\n\nconst createMeanAndVarianceProgramInfoLoader = (input: Tensor): ProgramInfoLoader => ({\n  ...meanAndVarianceProgramMetadata,\n  get: () => createMeanAndVarianceProgramInfo(meanAndVarianceProgramMetadata, input)\n});\n\nconst computeOutputProgramMetadata = {\n  name: 'InstanceNormalization_ComputeOutput',\n  inputNames: ['X', 'MeanAndVariance', 'Scale', 'B'],\n  inputTypes: [TextureType.unpacked, TextureType.packedLastDimension, TextureType.unpacked, TextureType.unpacked],\n};\n\nconst createComputeOutputProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, metadata: ProgramMetadata, input: Tensor, epsilon: number,\n     meanAndVarianceShape: readonly number[]): ProgramInfo => {\n      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n      const [textureWidth, textureHeight] =\n          inferenceHandler.calculateTextureWidthAndHeight(meanAndVarianceShape, TextureType.packedLastDimension);\n      const [meanAndVarianceWidth, meanAndVarianceHeight] = [textureWidth / 4, textureHeight];\n      const shaderSource = `\n      vec4 get_MeanAndVariance(int[2] mv) {\n        int offset = indicesToOffset_MeanAndVariance(mv);\n        vec2 coords = offsetToCoords(offset, ${meanAndVarianceWidth}, ${meanAndVarianceHeight});\n        return ${glsl.texture2D}(MeanAndVariance, coords);\n      }\n\n      float process(int[4] indices) {\n        int mv[2];\n        mv[0] = indices[0];\n        mv[1] = indices[1];\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\n        float mean = mean_and_variance.r;\n        float variance = mean_and_variance.g;\n\n        int sb[1];\n        sb[0] = indices[1];\n        float scale = _Scale(sb);\n        float b = _B(sb);\n\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\n      }`;\n      return {\n        ...metadata,\n        output: {dims: input.dims, type: input.type, textureType: TextureType.unpacked},\n        variables: [{name: 'epsilon', type: 'float', data: epsilon}],\n        shaderSource\n      };\n    };\n\nconst createComputeOutputProgramInfoLoader =\n    (inferenceHandler: WebGLInferenceHandler, input: Tensor, epsilon: number, meanAndVarianceShape: readonly number[]):\n        ProgramInfoLoader => {\n          const metadata = {...computeOutputProgramMetadata, cacheHint: `${epsilon}`};\n          return {\n            ...metadata,\n            get: () => createComputeOutputProgramInfo(inferenceHandler, metadata, input, epsilon, meanAndVarianceShape)\n          };\n        };\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 3) {\n    throw new Error('InstanceNormalization requires 3 inputs.');\n  }\n\n  const X = inputs[0];\n  const scale = inputs[1];\n  const B = inputs[2];\n\n  // input should at least have three dimensions - N,C,dim1,...,dimn\n  // other inputs can have only one dimensions\n  if (X.dims.length < 3 || scale.dims.length !== 1 || B.dims.length !== 1) {\n    throw new Error('Invalid input shape.');\n  }\n  if (scale.dims[0] !== X.dims[1] || B.dims[0] !== X.dims[1]) {\n    throw new Error('Input shapes are mismatched.');\n  }\n  if ((X.type !== 'float32' && X.type !== 'float64') || (scale.type !== 'float32' && scale.type !== 'float64') ||\n      (B.type !== 'float32' && B.type !== 'float64')) {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs[0].dims.length !== 4) {\n    throw new Error('Only support 4-D input shape.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, TextureType} from '../types';\n\nexport interface LrnAttributes extends AttributeWithCacheKey {\n  alpha: number;\n  beta: number;\n  bias: number;\n  size: number;\n}\n\nexport const lrn: OperatorImplementation<LrnAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: LrnAttributes): Tensor[] => {\n      validateInputs(inputs);\n\n      // if (inferenceHandler.session.pack) {\n      //   return [inferenceHandler.run(createPackedLrnProgramInfoLoader(inferenceHandler, inputs, attributes),\n      //   inputs)];\n      // } else {\n      return [inferenceHandler.run(createLrnProgramInfoLoader(inputs, attributes), inputs)];\n      //}\n    };\n\nexport const parseLrnAttributes: OperatorInitialization<LrnAttributes> = (node: Graph.Node): LrnAttributes => {\n  const alpha = node.attributes.getFloat('alpha', 0.0001);\n  const beta = node.attributes.getFloat('beta', 0.75);\n  const bias = node.attributes.getFloat('bias', 1.0);\n  const size = node.attributes.getInt('size');\n\n  return createAttributeWithCacheKey({alpha, beta, bias, size});\n};\n\nconst lrnProgramMetadata = {\n  name: 'LRN',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked]\n};\n\nfunction createLrnProgramInfo(inputs: Tensor[], attributes: LrnAttributes): ProgramInfo {\n  const C = inputs[0].dims[1];\n  const rank = inputs[0].dims.length;\n  const from = -Math.floor((attributes.size - 1) / 2);\n  const to = Math.ceil((attributes.size - 1) / 2);\n  const alpha = `float(${attributes.alpha}) / float(${attributes.size})`;\n  const bias = `float(${attributes.bias})`;\n  const beta = `float(${attributes.beta})`;\n\n  const shaderSource = `\n    float process(int indices[${rank}]) {\n        int c = indices[1];\n        float x = _X(indices);\n        float square_sum = 0.0;\n\n        for (int i = ${from}; i <= ${to}; i++) {\n          int idx = c + i;\n          if (c >= 0 && c < ${C}) {\n            indices[1] = idx;\n            float j = _X(indices);\n            square_sum += j * j;\n          }\n        }\n        return x / pow(${bias} + ${alpha} * square_sum, ${beta});\n    }`;\n  return {\n    ...lrnProgramMetadata,\n    cacheHint: attributes.cacheKey,\n    output: {dims: inputs[0].dims, type: inputs[0].type, textureType: TextureType.unpacked},\n    shaderSource,\n  };\n}\n\nexport function createLrnProgramInfoLoader(inputs: Tensor[], attributes: LrnAttributes): ProgramInfoLoader {\n  return {...lrnProgramMetadata, cacheHint: attributes.cacheKey, get: () => createLrnProgramInfo(inputs, attributes)};\n}\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('LRN requires 1 input.');\n  }\n  if (inputs[0].dims.length !== 4) {\n    throw new Error('currently only support LRN for input with \"NCHW\" format');\n  }\n  if (inputs[0].type !== 'float32') {\n    throw new Error('input should be float type');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {BroadcastUtil, ShapeUtil} from '../../../util';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\nimport {getCoordsDataType, getGlChannels} from '../utils';\n\nimport {getActivationSnippet, InternalActivationAttributes} from './fuse-utils';\nimport {getBiasForMatmul} from './matmul';\n\nconst createPackedMatmulProgramMetadata = (hasBias: boolean, cacheHint: string) => ({\n  name: 'MatMul (packed)',\n  inputNames: hasBias ? ['A', 'B', 'Bias'] : ['A', 'B'],\n  inputTypes: hasBias ? [TextureType.packed, TextureType.packed, TextureType.packed] :\n                        [TextureType.packed, TextureType.packed],\n  cacheHint\n});\n\nconst createPackedMatmulProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, metadata: ProgramMetadata, inputs: Tensor[],\n     activationAttributes: InternalActivationAttributes): ProgramInfo => {\n      const hasBias = inputs.length > 2;\n      const processBias = hasBias ? 'value += getBiasForMatmul();' : '';\n      const aShape = inputs[0].dims;\n      const bShape = inputs[1].dims;\n      const outputShape = BroadcastUtil.calcShape(aShape, bShape, true);\n      const isBroadcast = !ShapeUtil.areEqual(inputs[0].dims, inputs[1].dims);\n\n      if (!outputShape) {\n        throw new Error('Can\\'t use matmul on the given tensors');\n      }\n      const sharedDim = aShape[aShape.length - 1];\n      const sharedDimIndex = Math.ceil(sharedDim / 2);\n      const aRank = aShape.length;\n      const bRank = bShape.length;\n\n      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n      const coordsDataType = getCoordsDataType(outputShape.length);\n      const outRank = outputShape.length;\n      const allGlChannels = getGlChannels();\n      const {activationFunction, applyActivation} = getActivationSnippet(activationAttributes);\n\n      const getBiasForMatmulSnippet =\n          hasBias ? `${getBiasForMatmul(coordsDataType, allGlChannels, inputs[2].dims, outputShape, true)}` : '';\n\n      const getBcastedSamplerForMatmulSnippet =\n          isBroadcast ? `${getBcastSamplerForMatmul(coordsDataType, allGlChannels, inputs, outputShape)}` : '';\n\n      const getSamplerAInLoopSnippet = isBroadcast ? 'getAAtOutCoordsMatmul(i)' : `getA(${getA(allGlChannels, aRank)})`;\n      const getSamplerBInLoopSnippet = isBroadcast ? 'getBAtOutCoordsMatmul(i)' : `getB(${getB(allGlChannels, bRank)})`;\n      const getOutputCoordsSnippet = isBroadcast ? '' : `${coordsDataType} rc =\n          getOutputCoords(); int lastDim = rc.${allGlChannels[outRank - 1]}; rc.${allGlChannels[outRank - 1]} =\n          rc.${allGlChannels[outRank - 2]}; rc.${allGlChannels[outRank - 2]} = lastDim;\n      `;\n      const shaderSource = `\n            ${getBcastedSamplerForMatmulSnippet}\n            ${getBiasForMatmulSnippet}\n            ${activationFunction}\n            void main() {\n              ${getOutputCoordsSnippet}\n\n              vec4 value = vec4(0);\n              for (int i = 0; i < ${sharedDimIndex}; i++) {\n                vec4 a = ${getSamplerAInLoopSnippet};\n                vec4 b = ${getSamplerBInLoopSnippet};\n\n                value += (a.rrbb * b.rgrg);\n                value += (a.ggaa * b.baba);\n              }\n              ${processBias}\n              ${applyActivation}\n              ${glsl.output} = value;\n            }`;\n      return {\n        ...metadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.packed},\n        shaderSource,\n        hasMain: true\n      };\n    };\n\nexport const createPackedMatmulProgramInfoLoader =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[],\n     activationAttributes: InternalActivationAttributes): ProgramInfoLoader => {\n      const metadata = createPackedMatmulProgramMetadata(inputs.length > 2, activationAttributes.activationCacheKey);\n      return {\n        ...metadata,\n        get: () => createPackedMatmulProgramInfo(inferenceHandler, metadata, inputs, activationAttributes)\n      };\n    };\n\nfunction getBcastSamplerForMatmul(\n    coordsDataType: string, allGlChannels: readonly string[], inputs: Tensor[], outShape: readonly number[]): string {\n  let unpackedACoordsSnippet = [];\n  let unpackedBCoordsSnippet = [];\n\n  const inAShape = inputs[0].dims;\n  const inBShape = inputs[1].dims;\n\n  const inARank = inAShape.length;\n  const inBRank = inBShape.length;\n\n  const outRank = outShape.length;\n  const rankADiff = outRank - inARank;\n  const rankBDiff = outRank - inBRank;\n\n  unpackedACoordsSnippet = inAShape.map((s, i) => `coords.${allGlChannels[i + rankADiff]}`);\n  unpackedACoordsSnippet[inARank - 1] = 'i*2';\n  unpackedACoordsSnippet.join(', ');\n  unpackedBCoordsSnippet = inBShape.map((s, i) => `coords.${allGlChannels[i + rankBDiff]}`);\n  unpackedBCoordsSnippet[inBRank - 2] = 'i*2';\n  unpackedBCoordsSnippet.join(', ');\n\n  const broadcastADims = BroadcastUtil.getBroadcastDims(inAShape, outShape);\n  const broadcastBDims = BroadcastUtil.getBroadcastDims(inBShape, outShape);\n\n  const coordsASnippet = broadcastADims.map(d => `coords.${allGlChannels[d + rankADiff]} = 0;`).join('\\n');\n  const coordsBSnippet = broadcastBDims.map(d => `coords.${allGlChannels[d + rankBDiff]} = 0;`).join('\\n');\n  const swapDimSnippet = `int lastDim = coords.${allGlChannels[outRank - 1]};\n  coords.${allGlChannels[outRank - 1]} = coords.${allGlChannels[outRank - 2]};\n  coords.${allGlChannels[outRank - 2]} = lastDim;`;\n\n  const getBcastSamplerMatmulSource = `\nvec4 getAAtOutCoordsMatmul(int i) {\n  ${coordsDataType} coords = getOutputCoords();\n  ${swapDimSnippet}\n  ${coordsASnippet}\n  vec4 outputValue = getA(${unpackedACoordsSnippet});\n  return outputValue;\n}\n\nvec4 getBAtOutCoordsMatmul(int i) {\n  ${coordsDataType} coords = getOutputCoords();\n  ${swapDimSnippet}\n  ${coordsBSnippet}\n  vec4 outputValue = getB(${unpackedBCoordsSnippet});\n  return outputValue;\n}`;\n\n  return getBcastSamplerMatmulSource;\n}\n\nfunction getA(allGlChannels: string[], rank: number): string {\n  let res = '';\n  for (let i = 0; i < rank - 2; i++) {\n    res += `rc.${allGlChannels[i]}, `;\n  }\n  res += `rc.${allGlChannels[rank - 2]}, ` +\n      'i*2';\n  return res;\n}\n\nfunction getB(allGlChannels: string[], rank: number): string {\n  let res = '';\n  for (let i = 0; i < rank - 2; i++) {\n    res += `rc.${allGlChannels[i]}, `;\n  }\n  res += 'i*2, ' +\n      `rc.${allGlChannels[rank - 1]}`;\n  return res;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {BroadcastUtil, ShapeUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\nimport {getCoordsDataType, getGlChannels} from '../utils';\n\nimport {getActivationSnippet, InternalActivationAttributes, parseInternalActivationAttributes} from './fuse-utils';\nimport {createPackedMatmulProgramInfoLoader} from './matmul-pack';\n\nexport const matMul: OperatorImplementation<InternalActivationAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: InternalActivationAttributes): Tensor[] => {\n      validateInputs(inputs);\n\n      if (inferenceHandler.session.pack) {\n        return [inferenceHandler.run(\n            createPackedMatmulProgramInfoLoader(inferenceHandler, inputs, attributes), inputs)];\n      } else {\n        return [inferenceHandler.run(createMatmulProgramInfoLoader(inputs, attributes), inputs)];\n      }\n    };\n\nexport const parseMatMulAttributes: OperatorInitialization<InternalActivationAttributes> =\n    (node: Graph.Node): InternalActivationAttributes => parseInternalActivationAttributes(node.attributes);\n\nconst createMatmulProgramMetadata = (hasBias: boolean, cacheHint: string) => ({\n  name: 'MatMul',\n  inputNames: hasBias ? ['A', 'B', 'Bias'] : ['A', 'B'],\n  inputTypes: hasBias ? [TextureType.unpacked, TextureType.unpacked, TextureType.unpacked] :\n                        [TextureType.unpacked, TextureType.unpacked],\n  cacheHint\n});\n\nfunction createMatmulProgramInfo(\n    metadata: ProgramMetadata, inputs: Tensor[], activationAttributes: InternalActivationAttributes): ProgramInfo {\n  const aShape = inputs[0].dims;\n  const bShape = inputs[1].dims;\n  const outputShape = BroadcastUtil.calcShape(aShape, bShape, true);\n  if (!outputShape) {\n    throw new Error('Can\\'t use matmul on the given tensors');\n  }\n  const coordsDataType = getCoordsDataType(outputShape.length);\n  const allGlChannels = getGlChannels();\n  const {activationFunction, applyActivation} = getActivationSnippet(activationAttributes);\n\n  const hasBias = inputs.length > 2;\n  const processBias = hasBias ? 'value += getBiasForMatmul();' : '';\n  const getBiasForMatmulSnippet =\n      hasBias ? `${getBiasForMatmul(coordsDataType, allGlChannels, inputs[2].dims, outputShape, false)}` : '';\n\n  const rank = outputShape.length;\n  const arank = aShape.length;\n  const brank = bShape.length;\n  const sharedDim = aShape[aShape.length - 1];\n  const shaderSource = `\n    ${activationFunction}\n    ${getBiasForMatmulSnippet}\n    float process(int indices[${rank}]) {\n        int a[${arank}];\n        int b[${brank}];\n        bcastMatmulIndices_A(indices, a);\n        bcastMatmulIndices_B(indices, b);\n\n        float value;\n        for (int k=0; k<${sharedDim}; ++k) {\n            a[${arank - 1}] = k;\n            b[${brank - 2}] = k;\n            value += _A(a) * _B(b);\n        }\n        ${processBias}\n        ${applyActivation}\n        return value;\n    }`;\n  return {\n    ...metadata,\n    output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n    shaderSource,\n  };\n}\n\nexport function createMatmulProgramInfoLoader(\n    inputs: Tensor[], activationAttributes: InternalActivationAttributes): ProgramInfoLoader {\n  const metadata = createMatmulProgramMetadata(inputs.length > 2, activationAttributes.activationCacheKey);\n  return {...metadata, get: () => createMatmulProgramInfo(metadata, inputs, activationAttributes)};\n}\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 2) {\n    throw new Error('MatMul requires 2 inputs.');\n  }\n\n  if (inputs[0].dims[inputs[0].dims.length - 1] !== inputs[1].dims[inputs[1].dims.length - 2]) {\n    throw new Error('shared dimension does not match.');\n  }\n\n  if ((inputs[0].type !== 'float32' && inputs[0].type !== 'float64') ||\n      (inputs[1].type !== 'float32' && inputs[1].type !== 'float64')) {\n    throw new Error('inputs should be float type');\n  }\n\n  if (inputs[0].type !== inputs[1].type) {\n    throw new Error('inputs types should match');\n  }\n};\n\nexport function getBiasForMatmul(\n    coordsDataType: string, allGlChannels: readonly string[], inShape: readonly number[], outShape: readonly number[],\n    isPacked: boolean): string {\n  let unpackedCoordsSnippet = '';\n  const inRank = inShape.length;\n  const outRank = outShape.length;\n  const rankDiff = outRank - inRank;\n  if (outRank < 2 && inRank > 0) {\n    unpackedCoordsSnippet = 'coords';\n  } else {\n    unpackedCoordsSnippet = inShape.map((s, i) => `coords.${allGlChannels[i + rankDiff]}`).join(', ');\n  }\n  const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);\n  const coordsSnippet = broadcastDims.map(d => `coords.${allGlChannels[d + rankDiff]} = 0;`).join('\\n');\n  const inSize = ShapeUtil.size(inShape);\n  const isInputScalar = inSize === 1;\n  let output = 'vec4(outputValue.xx, outputValue.yy)';\n  if (isInputScalar) {\n    output = 'vec4(outputValue.x)';\n  }\n  const getBiasForMatmulSource = isPacked ? `\nvec4 getBiasForMatmul() {\n  ${coordsDataType} coords = getOutputCoords();\n  ${coordsSnippet}\n  vec4 outputValue = getBias(${unpackedCoordsSnippet});\n  return ${output};\n}` :\n                                            `\nfloat getBiasForMatmul() {\n  ${coordsDataType} coords = getOutputCoords();\n  ${coordsSnippet}\n  return getBias(coords.x);\n}`;\n\n  return getBiasForMatmulSource;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, TextureType} from '../types';\nimport {getCoordsDataType} from '../utils';\n\nimport {getChannels} from './packing-utils';\n\nconst packProgramMetadata = {\n  name: 'pack',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpackedReversed]\n};\n\nconst createPackProgramInfo = (handler: WebGLInferenceHandler, input: Tensor): ProgramInfo => {\n  const glsl = getGlsl(handler.session.backend.glContext.version);\n  const inputShape = input.dims;\n\n  const inputRank = inputShape.length;\n  // createTextureLayoutFromShape won't change output rank. Need to verify by running tests\n  const outputRank = input.dims.length;\n\n  const coordsDataType = getCoordsDataType(outputRank);\n  const channels = getChannels('rc', outputRank);\n  const setup = getSetup(outputRank, channels, inputShape[inputShape.length - 2], inputShape[inputShape.length - 1]);\n\n  let reversedInputWH;\n  if (inputRank === 0) {\n    reversedInputWH = [1, 1];\n  } else if (inputRank === 1) {\n    reversedInputWH = [inputShape[0], 1];\n  } else {\n    reversedInputWH = [inputShape[outputRank - 1], inputShape[outputRank - 2]];\n  }\n  const outOfBoundsCondition = getOutOfBoundsCondition(outputRank, reversedInputWH, channels);\n  const output = getOutput(inputShape, channels);\n\n  const shaderSource = `\n        void main() {\n          ${coordsDataType} rc = getOutputCoords();\n\n          if(${outOfBoundsCondition}) {\n            ${glsl.output} = vec4(0);\n          } else {\n            ${setup}\n\n            ${glsl.output} = vec4(${output});\n          }\n        }\n      `;\n  return {\n    ...packProgramMetadata,\n    hasMain: true,\n    output: {dims: input.dims, type: input.type, textureType: TextureType.packed},\n    shaderSource\n  };\n};\n\nexport const createPackProgramInfoLoader = (handler: WebGLInferenceHandler, input: Tensor): ProgramInfoLoader =>\n    ({...packProgramMetadata, get: () => createPackProgramInfo(handler, input)});\n\n/**\n * check output coordinate location and return false if it is outside input's width/height boundary\n */\nfunction getOutOfBoundsCondition(rank: number, shape: readonly number[], dims: string[]): string {\n  if (rank === 0) {\n    return 'false';\n  }\n  if (rank === 1) {\n    return `rc > ${shape[0]}`;\n  }\n\n  let cond = '';\n  for (let i = rank - 2; i < rank; i++) {\n    cond += `${dims[i]} >= ${shape[i - rank + 2]}`;\n    if (i < rank - 1) {\n      cond += '||';\n    }\n  }\n\n  return cond;\n}\n\n/**\n * code snippet to sample input texture with output coordiantes\n */\nfunction getOutput(shape: readonly number[], dims: string[]): string {\n  const rank = shape.length;\n\n  if (rank === 0) {\n    return 'getA(), 0, 0, 0';\n  }\n\n  if (rank === 1) {\n    return `getA(rc),\n            rc + 1 >= ${shape[0]} ? 0. : getA(rc + 1),\n            0, 0`;\n  }\n\n  const coord00 = 'r, c';\n  const coord01 = 'r, cp1';\n  const coord10 = 'rp1, c';\n  const coord11 = 'rp1, cp1';\n  let D = '';\n  if (rank > 2) {\n    for (let i = 0; i < rank - 2; ++i) {\n      D = D + `${dims[i]},`;\n    }\n  }\n  return `getA(${D}${coord00}),\n          rEdge ? 0. : getA(${D}${coord10}),\n          cEdge ? 0. : getA(${D}${coord01}),\n          rEdge || cEdge ? 0. : getA(${D}${coord11})`;\n}\n\n/**\n * code snippet to setup 4 coordinates and edge conditions\n */\nfunction getSetup(rank: number, dims: string[], rows: number, cols: number): string {\n  if (rank === 0 || rank === 1) {\n    return '';\n  }\n  // rank >= 2 for width+height pack.\n  else {\n    const setup = `\n    int r = ${dims[rank - 2]};\n    int c = ${dims[rank - 1]};\n    int rp1 = ${dims[rank - 2]} + 1;\n    int cp1 = ${dims[rank - 1]} + 1;\n    bool rEdge = rp1 >= ${cols};\n    bool cEdge = cp1 >= ${rows};\n    `;\n    return setup;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {getGlChannels} from '../utils';\n\nexport function getVecChannels(name: string, rank: number): string[] {\n  return getGlChannels(rank).map(d => `${name}.${d}`);\n}\n\nexport function getChannels(name: string, rank: number): string[] {\n  if (rank === 1) {\n    return [name];\n  }\n  return getVecChannels(name, rank);\n}\n\nexport function unpackFromChannel(): string {\n  return `\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  `;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {getGlsl, Glsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, TextureType} from '../types';\n\nexport interface PadAttributes extends AttributeWithCacheKey {\n  readonly mode: string;\n  readonly pads: number[];\n  readonly value: number;\n}\n\nconst padProgramMetadata = {\n  name: 'Pad',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpacked],\n};\n\nexport const padV2: OperatorImplementation<PadAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: PadAttributes): Tensor[] => {\n      validateInputsV2(inputs);\n      const output = inferenceHandler.run(\n          {\n            ...padProgramMetadata,\n            cacheHint: attributes.cacheKey,\n            get: () => createPadProgramInfo(inferenceHandler, inputs[0], attributes)\n          },\n          inputs);\n      return [output];\n    };\n\nexport const parsePadAttributesV2: OperatorInitialization<PadAttributes> = (node: Graph.Node): PadAttributes => {\n  const mode = node.attributes.getString('mode', 'constant');\n  const value = node.attributes.getFloat('value', 0.0);\n  const pads = node.attributes.getInts('pads');\n  return createAttributeWithCacheKey({mode, value, pads});\n};\n\nexport const padV11: OperatorImplementation<string> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], mode: string): Tensor[] => {\n      validateInputsV11(inputs);\n      const attrubutes = generatePadAttributesFromInputs(inferenceHandler, inputs, mode);\n      return padV2(inferenceHandler, [inputs[0]], attrubutes);\n    };\n\nexport const parsePadAttributesV11: OperatorInitialization<string> = (node: Graph.Node): string =>\n    node.attributes.getString('mode', 'constant');\n\nconst generatePadAttributesFromInputs =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], mode: string): PadAttributes => {\n      if (!inferenceHandler.session.isInitializer(inputs[1].dataId) ||\n          (inputs.length >= 3 && !inferenceHandler.session.isInitializer(inputs[2].dataId))) {\n        throw new Error('dynamic pad attributes are not allowed');\n      }\n\n      const pads = Array.from(inputs[1].integerData);\n      const value = (inputs.length >= 3) ? inputs[2].floatData[0] : 0.0;\n\n      return createAttributeWithCacheKey({mode, pads, value});\n    };\n\nconst createPadProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, input: Tensor, attributes: PadAttributes): ProgramInfo => {\n      const outputShape = ShapeUtil.padShape(input.dims.slice(), attributes.pads);\n      const rank = outputShape.length;\n      const padFunction = getPadFunction(inferenceHandler, input, attributes);\n      const shaderSource = `\n      ${padFunction}\n      float process(int[${rank}] indices) {\n          return padA(indices);\n      }`;\n      return {\n        name: 'Pad',\n        inputNames: ['A'],\n        inputTypes: [TextureType.unpacked],\n        output: {dims: outputShape, type: input.type, textureType: TextureType.unpacked},\n        shaderSource\n      };\n    };\n\nconst validateInputsV2 = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Pad requires 1 input');\n  }\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('Invalid input type.');\n  }\n};\n\nconst validateInputsV11 = (inputs: Tensor[]): void => {\n  if (!inputs || (inputs.length !== 2 && inputs.length !== 3)) {\n    throw new Error('Pad requires 2 or 3 inputs');\n  }\n  if (inputs[1].type !== 'int32') {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs.length >= 3 && inputs[2].type === 'string') {\n    throw new Error('Invalid input type.');\n  }\n};\n\nconst getPadFunction = (inferenceHandler: WebGLInferenceHandler, input: Tensor, attributes: PadAttributes): string => {\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const [width, height] = inferenceHandler.calculateTextureWidthAndHeight(input.dims, TextureType.unpacked);\n  const strides = ShapeUtil.computeStrides(input.dims);\n\n  switch (attributes.mode) {\n    case 'constant':\n      return getPadConstant(glsl, input.dims, strides, width, height, attributes.pads, attributes.value);\n    case 'reflect':\n      return getPadReflect(glsl, input.dims, strides, width, height, attributes.pads);\n    case 'edge':\n      return getPadEdge(glsl, input.dims, strides, width, height, attributes.pads);\n    default:\n      throw new Error('Invalid mode');\n  }\n};\n\nconst getPadConstant =\n    (glsl: Glsl, shape: readonly number[], strides: readonly number[], width: number, height: number, pads: number[],\n     value: number): string => {\n      const rank = shape.length;\n      let block = '';\n      for (let i = rank - 1; i >= 0; --i) {\n        block += `\n        k = m[${i}] - ${pads[i]};\n        if (k < 0)  return constant;\n        if (k >= ${shape[i]}) return constant;\n        offset += k * ${strides[i]};\n        `;\n      }\n      return `\n      float padA(int m[${rank}]) {\n        const float constant = float(${value});\n        int offset = 0;\n        int k = 0;\n        ${block}\n        vec2 coords = offsetToCoords(offset, ${width}, ${height});\n        float value = getColorAsFloat(${glsl.texture2D}(A, coords));\n        return value;\n      }\n      `;\n    };\n\nconst getPadReflect =\n    (glsl: Glsl, shape: readonly number[], strides: readonly number[], width: number, height: number, pads: number[]):\n        string => {\n          const rank = shape.length;\n\n          let block = '';\n          for (let i = rank - 1; i >= 0; --i) {\n            block += `\n        k = m[${i}] - ${pads[i]};\n        if (k < 0) { k = -k; }\n        {\n          const int _2n_1 = ${2 * (shape[i] - 1)};\n          k = int( mod( float(k), float(_2n_1) ) ) ;\n          if(k >= ${shape[i]}) { k = _2n_1 - k; }\n        }\n        offset += k * ${strides[i]};\n        `;\n          }\n          return `\n      float padA(int m[${rank}]) {\n        int offset = 0;\n        int k = 0;\n        ${block}\n        vec2 coords = offsetToCoords(offset, ${width}, ${height});\n        float value = getColorAsFloat(${glsl.texture2D}(A, coords));\n        return value;\n      }\n      `;\n        };\n\nconst getPadEdge =\n    (glsl: Glsl, shape: readonly number[], strides: readonly number[], width: number, height: number, pads: number[]):\n        string => {\n          const rank = shape.length;\n\n          let block = '';\n          for (let i = rank - 1; i >= 0; --i) {\n            block += `\n        k = m[${i}] - ${pads[i]};\n        if (k < 0)  k = 0;\n        if (k >= ${shape[i]}) k = ${shape[i] - 1};\n        offset += k * ${strides[i]};\n      `;\n          }\n          return `\n      float padA(int m[${rank}]) {\n        int offset = 0;\n        int k = 0;\n        ${block}\n        vec2 coords = offsetToCoords(offset, ${width}, ${height});\n        float value = getColorAsFloat(${glsl.texture2D}(A, coords));\n        return value;\n      }\n      `;\n        };\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {PoolConvUtil, ShapeUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramMetadata, TextureType} from '../types';\n\nexport interface AveragePoolAttributes extends AttributeWithCacheKey {\n  readonly autoPad: string;\n  readonly ceilMode: number;\n  readonly countIncludePad: boolean;\n  readonly kernelShape: readonly number[];\n  readonly strides: readonly number[];\n  readonly pads: readonly number[];\n}\n\nexport const averagePool: OperatorImplementation<AveragePoolAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: AveragePoolAttributes): Tensor[] => {\n      validateInputs(inputs);\n      const metadata =\n          {name: 'AveragePool', inputNames: ['X'], inputTypes: [TextureType.unpacked], cacheHint: attributes.cacheKey};\n      const output = inferenceHandler.run(\n          {...metadata, get: () => createAveragePoolProgramInfo(inputs, metadata, false, attributes)}, inputs);\n      return [output];\n    };\n\nexport const parseAveragePoolAttributes: OperatorInitialization<AveragePoolAttributes> =\n    (node: Graph.Node): AveragePoolAttributes => {\n      const autoPad = node.attributes.getString('auto_pad', 'NOTSET');\n      const ceilMode = node.attributes.getInt('ceil_mode', 0);\n      const countIncludePad = (node.attributes.getInt('count_include_pad', 0) === 0 ? false : true);\n      const kernelShape = node.attributes.getInts('kernel_shape');\n      const strides = node.attributes.getInts('strides', []);\n      const pads = node.attributes.getInts('pads', []);\n\n      // TODO: support attribute 'ceil_mode'\n      if (ceilMode !== 0) {\n        throw new Error('using ceil() in shape computation is not yet supported for AveragePool');\n      }\n\n      return createAttributeWithCacheKey({autoPad, ceilMode, countIncludePad, kernelShape, strides, pads});\n    };\n\nconst createAveragePoolProgramInfo =\n    (inputs: Tensor[], metadata: ProgramMetadata, isGlobalOperator: boolean, attributes: AveragePoolAttributes):\n        ProgramInfo => {\n          const [adjustedAttributes, outputShape] =\n              getAdjustedPoolAttributesAndOutputShape(inputs, attributes, isGlobalOperator);\n          const kernelSize = ShapeUtil.size(adjustedAttributes.kernelShape);\n          const op1 = 'value += _X(x);';\n          let op2 = '';\n          if (adjustedAttributes.countIncludePad) {\n            op2 += `value /= float(${kernelSize});`;\n          } else {\n            op2 += `value /= float(${kernelSize} - pad);`;\n          }\n          const poolingCode = generatePoolingCode(inputs[0].dims, adjustedAttributes, op1, op2, '0.0');\n          const shaderSource = `\n        ${poolingCode}\n      `;\n          return {\n            ...metadata,\n            output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n            shaderSource\n          };\n        };\n\nexport const globalAveragePool: OperatorImplementation<AveragePoolAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: AveragePoolAttributes): Tensor[] => {\n      validateInputs(inputs);\n      const metadata = {\n        name: 'GlobalAveragePool',\n        inputNames: ['X'],\n        inputTypes: [TextureType.unpacked],\n        cacheHint: `${attributes.countIncludePad}`\n      };\n      const output = inferenceHandler.run(\n          {...metadata, get: () => createAveragePoolProgramInfo(inputs, metadata, true, attributes)}, inputs);\n      return [output];\n    };\n\nexport const parseGlobalAveragePoolAttributes: OperatorInitialization<AveragePoolAttributes> =\n    (node: Graph.Node): AveragePoolAttributes => {\n      const countIncludePad = (node.attributes.getInt('count_include_pad', 0) === 0 ? false : true);\n      return createAttributeWithCacheKey(\n          {autoPad: '', ceilMode: 0, countIncludePad, kernelShape: [], strides: [], pads: []});\n    };\n\nexport interface MaxPoolAttributes extends AveragePoolAttributes {\n  readonly storageOrder: number;\n  readonly dilations: number[];\n}\n\nexport const maxPool: OperatorImplementation<MaxPoolAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: MaxPoolAttributes): Tensor[] => {\n      validateInputs(inputs);\n      const metadata =\n          {name: 'MaxPool', inputNames: ['X'], inputTypes: [TextureType.unpacked], cacheHint: attributes.cacheKey};\n      const output = inferenceHandler.run(\n          {...metadata, get: () => createMaxPoolProgramInfo(inputs, metadata, false, attributes)}, inputs);\n      return [output];\n    };\n\nexport const parseMaxPoolAttributes: OperatorInitialization<MaxPoolAttributes> =\n    (node: Graph.Node): MaxPoolAttributes => {\n      const autoPad = node.attributes.getString('auto_pad', 'NOTSET');\n      const ceilMode = node.attributes.getInt('ceil_mode', 0);\n      const kernelShape = node.attributes.getInts('kernel_shape');\n      const strides = node.attributes.getInts('strides', []);\n      const pads = node.attributes.getInts('pads', []);\n      const storageOrder = node.attributes.getInt('storage_order', 0);\n      const dilations = node.attributes.getInts('dilations', []);\n\n      // TODO: support attribute 'ceil_mode' and 'storage_order'\n      if (storageOrder !== 0) {\n        throw new Error('column major storage order is not yet supported for MaxPool');\n      }\n      if (ceilMode !== 0) {\n        throw new Error('using ceil() in shape computation is not yet supported for MaxPool');\n      }\n\n      return createAttributeWithCacheKey(\n          {autoPad, ceilMode, countIncludePad: false, kernelShape, strides, pads, storageOrder, dilations});\n    };\n\nconst createMaxPoolProgramInfo =\n    (inputs: Tensor[], metadata: ProgramMetadata, isGlobalOperator: boolean, attributes: MaxPoolAttributes):\n        ProgramInfo => {\n          const [adjustedAttributes, outputShape] =\n              getAdjustedPoolAttributesAndOutputShape(inputs, attributes, isGlobalOperator);\n          const op1 = `\n      value = max(_X(x), value);\n    `;\n          const op2 = '';\n          const poolingCode = generatePoolingCode(inputs[0].dims, adjustedAttributes, op1, op2, '-1e5');\n          const shaderSource = `\n      ${poolingCode}\n    `;\n          return {\n            ...metadata,\n            output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n            shaderSource\n          };\n        };\n\nconst getAdjustedPoolAttributesAndOutputShape =\n    (inputs: Tensor[], attributes: AveragePoolAttributes|MaxPoolAttributes, isGlobalOperator: boolean):\n        [AveragePoolAttributes|MaxPoolAttributes, number[]] => {\n          const inputShape = inputs[0].dims.slice();\n          const hasDilations = Object.hasOwnProperty.call(attributes, 'dilations');\n          const kernelShape = attributes.kernelShape.slice();\n          const strides = attributes.strides.slice();\n          const dilations: number[] = hasDilations ? (attributes as MaxPoolAttributes).dilations.slice() : [];\n          const pads = attributes.pads.slice();\n          PoolConvUtil.adjustPoolAttributes(isGlobalOperator, inputShape, kernelShape, strides, dilations, pads);\n\n          const outputShape = PoolConvUtil.computePoolOutputShape(\n              isGlobalOperator, inputShape, strides, dilations, kernelShape, pads, attributes.autoPad);\n\n          const newAttributes = Object.assign({}, attributes);\n          if (hasDilations) {\n            Object.assign(newAttributes, {kernelShape, strides, pads, dilations, cacheKey: attributes.cacheKey});\n          } else {\n            Object.assign(newAttributes, {kernelShape, strides, pads, cacheKey: attributes.cacheKey});\n          }\n          return [newAttributes, outputShape];\n        };\n\nconst globalMaxPoolAttributes = {\n  autoPad: '',\n  ceilMode: 0,\n  countIncludePad: false,\n  kernelShape: [],\n  strides: [],\n  pads: [],\n  storageOrder: 0,\n  dilations: [],\n  cacheKey: ''\n};\n\nconst globalMaxPoolMetadata = {\n  name: 'GlobalMaxPool',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked]\n};\n\nexport const globalMaxPool = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputs(inputs);\n  const output = inferenceHandler.run(\n      {\n        ...globalMaxPoolMetadata,\n        get: () => createMaxPoolProgramInfo(inputs, globalMaxPoolMetadata, true, globalMaxPoolAttributes)\n      },\n      inputs);\n  return [output];\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Pool ops requires 1 input.');\n  }\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('Invalid input type.');\n  }\n};\n\nconst generatePoolingCode =\n    (inputDims: readonly number[], attributes: AveragePoolAttributes, op1: string, op2: string, start: string):\n        string => {\n          const rank = inputDims.length;\n          if (attributes.kernelShape.length <= 2) {\n            const kw = attributes.kernelShape[attributes.kernelShape.length - 1];\n            const sw = attributes.strides[attributes.strides.length - 1];\n            const pwStart = attributes.pads[attributes.pads.length / 2 - 1];\n            const pwEnd = attributes.pads[attributes.pads.length - 1];\n            const dimW = inputDims[rank - 1];\n            let codeW = '';\n            let codeH = '';\n            let codeHEnd = '';\n            if (pwStart + pwEnd !== 0) {\n              codeW = `\n          for (int i = 0; i < ${kw}; i++) {\n            x[${rank} - 1] = indices[${rank} - 1] * ${sw} - ${pwStart} + i;\n            if (x[${rank} - 1] < 0 || x[${rank} - 1] >= ${dimW}) {\n              pad++;\n              continue;\n            }\n            ${op1}\n          }`;\n            } else {\n              codeW = `\n          for (int i = 0; i < ${kw}; i++) {\n            x[${rank} - 1] = indices[${rank} - 1] * ${sw} - ${pwStart} + i;\n            ${op1}\n          }`;\n            }\n\n            if (attributes.kernelShape.length === 2) {\n              const kh = attributes.kernelShape[attributes.kernelShape.length - 2];\n              const sh = attributes.strides[attributes.strides.length - 2];\n              const phStart = attributes.pads[attributes.pads.length / 2 - 2];\n              const phEnd = attributes.pads[attributes.pads.length - 2];\n              const dimH = inputDims[rank - 2];\n              if (phStart + phEnd !== 0) {\n                codeH = `\n            for (int j = 0; j < ${kh}; j++) {\n              x[${rank} - 2] = indices[${rank} - 2] * ${sh} - ${phStart} + j;\n              if (x[${rank} - 2] < 0 || x[${rank} - 2] >= ${dimH}) {\n                pad+= ${kw};\n                continue;\n              }\n          `;\n              } else {\n                codeH = `\n            for (int j = 0; j < ${kh}; j++) {\n              x[${rank} - 2] = indices[${rank} - 2] * ${sh} - ${phStart} + j;\n            `;\n              }\n              codeHEnd = `\n          }\n        `;\n            }\n\n            const poolingCode = `\n        float process(int indices[${rank}]) {\n          int x[${rank}];\n          copyVec(indices, x);\n\n          float value = ${start};\n          int pad = 0;\n          ${codeH}\n          ${codeW}\n          ${codeHEnd}\n          ${op2}\n          return value;\n        }\n      `;\n            return poolingCode;\n          } else {\n            const kernelSize = ShapeUtil.size(attributes.kernelShape);\n            const kernelStrides = ShapeUtil.computeStrides(attributes.kernelShape);\n            const stridesRank = kernelStrides.length;\n            const padsRank = attributes.pads.length;\n            const offsetToIndicesFunction = offsetToIndices(stridesRank);\n            const copyInputDims = copyArray(inputDims, 'inputDims');\n            const copyPads = copyArray(attributes.pads, 'pads');\n            const copyKernelStrides = copyArray(kernelStrides, 'kernelStrides');\n            const copyStrides = copyArray(attributes.strides, 'strides');\n            const hasPads = attributes.pads.reduce((sum, cur) => sum + cur);\n            let padCode = '';\n            if (hasPads) {\n              padCode = `\n            if (x[j] >= inputDims[j] || x[j] < 0) {\n              pad++;\n              isPad = true;\n              break;\n            }\n          }\n          if (!isPad) {\n            ${op1}\n          }`;\n            } else {\n              padCode = `\n          }\n          ${op1}\n        `;\n            }\n            const poolingCode = `\n        ${offsetToIndicesFunction}\n        float process(int indices[${rank}]) {\n          int x[${rank}];\n          copyVec(indices, x);\n          int offset[${stridesRank}];\n          int pads[${padsRank}];\n          int inputDims[${rank}];\n          int kernelStrides[${stridesRank}];\n          int strides[${stridesRank}];\n          ${copyPads}\n          ${copyInputDims}\n          ${copyStrides}\n          ${copyKernelStrides}\n\n          float value = ${start};\n          int pad = 0;\n          bool isPad = false;\n          for (int i = 0; i < ${kernelSize}; i++) {\n            offsetToIndices(i, kernelStrides, offset);\n            isPad = false;\n            for (int j = ${rank} - ${stridesRank}; j < ${rank}; j++) {\n              x[j] = indices[j] * strides[j - ${rank} + ${stridesRank}]\n                + offset[j - ${rank} + ${stridesRank}] - pads[j - 2];\n              ${padCode}\n          }\n          ${op2}\n\n          return value;\n        }\n      `;\n            return poolingCode;\n          }\n        };\n\nconst copyArray = (array: readonly number[], arrayName: string): string => {\n  let block = '';\n  for (let i = 0; i < array.length; i++) {\n    block += `\n      ${arrayName}[${i}] = ${array[i]};\n    `;\n  }\n  return block;\n};\n\nconst offsetToIndices = (rank: number): string => `\n  void offsetToIndices(int offset, int[${rank}] strides, out int[${rank}] indices) {\n    if (${rank} == 0) {\n      return;\n    }\n    for (int i = 0; i < ${rank} - 1; ++i) {\n      indices[i] = offset / strides[i];\n      offset -= indices[i] * strides[i];\n    }\n    indices[${rank} - 1] = offset;\n  }`;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {NUMBER_TYPES, OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramMetadata, TextureType} from '../types';\n\nexport interface ReduceAttributes extends AttributeWithCacheKey {\n  readonly axes: number[];\n  readonly keepDims: boolean;\n}\n\n// return [init ops, reduce ops, final ops]\ntype ReduceOp = (inputs: Tensor[], axes: number[]) => string[];\n\nconst reduce =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ReduceAttributes, name: string,\n     reduceOp: ReduceOp): Tensor[] => {\n      validateInputs(inputs);\n\n      const reduceProgramMetadata = {\n        name,\n        inputNames: ['A'],\n        inputTypes: [TextureType.unpacked],\n      };\n\n      const output = inferenceHandler.run(\n          {\n            ...reduceProgramMetadata,\n            cacheHint: attributes.cacheKey,\n            get: () =>\n                createReduceProgramInfo(inferenceHandler, inputs, attributes, name, reduceOp, reduceProgramMetadata)\n          },\n          inputs);\n      return [output];\n    };\n\nexport const parseReduceAttributes: OperatorInitialization<ReduceAttributes> = (node: Graph.Node): ReduceAttributes => {\n  const axes = node.attributes.getInts('axes', []);\n  const keepDims = node.attributes.getInt('keepdims', 1) === 1;\n  return createAttributeWithCacheKey({axes, keepDims});\n};\n\nconst createReduceProgramInfo =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], attributes: ReduceAttributes, name: string, reduceOp: ReduceOp,\n     reduceProgramMetadata: ProgramMetadata): ProgramInfo => {\n      const outputShape: number[] = [];\n      const iRank = inputs[0].dims.length || 1;\n\n      const idxCopy = [];  // copy output indexes to input indexes\n\n      const axes = ShapeUtil.normalizeAxes(attributes.axes, inputs[0].dims.length);\n      const ops = reduceOp(inputs, axes);\n      let reduceOps = ops[1];\n\n      for (let k = 0; k < inputs[0].dims.length; k++) {\n        // if this axis is reduced\n        if (axes.indexOf(k) >= 0 || axes.length === 0) {\n          if (attributes.keepDims) {\n            outputShape.push(1);\n          }  // else { remove the axis from outputShape; }\n\n          // loop over the d-th axis\n          reduceOps = `\n          for(int j${k} = 0; j${k} < ${inputs[0].dims[k]}; j${k}++) {\n            inputIdx[${k}] = j${k};\n            ${reduceOps}\n          }`;\n        } else {\n          idxCopy.push(`inputIdx[${k}] = outputIdx[${outputShape.length}];`);\n\n          outputShape.push(inputs[0].dims[k]);\n        }\n      }\n\n      const oRank = outputShape.length || 1;\n\n      const shaderSource = `\n      float process(int outputIdx[${oRank}]) {\n        float value;                 // final result\n        int inputIdx[${iRank}];      // addressing input data\n        ${idxCopy.join('\\n')}\n        ${ops[0]}       // init ops for reduce max/min\n        ${reduceOps}\n        ${ops[2]}       // final computation for reduce mean\n        return value;\n      }`;\n\n      return {\n        ...reduceProgramMetadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n        shaderSource\n      };\n    };\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  // TODO: support Reduce* operators with 2 inputs.\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Reduce op requires 1 input.');\n  }\n\n  if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {\n    throw new Error('Invalid input type.');\n  }\n};\n\nexport const reduceSum: OperatorImplementation<ReduceAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ReduceAttributes): Tensor[] => {\n      const reduceOp: ReduceOp = (): string[] => ['value = 0.0;', 'value += _A(inputIdx);', ''];\n      return reduce(inferenceHandler, inputs, attributes, 'ReduceSum', reduceOp);\n    };\n\nexport const reduceMean: OperatorImplementation<ReduceAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ReduceAttributes): Tensor[] => {\n      const reduceOp: ReduceOp = (inputs: Tensor[], axes: number[]): string[] => {\n        let size = 1.0;\n        for (let k = 0; k < inputs[0].dims.length; k++) {\n          if (axes.indexOf(k) >= 0 || axes.length === 0) {\n            size *= inputs[0].dims[k];\n          }\n        }\n\n        return ['value = 0.0;', 'value += _A(inputIdx);', `value /= ${size}.;`];  // ensure real number with `.`\n      };\n      return reduce(inferenceHandler, inputs, attributes, 'ReduceMean', reduceOp);\n    };\n\nexport const reduceMax: OperatorImplementation<ReduceAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ReduceAttributes): Tensor[] => {\n      const reduceOp: ReduceOp = (inputs: Tensor[], axes: number[]): string[] => {\n        const idxZero = [];\n        for (let k = 0; k < inputs[0].dims.length; k++) {\n          if (axes.indexOf(k) >= 0 || axes.length === 0) {\n            idxZero.push(`inputIdx[${k}] = 0;`);  // first element\n          }\n        }\n\n        return [`${idxZero.join('\\n')}\\nvalue = _A(inputIdx);`, 'value = max(value, _A(inputIdx));', ''];\n      };\n      return reduce(inferenceHandler, inputs, attributes, 'ReduceMax', reduceOp);\n    };\n\nexport const reduceMin: OperatorImplementation<ReduceAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ReduceAttributes): Tensor[] => {\n      const reduceOp: ReduceOp = (inputs: Tensor[], axes: number[]): string[] => {\n        const idxZero = [];\n        for (let k = 0; k < inputs[0].dims.length; k++) {\n          if (axes.indexOf(k) >= 0 || axes.length === 0) {\n            idxZero.push(`inputIdx[${k}] = 0;`);  // first element\n          }\n        }\n\n        return [`${idxZero.join('\\n')}\\nvalue = _A(inputIdx);`, 'value = min(value, _A(inputIdx));', ''];\n      };\n      return reduce(inferenceHandler, inputs, attributes, 'ReduceMin', reduceOp);\n    };\n\nexport const reduceProd: OperatorImplementation<ReduceAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ReduceAttributes): Tensor[] => {\n      const reduceOp: ReduceOp = (): string[] => ['value = 1.0;', 'value *= _A(inputIdx);', ''];\n      return reduce(inferenceHandler, inputs, attributes, 'ReduceProd', reduceOp);\n    };\n\nexport const reduceLogSum: OperatorImplementation<ReduceAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ReduceAttributes): Tensor[] => {\n      const reduceOp: ReduceOp = (): string[] => ['value = 0.0;', 'value += _A(inputIdx);', 'value = log(value);'];\n      return reduce(inferenceHandler, inputs, attributes, 'ReduceLogSum', reduceOp);\n    };\n\nexport const reduceLogSumSquare: OperatorImplementation<ReduceAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ReduceAttributes): Tensor[] => {\n      const reduceOp: ReduceOp = (): string[] => ['float t; value = 0.0;', 't = _A(inputIdx); value += t * t;', ''];\n      return reduce(inferenceHandler, inputs, attributes, 'ReduceLogSumSquare', reduceOp);\n    };\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\nimport {unpackFromChannel} from './packing-utils';\n\nconst createPackedReshape3DProgramMetadata = (outputShape3D: readonly number[]) =>\n    ({name: 'Reshape (packed)', inputTypes: [TextureType.packed], inputNames: ['A'], cacheHint: `${outputShape3D}`});\n\nconst createPackedReshape3DProgramInfo =\n    (handler: WebGLInferenceHandler, input3D: Tensor, metadata: ProgramMetadata, outputShape3D: readonly number[]):\n        ProgramInfo => {\n          const inputShape3D = input3D.dims as [number, number, number];\n          const squeezedOutputShape = outputShape3D as [number, number, number];\n\n          let mainLoop = '';\n          for (let i = 0; i < 4; i++) {\n            let outputCoords = '';\n            switch (i) {\n              case 0:\n                outputCoords = 'outputCoords = rc;';\n                break;\n              case 1:\n                outputCoords = 'outputCoords = ivec3(rc.x, rc.y+1, rc.z);';\n                break;\n              case 2:\n                outputCoords = 'outputCoords = ivec3(rc.x, rc.y, rc.z+1);';\n                break;\n              case 3:\n                outputCoords = 'outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);';\n                break;\n              default:\n                throw new Error();\n            }\n\n            mainLoop += `\n        ${outputCoords}\n        ${i > 0 ? 'if(outputCoords.y < rows && outputCoords.z < cols){' : ''}\n          int flattenedIndex = getFlattenedIndex(outputCoords);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${i}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\n\n        ${i > 0 ? '}' : ''}\n      `;\n          }\n          const glsl = getGlsl(handler.session.backend.glContext.version);\n\n          const shaderSource = `\n      ${getReshapedInputCoords(inputShape3D)}\n      ${getFlattenedIndexFrom3D(squeezedOutputShape)}\n      ${unpackFromChannel()}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.0);\n\n        ivec3 outputCoords;\n        int rows = ${squeezedOutputShape[2]};\n        int cols = ${squeezedOutputShape[1]};\n\n        ${mainLoop}\n        ${glsl.output} = result;\n      }\n    `;\n\n          return {\n            ...metadata,\n            output: {dims: squeezedOutputShape, type: input3D.type, textureType: TextureType.packed},\n            shaderSource,\n            hasMain: true\n          };\n        };\n\nexport const createPackedReshape3DProgramInfoLoader =\n    (handler: WebGLInferenceHandler, input3D: Tensor, outputShape3D: readonly number[]): ProgramInfoLoader => {\n      const metadata = createPackedReshape3DProgramMetadata(outputShape3D);\n      return {...metadata, get: () => createPackedReshape3DProgramInfo(handler, input3D, metadata, outputShape3D)};\n    };\n\nexport function processDims3D(shape: ArrayLike<number>): [number, number, number] {\n  if (shape.length === 0) {\n    return [1, 1, 1];\n  }\n  // TODO: squeeze other shapes to 2D case\n  let batch = 1;\n  for (let i = 0; i < shape.length - 2; ++i) {\n    batch *= shape[i];\n  }\n  return [batch, shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]];\n}\n\n// For packed reshape, we need to re-arrange texel data for output shape.\n// Our pack is designed to pack a 2x2 tile in last h and w dimension, so\n// for the reshaped new tensor, we just need to re-arrange the last h and\n// w dimension. For any shape that is not in 3D, i.e. [batch, W, H], we\n// first convert it to 3D by collapsing other dimension to batch dim, then\n// process with the last two dimensions.\n// Note: we only need the shape tensor to calculate output shape, so the\n// content in shape tensor is never uploaded to GPU. It is always kept in CPU.\n// TODO: optimize the algorithm -- in some cases, if the last two dims are\n// the same between input shape and output shape, the packed reshape can be\n// treated as no-op.\nexport function isReshapeCheap(dims: readonly number[], reshapedDims: readonly number[]) {\n  let isCheapReshape = false;\n  if (dims.length === 0 || reshapedDims.length === 0) {  // scalar\n    isCheapReshape = true;\n  } else if (dims.length < 2 || reshapedDims.length < 2) {  // 1D\n    isCheapReshape = dims[dims.length - 1] === reshapedDims[reshapedDims.length - 1];\n  } else {  // 2D +\n    isCheapReshape = dims[dims.length - 1] === reshapedDims[reshapedDims.length - 1] &&\n        dims[dims.length - 2] === reshapedDims[reshapedDims.length - 2];\n  }\n\n  return isCheapReshape;\n}\n\nfunction getReshapedInputCoords(shape: [number, number, number]): string {\n  const strides = ShapeUtil.computeStrides(shape);\n  const coords = ['b', 'r', 'c'];\n  const index = 'index';\n  const coordsFromIndexSnippet = strides\n                                     .map((stride, i) => {\n                                       const line1 = `int ${coords[i]} = ${index} / ${stride}`;\n                                       const line2 = i === strides.length - 1 ?\n                                           `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}` :\n                                           `index -= ${coords[i]} * ${stride}`;\n                                       return `${line1}; ${line2};`;\n                                     })\n                                     .join('');\n\n  return `\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${coordsFromIndexSnippet}\n      return ivec3(b, r, c);\n    }\n  `;\n}\n\nfunction getFlattenedIndexFrom3D(shape: [number, number, number]): string {\n  const strides = ShapeUtil.computeStrides(shape);\n\n  return `\n  int getFlattenedIndex(ivec3 coords) {\n    // reverse y, z order\n    return coords.x * ${strides[0]} + coords.z * ${strides[1]} + coords.y;\n  }\n`;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\n\nexport const reshape = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  const reshapedDims = ShapeUtil.calculateReshapedDims(inputs[0].dims, inputs[1].integerData);\n  if (handler.session.pack) {\n    return [handler.reshapePacked(inputs[0], reshapedDims)];\n  } else {\n    return [handler.reshapeUnpacked(inputs[0], reshapedDims)];\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, TextureType} from '../types';\nimport {getCoordsDataType} from '../utils';\n\nimport {unpackFromChannel} from './packing-utils';\nimport {parseUpsampleAttributes, scalesValidation, UpsampleAttributes, validateInputs} from './upsample';\n\nconst resizeProgramMetadata = {\n  name: 'Resize',\n  inputNames: ['A'],\n  inputTypes: [TextureType.packed]\n};\n\nexport const resize: OperatorImplementation<UpsampleAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: UpsampleAttributes): Tensor[] => {\n      validateInputs(inputs, attributes);\n      const output = inferenceHandler.run(\n          {\n            ...resizeProgramMetadata,\n            cacheHint: attributes.cacheKey,\n            get: () => createPackedResizeProgramInfo(inferenceHandler, inputs, attributes)\n          },\n          inputs);\n      return [output];\n    };\n\nexport const parseResizeAttributesV10: OperatorInitialization<UpsampleAttributes> =\n    (node: Graph.Node): UpsampleAttributes => parseUpsampleAttributes(node, 10);\n\nexport const parseResizeAttributesV11: OperatorInitialization<UpsampleAttributes> =\n    (node: Graph.Node): UpsampleAttributes => parseUpsampleAttributes(node, 11);\n\nconst createPackedResizeProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: UpsampleAttributes): ProgramInfo => {\n      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n      const [scales, outputShape] = prepareInputs(inputs, attributes);\n\n      const isSame =\n          scales.every((s: number) => s === 1) && attributes.coordinateTransformMode !== 'tf_crop_and_resize';\n      if (isSame) {\n        return {\n          ...resizeProgramMetadata,\n          output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.packed},\n          hasMain: true,\n          shaderSource: `void main() {\n                    vec4 v = ${glsl.texture2D}(X, TexCoords);\n                    ${glsl.output} = v;\n                }`\n        };\n      }\n\n      const dim = outputShape.length;\n      if (dim < 2) {\n        throw new Error(`output dimension should be at least 2, but got ${dim}`);\n      }\n\n      const outputHeight = outputShape[dim - 2];\n      const outputWidth = outputShape[dim - 1];\n\n      const inputShape = inputs[0].dims;\n      if (dim !== inputShape.length) {\n        throw new Error(`output dimension should match input ${inputShape.length}, but got ${dim}`);\n      }\n      const inputHeight = inputShape[dim - 2];\n      const inputWidth = inputShape[dim - 1];\n\n      const scalesHeight = scales[dim - 2];\n      const scalesWidth = scales[dim - 1];\n\n      let getSourceFracIndex = '';\n\n      if (attributes.mode !== 'linear') {\n        // TODO: support other modes\n        throw new Error(`resize (packed) does not support mode: '${attributes.mode}'`);\n      }\n      switch (attributes.coordinateTransformMode) {\n        case 'asymmetric':\n          getSourceFracIndex = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                `;\n          break;\n        case 'half_pixel':\n          getSourceFracIndex = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                `;\n          break;\n        case 'pytorch_half_pixel':\n          getSourceFracIndex = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 fcoords = vec4(coords);\n                        return vec4(\n                            ${outputWidth}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\n                            ${outputHeight}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\n                            ${outputWidth}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\n                            ${outputHeight}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\n                          );\n                    }\n                `;\n          break;\n        case 'align_corners':\n          getSourceFracIndex = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 resized = vec4(${outputWidth}.0 - 1.0, ${outputHeight}.0 - 1.0, ${outputWidth}.0 - 1.0,\n                            ${outputHeight}.0 - 1.0);\n                        vec4 original = vec4(${inputWidth}.0 - 1.0, ${inputHeight}.0 - 1.0, ${inputWidth}.0 - 1.0,\n                            ${inputHeight}.0 - 1.0);\n                        vec4 new_scale = original / resized;\n                        return vec4(coords) * new_scale;\n                    }\n                `;\n          break;\n        default:\n          // TODO:supporting other coordinateTransformModes\n          throw new Error(`resize (packed) does not support coordinateTransformMode: \\\n                                '${attributes.coordinateTransformMode}'`);\n      }\n\n      const coordsDataType = getCoordsDataType(dim);\n      const unpackChannel = unpackFromChannel();\n      const shaderSource = `\n            const vec2 inputWH = vec2(${inputHeight}.0, ${inputWidth}.0);\n            const vec4 scaleWHWH = vec4(float(${scalesHeight}), float(${scalesWidth}), float(${scalesHeight}), float(${\n          scalesWidth}));\n            ${unpackChannel}\n            ${getSourceFracIndex}\n            float getAValue(int x10, int r, int c, int d) {\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\n            }\n            void main() {\n                ${coordsDataType} rc = getOutputCoords();\n\n                int batch = rc[0];\n                int depth = rc[1];\n\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\n\n                // calculate the source index in fraction\n                vec4 sourceFrac = getSourceFracIndex(coords);\n\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\n\n                bool hasNextRow = rc.w < ${outputHeight - 1};\n                bool hasNextCol = rc.z < ${outputWidth - 1};\n\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\n                vec4 topLeft = vec4(\n                    getAValue(batch, depth, x00.x, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\n                vec4 topRight = vec4(\n                    getAValue(batch, depth, x00.x, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\n                vec4 bottomLeft = vec4(\n                    getAValue(batch, depth, x00.z, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\n                vec4 bottomRight = vec4(\n                    getAValue(batch, depth, x00.z, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\n\n                // calculate the interpolation fraction on u and v direction\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\n\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\n\n                ${glsl.output} = vec4(newValue);\n            }\n        `;\n      return {\n        ...resizeProgramMetadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.packed},\n        hasMain: true,\n        shaderSource\n      };\n    };\n\n\nconst prepareInputs = (inputs: Tensor[], attributes: UpsampleAttributes): [readonly number[], readonly number[]] => {\n  const x = inputs[0];\n  const xDims = x.dims;\n\n  let scales = attributes.scales;\n  let outputSizes: number[]|undefined;\n  if (scales.length === 0) {\n    const scalesTensor = inputs[attributes.scalesInputIdx];\n    if (scalesTensor && scalesTensor.size !== 0) {\n      if (inputs[attributes.sizesInputIdx]) {\n        throw new Error('Only one of scales or sizes must be provided as input.');\n      }\n      scales = parseScalesData(scalesTensor, attributes.mode, attributes.isResize);\n    } else {\n      const sizesTensor = inputs[attributes.sizesInputIdx];\n      if (!sizesTensor || sizesTensor.size === 0) {\n        throw new Error('Either scales or sizes MUST be provided as input.');\n      }\n\n      outputSizes = Array.from(sizesTensor.integerData);\n      scales = parseScalesDataFromOutputSize(outputSizes, xDims, attributes.mode, attributes.isResize);\n    }\n  } else {\n    if (inputs[attributes.sizesInputIdx]) {\n      throw new Error('Only one of scales or sizes must be provided as input.');\n    }\n  }\n\n  const yDims = outputSizes || (xDims.map((dim, i) => Math.floor(dim * scales[i])));\n\n  return [scales, yDims];\n};\n\nconst parseScalesData = (scale: Tensor, mode: string, isResize: boolean): number[] => {\n  const scales = Array.from(scale.floatData);\n  scalesValidation(scales, mode, isResize);\n  return scales;\n};\n\nconst parseScalesDataFromOutputSize =\n    (yDims: readonly number[], xDims: readonly number[], mode: string, isResize: boolean): number[] => {\n      const length = xDims.length;\n      const scales = new Array<number>(length);\n\n      for (let i = 0, end = length; i < end; i++) {\n        if (xDims[i] === 0) {\n          if (yDims[i] !== 0) {\n            throw new Error('Input dim is zero but required output dim is non-zero.');\n          }\n          scales[i] = 1;\n        } else {\n          scales[i] = yDims[i] / xDims[i];\n        }\n      }\n      scalesValidation(scales, mode, isResize);\n      return scales;\n    };\n\n// roi data is not used yet. but leave here for future usage.\n// const getRoi = (inputs: Tensor[], attributes: UpsampleAttributes) : number[] => {\n//     let roi: number[] = [];\n//     if (attributes.needRoiInput) {\n//         if (attributes.roiInputIdx <= 0) {\n//             throw new Error('Invalid roi input index.');\n//         }\n//         const roiTensor = inputs[attributes.roiInputIdx];\n//         roi = roiTensor.size > 0 ? Array.from(roiTensor.floatData) : [];\n//     } else {\n//         roi = new Array(inputs[0].dims.length * 2).fill(0);\n//     }\n//     return roi;\n// };\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {WebGLInferenceHandler} from '../inference-handler';\n\nexport const shape = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputs(inputs);\n  return [new Tensor([inputs[0].dims.length], 'int32', undefined, undefined, new Int32Array(inputs[0].dims))];\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Shape requires 1 input.');\n  }\n};","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {NUMBER_TYPES, OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, TextureType} from '../types';\n\nexport interface SliceAttributes extends AttributeWithCacheKey {\n  readonly axes: number[];\n  readonly ends: number[];\n  readonly starts: number[];\n}\n\nconst sliceProgramMetadata = {\n  name: 'Slice',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpacked]\n};\n\nexport const slice: OperatorImplementation<SliceAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: SliceAttributes): Tensor[] => {\n      validateInputs(inputs);\n      const output = inferenceHandler.run(\n          {\n            ...sliceProgramMetadata,\n            cacheHint: attributes.cacheKey,\n            get: () => createSliceProgramInfo(inferenceHandler, inputs[0], attributes)\n          },\n          inputs);\n      return [output];\n    };\n\nexport const parseSliceAttributes: OperatorInitialization<SliceAttributes> = (node: Graph.Node): SliceAttributes => {\n  const starts = node.attributes.getInts('starts');\n  const ends = node.attributes.getInts('ends');\n  const axes = node.attributes.getInts('axes', []);\n  return createAttributeWithCacheKey({starts, ends, axes});\n};\n\nconst createSliceProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, input: Tensor, attributes: SliceAttributes): ProgramInfo => {\n      const axes = (attributes.axes.length === 0) ? input.dims.slice(0).map((val, i) => i) : attributes.axes;\n      const normalizedAxes = ShapeUtil.normalizeAxes(axes, input.dims.length);\n      const starts = attributes.starts.map((start, i) => {\n        if (start > input.dims[normalizedAxes[i]] - 1) {\n          return input.dims[normalizedAxes[i]];\n        }\n        return ShapeUtil.normalizeAxis(start, input.dims[normalizedAxes[i]]);\n      });\n      const ends = attributes.ends.map((end, i) => {\n        if (end > input.dims[normalizedAxes[i]] - 1) {\n          return input.dims[normalizedAxes[i]];\n        }\n        return ShapeUtil.normalizeAxis(end, input.dims[normalizedAxes[i]]);\n      });\n\n      const outputShape = input.dims.slice();\n\n      const sliceOps: string[] = [];\n      for (let i = 0; i < normalizedAxes.length; i++) {\n        outputShape[normalizedAxes[i]] = ends[i] - starts[i];\n        if (starts[i] > 0) {\n          sliceOps.push(`outputIdx[${normalizedAxes[i]}] += ${starts[i]};`);\n        }  // else { sliceOps.push(`outputIdx[${normalizedAxes[i]}] += 0;`); }\n      }\n\n      const rank = outputShape.length;\n      const shaderSource = `\n      float process(int outputIdx[${rank}]) {\n        ${sliceOps.join('\\n      ')}\n        return _A(outputIdx);\n      }`;\n      return {\n        ...sliceProgramMetadata,\n        output: {dims: outputShape, type: input.type, textureType: TextureType.unpacked},\n        shaderSource\n      };\n    };\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Slice requires 1 input.');\n  }\n  if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {\n    throw new Error('Invalid input type.');\n  }\n};\n\nexport const sliceV10 = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputsV10(inputs);\n  const attributes = generateSliceAttributesFromInputs(inferenceHandler, inputs);\n  const output = inferenceHandler.run(\n      {\n        ...sliceProgramMetadata,\n        cacheHint: attributes.cacheKey,\n        get: () => createSliceProgramInfo(inferenceHandler, inputs[0], attributes)\n      },\n      [inputs[0]]);\n  return [output];\n};\n\nconst generateSliceAttributesFromInputs =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): SliceAttributes => {\n      if (!inferenceHandler.session.isInitializer(inputs[1].dataId) ||\n          !inferenceHandler.session.isInitializer(inputs[2].dataId) ||\n          (inputs.length >= 4 && !inferenceHandler.session.isInitializer(inputs[3].dataId)) ||\n          (inputs.length >= 5 && !inferenceHandler.session.isInitializer(inputs[4].dataId))) {\n        throw new Error('dynamic slice attributes are not allowed');\n      }\n\n      if (inputs.length >= 5 && inputs[4].integerData.some((i: number) => i !== 1)) {\n        throw new Error('currently non-1 steps is not supported for Slice');\n      }\n\n      const starts = Array.from(inputs[1].integerData);\n      const ends = Array.from(inputs[2].integerData);\n      const axes = inputs.length >= 4 ? Array.from(inputs[3].integerData) : [];\n      const cacheKey = `${axes};${starts};${ends}`;\n      return {starts, ends, axes, cacheKey};\n    };\n\nconst validateInputsV10 = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length < 3 || inputs.length > 5) {\n    throw new Error('Invalid input number.');\n  }\n  if (inputs[1].type !== 'int32' || inputs[1].dims.length !== 1) {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs[2].type !== 'int32' || inputs[2].dims.length !== 1) {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs.length >= 4 && (inputs[3].type !== 'int32' || inputs[3].dims.length !== 1)) {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs.length >= 5 && (inputs[4].type !== 'int32' || inputs[4].dims.length !== 1)) {\n    throw new Error('Invalid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, TextureType} from '../types';\n\nimport {transpose, TransposeAttributes} from './transpose';\n\nexport interface SoftmaxAttributes extends AttributeWithCacheKey {\n  readonly axis: number;\n}\n\nconst softmaxComputeMaxProgramMetadata = {\n  name: 'SoftmaxComputeMax',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpacked],\n};\n\nconst softmaxComputeScaleProgramMetadata = {\n  name: 'SoftmaxComputeScale',\n  inputNames: ['A', 'Max'],\n  inputTypes: [TextureType.unpacked, TextureType.unpacked],\n};\n\nconst softmaxProgramMetadata = {\n  name: 'SoftMax',\n  inputNames: ['A', 'Max', 'Norm'],\n  inputTypes: [TextureType.unpacked, TextureType.unpacked, TextureType.unpacked],\n};\n\nexport const softmax: OperatorImplementation<SoftmaxAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: SoftmaxAttributes): Tensor[] => {\n      validateInputs(inputs);\n\n      const inputShape = inputs[0].dims.slice();\n      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);\n      const logicalRowCount = ShapeUtil.sizeToDimension(inputShape, axis);\n      const featureCount = ShapeUtil.sizeFromDimension(inputShape, axis);\n\n      const output = computeSoftmax(inferenceHandler, inputs, attributes, logicalRowCount, featureCount);\n      return output;\n    };\n\nexport const parseSoftmaxAttributes: OperatorInitialization<SoftmaxAttributes> =\n    (node: Graph.Node): SoftmaxAttributes => createAttributeWithCacheKey({axis: node.attributes.getInt('axis', 1)});\n\nexport const parseSoftmaxAttributesV13: OperatorInitialization<SoftmaxAttributes> =\n    (node: Graph.Node): SoftmaxAttributes => createAttributeWithCacheKey({axis: node.attributes.getInt('axis', -1)});\n\n// The \"semantic\" meaning of axis has changed in opset-13.\n// Please compare: https://github.com/onnx/onnx/blob/main/docs/Operators.md#Softmax\n// with https://github.com/onnx/onnx/blob/main/docs/Changelog.md#Softmax-11 for detailed explanations\n// To account for the opset-13 behavior, our plan will be to transpose the \"axis\" dim to the innermost dim\n// and perform softmax and then reverse the transpose. We can skip the transposing aspect if the axis is already\n// the innermost dim\nexport const softmaxV13: OperatorImplementation<SoftmaxAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: SoftmaxAttributes): Tensor[] => {\n      validateInputs(inputs);\n\n      const inputShape = inputs[0].dims.slice();\n      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);\n      const rank = inputShape.length;\n\n      const isTransposeRequired = (axis !== rank - 1) ? true : false;\n      const transposedInputShape: number[] = [];\n      let perm: number[] = [];\n      let transposedInputs: Tensor[] = [];\n      let transposeAttribute: TransposeAttributes;\n\n      if (isTransposeRequired) {\n        perm = Array.from({length: rank}).map((_, i) => i);\n\n        // swap the innermost dim with the dim corresponding to axis\n        perm[axis] = rank - 1;\n        perm[rank - 1] = axis;\n\n        perm.map(p => transposedInputShape.push(inputShape[p]));\n\n        transposeAttribute = createAttributeWithCacheKey({perm});\n        transposedInputs = transpose(inferenceHandler, inputs, transposeAttribute);\n      }\n\n      const logicalRowCount = isTransposeRequired ? ShapeUtil.sizeToDimension(transposedInputShape, rank - 1) :\n                                                    ShapeUtil.sizeToDimension(inputShape, rank - 1);\n      const featureCount = isTransposeRequired ? ShapeUtil.sizeFromDimension(transposedInputShape, rank - 1) :\n                                                 ShapeUtil.sizeFromDimension(inputShape, rank - 1);\n\n      const output = computeSoftmax(\n          inferenceHandler, isTransposeRequired ? transposedInputs : inputs, attributes, logicalRowCount, featureCount);\n\n      if (isTransposeRequired) {\n        const reversedOutput = transpose(inferenceHandler, output, transposeAttribute!);\n        return reversedOutput;\n      } else {\n        return output;\n      }\n    };\n\nconst computeSoftmax =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: SoftmaxAttributes, logicalRowCount: number,\n     featureCount: number): Tensor[] => {\n      const computeMaxProgramInfo =\n          createComputeMaxProgramInfo(inferenceHandler, inputs[0], logicalRowCount, featureCount, [logicalRowCount]);\n      const max = inferenceHandler.run(\n          {...softmaxComputeMaxProgramMetadata, cacheHint: attributes.cacheKey, get: () => computeMaxProgramInfo},\n          inputs);\n\n      const computeScaleProgramInfo = createComputScaleProgramInfo(\n          inferenceHandler, inputs[0], logicalRowCount, featureCount, computeMaxProgramInfo.output.dims,\n          [logicalRowCount]);\n      const scale = inferenceHandler.run(\n          {...softmaxComputeScaleProgramMetadata, cacheHint: attributes.cacheKey, get: () => computeScaleProgramInfo},\n          [inputs[0], max]);\n\n      const softMaxProgramInfo = createSoftMaxProgramInfo(\n          inferenceHandler, inputs[0], logicalRowCount, featureCount, computeMaxProgramInfo.output.dims,\n          computeScaleProgramInfo.output.dims);\n      const output = inferenceHandler.run(\n          {...softmaxProgramMetadata, cacheHint: attributes.cacheKey, get: () => softMaxProgramInfo},\n          [inputs[0], max, scale]);\n      return [output];\n    };\n\n/**\n * Create a texture that contains the maximum value of each of the 'N' rows\n */\nconst createComputeMaxProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, input: Tensor, logicalRowCount: number, featureCount: number,\n     outputShape: number[]): ProgramInfo => {\n      const [textureWidth, textureHeight] =\n          inferenceHandler.calculateTextureWidthAndHeight(input.dims, TextureType.unpacked);\n      const rank = outputShape.length;\n\n      if (logicalRowCount < 1 || featureCount < 1) {\n        throw new Error('Logical row count N and feature count D must be greater than or equal to 1');\n      }\n\n      if (outputShape.length !== 1) {\n        throw new Error('Dimensionality of the output should be 1');\n      }\n\n      if (outputShape[0] !== logicalRowCount) {\n        throw new Error('Shape of the output should be equal to logical row count');\n      }\n\n      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n      const shaderSource = `\n      float process(int[${rank}] indices) {\n        int logical_row_start_offset = indices[0] * ${featureCount};\n\n        float max = getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset, ${textureWidth},\n        ${textureHeight} )));\n        for(int i=1; i<${featureCount}; ++i)\n        {\n          float current = getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${textureWidth}, ${textureHeight})));\n          if(current > max)\n          max = current;\n        }\n\n        return max;\n      }`;\n      return {\n        ...softmaxComputeMaxProgramMetadata,\n        output: {dims: outputShape, type: input.type, textureType: TextureType.unpacked},\n        shaderSource\n      };\n    };\n\n/**\n * Create a texture that contains the normalization factor for each of the 'N' rows\n */\nconst createComputScaleProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, input: Tensor, logicalRowCount: number, featureCount: number,\n     maxElementPerLogicalRow: readonly number[], outputShape: number[]): ProgramInfo => {\n      const [textureWidth, textureHeight] =\n          inferenceHandler.calculateTextureWidthAndHeight(input.dims, TextureType.unpacked);\n      const rank = outputShape.length;\n\n      if (logicalRowCount < 1 || featureCount < 1) {\n        throw new Error('Logical row count N and feature count D must be greater than or equal to 1');\n      }\n\n      if (outputShape.length !== 1) {\n        throw new Error('Dimensionality of the output should be 1');\n      }\n\n      if (outputShape[0] !== logicalRowCount) {\n        throw new Error('Shape of the output should be equal to logical row count');\n      }\n\n      if (maxElementPerLogicalRow.length !== 1) {\n        throw new Error('Dimensionality of the intermediate results should be 1');\n      }\n\n      if (maxElementPerLogicalRow[0] !== logicalRowCount) {\n        throw new Error('Shape of the intermediate results should be equal to logical row count');\n      }\n\n      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n      const shaderSource = `\n      float process(int[${rank}] indices) {\n        int logical_row_start_offset = indices[0] * ${featureCount};\n\n        float norm_factor = 0.0;\n        float max = _Max(indices);\n        for(int i=0; i<${featureCount}; ++i)\n        {\n          norm_factor += exp(getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${textureWidth}, ${textureHeight}))) - max);\n        }\n\n        return norm_factor;\n      }`;\n      return {\n        ...softmaxComputeScaleProgramMetadata,\n        output: {dims: outputShape, type: input.type, textureType: TextureType.unpacked},\n        shaderSource\n      };\n    };\n\nconst createSoftMaxProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, input: Tensor, logicalRowCount: number, featureCount: number,\n     maxElementPerLogicalRow: readonly number[], normalizationPerLogicalRow: readonly number[]): ProgramInfo => {\n      const [textureWidth, textureHeight] =\n          inferenceHandler.calculateTextureWidthAndHeight(input.dims, TextureType.unpacked);\n      const rank = input.dims.length;\n\n      if (logicalRowCount < 1 || featureCount < 1) {\n        throw new Error('Logical row count N and feature count D must be greater than or equal to 1');\n      }\n\n      if (maxElementPerLogicalRow.length !== 1 || normalizationPerLogicalRow.length !== 1) {\n        throw new Error('Dimensionality of the intermediate results should be 1');\n      }\n\n      if (maxElementPerLogicalRow[0] !== logicalRowCount || normalizationPerLogicalRow[0] !== logicalRowCount) {\n        throw new Error('Shape of the intermediate results should be equal to logical row count');\n      }\n\n      const shaderSource = `\n      float process(int[${rank}] indices) {\n\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\n      int offset = coordsToOffset(TexCoords, ${textureWidth}, ${textureHeight});\n\n      //determine the logical row for this index\n      int logical_row_index[1];\n      logical_row_index[0] = offset / ${featureCount};\n\n      float norm_factor = _Norm(logical_row_index);\n\n      // avoid possible division by 0\n      // if norm_facor is 0, all elements are zero\n      // if so, return 0\n      if(norm_factor == 0.0)\n        return 0.0;\n\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\n    }`;\n      return {\n        ...softmaxProgramMetadata,\n        output: {dims: input.dims, type: input.type, textureType: TextureType.unpacked},\n        shaderSource\n      };\n    };\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Softmax requires 1 input.');\n  }\n\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('Invalid input type');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil, SplitUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, TextureType} from '../types';\n\nexport interface SplitAttributes extends AttributeWithCacheKey {\n  readonly axis: number;\n  readonly split: number[];\n  readonly numOutputs: number;\n}\n\nconst splitProgramMetadata = {\n  name: 'Split',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpacked],\n};\n\nexport const split: OperatorImplementation<SplitAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: SplitAttributes): Tensor[] => {\n      validateInputs(inputs);\n\n      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputs[0].dims.length);\n      const count = getProgramCount(inferenceHandler, inputs, axis, attributes);\n      const output: Tensor[] = [];\n      for (let i = 0; i < count; ++i) {\n        output.push(inferenceHandler.run(\n            {\n              ...splitProgramMetadata,\n              cacheHint: `${attributes.cacheKey};${i}`,\n              get: () => createSplitProgramInfo(inferenceHandler, inputs[0], attributes, axis, i)\n            },\n            inputs));\n      }\n\n      return output;\n    };\n\nexport const parseSplitAttributes: OperatorInitialization<SplitAttributes> = (node: Graph.Node): SplitAttributes => {\n  const axis = node.attributes.getInt('axis', 0);\n  const split = node.attributes.getInts('split', []);\n  const numOutputs = node.outputs.length;\n  return createAttributeWithCacheKey({axis, split, numOutputs});\n};\n\nconst getProgramCount =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], axis: number, attributes: SplitAttributes): number => {\n      const [, offsets] = SplitUtil.splitShape(inputs[0].dims, axis, attributes.split, attributes.numOutputs);\n      return offsets.length;\n    };\n\nconst createSplitProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, input: Tensor, attributes: SplitAttributes, axis: number, index: number):\n        ProgramInfo => {\n          const [shapes, offsets] = SplitUtil.splitShape(input.dims, axis, attributes.split, attributes.numOutputs);\n          const offset = offsets[index];\n          const outputShape = shapes[index];\n          const rank = outputShape.length;\n          const shaderSource = `\n      float process(int indices[${rank}]) {\n        indices[${axis}] += ${offset};\n        return _A(indices);\n      }\n    `;\n          return {\n            ...splitProgramMetadata,\n            cacheHint: `${attributes.cacheKey}:${index}`,\n            output: {dims: outputShape, type: input.type, textureType: TextureType.unpacked},\n            shaderSource\n          };\n        };\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Split requires one input.');\n  }\n\n  if (inputs[0].type !== 'int8' && inputs[0].type !== 'uint8' && inputs[0].type !== 'int16' &&\n      inputs[0].type !== 'uint16' && inputs[0].type !== 'int32' && inputs[0].type !== 'uint32' &&\n      inputs[0].type !== 'float32' && inputs[0].type !== 'float64' && inputs[0].type !== 'bool') {\n    throw new Error('Invalid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\n\nexport const squeeze: OperatorImplementation<number[]> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], axes: number[]): Tensor[] => {\n      validateInputs(inputs);\n      const outputShape = ShapeUtil.squeezeShape(inputs[0].dims, axes);\n      const output = inferenceHandler.reshapeUnpacked(inputs[0], outputShape);\n      return [output];\n    };\n\nexport const squeezeV13 = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputsV13(inputs);\n  return squeeze(inferenceHandler, [inputs[0]], Array.from(inputs[1].integerData));\n};\n\nexport const parseSqueezeAttributes: OperatorInitialization<number[]> = (node: Graph.Node): number[] =>\n    node.attributes.getInts('axes');\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Squeeze requires 1 input.');\n  }\n\n  if (inputs[0].type === 'string') {\n    throw new Error('invalid input tensor types.');\n  }\n};\n\nconst validateInputsV13 = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 2) {\n    throw new Error('Squeeze requires 2 inputs.');\n  }\n\n  if (inputs[1].type !== 'int32') {\n    throw new Error('Invalid input type.');\n  }\n};","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramMetadata, TextureType} from '../types';\n\nexport const sum = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputs(inputs);\n\n  const sumProgramMetadata = {\n    name: 'Sum',\n    inputNames: inputs.map((v, i) => `X${i}`),\n    inputTypes: new Array(inputs.length).fill(TextureType.unpacked)\n  };\n\n  const output = inferenceHandler.run(\n      {...sumProgramMetadata, get: () => createSumProgramInfo(inferenceHandler, inputs, sumProgramMetadata)}, inputs);\n  return [output];\n};\n\nconst createSumProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], sumProgramMetadata: ProgramMetadata): ProgramInfo => {\n      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n      const outputShape = inputs[0].dims.slice();\n      const sumLine = inputs.map((v, i) => `${glsl.texture2D}(X${i},TexCoords)`).join(' + ');\n      const shaderSource = `\n      void main() {\n        vec4 result = ${sumLine};\n        ${glsl.output} = result;\n      }\n    `;\n      return {\n        ...sumProgramMetadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n        hasMain: true,\n        shaderSource\n      };\n    };\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length === 0) {\n    throw new Error('Sum requires inputs.');\n  }\n\n  const length = inputs[0].dims.length;\n  for (let i = 1; i < inputs.length; i++) {\n    if (length !== inputs[i].dims.length) {\n      throw new Error('Input shapes are mismatched.');\n    }\n\n    for (let j = 0; j < length; j++) {\n      if (inputs[0].dims[j] !== inputs[i].dims[j]) {\n        throw new Error('Input shapes are not matched.');\n      }\n    }\n  }\n\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('Invalid input type.');\n  }\n  for (let i = 1; i < inputs.length; i++) {\n    if (inputs[0].type !== inputs[i].type) {\n      throw new Error('Input types are not matched.');\n    }\n  }\n};","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {NUMBER_TYPES} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramMetadata, TextureType} from '../types';\n\nexport const tile = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputs(inputs);\n\n  const tileProgramMetadata = {\n    name: 'Tile',\n    inputNames: ['A'],\n    inputTypes: [TextureType.unpacked],\n  };\n\n  const output = inferenceHandler.run(\n      {...tileProgramMetadata, get: () => createTileProgramInfo(inferenceHandler, inputs, tileProgramMetadata)},\n      inputs);\n  return [output];\n};\n\nconst createTileProgramInfo =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], tileProgramMetadata: ProgramMetadata): ProgramInfo => {\n      const inputShape = inputs[0].dims.slice();\n      const outputShape = new Array(inputShape.length);\n\n      const tileOps: string[] = [];\n      for (let i = 0; i < inputShape.length; i++) {\n        outputShape[i] = inputShape[i] * inputs[1].numberData[i];\n        tileOps.push(`inputIdx[${i}] = int(mod(float(outputIdx[${i}]), ${inputShape[i]}.));`);\n      }\n\n      const rank = outputShape.length;\n      const shaderSource = `\n      float process(int outputIdx[${rank}]) {\n        int inputIdx[${rank}];\n        ${tileOps.join('\\n')}\n        return _A(inputIdx);\n      }\n    `;\n      return {\n        ...tileProgramMetadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n        shaderSource\n      };\n    };\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 2) {\n    throw new Error('Tile requires 2 input.');\n  }\n  if (inputs[1].dims.length !== 1) {\n    throw new Error('The second input shape must 1 dimension.');\n  }\n  if (inputs[1].dims[0] !== inputs[0].dims.length) {\n    throw new Error('Invalid input shape.');\n  }\n  if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs[1].type !== 'int32' && inputs[1].type !== 'int16') {\n    throw new Error('Invalid repeat type.');\n  }\n};","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, TextureType} from '../types';\n\nexport interface TransposeAttributes extends AttributeWithCacheKey {\n  readonly perm: number[];\n}\n\nconst transposeProgramMetadata = {\n  name: 'Transpose',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpacked]\n};\n\nexport const transpose: OperatorImplementation<TransposeAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: TransposeAttributes): Tensor[] => {\n      validateInputs(inputs);\n      const output = inferenceHandler.run(\n          {\n            ...transposeProgramMetadata,\n            cacheHint: attributes.cacheKey,\n            get: () => createTransposeProgramInfo(inferenceHandler, inputs[0], attributes.perm)\n          },\n          inputs);\n      return [output];\n    };\n\nexport const parseTransposeAttributes: OperatorInitialization<TransposeAttributes> =\n    (node: Graph.Node): TransposeAttributes => createAttributeWithCacheKey({perm: node.attributes.getInts('perm', [])});\n\nconst createTransposeProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, input: Tensor, perm: number[]): ProgramInfo => {\n      const inputShape = input.dims;\n      perm = getAdjustedPerm(inputShape, perm);\n      const unpackedOutputShape = getOutputShape(inputShape, perm);\n      const rank = inputShape.length;\n      // A dims=[${inputs[0].dims.toString()}]\n      // out Dims=[${unpackedOutputShape.toString()}]\n      // based on perm=[${perm.toString()}]\n      const shaderSource = `\n      ${getPermFunctionBody('perm', perm, rank)}\n      float process(int indices[${rank}]) {\n        int a[${rank}];\n        perm(a, indices);\n        return _A(a);\n      }`;\n      return {\n        ...transposeProgramMetadata,\n        output: {dims: unpackedOutputShape, type: input.type, textureType: TextureType.unpacked},\n        shaderSource\n      };\n    };\n\nconst getAdjustedPerm = (inputShape: readonly number[], perm: number[]): number[] => {\n  if (perm && perm.length !== inputShape.length) {\n    perm = [...(inputShape.keys())].reverse();\n  }\n  return perm;\n};\n\nconst getOutputShape = (inputShape: readonly number[], perm: number[]): readonly number[] => {\n  perm = getAdjustedPerm(inputShape, perm);\n  return ShapeUtil.sortBasedOnPerm(inputShape, perm);\n};\n\nconst getPermFunctionBody = (name: string, perm: number[], rank: number): string => {\n  const reverseFunc = [];\n  reverseFunc.push(`void ${name}(out int a[${rank}], int src[${rank}]) {`);\n  for (let i = 0; i < rank; ++i) {\n    reverseFunc.push(`\\ta[${perm[i]}]=src[${i}];`);\n  }\n  reverseFunc.push('\\t}');\n  return reverseFunc.join('\\n');\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Transpose requires 1 input.');\n  }\n\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('input should be float tensor');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {TextureData, TextureType} from '../types';\n\nexport const encodeAsUint8 = (inferenceHandler: WebGLInferenceHandler, input: TextureData): TextureData => {\n  const outputShape = input.shape;\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  /**\n   * https://github.com/tensorflow/tfjs-core/blob/master/src/kernels/webgl/encode_float_gpu.ts\n   */\n  const shaderSource = `\n    const float FLOAT_MAX = 1.70141184e38;\n    const float FLOAT_MIN = 1.17549435e-38;\n\n    bool isNaN(float val) {\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n    }\n\n    highp vec4 encodeAsUint8(highp float v) {\n      if (isNaN(v)) {\n        return vec4(255, 255, 255, 255);\n      }\n\n      highp float av = abs(v);\n\n      if(av < FLOAT_MIN) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n      } else if(v > FLOAT_MAX) {\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n      } else if(v < -FLOAT_MAX) {\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n      }\n\n      highp vec4 c = vec4(0,0,0,0);\n\n      highp float e = floor(log2(av));\n      highp float m = exp2(fract(log2(av))) - 1.0;\n\n      c[2] = floor(128.0 * m);\n      m -= c[2] / 128.0;\n      c[1] = floor(32768.0 * m);\n      m -= c[1] / 32768.0;\n      c[0] = floor(8388608.0 * m);\n\n      highp float ebias = e + 127.0;\n      c[3] = floor(ebias / 2.0);\n      ebias -= c[3] * 2.0;\n      c[2] += floor(ebias) * 128.0;\n\n      c[3] += 128.0 * step(0.0, -v);\n\n      return c / 255.0;\n    }\n\n    void main() {\n      float value = ${glsl.texture2D}(X,TexCoords).r;\n      ${glsl.output} = encodeAsUint8(value);\n    }`;\n  const programInfo = {\n    name: 'Uint8Encode',\n    inputTypes: [TextureType.unpacked],\n    inputNames: ['X'],\n    output: {dims: outputShape, type: input.tensor.type, textureType: TextureType.downloadUint8AsFloat},\n    shaderSource,\n    hasMain: true\n  };\n  return inferenceHandler.executeProgram(programInfo, [input.tensor]);\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {Tensor} from '../../../tensor';\nimport {MAX_CLIP, MIN_CLIP} from '../../../util';\nimport {FunctionType, GlslValueFunction} from '../glsl-definitions';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\nexport function glslAbs(): GlslValueFunction {\n  return glslBuiltinUnary('abs');\n}\nexport function glslAcos(): GlslValueFunction {\n  return glslBuiltinUnary('acos');\n}\nexport function glslAsin(): GlslValueFunction {\n  return glslBuiltinUnary('asin');\n}\nexport function glslAtan(): GlslValueFunction {\n  return glslBuiltinUnary('atan');\n}\nexport function glslCeil(): GlslValueFunction {\n  return glslBuiltinUnary('ceil');\n}\nexport function glslCos(): GlslValueFunction {\n  return glslBuiltinUnary('cos');\n}\nexport function glslElu(alpha: number): GlslValueFunction {\n  const name = 'elu';\n  const body = `\n  const float alpha = float(${alpha});\n\n  float ${name}_(float a) {\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\n  }\n  vec4 ${name}_(vec4 v) {\n    return vec4(${name}_(v.x), ${name}_(v.y), ${name}_(v.z), ${name}_(v.w));\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslExp(): GlslValueFunction {\n  return glslBuiltinUnary('exp');\n}\nexport function glslFloor(): GlslValueFunction {\n  return glslBuiltinUnary('floor');\n}\nexport function glslClip(min: number, max: number): GlslValueFunction {\n  const name = 'clip';\n  const body = `\n  const float min = float(${min});\n  const float max = float(${max});\n\n  float ${name}_(float a) {\n    return clamp(a, min, max);\n  }\n  vec4 ${name}_(vec4 v) {\n    return clamp(v, min, max);\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslIdentity(): GlslValueFunction {\n  const name = 'indentity';\n  const body = `\n  float ${name}_(float a) {\n    return a;\n  }\n  vec4 ${name}_(vec4 v) {\n    return v;\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslLeakyRelu(alpha: number): GlslValueFunction {\n  const name = 'leakyRelu';\n  const body = `\n  const float alpha = float(${alpha});\n\n  float ${name}_(float a) {\n    return a < 0.0 ? a * alpha : a;\n  }\n  vec4 ${name}_(vec4 v) {\n    return vec4(${name}_(v.x), ${name}_(v.y), ${name}_(v.z), ${name}_(v.w));\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslLog(): GlslValueFunction {\n  return glslBuiltinUnary('log');\n}\nexport function glslNeg(): GlslValueFunction {\n  const name = 'neg';\n  const body = `\n  float ${name}_(float a) {\n    return -a;\n  }\n  vec4 ${name}_(vec4 v) {\n    return -v;\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslNot(): GlslValueFunction {\n  const name = 'not';\n  const body = `\n  float ${name}_(float a) {\n    return float( ! bool(a) );\n  }\n  bool ${name}_(bool a) {\n    return !a;\n  }\n  vec4 ${name}_(vec4 v) {\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\n  }\n  bvec4 ${name}_(bvec4 v) {\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslSin(): GlslValueFunction {\n  return glslBuiltinUnary('sin');\n}\nexport function glslRelu(): GlslValueFunction {\n  const name = 'relu';\n  const body = `\n  float ${name}_(float a) {\n    return max( a, 0.0 );\n  }\n  vec4 ${name}_(vec4 v) {\n    return max( v, 0.0 );\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslSigmoid(): GlslValueFunction {\n  const name = 'sigmoid';\n  const body = `\n  float ${name}_(float a) {\n    return 1.0 / (1.0 + exp(-a));\n  }\n  vec4 ${name}_(vec4 v) {\n    return 1.0 / (1.0 + exp(-v));\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslSqrt(): GlslValueFunction {\n  return glslBuiltinUnary('sqrt');\n}\nexport function glslTan(): GlslValueFunction {\n  return glslBuiltinUnary('tan');\n}\nexport function glslTanh(): GlslValueFunction {\n  const name = 'tanh';\n  const body = `\n  float ${name}_(float a) {\n    a = clamp(a, -10., 10.);\n    a = exp(2.*a);\n    return (a - 1.) / (a + 1.);\n  }\n  vec4 ${name}_(vec4 v) {\n    v = clamp(v, -10., 10.);\n    v = exp(2.*v);\n    return (v - 1.) / (v + 1.);\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nfunction glslBuiltinUnary(name: string): GlslValueFunction {\n  const body = `\n  float ${name}_(float a) {\n    return ${name}(a);\n  }\n  vec4 ${name}_(vec4 v) {\n    return ${name}(v);\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\n\n/////\n/////\n/////\n\nconst createElementwiseProgramInfo =\n    (handler: WebGLInferenceHandler, metadata: ProgramMetadata, input: Tensor, glslFunc: GlslValueFunction):\n        ProgramInfo => {\n          const textureType = handler.session.pack ? TextureType.packed : TextureType.unpacked;\n          const glsl = getGlsl(handler.session.backend.glContext.version);\n          return {\n            ...metadata,\n            output: {dims: input.dims, type: input.type, textureType},\n            shaderSource: `\n     ${glslFunc.body}\n     void main() {\n       vec4 v = ${glsl.texture2D}(A, TexCoords);\n       v = ${glslFunc.name}_(v);\n       ${glsl.output} = v;\n     }\n     `,\n            hasMain: true\n          };\n        };\n\nconst createElementwiseProgramInfoLoader =\n    (handler: WebGLInferenceHandler, input: Tensor, glslFunc: GlslValueFunction, cacheKey?: string):\n        ProgramInfoLoader => {\n          const textureType = handler.session.pack ? TextureType.packed : TextureType.unpacked;\n          const metadata = {name: glslFunc.name, inputTypes: [textureType], inputNames: ['A'], cacheHint: cacheKey};\n          return {...metadata, get: () => createElementwiseProgramInfo(handler, metadata, input, glslFunc)};\n        };\n\nexport const abs = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAbs()), inputs)];\n\nexport const acos = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAcos()), inputs)];\n\nexport const asin = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAsin()), inputs)];\n\nexport const atan = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAtan()), inputs)];\n\nexport interface ClipAttributes extends AttributeWithCacheKey {\n  readonly min: number;\n  readonly max: number;\n}\n\nexport const clip =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], attributes: ClipAttributes): Tensor[] => [handler.run(\n        createElementwiseProgramInfoLoader(\n            handler, inputs[0], glslClip(attributes.min, attributes.max), attributes.cacheKey),\n        inputs)];\n\nexport const parseClipAttributes = (node: Graph.Node): ClipAttributes => createAttributeWithCacheKey(\n    {min: node.attributes.getFloat('min', MIN_CLIP), max: node.attributes.getFloat('max', MAX_CLIP)});\n\nexport const clipV11 = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  const attributes = generateClipAttributesFromInputs(handler, inputs);\n  return clip(handler, [inputs[0]], attributes);\n};\n\nconst generateClipAttributesFromInputs = (handler: WebGLInferenceHandler, inputs: Tensor[]): ClipAttributes => {\n  if (inputs.length >= 3 &&\n      (!handler.session.isInitializer(inputs[1].dataId) || !handler.session.isInitializer(inputs[2].dataId))) {\n    throw new Error('dynamic clip attributes are not allowed');\n  }\n\n  const min = (inputs.length >= 3) ? inputs[1].numberData[0] : MIN_CLIP;\n  const max = (inputs.length >= 3) ? inputs[2].numberData[0] : MAX_CLIP;\n  return createAttributeWithCacheKey({min, max});\n};\n\nexport const ceil = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslCeil()), inputs)];\n\nexport const cos = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslCos()), inputs)];\n\nexport interface EluAttributes extends AttributeWithCacheKey {\n  readonly alpha: number;\n}\n\nexport const elu =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], attributes: EluAttributes): Tensor[] => [handler.run(\n        createElementwiseProgramInfoLoader(handler, inputs[0], glslElu(attributes.alpha), attributes.cacheKey),\n        inputs)];\n\nexport const parseEluAttributes = (node: Graph.Node): EluAttributes =>\n    createAttributeWithCacheKey({alpha: node.attributes.getFloat('alpha', 1.0)});\n\nexport const exp = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslExp()), inputs)];\n\nexport const floor = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslFloor()), inputs)];\n\nexport const identity = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslIdentity()), inputs)];\n\nexport interface LeakyReluAttributes extends AttributeWithCacheKey {\n  readonly alpha: number;\n}\n\nexport const leakyRelu =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], attributes: LeakyReluAttributes): Tensor[] => [handler.run(\n        createElementwiseProgramInfoLoader(handler, inputs[0], glslLeakyRelu(attributes.alpha), attributes.cacheKey),\n        inputs)];\n\nexport const parseLeakyReluAttributes = (node: Graph.Node): LeakyReluAttributes =>\n    createAttributeWithCacheKey({alpha: node.attributes.getFloat('alpha', 0.01)});\n\nexport const log = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslLog()), inputs)];\n\nexport const neg = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslNeg()), inputs)];\n\nexport const not = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslNot()), inputs)];\n\nexport const relu = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslRelu()), inputs)];\n\nexport const sigmoid = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSigmoid()), inputs)];\n\nexport const sin = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSin()), inputs)];\n\nexport const sqrt = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSqrt()), inputs)];\n\nexport const tan = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslTan()), inputs)];\n\nexport const tanh = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslTanh()), inputs)];\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, TextureType} from '../types';\nimport {getCoordsDataType} from '../utils';\n\nimport {getChannels, unpackFromChannel} from './packing-utils';\n\nconst unpackProgramMetadata = {\n  name: 'unpack',\n  inputNames: ['A'],\n  inputTypes: [TextureType.packed]\n};\n\nexport const createUnpackProgramInfo = (handler: WebGLInferenceHandler, input: Tensor): ProgramInfo => {\n  const rank = input.dims.length;\n\n  const channels = getChannels('rc', rank);\n  const innerDims = channels.slice(-2);\n  const coordsDataType = getCoordsDataType(rank);\n  const unpackChannel = unpackFromChannel();\n  const isScalar = (input.dims.length === 0);\n  const sourceCoords = isScalar ? '' : getSourceCoords(rank, channels);\n  const coords = rank <= 1 ? 'rc' : `vec2(${innerDims.join(',')})`;\n  const glsl = getGlsl(handler.session.backend.glContext.version);\n  const shaderSource = `\n    ${unpackChannel}\n    void main() {\n      ${coordsDataType} rc = getOutputCoords();\n\n       // Sample the texture with the coords to get the rgba channel value.\n       vec4 packedInput = getA(${sourceCoords});\n\n       ${glsl.output} = vec4(getChannel(packedInput, ${coords}), 0, 0, 0);\n     }\n   `;\n\n  return {\n    ...unpackProgramMetadata,\n    hasMain: true,\n    output: {dims: input.dims, type: input.type, textureType: TextureType.unpacked},\n    shaderSource\n  };\n};\n\nexport const createUnpackProgramInfoLoader = (handler: WebGLInferenceHandler, input: Tensor): ProgramInfoLoader =>\n    ({...unpackProgramMetadata, get: () => createUnpackProgramInfo(handler, input)});\n\nfunction getSourceCoords(rank: number, dims: string[]): string {\n  if (rank === 1) {\n    return 'rc';\n  }\n\n  let coords = '';\n  for (let i = 0; i < rank; i++) {\n    coords += dims[i];\n    if (i < rank - 1) {\n      coords += ',';\n    }\n  }\n  return coords;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\n\nexport const unsqueeze: OperatorImplementation<number[]> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], axes: number[]): Tensor[] => {\n      validateInputs(inputs);\n      const outputShape = ShapeUtil.unsqueezeShape(inputs[0].dims, axes);\n      const output = inferenceHandler.reshapeUnpacked(inputs[0], outputShape);\n      return [output];\n    };\n\nexport const unsqueezeV13 = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputsV13(inputs);\n  return unsqueeze(inferenceHandler, [inputs[0]], Array.from(inputs[1].integerData));\n};\n\nexport const parseUnsqueezeAttributes: OperatorInitialization<number[]> = (node: Graph.Node): number[] =>\n    node.attributes.getInts('axes');\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Unsqueeze requires 1 input.');\n  }\n\n  if (inputs[0].type === 'string') {\n    throw new Error('invalid input tensor types.');\n  }\n};\n\nconst validateInputsV13 = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 2) {\n    throw new Error('Unsqueeze requires 2 inputs.');\n  }\n\n  if (inputs[1].type !== 'int32') {\n    throw new Error('Invalid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, TextureType} from '../types';\n\nexport interface UpsampleAttributes extends AttributeWithCacheKey {\n  readonly opset: number;\n  readonly isResize: boolean;\n  readonly mode: string;\n  readonly scales: number[];\n  readonly extrapolationValue: number;\n  readonly coordinateTransformMode: string;\n  readonly useExtrapolation: boolean;\n  readonly needRoiInput: boolean;\n  readonly nearestMode: string;\n  readonly cubicCoefficientA: number;\n  readonly excludeOutside: boolean;\n  readonly useNearest2xOptimization: boolean;\n  readonly roiInputIdx: number;\n  readonly scalesInputIdx: number;\n  readonly sizesInputIdx: number;\n}\n\nconst upsampleProgramMetadata = {\n  name: 'Upsample',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked],\n};\n\nexport const upsample: OperatorImplementation<UpsampleAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: UpsampleAttributes): Tensor[] => {\n      validateInputs(inputs, attributes);\n      const output = inferenceHandler.run(\n          {\n            ...upsampleProgramMetadata,\n            cacheHint: attributes.cacheKey,\n            get: () => createUpsampleProgramInfo(inferenceHandler, inputs, attributes)\n          },\n          inputs);\n      return [output];\n    };\n\nexport const parseUpsampleAttributesV7: OperatorInitialization<UpsampleAttributes> =\n    (node: Graph.Node): UpsampleAttributes => parseUpsampleAttributes(node, 7);\n\nexport const parseUpsampleAttributesV9: OperatorInitialization<UpsampleAttributes> =\n    (node: Graph.Node): UpsampleAttributes => parseUpsampleAttributes(node, 9);\n\nexport const parseUpsampleAttributes = (node: Graph.Node, opset: number): UpsampleAttributes => {\n  const isResize = (opset >= 10);\n\n  // processing node attributes\n  const mode = node.attributes.getString('mode', 'nearest');\n  if (mode !== 'nearest' && mode !== 'linear' && (opset < 11 || mode !== 'cubic')) {\n    throw new Error(`unrecognized mode: ${mode}`);\n  }\n\n  let scales: number[] = [];\n  if (opset < 9) {\n    scales = node.attributes.getFloats('scales');\n    scalesValidation(scales, mode, isResize);\n  }\n\n  const extrapolationValue = node.attributes.getFloat('extrapolation_value', 0.0);\n\n  const coordinateTransformMode =\n      opset > 10 ? node.attributes.getString('coordinate_transformation_mode', 'half_pixel') : 'asymmetric';\n  if ([\n        'asymmetric', 'pytorch_half_pixel', 'tf_half_pixel_for_nn', 'align_corners', 'tf_crop_and_resize', 'half_pixel'\n      ].indexOf(coordinateTransformMode) === -1) {\n    throw new Error(`coordinate_transform_mode '${coordinateTransformMode}' is not supported`);\n  }\n  const needRoiInput = (coordinateTransformMode === 'tf_crop_and_resize');\n  const useExtrapolation = needRoiInput;\n\n  const nearestMode =\n      (mode === 'nearest' && opset >= 11) ? node.attributes.getString('nearest_mode', 'round_prefer_floor') : '';\n  if (['round_prefer_floor', 'round_prefer_ceil', 'floor', 'ceil', ''].indexOf(nearestMode) === -1) {\n    throw new Error(`nearest_mode '${nearestMode}' is not supported`);\n  }\n\n  const cubicCoefficientA = node.attributes.getFloat('cubic_coeff_a', -0.75);\n  const excludeOutside = node.attributes.getInt('exclude_outside', 0) !== 0;\n  if (excludeOutside && mode !== 'cubic') {\n    throw new Error('exclude_outside can be set to 1 only when mode is CUBIC.');\n  }\n\n  const useNearest2xOptimization =\n      (opset < 11) ? true : (mode === 'nearest' && coordinateTransformMode === 'asymmetric' && nearestMode === 'floor');\n\n  let roiInputIdx = 0;\n  let scalesInputIdx = 0;\n  let sizesInputIdx = 0;\n\n  if (opset > 10) {\n    // handle when roiInput is not given\n    if (node.inputs.length > 2) {\n      roiInputIdx = 1;\n      scalesInputIdx = 2;\n      sizesInputIdx = 3;\n    } else {\n      scalesInputIdx = 1;\n      sizesInputIdx = 2;\n    }\n  } else if (opset === 9) {\n    scalesInputIdx = 1;\n  }\n\n  return createAttributeWithCacheKey({\n    opset,\n    isResize,\n    mode,\n    scales,\n    extrapolationValue,\n    coordinateTransformMode,\n    useExtrapolation,\n    needRoiInput,\n    nearestMode,\n    cubicCoefficientA,\n    excludeOutside,\n    useNearest2xOptimization,\n    roiInputIdx,\n    scalesInputIdx,\n    sizesInputIdx\n  });\n};\n\nconst createUpsampleProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: UpsampleAttributes): ProgramInfo => {\n      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n      const [inputWidth, inputHeight] =\n          inferenceHandler.calculateTextureWidthAndHeight(inputs[0].dims, TextureType.unpacked);\n\n      const outputShape = inputs[0].dims.map((dim, i) => Math.floor(dim * attributes.scales[i]));\n      const [outputWidth, outputHeight] =\n          inferenceHandler.calculateTextureWidthAndHeight(outputShape, TextureType.unpacked);\n      const dim = outputShape.length;\n\n      const outputPitches = new Array<number>(dim);\n      const inputPitches = new Array<number>(dim);\n      let precalculatedPitches = `\n      int output_pitches[${dim}];\n      int input_pitches[${dim}];\n      `;\n      for (let d = dim - 1; d >= 0; d--) {\n        outputPitches[d] = (d === dim - 1) ? 1 : outputPitches[d + 1] * outputShape[d + 1];\n        inputPitches[d] = (d === dim - 1) ? 1 : inputPitches[d + 1] * inputs[0].dims[d + 1];\n\n        precalculatedPitches += `\n        output_pitches[${d}] = ${outputPitches[d]};\n        input_pitches[${d}] = ${inputPitches[d]};\n        `;\n      }\n      const getInputFloatFunction = `\n      float getInputFloat(int index) {\n        vec2 coords = offsetToCoords(index, ${inputWidth}, ${inputHeight});\n        float value = getColorAsFloat(${glsl.texture2D}(X, coords));\n        return value;\n      }\n      `;\n\n      const shaderSource = attributes.mode === 'nearest' ?\n          // nearest\n          `\n    ${getInputFloatFunction}\n    float process(int indices[${dim}]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});\n\n      ${precalculatedPitches}\n\n      int d, m;\n      for (int dim = 0; dim < ${dim}; ++dim) {\n        d = output_index / output_pitches[dim];\n        m = output_index - d * output_pitches[dim];\n        output_index = m;\n\n        if (scales[dim] != 1 && d > 0) {\n          int d2 = d / scales[dim];\n          m = d - d2 * scales[dim];\n          d = d2;\n        }\n        input_index += input_pitches[dim] * d;\n      }\n\n      return getInputFloat(input_index);\n    }` :\n          dim === 4 ?\n          // bilinear 4D\n              `\n    ${getInputFloatFunction}\n    float process(int indices[4]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});\n\n      ${precalculatedPitches}\n\n      int m;\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m / output_pitches[1];\n      m = m - index_of_dim1 * output_pitches[1];\n      index_of_dim2 = m / output_pitches[2];\n      m = m - index_of_dim2 * output_pitches[2];\n      index_of_dim3 = m;\n\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\n      index_of_input_dim2 = index_of_dim2 / scales[2];\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\n      index_of_input_dim3 = index_of_dim3 / scales[3];\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\n\n      input_index = index_of_dim0 * input_pitches[0] +\n            index_of_dim1 * input_pitches[1] +\n            index_of_input_dim2 * input_pitches[2] +\n            index_of_input_dim3;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim2 = false;\n      if (index_of_input_dim2 == (${inputs[0].dims[2]} - 1)) {\n        // It's the end in dimension 2\n        x01 = x00;\n        end_of_dim2 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[2]);\n      }\n\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\n        // It's the end in dimension 3\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\n    }` :\n              // bilinear 2D\n              `\n    ${getInputFloatFunction}\n    float process(int indices[2]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});\n\n      ${precalculatedPitches}\n\n      int m;\n      int index_of_dim0, index_of_dim1;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m;\n\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\n      index_of_input_dim0 = index_of_dim0 / scales[0];\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\n      index_of_input_dim1 = index_of_dim1 / scales[1];\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\n\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim0 = false;\n      if (index_of_input_dim0 == (${inputs[0].dims[0]} - 1)) {\n        // It's the end in dimension 0\n        x01 = x00;\n        end_of_dim0 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[0]);\n      }\n\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\n        // It's the end in dimension 1\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\n    }`;\n      return {\n        ...upsampleProgramMetadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n        shaderSource,\n        variables: [{\n          name: 'scales',\n          type: 'int',\n          arrayLength: attributes.scales.length,\n          data: attributes.scales.map(x => Math.ceil(x))\n        }]\n      };\n    };\n\nexport const validateInputs = (inputs: Tensor[], attribute: UpsampleAttributes): void => {\n  if (!inputs || (attribute.opset < 9 && inputs.length !== 1) ||\n      (attribute.opset >= 9 && attribute.opset < 11 && inputs.length !== 2) ||\n      (attribute.opset >= 11 && inputs.length < 2)) {\n    throw new Error('invalid inputs.');\n  }\n\n  if (attribute.scales.length > 0 && inputs[0].dims.length !== attribute.scales.length) {\n    throw new Error('Invalid input shape.');\n  }\n\n  if (inputs[0].type === 'string') {\n    throw new Error('Invalid input tensor types.');\n  }\n};\n\nexport const scalesValidation = (scales: number[], mode: string, isResize: boolean): void => {\n  if (!isResize) {\n    for (const scale of scales) {\n      if (scale < 1) {\n        throw new Error('Scale value should be greater than or equal to 1.');\n      }\n    }\n  } else {\n    for (const scale of scales) {\n      if (scale <= 0) {\n        throw new Error('Scale value should be greater than 0.');\n      }\n    }\n  }\n  if (mode === 'linear' || mode === 'cubic') {\n    if (scales.length !== 2 && (scales.length !== 4 || scales[0] !== 1 || scales[1] !== 1)) {\n      throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic') \\\n        or 4-D inputs with the corresponding outermost 2 scale values being 1 \\\n        in the ${isResize ? 'Resize' : 'Upsample'} opeartor.`);\n    }\n  }\n};","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {env} from 'onnxruntime-common';\n\nimport {Logger, Profiler} from '../../instrument';\n\nimport {GlslPreprocessor} from './glsl-preprocessor';\nimport {getVertexShaderSource} from './glsl-source';\nimport {TextureLayoutStrategy} from './texture-layout-strategy';\nimport {Artifact, ProgramInfo, ProgramVariable, TextureData, TextureLayout, VariableInfo} from './types';\nimport {WebGLContext} from './webgl-context';\n\n/**\n * ProgramManager is the main class behind running computations\n * It builds ProgramInfo's into Artifacts\n * It compiles given ProgramInfo's into WebGL Prorams (cached as Artifacts)\n * Uses the artifact to run the computation by calling Draw on\n * the WebGL drawing buffer\n * ProgramManager automatically maps (binds) input variables to their\n * corresponding Location's in the binary program\n */\nexport class ProgramManager {\n  repo: Map<unknown, Artifact>;  // this should be per-session object\n  vertexShader: WebGLShader;\n  attributesBound: boolean;\n\n  constructor(\n      public profiler: Readonly<Profiler>, public glContext: WebGLContext,\n      public textureLayoutStrategy: TextureLayoutStrategy) {\n    this.repo = new Map();\n    this.attributesBound = false;\n  }\n  getArtifact(key: unknown): Artifact|undefined {\n    return this.repo.get(key);\n  }\n  setArtifact(key: unknown, artifact: Artifact): void {\n    this.repo.set(key, artifact);\n  }\n  run(buildArtifact: Artifact, inputs: TextureData[], output: TextureData): void {\n    this.profiler.event('op', `ProgramManager.run ${buildArtifact.programInfo.name ?? 'unknown kernel'}`, () => {\n      const gl = this.glContext.gl;\n      const program = buildArtifact.program;\n      gl.useProgram(program);\n      try {\n        this.bindOutput(output);\n        if (!this.attributesBound) {\n          this.bindAttributes(buildArtifact.attribLocations);\n        }\n        this.bindUniforms(buildArtifact.uniformLocations, buildArtifact.programInfo.variables ?? [], inputs);\n      } catch (err) {\n        Logger.error('ProgramManager', buildArtifact.programInfo.shaderSource);\n        throw err;\n      }\n      this.profiler.event('backend', 'GlContext.draw()', () => {\n        this.glContext.draw();\n      });\n    }, this.glContext);\n  }\n  dispose(): void {\n    if (this.vertexShader) {\n      this.glContext.deleteShader(this.vertexShader);\n    }\n    this.repo.forEach(a => this.glContext.deleteProgram(a.program));\n  }\n  build(programInfo: ProgramInfo, inputTextureLayouts: TextureLayout[], outputTextureLayout: TextureLayout): Artifact {\n    return this.profiler.event('backend', 'ProgramManager.build', () => {\n      const preprocessor = new GlslPreprocessor(this.glContext, programInfo, inputTextureLayouts, outputTextureLayout);\n      const fragScript = preprocessor.preprocess();\n      const program = this.compile(fragScript);\n      const artifact = {\n        programInfo,\n        program,\n        uniformLocations: this.getUniformLocations(\n            program, preprocessor.context.programInfo.inputNames, preprocessor.context.programInfo.variables),\n        attribLocations: this.getAttribLocations(program)\n      };\n      return artifact;\n    });\n  }\n  protected compile(fragShaderScript: string): WebGLProgram {\n    if (!this.vertexShader) {\n      Logger.verbose('ProrgramManager', 'Compiling and caching Vertex shader for the first time');\n      const vertexShaderScript = getVertexShaderSource(this.glContext.version);\n      this.vertexShader = this.glContext.compileShader(vertexShaderScript, this.glContext.gl.VERTEX_SHADER);\n    }\n    if (env.debug) {\n      Logger.verbose('ProrgramManager', `FragShader:\n${fragShaderScript}\n`);\n    }\n    const fragShader = this.glContext.compileShader(fragShaderScript, this.glContext.gl.FRAGMENT_SHADER);\n    const program = this.glContext.createProgram(this.vertexShader, fragShader);\n    this.glContext.deleteShader(fragShader);\n    return program;\n  }\n  bindOutput(td: TextureData): void {\n    const width = td.width;\n    const height = td.height;\n    Logger.verbose(\n        'ProrgramManager',\n        `Binding output texture to Framebuffer: w/h=${width}/${height}, shape=${td.shape}, type=${td.tensor.type}`);\n    this.glContext.attachFramebuffer(td.texture, width, height);\n  }\n  bindAttributes(attribLocations: Artifact.AttribLocations): void {\n    const positionHandle = attribLocations.position;\n    const textureCoordHandle = attribLocations.textureCoord;\n    this.glContext.setVertexAttributes(positionHandle, textureCoordHandle);\n    this.attributesBound = true;\n  }\n  bindUniforms(uniformLocations: Artifact.UniformLocations, variables: ProgramVariable[], textures: TextureData[]):\n      void {\n    const gl = this.glContext.gl;\n    let texturePosition = 0;\n    for (const {name, type, location, arrayLength} of uniformLocations) {\n      const value = variables.find(v => v.name === name)?.data;\n      if (type !== 'sampler2D' && !value) {\n        throw new Error(`variable '${name}' does not have data defined in program info`);\n      }\n      switch (type) {\n        case 'sampler2D':\n          this.bindTexture(textures[texturePosition], location, texturePosition);\n          texturePosition++;\n          break;\n        case 'float':\n          if (arrayLength) {\n            gl.uniform1fv(location, value as number[]);\n          } else {\n            gl.uniform1f(location, value as number);\n          }\n          break;\n        case 'int':\n          if (arrayLength) {\n            gl.uniform1iv(location, value as number[]);\n          } else {\n            gl.uniform1i(location, value as number);\n          }\n          break;\n        default:\n          throw new Error(`Uniform not implemented: ${type}`);\n      }\n    }\n  }\n  bindTexture(td: TextureData, uniformHandle: WebGLUniformLocation, position: number): void {\n    this.glContext.bindTextureToUniform(td.texture, position, uniformHandle);\n  }\n  getAttribLocations(program: WebGLProgram): Artifact.AttribLocations {\n    return {\n      position: this.getAttribLocation(program, 'position'),\n      textureCoord: this.getAttribLocation(program, 'textureCoord')\n    };\n  }\n  getUniformLocations(program: WebGLProgram, samplers?: string[], variables?: VariableInfo[]):\n      Artifact.UniformLocations {\n    const uniformLocations: Artifact.UniformLocations = [];\n    if (samplers) {\n      for (const sampler of samplers) {\n        uniformLocations.push({name: sampler, type: 'sampler2D', location: this.getUniformLocation(program, sampler)});\n      }\n    }\n    if (variables) {\n      for (const variable of variables) {\n        uniformLocations.push({...variable, location: this.getUniformLocation(program, variable.name)});\n      }\n    }\n    return uniformLocations;\n  }\n  getUniformLocation(program: WebGLProgram, name: string): WebGLUniformLocation {\n    const gl = this.glContext.gl;\n    const reference = gl.getUniformLocation(program, name);\n    if (reference === null) {\n      throw new Error(`Uniform ${name} not found.`);\n    }\n    return reference;\n  }\n  getAttribLocation(program: WebGLProgram, name: string): number {\n    const gl = this.glContext.gl;\n    const attributeLocation: number = gl.getAttribLocation(program, name);\n    return attributeLocation;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {SessionHandler} from '../../backend';\nimport {Graph} from '../../graph';\nimport {Logger} from '../../instrument';\nimport {Operator} from '../../operators';\nimport {OpSet, resolveOperator} from '../../opset';\nimport {Session} from '../../session';\nimport {Tensor} from '../../tensor';\nimport {WebGLBackend} from '../backend-webgl';\n\nimport {WebGLInferenceHandler} from './inference-handler';\nimport {WEBGL_OP_RESOLVE_RULES} from './op-resolve-rules';\nimport {ProgramManager} from './program-manager';\nimport {PreferLogicalStrategy, TextureLayoutStrategy} from './texture-layout-strategy';\nimport {TextureManager} from './texture-manager';\nimport {TextureData} from './types';\n\nexport class WebGLSessionHandler implements SessionHandler {\n  programManager: ProgramManager;\n  textureManager: TextureManager;\n  layoutStrategy: TextureLayoutStrategy;\n  packedTextureDataCache: Map<Tensor.Id, TextureData>;\n  unpackedTextureDataCache: Map<Tensor.Id, TextureData>;\n  pack2unpackMap: Map<Tensor.Id, Tensor.Id>;\n  unpack2packMap: Map<Tensor.Id, Tensor.Id>;\n  initializers: Set<Tensor.Id>;\n  pack?: boolean;\n\n  constructor(public readonly backend: WebGLBackend, public readonly context: Session.Context) {\n    this.layoutStrategy = new PreferLogicalStrategy(backend.glContext.maxTextureSize);\n    this.programManager = new ProgramManager(this.context.profiler, backend.glContext, this.layoutStrategy);\n    this.textureManager = new TextureManager(\n        backend.glContext, this.layoutStrategy, this.context.profiler,\n        {reuseTextures: backend.textureCacheMode === 'full'});\n    this.packedTextureDataCache = new Map();\n    this.unpackedTextureDataCache = new Map();\n    this.pack = backend.pack;\n    this.pack2unpackMap = new Map();\n    this.unpack2packMap = new Map();\n  }\n\n  createInferenceHandler() {\n    return new WebGLInferenceHandler(this);\n  }\n  onGraphInitialized(graph: Graph): void {\n    const initializers = graph.getValues().filter(v => v.from === -1 && v.tensor).map(v => v.tensor!.dataId);\n    this.initializers = new Set(initializers);\n  }\n  isInitializer(tensorId: Tensor.Id): boolean {\n    return this.initializers ? this.initializers.has(tensorId) : false;\n  }\n  addInitializer(tensorId: Tensor.Id): void {\n    this.initializers.add(tensorId);\n  }\n  getTextureData(tensorId: Tensor.Id, isPacked: boolean): TextureData|undefined {\n    if (isPacked) {\n      return this.packedTextureDataCache.get(tensorId);\n    } else {\n      return this.unpackedTextureDataCache.get(tensorId);\n    }\n  }\n  setTextureData(tensorId: Tensor.Id, textureData: TextureData, isPacked = false): void {\n    Logger.verbose('WebGLSessionHandler', 'Storing Texture data in cache');\n    if (isPacked) {\n      this.packedTextureDataCache.set(tensorId, textureData);\n    } else {\n      this.unpackedTextureDataCache.set(tensorId, textureData);\n    }\n  }\n  dispose(): void {\n    this.programManager.dispose();\n    this.textureManager.clearActiveTextures();\n    this.packedTextureDataCache.forEach(td => this.textureManager.releaseTexture(td, true));\n    this.packedTextureDataCache = new Map();\n    this.unpackedTextureDataCache.forEach(td => this.textureManager.releaseTexture(td, true));\n    this.unpackedTextureDataCache = new Map();\n  }\n  resolve(node: Graph.Node, opsets: readonly OpSet[], graph: Graph): Operator {\n    const op = resolveOperator(node, opsets, WEBGL_OP_RESOLVE_RULES);\n    return {impl: op.opImpl, context: op.opInit ? op.opInit(node, graph) : node};\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Logger} from '../../instrument';\n\nexport declare namespace Encoder {\n  export interface DataTypeMap {\n    float: Float32Array;\n    byte: Uint8Array;\n    int: Uint32Array;\n  }\n  export type DataType = keyof DataTypeMap;\n  type DataArrayType = DataTypeMap[DataType];\n\n  /* eslint-disable @typescript-eslint/naming-convention */\n  export const enum Usage {\n    Default = 0,\n    UploadOnly,\n    Download4BytesAsFloat32,\n  }\n}\n\n/**\n * Abstraction for mapping data types to texture texlets\n * Encoding means how a Float32 is mapped to 1 or 4 channels for each texlet\n * Decoding means how a texlet's channels are mapped to a resulting Float32\n */\nexport interface DataEncoder {\n  internalFormat: number;\n  format: number;\n  textureType: number;\n  channelSize: number;\n  encode(src: Encoder.DataArrayType, textureSize: number): Encoder.DataArrayType;\n  allocate(size: number): Encoder.DataArrayType;\n  decode(buffer: Encoder.DataArrayType, dataSize: number): Encoder.DataArrayType;\n}\n/**\n * WebGL2 data encoder\n * Uses R32F as the format for texlet\n */\nexport class RedFloat32DataEncoder implements DataEncoder {\n  internalFormat: number;\n  format: number;\n  textureType: number;\n  channelSize: number;\n  constructor(gl: WebGL2RenderingContext, channels = 1) {\n    if (channels === 1) {\n      this.internalFormat = gl.R32F;\n      this.format = gl.RED;\n      this.textureType = gl.FLOAT;\n      this.channelSize = channels;\n    } else if (channels === 4) {\n      this.internalFormat = gl.RGBA32F;\n      this.format = gl.RGBA;\n      this.textureType = gl.FLOAT;\n      this.channelSize = channels;\n    } else {\n      throw new Error(`Invalid number of channels: ${channels}`);\n    }\n  }\n  encode(src: Encoder.DataArrayType, textureSize: number): Encoder.DataArrayType {\n    let result: Float32Array;\n    let source: Float32Array;\n    if (src.constructor !== Float32Array) {\n      Logger.warning('Encoder', 'data was not of type Float32; creating new Float32Array');\n      source = new Float32Array(src);\n    }\n    if (textureSize * this.channelSize > src.length) {\n      Logger.warning('Encoder', 'Source data too small. Allocating larger array');\n      source = src as Float32Array;\n      result = this.allocate(textureSize * this.channelSize) as Float32Array;\n      source.forEach((v, i) => result[i] = v);\n    } else {\n      source = src as Float32Array;\n      result = source;\n    }\n    return result;\n  }\n  allocate(size: number): Encoder.DataArrayType {\n    return new Float32Array(size * 4);\n  }\n  decode(buffer: Encoder.DataArrayType, dataSize: number): Float32Array {\n    if (this.channelSize === 1) {\n      const filteredData = (buffer as Float32Array).filter((value, index) => index % 4 === 0).subarray(0, dataSize);\n      return filteredData;\n    }\n    return buffer.subarray(0, dataSize) as Float32Array;\n  }\n}\n/**\n * Data encoder for WebGL 1 with support for floating point texture\n */\nexport class RGBAFloatDataEncoder implements DataEncoder {\n  internalFormat: number;\n  format: number;\n  textureType: number;\n  channelSize: number;\n  constructor(gl: WebGLRenderingContext, channels = 1, textureType?: number) {\n    if (channels !== 1 && channels !== 4) {\n      throw new Error(`Invalid number of channels: ${channels}`);\n    }\n    this.internalFormat = gl.RGBA;\n    this.format = gl.RGBA;\n    this.channelSize = channels;\n    this.textureType = textureType || gl.FLOAT;\n  }\n  encode(src: Float32Array, textureSize: number): Encoder.DataArrayType {\n    let dest = src;\n    if (this.channelSize === 1) {\n      Logger.verbose('Encoder', 'Exploding into a larger array');\n      dest = this.allocate(textureSize) as Float32Array;\n      src.forEach((v, i) => dest[i * 4] = v);\n    }\n    return dest;\n  }\n  allocate(size: number): Encoder.DataArrayType {\n    return new Float32Array(size * 4);\n  }\n  decode(buffer: Encoder.DataArrayType, dataSize: number): Float32Array {\n    if (this.channelSize === 1) {\n      const filteredData = (buffer as Float32Array).filter((value, index) => index % 4 === 0).subarray(0, dataSize);\n      return filteredData;\n    }\n    return buffer.subarray(0, dataSize) as Float32Array;\n  }\n}\n\nexport class Uint8DataEncoder implements DataEncoder {\n  internalFormat: number;\n  format: number;\n  textureType: number;\n  channelSize = 4;\n  constructor(gl: WebGLRenderingContext, channels = 1) {\n    if (channels === 1) {\n      this.internalFormat = gl.ALPHA;\n      this.format = gl.ALPHA;  // not tested\n      this.textureType = gl.UNSIGNED_BYTE;\n      this.channelSize = channels;\n    } else if (channels === 4) {\n      this.internalFormat = gl.RGBA;\n      this.format = gl.RGBA;\n      this.textureType = gl.UNSIGNED_BYTE;\n      this.channelSize = channels;\n    } else {\n      throw new Error(`Invalid number of channels: ${channels}`);\n    }\n  }\n  encode(src: Uint8Array, _textureSize: number): Encoder.DataArrayType {\n    return new Uint8Array(src.buffer, src.byteOffset, src.byteLength);\n  }\n  allocate(size: number): Encoder.DataArrayType {\n    return new Uint8Array(size * this.channelSize);\n  }\n  decode(buffer: Encoder.DataArrayType, dataSize: number): Uint8Array {\n    if (buffer instanceof Uint8Array) {\n      return buffer.subarray(0, dataSize);\n    }\n    throw new Error(`Invalid array type: ${buffer.constructor}`);\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Logger} from '../../instrument';\nimport {assert} from '../../util';\n\n/** Layout preferences */\nexport interface WidthHeightPrefs {\n  breakAxis?: number;\n  isPacked?: boolean;\n  reverseWH?: boolean;\n}\n/**\n * TextureLayoutStrategy is an abstraction for different plans\n * for mapping n-dimensional arrays to 2D textures (and back)\n */\nexport interface TextureLayoutStrategy {\n  computeTextureWH(shape: readonly number[], prefs?: WidthHeightPrefs): [number, number];\n}\n\n/**\n * This strategy try to find the minimal max(W,H) that fulfills (W * H == totalSize)\n */\nexport class AlwaysKeepOriginalSizeStrategy implements TextureLayoutStrategy {\n  constructor(public maxTextureSize: number) {}\n  computeTextureWH(shape: readonly number[], prefs?: WidthHeightPrefs): [number, number] {\n    // scalar tensor\n    if (shape.length === 0) {\n      return [1, 1];\n    }\n    const maxTextureSize = this.maxTextureSize;\n    if (prefs && prefs.breakAxis !== undefined) {\n      // check to see if dims fit\n      const wsize = prefs.breakAxis >= shape.length ? 1 : shape.slice(prefs.breakAxis).reduce((a, b) => a * b);\n      const hsize = prefs.breakAxis <= 0 ? 1 : shape.slice(0, prefs.breakAxis).reduce((a, b) => a * b);\n      if (wsize > maxTextureSize || hsize > maxTextureSize) {\n        // ignore preferences\n        // continue with default layout\n        Logger.verbose(\n            'TextureLayout',\n            `Given width/height preferences were unattainable: shape:${shape}, breakAxis:${prefs.breakAxis}`);\n      } else {\n        return [wsize, hsize];\n      }\n    }\n    const totalSize = shape.reduce((a, b) => a * b);\n\n    let width = Math.floor(Math.sqrt(totalSize));\n\n    for (; width < maxTextureSize && width < totalSize; width++) {\n      if (totalSize % width === 0) {\n        break;\n      }\n    }\n\n    if (width >= maxTextureSize || totalSize % width !== 0) {\n      throw new Error(`The given dimensions are outside this GPU's boundaries: ${shape}`);\n    }\n    return [width, totalSize / width];\n  }\n}\n\nexport class PreferLogicalStrategy implements TextureLayoutStrategy {\n  constructor(public maxTextureSize: number) {}\n  computeTextureWH(shape: readonly number[], prefs?: WidthHeightPrefs): [number, number] {\n    const wh = this.computeTexture(shape, prefs);\n    if (prefs && prefs.isPacked) {\n      wh[0] /= 2;\n      wh[1] /= 2;\n    }\n    if (prefs && prefs.reverseWH) {\n      return [wh[1], wh[0]];\n    }\n    return wh;\n  }\n\n  computeTexture(shape: readonly number[], prefs?: WidthHeightPrefs): [number, number] {\n    const isPacked = prefs && prefs.isPacked;\n    // scalar tensor\n    if (shape.length === 0) {\n      return isPacked ? [2, 2] : [1, 1];\n    }\n    let maxTextureSize = this.maxTextureSize;\n    if (prefs && prefs.breakAxis !== undefined) {\n      // check to see if dims fit\n      const wsize = prefs.breakAxis >= shape.length ? 1 : shape.slice(prefs.breakAxis).reduce((a, b) => a * b);\n      const hsize = prefs.breakAxis <= 0 ? 1 : shape.slice(0, prefs.breakAxis).reduce((a, b) => a * b);\n      if (wsize > maxTextureSize || hsize > maxTextureSize) {\n        // ignore preferences\n        // continue with default layout\n        Logger.verbose(\n            'TextureLayout',\n            `Given width/height preferences were unattainable: shape:${shape}, breakAxis:${prefs.breakAxis}`);\n      } else {\n        return [wsize, hsize];\n      }\n    }\n    let logShape = shape.slice(0);\n    if (isPacked) {\n      maxTextureSize = maxTextureSize * 2;\n\n      // This logic ensures we accurately count the number of packed texels needed\n      // to accommodate the tensor. We can only pack values in the same texel if\n      // they are from adjacent pairs of rows/cols within the same batch. So if a\n      // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n      // fact that the texels containing the third row are half empty.\n      logShape = logShape.map(\n          (d, i) => i >= logShape.length - 2 ? (logShape[i] % 2 === 0 ? logShape[i] : logShape[i] + 1) : logShape[i]);\n\n      // Packed texture height is at least 2 (the channel height of a single\n      // texel).\n      if (logShape.length === 1) {\n        logShape = [2, logShape[0]];\n      }\n    }\n\n    // If logical shape is 2, we don't squeeze, since we want to match physical.\n    if (logShape.length !== 2) {\n      const squeezeResult = squeezeShape(logShape);\n      logShape = squeezeResult.newShape;\n    }\n\n    const size = sizeFromShape(logShape);\n    if (logShape.length <= 1 && size <= maxTextureSize) {\n      return [1, size];\n    } else if (logShape.length === 2 && logShape[0] <= maxTextureSize && logShape[1] <= maxTextureSize) {\n      return logShape as [number, number];\n    } else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTextureSize && logShape[2] <= maxTextureSize) {\n      return [logShape[0] * logShape[1], logShape[2]];\n    } else if (logShape.length === 3 && logShape[0] <= maxTextureSize && logShape[1] * logShape[2] <= maxTextureSize) {\n      return [logShape[0], logShape[1] * logShape[2]];\n    } else if (\n        logShape.length === 4 && logShape[0] * logShape[1] * logShape[2] <= maxTextureSize &&\n        logShape[3] <= maxTextureSize) {\n      return [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n    } else if (\n        logShape.length === 4 && logShape[0] <= maxTextureSize &&\n        logShape[1] * logShape[2] * logShape[3] <= maxTextureSize) {\n      return [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n    } else {\n      if (isPacked) {\n        // For packed textures size equals the number of channels required to\n        // accommodate the texture data. However in order to squarify such that\n        // inner dimensions stay even, we rewrite size to equal the number of\n        // texels. Then in the return statement we rehydrate the squarified\n        // dimensions to channel units.\n        return sizeToSquarishShape(size / 4).map(d => d * 2) as [number, number];\n      }\n      return sizeToSquarishShape(size);\n    }\n  }\n}\n\nexport function squeezeShape(shape: number[], axis?: number[]): {newShape: number[]; keptDims: number[]} {\n  const newShape: number[] = [];\n  const keptDims: number[] = [];\n  const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;\n  const axes = (axis == null || isEmptyArray) ? null : parseAxisParam(axis, shape).sort();\n  let j = 0;\n  for (let i = 0; i < shape.length; ++i) {\n    if (axes != null) {\n      if (axes[j] === i && shape[i] !== 1) {\n        throw new Error(`Can't squeeze axis ${i} since its dim '${shape[i]}' is not 1`);\n      }\n      if ((axes[j] == null || axes[j] > i) && shape[i] === 1) {\n        newShape.push(shape[i]);\n        keptDims.push(i);\n      }\n      if (axes[j] <= i) {\n        j++;\n      }\n    }\n    if (shape[i] !== 1) {\n      newShape.push(shape[i]);\n      keptDims.push(i);\n    }\n  }\n  return {newShape, keptDims};\n}\n\nexport function parseAxisParam(axis: number|number[], shape: number[]): number[] {\n  const rank = shape.length;\n\n  // Normalize input\n  axis = axis == null ? shape.map((s, i) => i) : ([] as number[]).concat(axis);\n\n  // Check for valid range\n  assert(\n      axis.every(ax => ax >= -rank && ax < rank),\n      () => `All values in axis param must be in range [-${rank}, ${rank}) but ` +\n          `got axis ${axis}`);\n\n  // Check for only integers\n  assert(\n      axis.every(isInt),\n      () => 'All values in axis param must be integers but ' +\n          `got axis ${axis}`);\n\n  // Handle negative axis.\n  return axis.map(a => a < 0 ? rank + a : a);\n}\nexport function isInt(a: number): boolean {\n  return a % 1 === 0;\n}\nexport function sizeFromShape(shape: number[]): number {\n  if (shape.length === 0) {\n    // Scalar.\n    return 1;\n  }\n  let size = shape[0];\n  for (let i = 1; i < shape.length; i++) {\n    size *= shape[i];\n  }\n  return size;\n}\nexport function getRowsCols(shape: number[]): [number, number] {\n  if (shape.length === 0) {\n    throw Error('Cannot get rows and columns of an empty shape array.');\n  }\n\n  return [shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]];\n}\nexport function sizeToSquarishShape(size: number): [number, number] {\n  const width = Math.ceil(Math.sqrt(size));\n  return [width, Math.ceil(size / width)];\n}\nexport function getBatchDim(shape: number[], dimsToSkip = 2): number {\n  return sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {ShapeUtil} from '../../util';\n\nimport {TextureLayoutStrategy, WidthHeightPrefs} from './texture-layout-strategy';\nimport {TextureLayout, TextureType} from './types';\n\nexport const createTextureLayoutFromTextureType =\n    (textureLayoutStrategy: TextureLayoutStrategy, shape: readonly number[],\n     textureType: TextureType): TextureLayout => {\n      const channel = (textureType === TextureType.unpacked || textureType === TextureType.unpackedReversed) ? 1 : 4;\n      const isPacked = textureType === TextureType.packed;\n      const reverseWH = (textureType === TextureType.unpackedReversed || textureType === TextureType.packed);\n      const breakAxis = textureType === TextureType.packedLastDimension ? shape.length - 1 : undefined;\n      const unpackedShape = textureType === TextureType.packedLastDimension ?\n          shape.map((d, i) => i === shape.length - 1 ? d * 4 : d) :\n          undefined;\n      return createTextureLayoutFromShape(\n          textureLayoutStrategy, shape, channel, unpackedShape, {isPacked, reverseWH, breakAxis});\n    };\n\nexport const calculateTextureWidthAndHeight =\n    (textureLayoutStrategy: TextureLayoutStrategy, shape: readonly number[], textureType: TextureType):\n        [number, number] => {\n          const layout = createTextureLayoutFromTextureType(textureLayoutStrategy, shape, textureType);\n          return [layout.width, layout.height];\n        };\n\n/**\n * Create a TextureLayout object from shape.\n */\nexport const createTextureLayoutFromShape =\n    (textureLayoutStrategy: TextureLayoutStrategy, shape: readonly number[], channels: 1|4 = 1,\n     unpackedShape?: readonly number[], prefs?: WidthHeightPrefs): TextureLayout => {\n      const isPacked = !!(prefs && prefs.isPacked);\n      const [width, height] = textureLayoutStrategy.computeTextureWH(isPacked ? unpackedShape || shape : shape, prefs);\n      const rank = shape.length;\n      let inferredDims = shape.slice(0);\n      if (rank === 0) {\n        inferredDims = [1];\n      }\n      if (channels === 1) {\n        // unpackedShape will take `shape` and not `inferredDims` so as to create a scalar Tensor if need be\n        unpackedShape = shape;\n      } else if (isPacked) {\n        if (channels !== 4) {\n          throw new Error('a packed texture must be 4-channel');\n        }\n        unpackedShape = shape;\n        if (rank > 0) {\n          inferredDims[rank - 1] = Math.ceil(inferredDims[rank - 1] / 2);\n        }\n        if (rank > 1) {\n          inferredDims[rank - 2] = Math.ceil(inferredDims[rank - 2] / 2);\n        }\n      } else if (!unpackedShape) {\n        throw new Error('Unpacked shape is needed when using channels > 1');\n      }\n      return {\n        width,\n        height,\n        channels,\n        isPacked,\n        shape: inferredDims,\n        strides: ShapeUtil.computeStrides(inferredDims),\n        unpackedShape,\n        reversedWH: (prefs && prefs.reverseWH)\n      };\n    };\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Logger, Profiler} from '../../instrument';\nimport {Tensor} from '../../tensor';\n\nimport {Encoder} from './texture-data-encoder';\nimport {TextureLayoutStrategy} from './texture-layout-strategy';\nimport {TextureData, TextureLayout} from './types';\nimport {WebGLContext} from './webgl-context';\n\nexport interface TextureManagerConfig {\n  reuseTextures?: boolean;\n}\n\n/**\n * TextureManager is the mainly responsible for caching Textures\n * Textures are cached in 2 levels:\n *   1. the texures which are associated with a dataId (from Tensor)\n *    Caching these is crucial to performance. These are In-use Textures\n *   2. textures which are not in use by any current ProgramInfo/Tensor\n *     These are called Free Textures\n * TextureManager is also used to help creating textures. For this it\n * uses WebGLContext and TextureLayoutStrategy\n */\nexport class TextureManager {\n  private readonly inUseTextures: Map<string, WebGLTexture[]>;\n  private readonly idleTextures: Map<string, WebGLTexture[]>;\n  private readonly textureLookup: Map<WebGLTexture, string>;\n  private readonly pendingRead: Map<Tensor.Id, Array<(arr: Tensor.NumberType) => void>> = new Map();\n\n  constructor(\n      public glContext: WebGLContext, public layoutStrategy: TextureLayoutStrategy, public profiler: Readonly<Profiler>,\n      private config: TextureManagerConfig) {\n    if (config.reuseTextures) {\n      this.inUseTextures = new Map();\n      this.idleTextures = new Map();\n      this.textureLookup = new Map();\n    }\n  }\n  createTextureFromLayout(\n      dataType: Tensor.DataType, layout: TextureLayout, data?: Tensor.NumberType, usage?: Encoder.Usage) {\n    const textureDataType = this.toEncoderType(dataType);\n\n    const encoder = this.glContext.getEncoder(textureDataType, layout.channels || 1, usage);\n    if (layout.isPacked && usage === Encoder.Usage.UploadOnly) {\n      throw new Error('not implemented');\n    }\n    const width = layout.width;\n    const height = layout.height;\n\n    let key: string|undefined;\n    let inUseTextures: WebGLTexture[]|undefined;\n    if (this.config.reuseTextures) {\n      key = `${width}x${height}_${encoder.format}_${encoder.internalFormat}_${encoder.textureType}`;\n      inUseTextures = this.inUseTextures.get(key);\n      if (!inUseTextures) {\n        inUseTextures = [];\n        this.inUseTextures.set(key, inUseTextures);\n      }\n\n      const idleTextures = this.idleTextures.get(key);\n      if (idleTextures && idleTextures.length > 0) {\n        const texture = idleTextures.pop()!;\n        inUseTextures.push(texture);\n        if (usage === Encoder.Usage.UploadOnly) {\n          this.glContext.updateTexture(texture, width, height, encoder, this.toTextureData(dataType, data)!);\n        }\n        return texture;\n      }\n    }\n\n    Logger.verbose('TextureManager', `Creating new texture of size ${layout.width}x${layout.height}`);\n    const texture = this.glContext.allocateTexture(width, height, encoder, this.toTextureData(dataType, data));\n\n    if (this.config.reuseTextures) {\n      inUseTextures!.push(texture);\n      this.textureLookup.set(texture, key!);\n    }\n    return texture;\n  }\n  readTexture(td: TextureData, dataType: Tensor.DataType, channels?: number): Tensor.NumberType {\n    if (!channels) {\n      channels = 1;\n    }\n    return this.profiler.event('backend', 'TextureManager.readTexture', () => {\n      const dataSize = td.shape.reduce((a, b) => a * b) * channels!;\n      const data = this.glContext.readTexture(\n          td.texture, td.width, td.height, dataSize, this.toEncoderType(dataType), channels!);\n      return this.toTensorData(dataType, data);\n    });\n  }\n  async readTextureAsync(td: TextureData, dataType: Tensor.DataType, channels?: number): Promise<Tensor.NumberType> {\n    const dataId = td.tensor.dataId;\n    if (!channels) {\n      channels = 1;\n    }\n    if (this.pendingRead.has(dataId)) {\n      const subscribers = this.pendingRead.get(dataId);\n      return new Promise<Tensor.NumberType>(resolve => subscribers?.push(resolve));\n    }\n    return this.profiler.event('backend', 'TextureManager.readTextureAsync', async () => {\n      this.pendingRead.set(dataId, []);\n      const dataSize = td.shape.reduce((a, b) => a * b) * channels!;\n      // add a fence waiting for the data to be ready\n      await this.glContext.createAndWaitForFence();\n      const data = this.glContext.readTexture(\n          td.texture, td.width, td.height, dataSize, this.toEncoderType(dataType), channels!);\n      const tensorData = this.toTensorData(dataType, data);\n      const subscribers = this.pendingRead.get(dataId);\n      this.pendingRead.delete(dataId);\n      subscribers?.forEach(resolve => resolve(tensorData));\n      return tensorData;\n    });\n  }\n  readUint8TextureAsFloat(td: TextureData): Float32Array {\n    return this.profiler.event('backend', 'TextureManager.readUint8TextureAsFloat', () => {\n      const dataSize = td.shape.reduce((a, b) => a * b);\n      const data = this.glContext.readTexture(td.texture, td.width, td.height, dataSize * 4, 'byte', 4);\n      return new Float32Array(data.buffer, data.byteOffset, dataSize);\n    });\n  }\n  releaseTexture(textureData: TextureData, deleteTexture?: boolean): void {\n    let key: string|undefined;\n    if (this.config.reuseTextures) {\n      key = this.textureLookup.get(textureData.texture);\n      if (key) {\n        if (deleteTexture) {\n          this.textureLookup.delete(key);\n        }\n        const inUseTextures = this.inUseTextures.get(key);\n        if (inUseTextures) {\n          const index = inUseTextures.indexOf(textureData.texture);\n          if (index !== -1) {\n            inUseTextures.splice(index, 1);\n            let idleTextures = this.idleTextures.get(key);\n            if (!idleTextures) {\n              idleTextures = [];\n              this.idleTextures.set(key, idleTextures);\n            }\n            idleTextures.push(textureData.texture);\n          }\n        }\n      }\n    }\n\n    if (!key || deleteTexture) {\n      Logger.verbose('TextureManager', `Deleting texture of size ${textureData.width}x${textureData.height}`);\n      this.glContext.deleteTexture(textureData.texture);\n    }\n  }\n  toTensorData(dataType: Tensor.DataType, data: Encoder.DataArrayType): Tensor.NumberType {\n    switch (dataType) {\n      case 'int16':\n        return data instanceof Int16Array ? data : Int16Array.from(data);\n      case 'int32':\n        return data instanceof Int32Array ? data : Int32Array.from(data);\n      case 'int8':\n        return data instanceof Int8Array ? data : Int8Array.from(data);\n      case 'uint16':\n        return data instanceof Uint16Array ? data : Uint16Array.from(data);\n      case 'uint32':\n        return data instanceof Uint32Array ? data : Uint32Array.from(data);\n      case 'uint8':\n      case 'bool':\n        return data instanceof Uint8Array ? data : Uint8Array.from(data);\n      case 'float32':\n        return data instanceof Float32Array ? data : Float32Array.from(data);\n      case 'float64':\n        return data instanceof Float64Array ? data : Float64Array.from(data);\n      default:\n        throw new Error(`TensorData type ${dataType} is not supported`);\n    }\n  }\n  toTextureData(dataType: Tensor.DataType, data: Tensor.NumberType|undefined): Encoder.DataArrayType|undefined {\n    if (!data) {\n      return undefined;\n    }\n    return (data instanceof Float32Array) ? data : new Float32Array(data);\n    /*\n    switch (dataType) {\n      case 'int16':\n      case 'int32':\n      case 'uint16':\n      case 'uint32':\n        return (data.constructor === Uint32Array) ? data as Uint32Array : new Uint32Array(data);\n      case 'int8':\n      case 'uint8':\n      case 'bool':\n        return (data.constructor === Uint8Array) ? data as Uint8Array : new Uint8Array(data);\n      case 'float32':\n      case 'float64':\n        return (data.constructor === Float32Array) ? data as Float32Array : new Float32Array(data);\n      default:\n        throw new Error(`TensorData type ${dataType} is not supported`);\n    }\n    */\n  }\n  toEncoderType(_dataType: Tensor.DataType): Encoder.DataType {\n    return 'float';\n    // switch (dataType) {\n    //   case 'int16':\n    //   case 'int32':\n    //   case 'uint16':\n    //   case 'uint32':\n    //     return 'int';\n    //   case 'uint8':\n    //   case 'bool':\n    //     return 'byte';\n    //   case 'float32':\n    //   case 'float64':\n    //     return 'float';\n    //   default:\n    //     throw new Error(`TensorData type ${dataType} is not supported`);\n    // }\n  }\n  clearActiveTextures(): void {\n    this.glContext.clearActiveTextures();\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../tensor';\n\n/**\n * Layout info is used for mapping n-dimensional array to 2D textures\n * The layout is created by the TextureLayoutStrategy based on\n * the Tensor's dimensions and strides\n */\nexport interface TextureLayout {\n  width: number;\n  height: number;\n  /**\n   * specify the number of value that encoded in a single pixel\n   */\n  channels: 1|2|3|4;\n  /**\n   * whether in packed mode or not\n   */\n  isPacked?: boolean;\n  /**\n   * the normalized shape\n   */\n  shape: readonly number[];\n  /**\n   * the stride of each dimensions, calculated according to shape\n   */\n  strides: readonly number[];\n  /**\n   * the original shape(dims) of the corresponding tensor\n   */\n  unpackedShape: readonly number[];\n\n  reversedWH?: boolean;\n}\nexport interface TextureData extends TextureLayout {\n  tensor: Tensor;\n  texture: WebGLTexture;\n}\n\nexport enum TextureType {\n  unpacked,              // <-- normal unpacked texture\n  unpackedReversed,      // <-- unpacked texture used in old ONNX.js implementation (deprecated)\n  packed,                // <-- normal packed texture\n  downloadUint8AsFloat,  // <-- ONLY used in texture downloading for iOS devices\n  packedLastDimension    // <-- ONLY used in old ONNX.js Conv implementation for input W (deprecated)\n}\n\nexport interface TensorInfo {\n  id?: Tensor.Id;\n  dims: readonly number[];\n  type: Tensor.DataType;\n  textureType: TextureType;\n}\n\nexport interface ProgramVariable {\n  type: 'float'|'int';\n  name: string;\n  arrayLength?: number;\n  data: number|number[];\n}\n\n/**\n * A set of metadata of a shader program.\n */\nexport interface ProgramMetadata {\n  /**\n   * the name of the program. used for debugging and profiling\n   */\n  name: string;\n  /**\n   * texture types for each input\n   */\n  inputTypes: TextureType[];\n  /**\n   * names of each input\n   */\n  inputNames: string[];\n  /**\n   * an optional string as a cache hint in the artifact cache\n   */\n  cacheHint?: string;\n}\n\n/**\n * A ProgramInfoLoader allows\n */\nexport interface ProgramInfoLoader extends ProgramMetadata {\n  /**\n   * a function to get the program info\n   */\n  get(): ProgramInfo;\n}\n\n/**\n * A set of data that represent a shader program\n */\nexport interface ProgramInfo extends ProgramMetadata {\n  /**\n   * information of uniform variables\n   */\n  variables?: ProgramVariable[];\n  /**\n   * tensor info for output\n   */\n  output: TensorInfo;\n  /**\n   * the shader's processing source code\n   */\n  shaderSource: string;\n  /**\n   * whether the shader source contains a customized main function implementation\n   */\n  hasMain?: boolean;\n}\n\nexport interface VariableInfo {\n  type: 'float'|'int';\n  name: string;\n  arrayLength?: number;\n}\n\nexport interface ProgramVariable {\n  type: 'float'|'int';\n  name: string;\n  arrayLength?: number;\n  data: number|number[];\n}\n\n/**\n * Information of uniforms that shader uses\n */\nexport interface UniformInfo {\n  type: 'sampler2D'|VariableInfo['type'];\n  name: string;\n  arrayLength?: number;\n}\n\nexport interface UniformLocation extends UniformInfo {\n  location: WebGLUniformLocation;\n}\n\n/**\n * Artifact is the result of compilation\n * It does not contain input of output data\n * However anything that could be run as a \"program\"\n */\nexport interface Artifact {\n  programInfo: ProgramInfo;\n  program: WebGLProgram;\n  uniformLocations: UniformLocation[];\n  attribLocations: {position: number; textureCoord: number};\n}\nexport declare namespace Artifact {\n  type UniformLocations = Artifact['uniformLocations'];\n  type AttribLocations = Artifact['attribLocations'];\n}\n\nexport interface UniformData {\n  [name: string]: number|number[];\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {assert} from '../../util';\n/**\n * Given a non RGBA shape calculate the R version\n * It is assumed that the dimensions are multiples of given channels\n * NOTE: it is always the last dim that gets packed.\n * @param unpackedShape original shape to create a packed version from\n */\nexport function getPackedShape(unpackedShape: readonly number[]): readonly number[] {\n  const len = unpackedShape.length;\n  return unpackedShape.slice(0, len - 1).concat(unpackedShape[len - 1] / 4);\n}\n\nexport async function repeatedTry(\n    checkFn: () => boolean, delayFn = (_counter: number) => 0, maxCounter?: number): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    let tryCount = 0;\n\n    const tryFn = () => {\n      if (checkFn()) {\n        resolve();\n        return;\n      }\n\n      tryCount++;\n\n      const nextBackoff = delayFn(tryCount);\n\n      if (maxCounter != null && tryCount >= maxCounter) {\n        reject();\n        return;\n      }\n      setTimeout(tryFn, nextBackoff);\n    };\n\n    tryFn();\n  });\n}\n\n/**\n * Generates the function name from an input sampler name.\n * @param samplerName Name of the sampler.\n */\nexport function generateShaderFuncNameFromInputSamplerName(samplerName: string): string {\n  assert(typeof samplerName !== 'undefined' && samplerName.length !== 0, () => 'empty string found for sampler name');\n  return 'get' + samplerName.charAt(0).toUpperCase() + samplerName.slice(1);\n}\n\n/**\n * Generates the function name from an input sampler name at output coordinates.\n * @param samplerName Name of the sampler.\n */\nexport function generateShaderFuncNameFromInputSamplerNameAtOutCoords(samplerName: string): string {\n  assert(typeof samplerName !== 'undefined' && samplerName.length !== 0, () => 'empty string found for sampler name');\n  return 'get' + samplerName.charAt(0).toUpperCase() + samplerName.slice(1) + 'AtOutCoords';\n}\n\n/** Returns a new input shape (a copy) that has a squeezed logical shape. */\nexport function squeezeInputShape(inputShape: readonly number[], squeezedShape: number[]): number[] {\n  // Deep copy.\n  let newInputShape: number[] = JSON.parse(JSON.stringify(inputShape));\n  newInputShape = squeezedShape;\n  return newInputShape;\n}\n\n/** Returns a list of squeezed parameters for shader functions */\nexport function getSqueezedParams(params: string[], keptDims: number[]): string {\n  return keptDims.map(d => params[d]).join(', ');\n}\n\n/** Returns the data type for different ranks. */\nexport function getCoordsDataType(rank: number): string {\n  if (rank <= 1) {\n    return 'int';\n  } else if (rank === 2) {\n    return 'ivec2';\n  } else if (rank === 3) {\n    return 'ivec3';\n  } else if (rank === 4) {\n    return 'ivec4';\n  } else if (rank === 5) {\n    return 'ivec5';\n  } else if (rank === 6) {\n    return 'ivec6';\n  } else {\n    throw Error(`GPU for rank ${rank} is not yet supported`);\n  }\n}\n\nexport function getGlChannels(rank = 6): string[] {\n  return ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Logger} from '../../instrument';\n\nimport {WebGLContext} from './webgl-context';\n\nconst cache: {[contextId: string]: WebGLContext} = {};\n\n/**\n * This factory function creates proper WebGLRenderingContext based on\n * the current browsers capabilities\n * The order is from higher/most recent versions to most basic\n */\nexport function createWebGLContext(contextId?: 'webgl'|'webgl2'): WebGLContext {\n  let context: WebGLContext|undefined;\n  if ((!contextId || contextId === 'webgl2') && 'webgl2' in cache) {\n    context = cache.webgl2;\n  } else if ((!contextId || contextId === 'webgl') && 'webgl' in cache) {\n    context = cache.webgl;\n  }\n\n  if (!context) {\n    try {\n      // try to create webgl context from an offscreen canvas\n      const offscreenCanvas = createOffscreenCanvas();\n      context = createNewWebGLContext(offscreenCanvas, contextId);\n    } catch (e) {\n      // if failed, fallback to try to use a normal canvas element\n      const canvas = createCanvas();\n      context = createNewWebGLContext(canvas, contextId);\n    }\n  }\n\n  contextId = contextId || context.version === 1 ? 'webgl' : 'webgl2';\n  const gl = context.gl;\n\n  cache[contextId] = context;\n\n  if (gl.isContextLost()) {\n    delete cache[contextId];\n    return createWebGLContext(contextId);\n  }\n\n  gl.disable(gl.DEPTH_TEST);\n  gl.disable(gl.STENCIL_TEST);\n  gl.disable(gl.BLEND);\n  gl.disable(gl.DITHER);\n  gl.disable(gl.POLYGON_OFFSET_FILL);\n  gl.disable(gl.SAMPLE_COVERAGE);\n  gl.enable(gl.SCISSOR_TEST);\n  gl.enable(gl.CULL_FACE);\n  gl.cullFace(gl.BACK);\n\n  return context;\n}\n\nexport function createNewWebGLContext(canvas: HTMLCanvasElement, contextId?: 'webgl'|'webgl2'): WebGLContext {\n  const contextAttributes: WebGLContextAttributes = {\n    alpha: false,\n    depth: false,\n    antialias: false,\n    stencil: false,\n    preserveDrawingBuffer: false,\n    premultipliedAlpha: false,\n    failIfMajorPerformanceCaveat: false\n  };\n  let gl: WebGLRenderingContext|null;\n  const ca = contextAttributes;\n  if (!contextId || contextId === 'webgl2') {\n    gl = canvas.getContext('webgl2', ca);\n    if (gl) {\n      try {\n        return new WebGLContext(gl, 2);\n      } catch (err) {\n        Logger.warning('GlContextFactory', `failed to create WebGLContext using contextId 'webgl2'. Error: ${err}`);\n      }\n    }\n  }\n  if (!contextId || contextId === 'webgl') {\n    gl = canvas.getContext('webgl', ca) || canvas.getContext('experimental-webgl', ca) as WebGLRenderingContext;\n    if (gl) {\n      try {\n        return new WebGLContext(gl, 1);\n      } catch (err) {\n        Logger.warning(\n            'GlContextFactory',\n            `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${err}`);\n      }\n    }\n  }\n\n  throw new Error('WebGL is not supported');\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\ndeclare let OffscreenCanvas: {new (width: number, height: number): HTMLCanvasElement};\n\nfunction createCanvas(): HTMLCanvasElement {\n  if (typeof document === 'undefined') {\n    throw new TypeError('failed to create canvas: document is not supported');\n  }\n  const canvas: HTMLCanvasElement = document.createElement('canvas');\n  canvas.width = 1;\n  canvas.height = 1;\n  return canvas;\n}\n\nfunction createOffscreenCanvas(): HTMLCanvasElement {\n  if (typeof OffscreenCanvas === 'undefined') {\n    throw new TypeError('failed to create offscreen canvas: OffscreenCanvas is not supported');\n  }\n  return new OffscreenCanvas(1, 1);\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {env} from 'onnxruntime-common';\n\nimport * as DataEncoders from './texture-data-encoder';\nimport {DataEncoder, Encoder} from './texture-data-encoder';\nimport {repeatedTry} from './utils';\n\nexport interface FenceContext {\n  query: WebGLSync|null;\n  isFencePassed(): boolean;\n}\n\ntype PollItem = {\n  isDoneFn: () => boolean; resolveFn: () => void;\n};\n\nexport function linearSearchLastTrue(arr: Array<() => boolean>): number {\n  let i = 0;\n  for (; i < arr.length; ++i) {\n    const isDone = arr[i]();\n    if (!isDone) {\n      break;\n    }\n  }\n  return i - 1;\n}\n\n/**\n * Abstraction and wrapper around WebGLRenderingContext and its operations\n */\nexport class WebGLContext {\n  gl: WebGLRenderingContext;\n  version: 1|2;\n\n  private vertexbuffer: WebGLBuffer;\n  private framebuffer: WebGLFramebuffer;\n\n  // WebGL flags and vital parameters\n  private isFloatTextureAttachableToFrameBuffer: boolean;\n  isFloat32DownloadSupported: boolean;\n  isRenderFloat32Supported: boolean;\n  isBlendSupported: boolean;\n  maxTextureSize: number;\n  // private maxCombinedTextureImageUnits: number;\n  private maxTextureImageUnits: number;\n  // private maxCubeMapTextureSize: number;\n  // private shadingLanguageVersion: string;\n  // private webglVendor: string;\n  // private webglVersion: string;\n\n  // WebGL2 flags and vital parameters\n  // private max3DTextureSize: number;\n  // private maxArrayTextureLayers: number;\n  // private maxColorAttachments: number;\n  // private maxDrawBuffers: number;\n\n  // WebGL extensions\n  // eslint-disable-next-line camelcase\n  textureFloatExtension: OES_texture_float|null;\n  // eslint-disable-next-line camelcase\n  textureHalfFloatExtension: OES_texture_half_float|null;\n\n  // WebGL2 extensions\n  colorBufferFloatExtension: unknown|null;\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  disjointTimerQueryWebgl2Extension: {TIME_ELAPSED_EXT: GLenum; GPU_DISJOINT_EXT: GLenum}|null;\n\n  private disposed: boolean;\n  private frameBufferBound = false;\n\n  constructor(gl: WebGLRenderingContext, version: 1|2) {\n    this.gl = gl;\n    this.version = version;\n\n    this.getExtensions();\n    this.vertexbuffer = this.createVertexbuffer();\n    this.framebuffer = this.createFramebuffer();\n    this.queryVitalParameters();\n  }\n\n  allocateTexture(width: number, height: number, encoder: DataEncoder, data?: Encoder.DataArrayType): WebGLTexture {\n    const gl = this.gl;\n    // create the texture\n    const texture = gl.createTexture();\n    // bind the texture so the following methods effect this texture.\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    const buffer = data ? encoder.encode(data, width * height) : null;\n    gl.texImage2D(\n        gl.TEXTURE_2D,\n        0,  // Level of detail.\n        encoder.internalFormat, width, height,\n        0,  // Always 0 in OpenGL ES.\n        encoder.format, encoder.textureType, buffer);\n    this.checkError();\n    return texture as WebGLTexture;\n  }\n  updateTexture(\n      texture: WebGLTexture, width: number, height: number, encoder: DataEncoder, data: Encoder.DataArrayType): void {\n    const gl = this.gl;\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const buffer = encoder.encode(data, width * height);\n    gl.texSubImage2D(\n        gl.TEXTURE_2D,\n        0,  // level\n        0,  // xoffset\n        0,  // yoffset\n        width, height, encoder.format, encoder.textureType, buffer);\n    this.checkError();\n  }\n  attachFramebuffer(texture: WebGLTexture, width: number, height: number): void {\n    const gl = this.gl;\n    // Make it the target for framebuffer operations - including rendering.\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\n    gl.framebufferTexture2D(\n        gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture,\n        0);  // 0, we aren't using MIPMAPs\n    this.checkError();\n    gl.viewport(0, 0, width, height);\n    gl.scissor(0, 0, width, height);\n  }\n  readTexture(\n      texture: WebGLTexture, width: number, height: number, dataSize: number, dataType: Encoder.DataType,\n      channels: number): Encoder.DataArrayType {\n    const gl = this.gl;\n    if (!channels) {\n      channels = 1;\n    }\n    if (!this.frameBufferBound) {\n      this.attachFramebuffer(texture, width, height);\n    }\n    const encoder = this.getEncoder(dataType, channels);\n    const buffer = encoder.allocate(width * height);\n    // bind texture to framebuffer\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.framebufferTexture2D(\n        gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture,\n        0);  // 0, we aren't using MIPMAPs\n    // TODO: Check if framebuffer is ready\n    gl.readPixels(0, 0, width, height, gl.RGBA, encoder.textureType, buffer);\n    this.checkError();\n    // unbind FB\n    return encoder.decode(buffer, dataSize);\n  }\n\n  isFramebufferReady(): boolean {\n    // TODO: Implement logic to check if the framebuffer is ready\n    return true;\n  }\n  getActiveTexture(): string {\n    const gl = this.gl;\n    const n = gl.getParameter(this.gl.ACTIVE_TEXTURE);\n    return `TEXTURE${(n - gl.TEXTURE0)}`;\n  }\n  getTextureBinding(): WebGLTexture {\n    return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);\n  }\n  getFramebufferBinding(): WebGLFramebuffer {\n    return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);\n  }\n  setVertexAttributes(positionHandle: number, textureCoordHandle: number): void {\n    const gl = this.gl;\n    gl.vertexAttribPointer(positionHandle, 3, gl.FLOAT, false, 20, 0);\n    gl.enableVertexAttribArray(positionHandle);\n    if (textureCoordHandle !== -1) {\n      gl.vertexAttribPointer(textureCoordHandle, 2, gl.FLOAT, false, 20, 12);\n      gl.enableVertexAttribArray(textureCoordHandle);\n    }\n    this.checkError();\n  }\n  createProgram(\n      vertexShader: WebGLShader,\n      fragShader: WebGLShader,\n      ): WebGLProgram {\n    const gl = this.gl;\n    const program = gl.createProgram()!;\n\n    // the program consists of our shaders\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragShader);\n    gl.linkProgram(program);\n    return program;\n  }\n  compileShader(shaderSource: string, shaderType: number): WebGLShader {\n    const gl = this.gl;\n    const shader = gl.createShader(shaderType);\n    if (!shader) {\n      throw new Error(`createShader() returned null with type ${shaderType}`);\n    }\n\n    gl.shaderSource(shader, shaderSource);\n    gl.compileShader(shader);\n    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {\n      throw new Error(`Failed to compile shader: ${gl.getShaderInfoLog(shader)}\nShader source:\n${shaderSource}`);\n    }\n    return shader;\n  }\n  deleteShader(shader: WebGLShader): void {\n    this.gl.deleteShader(shader);\n  }\n  bindTextureToUniform(texture: WebGLTexture, position: number, uniformHandle: WebGLUniformLocation): void {\n    const gl = this.gl;\n    gl.activeTexture(gl.TEXTURE0 + position);\n    this.checkError();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    this.checkError();\n    gl.uniform1i(uniformHandle, position);\n    this.checkError();\n  }\n  draw(): void {\n    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\n    this.checkError();\n  }\n  checkError(): void {\n    if (env.debug) {\n      const gl = this.gl;\n      const error = gl.getError();\n      let label = '';\n      switch (error) {\n        case (gl.NO_ERROR):\n          return;\n        case (gl.INVALID_ENUM):\n          label = 'INVALID_ENUM';\n          break;\n        case (gl.INVALID_VALUE):\n          label = 'INVALID_VALUE';\n          break;\n        case (gl.INVALID_OPERATION):\n          label = 'INVALID_OPERATION';\n          break;\n        case (gl.INVALID_FRAMEBUFFER_OPERATION):\n          label = 'INVALID_FRAMEBUFFER_OPERATION';\n          break;\n        case (gl.OUT_OF_MEMORY):\n          label = 'OUT_OF_MEMORY';\n          break;\n        case (gl.CONTEXT_LOST_WEBGL):\n          label = 'CONTEXT_LOST_WEBGL';\n          break;\n        default:\n          label = `Unknown WebGL Error: ${error.toString(16)}`;\n      }\n      throw new Error(label);\n    }\n  }\n  deleteTexture(texture: WebGLTexture): void {\n    this.gl.deleteTexture(texture);\n  }\n  deleteProgram(program: WebGLProgram): void {\n    this.gl.deleteProgram(program);\n  }\n  getEncoder(dataType: Encoder.DataType, channels: number, usage: Encoder.Usage = Encoder.Usage.Default): DataEncoder {\n    if (this.version === 2) {\n      return new DataEncoders.RedFloat32DataEncoder(this.gl as WebGL2RenderingContext, channels);\n    }\n\n    switch (dataType) {\n      case 'float':\n        if (usage === Encoder.Usage.UploadOnly || this.isRenderFloat32Supported) {\n          return new DataEncoders.RGBAFloatDataEncoder(this.gl, channels);\n        } else {\n          return new DataEncoders.RGBAFloatDataEncoder(\n              this.gl, channels, this.textureHalfFloatExtension!.HALF_FLOAT_OES);\n        }\n      case 'int':\n        throw new Error('not implemented');\n      case 'byte':\n        return new DataEncoders.Uint8DataEncoder(this.gl, channels);\n      default:\n        throw new Error(`Invalid dataType: ${dataType}`);\n    }\n  }\n  clearActiveTextures(): void {\n    const gl = this.gl;\n    for (let unit = 0; unit < this.maxTextureImageUnits; ++unit) {\n      gl.activeTexture(gl.TEXTURE0 + unit);\n      gl.bindTexture(gl.TEXTURE_2D, null);\n    }\n  }\n  dispose(): void {\n    if (this.disposed) {\n      return;\n    }\n    const gl = this.gl;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteFramebuffer(this.framebuffer);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    gl.deleteBuffer(this.vertexbuffer);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    gl.finish();\n    this.disposed = true;\n  }\n\n  private createDefaultGeometry(): Float32Array {\n    // Sets of x,y,z(=0),s,t coordinates.\n    return new Float32Array([\n      -1.0, 1.0,  0.0, 0.0, 1.0,  // upper left\n      -1.0, -1.0, 0.0, 0.0, 0.0,  // lower left\n      1.0,  1.0,  0.0, 1.0, 1.0,  // upper right\n      1.0,  -1.0, 0.0, 1.0, 0.0   // lower right\n    ]);\n  }\n  private createVertexbuffer(): WebGLBuffer {\n    const gl = this.gl;\n    const buffer = gl.createBuffer();\n    if (!buffer) {\n      throw new Error('createBuffer() returned null');\n    }\n    const geometry = this.createDefaultGeometry();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, geometry, gl.STATIC_DRAW);\n    this.checkError();\n    return buffer;\n  }\n  private createFramebuffer(): WebGLFramebuffer {\n    const fb = this.gl.createFramebuffer();\n    if (!fb) {\n      throw new Error('createFramebuffer returned null');\n    }\n    return fb;\n  }\n\n  private queryVitalParameters(): void {\n    const gl = this.gl;\n\n    this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer();\n    this.isRenderFloat32Supported = this.checkRenderFloat32();\n    this.isFloat32DownloadSupported = this.checkFloat32Download();\n\n    if (this.version === 1 && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported) {\n      throw new Error('both float32 and float16 TextureType are not supported');\n    }\n\n    this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend();\n\n    // this.maxCombinedTextureImageUnits = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n    this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    this.maxTextureImageUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    // this.maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n    // this.shadingLanguageVersion = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);\n    // this.webglVendor = gl.getParameter(gl.VENDOR);\n    // this.webglVersion = gl.getParameter(gl.VERSION);\n\n    if (this.version === 2) {\n      // this.max3DTextureSize = gl.getParameter(WebGL2RenderingContext.MAX_3D_TEXTURE_SIZE);\n      // this.maxArrayTextureLayers = gl.getParameter(WebGL2RenderingContext.MAX_ARRAY_TEXTURE_LAYERS);\n      // this.maxColorAttachments = gl.getParameter(WebGL2RenderingContext.MAX_COLOR_ATTACHMENTS);\n      // this.maxDrawBuffers = gl.getParameter(WebGL2RenderingContext.MAX_DRAW_BUFFERS);\n    }\n  }\n  private getExtensions(): void {\n    if (this.version === 2) {\n      this.colorBufferFloatExtension = this.gl.getExtension('EXT_color_buffer_float');\n      this.disjointTimerQueryWebgl2Extension = this.gl.getExtension('EXT_disjoint_timer_query_webgl2');\n    } else {\n      this.textureFloatExtension = this.gl.getExtension('OES_texture_float');\n      this.textureHalfFloatExtension = this.gl.getExtension('OES_texture_half_float');\n    }\n  }\n\n  private checkFloatTextureAttachableToFrameBuffer(): boolean {\n    // test whether Float32 texture is supported:\n    // STEP.1 create a float texture\n    const gl = this.gl;\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    const internalFormat = this.version === 2 ? (gl as unknown as {RGBA32F: number}).RGBA32F : gl.RGBA;\n    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);\n    // STEP.2 bind a frame buffer\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    // STEP.3 attach texture to framebuffer\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    // STEP.4 test whether framebuffer is complete\n    const isComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(frameBuffer);\n    return isComplete;\n  }\n\n  private checkRenderFloat32(): boolean {\n    if (this.version === 2) {\n      if (!this.colorBufferFloatExtension) {\n        return false;\n      }\n    } else {\n      if (!this.textureFloatExtension) {\n        return false;\n      }\n    }\n    return this.isFloatTextureAttachableToFrameBuffer;\n  }\n\n  private checkFloat32Download(): boolean {\n    if (this.version === 2) {\n      if (!this.colorBufferFloatExtension) {\n        return false;\n      }\n    } else {\n      if (!this.textureFloatExtension) {\n        return false;\n      }\n      if (!this.gl.getExtension('WEBGL_color_buffer_float')) {\n        return false;\n      }\n    }\n    return this.isFloatTextureAttachableToFrameBuffer;\n  }\n\n  /**\n   * Check whether GL_BLEND is supported\n   */\n  private checkFloat32Blend(): boolean {\n    // it looks like currently (2019-05-08) there is no easy way to detect whether BLEND is supported\n    // https://github.com/microsoft/onnxjs/issues/145\n\n    const gl = this.gl;\n\n    let texture: WebGLTexture|null|undefined;\n    let frameBuffer: WebGLFramebuffer|null|undefined;\n    let vertexShader: WebGLShader|null|undefined;\n    let fragmentShader: WebGLShader|null|undefined;\n    let program: WebGLProgram|null|undefined;\n\n    try {\n      texture = gl.createTexture();\n      frameBuffer = gl.createFramebuffer();\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      const internalFormat = this.version === 2 ? (gl as unknown as {RGBA32F: number}).RGBA32F : gl.RGBA;\n      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);\n\n      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n      gl.enable(gl.BLEND);\n\n      vertexShader = gl.createShader(gl.VERTEX_SHADER);\n      if (!vertexShader) {\n        return false;\n      }\n      gl.shaderSource(vertexShader, 'void main(){}');\n      gl.compileShader(vertexShader);\n\n      fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n      if (!fragmentShader) {\n        return false;\n      }\n      gl.shaderSource(fragmentShader, 'precision highp float;void main(){gl_FragColor=vec4(0.5);}');\n      gl.compileShader(fragmentShader);\n\n      program = gl.createProgram();\n      if (!program) {\n        return false;\n      }\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n      gl.useProgram(program);\n\n      gl.drawArrays(gl.POINTS, 0, 1);\n      return gl.getError() === gl.NO_ERROR;\n\n    } finally {\n      gl.disable(gl.BLEND);\n\n      if (program) {\n        gl.deleteProgram(program);\n      }\n      if (vertexShader) {\n        gl.deleteShader(vertexShader);\n      }\n      if (fragmentShader) {\n        gl.deleteShader(fragmentShader);\n      }\n      if (frameBuffer) {\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.deleteFramebuffer(frameBuffer);\n      }\n      if (texture) {\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        gl.deleteTexture(texture);\n      }\n    }\n  }\n\n  beginTimer(): WebGLQuery {\n    if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.disjointTimerQueryWebgl2Extension;\n\n      const query = gl2.createQuery() as WebGLQuery;\n      gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);\n      return query;\n    } else {\n      // TODO: add webgl 1 handling.\n      throw new Error('WebGL1 profiling currently not supported.');\n    }\n  }\n\n  endTimer() {\n    if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.disjointTimerQueryWebgl2Extension;\n      gl2.endQuery(ext.TIME_ELAPSED_EXT);\n      return;\n    } else {\n      // TODO: add webgl 1 handling.\n      throw new Error('WebGL1 profiling currently not supported');\n    }\n  }\n\n  isTimerResultAvailable(query: WebGLQuery): boolean {\n    let available = false, disjoint = false;\n    if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.disjointTimerQueryWebgl2Extension;\n\n      available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n      disjoint = gl2.getParameter(ext.GPU_DISJOINT_EXT);\n    } else {\n      // TODO: add webgl 1 handling.\n      throw new Error('WebGL1 profiling currently not supported');\n    }\n\n    return available && !disjoint;\n  }\n\n  getTimerResult(query: WebGLQuery): number {\n    let timeElapsed = 0;\n    if (this.version === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      timeElapsed = gl2.getQueryParameter(query, gl2.QUERY_RESULT);\n      gl2.deleteQuery(query);\n    } else {\n      // TODO: add webgl 1 handling.\n      throw new Error('WebGL1 profiling currently not supported');\n    }\n    // return miliseconds\n    return timeElapsed / 1000000;\n  }\n\n  async waitForQueryAndGetTime(query: WebGLQuery): Promise<number> {\n    await repeatedTry(() => this.isTimerResultAvailable(query));\n    return this.getTimerResult(query);\n  }\n\n  public async createAndWaitForFence(): Promise<void> {\n    const fenceContext = this.createFence(this.gl);\n    return this.pollFence(fenceContext);\n  }\n\n  private createFence(gl: WebGLRenderingContext): FenceContext {\n    let isFencePassed: () => boolean;\n    const gl2 = gl as WebGL2RenderingContext;\n    const query = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);\n    gl.flush();\n    if (query === null) {\n      isFencePassed = () => true;\n    } else {\n      isFencePassed = () => {\n        const status = gl2.clientWaitSync(query, 0, 0);\n        return status === gl2.ALREADY_SIGNALED || status === gl2.CONDITION_SATISFIED;\n      };\n    }\n    return {query, isFencePassed};\n  }\n\n  async pollFence(fenceContext: FenceContext) {\n    return new Promise<void>(resolve => {\n      void this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());\n    });\n  }\n\n  private itemsToPoll: PollItem[] = [];\n\n  pollItems(): void {\n    // Find the last query that has finished.\n    const index = linearSearchLastTrue(this.itemsToPoll.map(x => x.isDoneFn));\n    for (let i = 0; i <= index; ++i) {\n      const {resolveFn} = this.itemsToPoll[i];\n      resolveFn();\n    }\n    this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n  }\n\n  private async addItemToPoll(isDoneFn: () => boolean, resolveFn: () => void) {\n    this.itemsToPoll.push({isDoneFn, resolveFn});\n    if (this.itemsToPoll.length > 1) {\n      // We already have a running loop that polls.\n      return;\n    }\n    // Start a new loop that polls.\n    await repeatedTry(() => {\n      this.pollItems();\n      // End the loop if no more items to poll.\n      return this.itemsToPoll.length === 0;\n    });\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {SessionHandler} from './backend';\nimport {Graph} from './graph';\nimport {Logger, Profiler} from './instrument';\nimport {Operator} from './operators';\nimport {Tensor} from './tensor';\n\nclass KernelOp {\n  constructor(public op: Operator, public node: Graph.Node) {}\n}\n\nexport class ExecutionPlan {\n  constructor(private graph: Graph, ops: Operator[], private profiler: Readonly<Profiler>) {\n    this.initialize(ops);\n  }\n\n  initialize(ops: Operator[]) {\n    this.profiler.event('session', 'ExecutionPlan.initialize', () => {\n      const graphNodes = this.graph.getNodes();\n      if (graphNodes.length !== ops.length) {\n        throw new Error('The size of nodes and OPs do not match.');\n      }\n\n      this._ops = ops.map((op, i) => new KernelOp(op, graphNodes[i]));\n      this.reset();\n\n      // look for starter node(s)\n      this._starter = [];\n      this._ops.forEach((op, i) => {\n        let resolved = true;\n        for (const input of op.node.inputs) {\n          if (\n              !this._values[input]                                   // not an initialized input\n              && this.graph.getInputIndices().indexOf(input) === -1  // not model input\n          ) {\n            resolved = false;\n            break;\n          }\n        }\n        if (resolved) {\n          this._starter.push(i);\n        }\n      });\n    });\n  }\n\n  reset() {\n    this._values = this.graph.getValues().map(i => i.tensor);\n  }\n\n  async execute(sessionHandler: SessionHandler, modelInputs: Tensor[]): Promise<Tensor[]> {\n    return this.profiler.event('session', 'ExecutionPlan.execute', async () => {\n      // reset mediem result\n      this.reset();\n\n      // create inference handler\n      const inferenceHandler = sessionHandler.createInferenceHandler();\n\n      // populate inputs value\n      const graphInputs = this.graph.getInputIndices();\n      if (modelInputs.length !== graphInputs.length) {\n        throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${\n            modelInputs.length} expected: ${graphInputs.length}`);\n      }\n\n      modelInputs.forEach((input, i) => {\n        const index = graphInputs[i];\n        this._values[index] = input;\n      });\n\n      // prepare running sequence\n      const sequence: number[] = this._starter.slice(0);\n\n      // execution iterations\n      const graphValues = this.graph.getValues();\n      const graphNodes = this.graph.getNodes();\n\n      let rear = 0;\n      while (rear < sequence.length) {\n        const thisOpIndex = sequence[rear++];\n        const thisOp = this._ops[thisOpIndex];\n\n        // check input\n        const inputList = thisOp.node.inputs.map(i => this._values[i]);\n        if (inputList.indexOf(undefined) !== -1) {\n          throw new Error(`unresolved input detected: op: ${thisOp.node}`);\n        }\n\n        // run\n        const inputTensors = inputList as Tensor[];\n        Logger.verbose(\n            'ExecPlan',\n            `Runing op:${thisOp.node.name} (${\n                inputTensors.map((t, i) => `'${thisOp.node.inputs[i]}': ${t.type}[${t.dims.join(',')}]`).join(', ')})`);\n\n        const outputList = await this.profiler.event(\n            'node', thisOp.node.name, async () => thisOp.op.impl(inferenceHandler, inputTensors, thisOp.op.context));\n\n        // check output\n        if (outputList.length !== thisOp.node.outputs.length) {\n          throw new Error('the size of output does not match model definition.');\n        }\n\n        // fill value\n        outputList.forEach((output, i) => {\n          const j = thisOp.node.outputs[i];\n          if (this._values[j]) {\n            throw new Error(`output [${j}] already has value: op:${thisOp.node.name}`);\n          }\n          this._values[j] = output;\n        });\n\n        // resolve downstream nodes\n        const downstreamNodes = new Set<number>();\n        outputList.forEach((output, i) => {\n          const j = thisOp.node.outputs[i];\n          for (const currentDownstreamNodeIndex of graphValues[j].to) {\n            const currentDownstreamNode = graphNodes[currentDownstreamNodeIndex];\n            let resolved = true;\n            for (const k of currentDownstreamNode.inputs) {\n              if (!this._values[k]) {\n                resolved = false;\n                break;\n              }\n            }\n            if (resolved) {\n              downstreamNodes.add(currentDownstreamNodeIndex);\n            }\n          }\n        });\n        sequence.push(...downstreamNodes);\n      }\n\n      const output: Tensor[] = [];\n      for (let i = 0; i < this.graph.getOutputIndices().length; i++) {\n        const outputIndex = this.graph.getOutputIndices()[i];\n        const outputTensor = this._values[outputIndex];\n        if (outputTensor === undefined) {\n          throw new Error(`required output [${outputIndex}] does not have value`);\n        }\n        if (outputIndex === 0) {\n          await outputTensor.getData();\n        } else {\n          // eslint-disable-next-line no-unused-expressions\n          outputTensor.data;\n        }\n        output.push(outputTensor);\n      }\n      Logger.verbose('ExecPlan', 'disposing of inferenceHandler');\n      inferenceHandler.dispose();\n      return output;\n    });\n  }\n\n  _values: Array<Tensor|undefined>;\n  _ops: KernelOp[];\n  _starter: number[];\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Attribute} from './attribute';\nimport {onnxruntime} from './ort-schema/flatbuffers/ort-generated';\nimport {onnx} from './ort-schema/protobuf/onnx';\nimport {Tensor} from './tensor';\nimport {LongUtil, MAX_CLIP, MIN_CLIP, ProtoUtil} from './util';\n\nimport ortFbs = onnxruntime.experimental.fbs;\n\nexport declare namespace Graph {\n  export interface Shape {\n    readonly dims: readonly number[];\n  }\n  export interface ValueType {\n    readonly tensorType: Tensor.DataType;\n    readonly shape: Shape;\n  }\n  export interface Value {\n    // the tensor data. empty for non-initialized inputs\n    readonly tensor?: Tensor;\n\n    // index to the Node where the value comes from. -1 for initializer.\n    readonly from: number;\n\n    // indices to the Nodes where the values go to.\n    readonly to: readonly number[];\n\n    // value type specification. empty for non-input values.\n    readonly type?: ValueType;\n  }\n  export interface Node {\n    // name of the node\n    readonly name: string;\n\n    // the operator type\n    readonly opType: string;\n\n    // indices to the Values where the inputs come from.\n    readonly inputs: readonly number[];\n\n    // indices to the Values where the outpus go to.\n    readonly outputs: readonly number[];\n\n    // the attributes that used by the operator\n    readonly attributes: Attribute;\n  }\n\n  /**\n   * a Transformer is an instance that allows all possible transformation operations that applied to a graph\n   */\n  export interface Transformer {\n    removeAllIdentityNodes(): void;\n    removeAllDropoutNodes(): void;\n    fuseConvActivationNodes(): void;\n    // TODO: add generic functions to manipulate the graph\n  }\n\n  // an initializer can use transformer to transform the graph\n  export interface Initializer {\n    transformGraph(transformer: Transformer): void;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport interface Graph {\n  getInputIndices(): readonly number[];\n  getInputNames(): readonly string[];\n  getOutputIndices(): readonly number[];\n  getOutputNames(): readonly string[];\n  getValues(): readonly Graph.Value[];\n  getNodes(): readonly Graph.Node[];\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-redeclare\nexport const Graph = {\n  /**\n   * construct a graph from a graph protobuf type\n   */\n  from: (graphProto: onnx.IGraphProto|ortFbs.Graph, initializer?: Graph.Initializer) =>\n      new GraphImpl(graphProto, initializer),\n};\n\nclass Value implements Graph.Value {\n  constructor(valueInfo?: onnx.IValueInfoProto) {\n    this._from = undefined;\n    this._to = [];\n    this.tensor = undefined;\n    this.type = undefined;\n\n    if (valueInfo) {\n      this.type = ProtoUtil.tensorValueTypeFromProto(valueInfo.type!.tensorType!);\n    }\n  }\n\n  _from?: number;  // -1 represent from initializer\n  get from() {\n    return this._from!;\n  }\n  _to: number[];\n  get to() {\n    return this._to;\n  }\n  type?: Graph.ValueType;\n  tensor?: Tensor;\n}\n\nclass Node implements Graph.Node {\n  constructor(_nodeProto: onnx.INodeProto|ortFbs.Node, name?: string) {\n    if (_nodeProto instanceof onnx.NodeProto) {\n      this.name = _nodeProto.name;\n      this.opType = _nodeProto.opType;\n      this.attributes = new Attribute(_nodeProto.attribute);\n    } else if (_nodeProto instanceof ortFbs.Node) {\n      this.name = name ?? _nodeProto.name()!;\n      this.opType = _nodeProto.opType()!;\n      this.attributes = new Attribute(ProtoUtil.tensorAttributesFromORTFormat(_nodeProto));\n    }\n\n    this.inputs = [];\n    this.outputs = [];\n    this.executeNode = true;\n  }\n\n  name: string;\n  opType: string;\n  inputs: number[];\n  outputs: number[];\n  attributes: Attribute;\n  executeNode: boolean;\n}\n\nclass GraphImpl implements Graph, Graph.Transformer {\n  private _allData: Value[];\n\n  private _allInputIndices: number[];\n  private _allInputNames: string[];\n\n  private _allOutputIndices: number[];\n  private _allOutputNames: string[];\n\n  private _nodes: Node[];\n\n  constructor(graph: onnx.IGraphProto|ortFbs.Graph, graphInitializer?: Graph.Initializer) {\n    if (!graph) {\n      throw new TypeError('graph is empty');\n    }\n\n    // build the graph - will throw exceptions if something fatal is detected\n    this.buildGraph(graph);\n\n    // execute any transformation logic for the graph (if applicable)\n    this.transformGraph(graphInitializer);\n\n    // check for cycles and other inconsistencies - will throw exceptions if something fatal is detected\n    this.checkIsAcyclic();\n  }\n\n  getInputIndices(): readonly number[] {\n    return this._allInputIndices;\n  }\n\n  getInputNames(): readonly string[] {\n    return this._allInputNames;\n  }\n\n  getOutputIndices(): readonly number[] {\n    return this._allOutputIndices;\n  }\n\n  getOutputNames(): readonly string[] {\n    return this._allOutputNames;\n  }\n\n  getValues(): readonly Graph.Value[] {\n    return this._allData;\n  }\n\n  getNodes(): readonly Graph.Node[] {\n    return this._nodes;\n  }\n\n  private buildGraph(graph: onnx.IGraphProto|ortFbs.Graph) {\n    // build the graph - will throw exceptions if something fatal is detected\n    if (graph instanceof onnx.GraphProto) {\n      this.buildGraphFromOnnxFormat(graph);\n    } else if (graph instanceof ortFbs.Graph) {\n      this.buildGraphFromOrtFormat(graph);\n    } else {\n      throw new TypeError('Graph type is not supported.');\n    }\n  }\n  private buildGraphFromOnnxFormat(graph: onnx.IGraphProto) {\n    const dataIndices = new Map<string, number>();\n    this._allData = [];\n\n    this._allInputIndices = [];\n    this._allInputNames = [];\n\n    this._allOutputIndices = [];\n    this._allOutputNames = [];\n\n    this._nodes = [];\n\n    const nodesIndices = new Map<string, number>();\n\n    // scan all inputs\n    if (!graph.input) {\n      throw new Error('missing information in graph: input');\n    }\n    const inputValueNames = [];\n    for (const i of graph.input) {\n      if (dataIndices.has(i.name!)) {\n        throw new Error(`duplicated input name: ${i.name}`);\n      }\n      const currentIndex = this._allData.push(new Value(i)) - 1;\n      dataIndices.set(i.name!, currentIndex);\n      inputValueNames.push(i.name!);\n    }\n\n    // scan all initializers\n    if (!graph.initializer) {\n      throw new Error('missing information in graph: initializer');\n    }\n    for (const i of graph.initializer) {\n      let index = dataIndices.get(i.name!);\n      if (index === undefined) {\n        const value = new Value();\n        value.type = {\n          shape: {dims: ProtoUtil.tensorDimsFromProto(i.dims!)},\n          tensorType: ProtoUtil.tensorDataTypeFromProto(i.dataType!)\n        };\n        index = this._allData.push(value) - 1;\n        dataIndices.set(i.name!, index);\n      }\n      this._allData[index]._from = -1;\n      this._allData[index].tensor = Tensor.fromProto(i);\n    }\n\n    // filter out input indices\n    for (let i = 0; i < this._allData.length; i++) {\n      if (!this._allData[i].tensor) {\n        this._allInputIndices.push(i);\n        this._allInputNames.push(inputValueNames[i]);\n      }\n    }\n\n    // scan all outputs\n    if (!graph.output) {\n      throw new Error('missing information in graph: output');\n    }\n    for (const i of graph.output) {\n      if (dataIndices.has(i.name!)) {\n        throw new Error(`duplicated output name: ${i.name}`);\n      }\n      const currentIndex = this._allData.push(new Value(i)) - 1;\n      dataIndices.set(i.name!, currentIndex);\n      this._allOutputIndices.push(currentIndex);\n      this._allOutputNames.push(i.name!);\n    }\n\n    // scan all nodes\n    if (!graph.node) {\n      throw new Error('missing information in graph: node');\n    }\n    for (const nodeProto of graph.node) {\n      if (!nodeProto.name) {\n        // assign a name to the node if it doesn't have one\n        for (let pick = 0;; pick++) {\n          const name = `unnamed_${nodeProto.opType}_${pick}`;\n          if (!nodesIndices.has(name)) {\n            nodeProto.name = name;\n            break;\n          }\n        }\n      }\n\n      if (nodesIndices.has(nodeProto.name)) {\n        throw new Error(`duplicated node name: ${nodeProto.name}`);\n      }\n      const currentIndex = this._nodes.push(new Node(nodeProto)) - 1;\n      nodesIndices.set(nodeProto.name, currentIndex);\n    }\n\n    // scan node's outputs\n    for (let i = 0; i < this._nodes.length; i++) {\n      const node = this._nodes[i];\n      const nodeProto = graph.node[i];\n      if (!nodeProto.output) {\n        throw new Error(`missing output for node: ${nodeProto.name}`);\n      }\n      for (const output of nodeProto.output) {\n        let dataIndex = dataIndices.get(output);\n        if (typeof dataIndex === 'undefined') {\n          dataIndex = this._allData.push(new Value()) - 1;\n          dataIndices.set(output, dataIndex);\n        }\n        node.outputs.push(dataIndex);\n\n        if (this._allData[dataIndex]._from !== undefined) {\n          throw new Error(`multiple nodes output to one data value: ${dataIndex}`);\n        }\n        this._allData[dataIndex]._from = i;\n\n        // for the 'Constant' operator, just create a new edge in the graph corresponding to the 'output' of the\n        // operator and ignore the node from the graph\n        if (nodeProto.opType === 'Constant') {\n          if (!nodeProto.attribute || nodeProto.attribute.length !== 1 || !nodeProto.attribute[0].t) {\n            throw new Error('missing attributes or missing tensor value in attributes for this Constant operator');\n          }\n          if (!nodeProto.output || nodeProto.output.length !== 1) {\n            throw new Error('missing output or incorrect number of outputs for this Constant operator');\n          }\n          node.outputs.pop();\n          node.executeNode = false;\n\n          this._allData[dataIndex]._from = -1;\n          this._allData[dataIndex].tensor = Tensor.fromProto(nodeProto.attribute[0].t);\n        }\n      }\n    }\n\n    // scan node's inputs\n    for (let i = 0; i < this._nodes.length; i++) {\n      const node = this._nodes[i];\n      const nodeProto = graph.node[i];\n\n      if (!nodeProto.input) {\n        throw new Error(`missing input for node: ${nodeProto.name}`);\n      }\n      for (const input of nodeProto.input) {\n        const dataIndex = dataIndices.get(input);\n        if (typeof dataIndex === 'undefined') {\n          // handle exception when opset > 9 and roi / scales not given\n          if (input === '' && (nodeProto.input.length === 3 || nodeProto.input.length === 4) &&\n              nodeProto.opType === 'Resize') {\n            continue;\n          }\n          throw new Error(`unrecognized input '${input}' for node: ${nodeProto.name}`);\n        }\n        node.inputs.push(dataIndex);\n\n        this._allData[dataIndex]._to.push(i);\n      }\n    }\n\n    return true;\n  }\n\n  private buildGraphFromOrtFormat(graph: ortFbs.Graph) {\n    const dataIndices = new Map<string, number>();\n    this._allData = [];\n\n    this._allInputIndices = [];\n    this._allInputNames = [];\n\n    this._allOutputIndices = [];\n    this._allOutputNames = [];\n\n    this._nodes = [];\n\n    const nodesIndices = new Map<string, number>();\n\n    // scan all inputs\n    const inputValueNames = [];\n    for (let i = 0; i < graph.inputsLength(); i++) {\n      const inputName = graph.inputs(i);\n      if (dataIndices.has(inputName)) {\n        throw new Error(`duplicated input name: ${inputName}`);\n      }\n      // Find the input typeInfo from nodeargs\n      for (let j = 0; j < graph.nodeArgsLength(); j++) {\n        if (graph.nodeArgs(j)?.name() === inputName) {\n          const value = new Value();\n          const valueType = graph.nodeArgs(j)?.type()?.valueType();\n          if (valueType !== ortFbs.TypeInfoValue.tensor_type) {\n            throw new Error('Unexpected value type for the nodeArg.');\n          }\n          const valueInfo = graph.nodeArgs(j)!.type()!.value(new ortFbs.TensorTypeAndShape())!;\n          const type = ProtoUtil.tensorDataTypeFromProto(valueInfo.elemType());\n          const shape = valueInfo.shape()!;\n          const dims = [];\n          for (let k = 0; k < shape.dimLength()!; k++) {\n            dims.push(LongUtil.longToNumber(shape.dim(k)!.value()!.dimValue()!));\n          }\n          value.type = {shape: {dims}, tensorType: type};\n          const currentIndex = this._allData.push(value) - 1;\n          dataIndices.set(inputName, currentIndex);\n          inputValueNames.push(inputName);\n        }\n      }\n    }\n    // check initializers\n    for (let i = 0; i < graph.initializersLength(); i++) {\n      const initializer = graph.initializers(i)!;\n      let index = dataIndices.get(initializer.name()!);\n      if (index === undefined) {\n        const value = new Value();\n        const dims = ProtoUtil.tensorDimsFromORTFormat(initializer);\n        const type = ProtoUtil.tensorDataTypeFromProto(initializer.dataType());\n        value.type = {shape: {dims}, tensorType: type};\n        index = this._allData.push(value) - 1;\n        dataIndices.set(initializer.name()!, index);\n      }\n      this._allData[index]._from = -1;\n      this._allData[index].tensor = Tensor.fromOrtTensor(initializer);\n    }\n\n    // filter out input indices\n    for (let i = 0; i < this._allData.length; i++) {\n      if (!this._allData[i].tensor) {\n        this._allInputIndices.push(i);\n        this._allInputNames.push(inputValueNames[i]);\n      }\n    }\n\n    // scan all outputs\n    for (let i = 0; i < graph.outputsLength(); i++) {\n      const outputName = graph.outputs(i);\n      if (dataIndices.has(outputName)) {\n        throw new Error(`duplicated output name: ${outputName}`);\n      }\n      const currentIndex = this._allData.push(new Value()) - 1;\n      dataIndices.set(outputName, currentIndex);\n      this._allOutputIndices.push(currentIndex);\n      this._allOutputNames.push(outputName);\n    }\n\n    // scan all nodes\n    if (!graph.nodes) {\n      throw new Error('missing information in graph: node');\n    }\n    for (let i = 0; i < graph.nodesLength(); i++) {\n      const nodeProto = graph.nodes(i);\n      let name = nodeProto!.name();\n      if (!name) {\n        // assign a name to the node if it doesn't have one\n        for (let pick = 0;; pick++) {\n          name = `unnamed_${nodeProto!.opType()}_${pick}`;\n          if (!nodesIndices.has(name)) {\n            // an unique name is found. break.\n            break;\n          }\n        }\n      }\n\n      if (nodesIndices.has(name)) {\n        throw new Error(`duplicated node name: ${name}`);\n      }\n      const currentIndex = this._nodes.push(new Node(nodeProto!, name)) - 1;\n      nodesIndices.set(name, currentIndex);\n    }\n\n    // scan node's outputs\n    for (let i = 0; i < this._nodes.length; i++) {\n      const node = this._nodes[i];\n      const nodeProto = graph.nodes(i);\n      if (nodeProto == null) {\n        throw new Error(`No node exists at index ${i}`);\n      }\n      if (nodeProto?.outputsLength() === 0) {\n        throw new Error(`missing output for node: ${nodeProto.name}`);\n      }\n      for (let j = 0; j < nodeProto?.outputsLength(); j++) {\n        const output = nodeProto?.outputs(j);\n        let dataIndex = dataIndices.get(output);\n        if (typeof dataIndex === 'undefined') {\n          dataIndex = this._allData.push(new Value()) - 1;\n          dataIndices.set(output, dataIndex);\n        }\n        node.outputs.push(dataIndex);\n\n        if (this._allData[dataIndex]._from !== undefined) {\n          throw new Error(`multiple nodes output to one data value: ${dataIndex}`);\n        }\n        this._allData[dataIndex]._from = i;\n\n        // for the 'Constant' operator, just create a new edge in the graph corresponding to the 'output' of the\n        // operator and ignore the node from the graph\n        if (nodeProto.opType() === 'Constant') {\n          if (nodeProto.attributesLength() !== 1 || !nodeProto.attributes(0)!.t()) {\n            throw new Error('missing attributes or missing tensor value in attributes for this Constant operator');\n          }\n          if (nodeProto.outputsLength() !== 1) {\n            throw new Error('missing output or incorrect number of outputs for this Constant operator');\n          }\n          node.outputs.pop();\n          node.executeNode = false;\n\n          this._allData[dataIndex]._from = -1;\n          this._allData[dataIndex].tensor = Tensor.fromOrtTensor(nodeProto.attributes(0)!.t()!);\n        }\n      }\n    }\n\n    // scan node's inputs\n    for (let i = 0; i < this._nodes.length; i++) {\n      const node = this._nodes[i];\n      const nodeProto = graph.nodes(i)!;\n\n      if (nodeProto.inputsLength() === 0) {\n        throw new Error(`missing input for node: ${nodeProto.name}`);\n      }\n      for (let j = 0; j < nodeProto.inputsLength()!; j++) {\n        const input = nodeProto.inputs(j)!;\n        const dataIndex = dataIndices.get(input);\n        if (typeof dataIndex === 'undefined') {\n          throw new Error(`unrecognized input '${input}' for node: ${nodeProto!.name()}`);\n        }\n        node.inputs.push(dataIndex);\n\n        this._allData[dataIndex]._to.push(i);\n      }\n    }\n  }\n\n  private checkIsAcyclic() {\n    // go through the graph and check for cycles or other fatal inconsistencies\n    const starters: Set<number> = new Set<number>();\n    this._allInputIndices.forEach(i => {\n      const data = this._allData[i];\n      data._to.forEach(j => {\n        starters.add(j);\n      });\n    });\n\n    // Iterative DFS to check for cycles\n    const nodesStack = Array.from(starters);\n    const nodesState = new Array<string>(this._nodes.length).fill('white');\n\n    while (nodesStack.length > 0) {\n      const nodeIndex = nodesStack.pop()!;\n      // this node has now been processed completely. Mark this node 'black' to denote this.\n      if (nodesState[nodeIndex] === 'gray') {\n        nodesState[nodeIndex] = 'black';\n      } else {\n        // this node is under processing stage. mark this node 'gray' to denote this.\n        nodesStack.push(nodeIndex);\n        nodesState[nodeIndex] = 'gray';\n\n        this._nodes[nodeIndex].outputs.forEach((outgoingEdgeIndex) => {\n          const data = this._allData[outgoingEdgeIndex];\n          if (typeof data.tensor !== 'undefined') {\n            throw new Error('node outputs should not be initialized');\n          }\n          if (data._from !== nodeIndex) {\n            throw new Error('from property of the Value object doesn\\'t match index of Node being processed');\n          }\n          data._to.forEach((downstreamNodeIndex) => {\n            // back edge found - cyclic\n            if (nodesState[downstreamNodeIndex] === 'gray') {\n              throw new Error('model graph is cyclic');\n            }\n            // tree edge found - continue processing by adding it to stack\n            else if (nodesState[downstreamNodeIndex] === 'white') {\n              nodesStack.push(downstreamNodeIndex);\n            }\n          });\n        });\n      }\n    }\n  }\n\n  private transformGraph(graphInitializer?: Graph.Initializer): void {\n    // apply common transform\n    this.removeAllIdentityNodes();\n    this.removeAllDropoutNodes();\n    this.fuseConvActivationNodes();\n    // apply initializer specific transform\n    if (graphInitializer) {\n      graphInitializer.transformGraph(this);\n    }\n\n    // finalize graph\n    this.finalizeGraph();\n  }\n\n  /**\n   * finalize the graph.\n   *\n   * this function should be called after all the transformation completed.\n   * this function removes all unnecessary nodes and values from the graph\n   */\n  finalizeGraph() {\n    let offset = 0;\n    // delete all nodes that are not being executed\n    // The graph is represented using these two arrays\n    // this._nodes - Array holding the kernels to execute - each entry is a kernel pointing to this._allData\n    // this._allData - hold 2 fields - to [] & from - these feileds hold the graph map for inputs and outputs per node\n    // newIndices - remapping the graph after reading the flag 'executeNode'\n    const newIndices = new Array<number>(this._nodes.length, 0);\n    let nodePossition = 0;\n\n    for (let i = 0; i < this._nodes.length; i++) {\n      // giving new indexes to the nodes based on execution flag\n      newIndices[i] = nodePossition;\n      if (this._nodes[i].executeNode) {\n        if (nodePossition !== i) {\n          this._nodes[nodePossition] = this._nodes[i];\n        }\n        nodePossition++;\n\n      } else {\n        // delete all output values\n        this._nodes[i].outputs.forEach(ind => {\n          this._allData[ind]._from = -2;\n        });\n      }\n    }\n\n    // removing the unused nodes\n    this._nodes.splice(nodePossition, this._nodes.length - nodePossition);\n\n    // Updating this._allData according to the new this._nodes\n    for (let i = 0; i < this._allData.length; i++) {\n      const currentData = this._allData[i];\n      if (currentData._from !== undefined && currentData._from !== -1 && currentData._from !== -2) {\n        currentData._from = newIndices[currentData._from];\n      }\n\n      for (let j = 0; j < currentData._to.length; j++) {\n        if (currentData._to[j] >= 0) {\n          currentData._to[j] = newIndices[currentData._to[j]];\n        } else {\n          throw new Error('Trying to update a removed node');\n        }\n      }\n    }\n\n    offset = 0;\n    // delete all values that are not being referenced\n    for (let i = 0; i < this._allData.length; i++) {\n      // if current value is neither linked to next node, nor an output value, remove it.\n      if (this._allData[i].from === -2 && this._allOutputIndices.indexOf(i + offset) === -1) {\n        offset++;\n        this._allData.splice(i, 1);\n        i--;\n        continue;\n      }\n      if (offset > 0) {\n        let ind = -1;\n        // if current value is neither an input value nor an initializer, find the node it's\n        // coming from and update the corresponding node output\n        if (this._allData[i].from !== undefined && this._allData[i].from !== -1) {\n          ind = this._nodes[this._allData[i].from].outputs.indexOf(i + offset);\n          if (ind !== -1) {\n            this._nodes[this._allData[i].from].outputs[ind] = i;\n          }\n        } else {\n          // if current value is an input value, update its reference in inputIndices\n          ind = this._allInputIndices.indexOf(i + offset);\n          if (ind !== -1) {\n            this._allInputIndices[ind] = i;\n          }\n        }\n\n        // find the node that the current value is linking to and update its input reference\n        this._allData[i].to.forEach(node => {\n          ind = this._nodes[node].inputs.indexOf(i + offset);\n          if (ind !== -1) {\n            this._nodes[node].inputs[ind] = i;\n          }\n        });\n        if (this._allData[i].to.length === 0) {\n          // if current value is a graph output, update its reference in outputIndices\n          ind = this._allOutputIndices.indexOf(i + offset);\n          if (ind !== -1) {\n            this._allOutputIndices[ind] = i;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Delete the specifed node. Assume the node has one incoming input and the first output connected to other nodes.\n   * An input validation must be done before calling this function.\n   * @param nodeIndex The index of node to be deleted\n   */\n  private deleteNode(nodeIndex: number) {\n    const node = this._nodes[nodeIndex];\n    if (node.outputs.length > 1) {\n      for (let i = 1; i < node.outputs.length; i++) {\n        if (this._allData[node.outputs[i]].to.length > 0) {\n          throw new Error('Node deletion with more than one output connected to other nodes is not supported. ');\n        }\n      }\n    }\n\n    // this node wil not be executed\n    node.executeNode = false;\n    const inputValueIndex = node.inputs[0];\n    const outputValueIndex = node.outputs[0];\n    const nodesConsumingOutput = this._allData[outputValueIndex].to;\n\n    // remove this node from the to property of the input Value\n    for (let i = 0; i < node.inputs.length; i++) {\n      const delIndex = this._allData[node.inputs[i]].to.indexOf(nodeIndex);\n      // should not happen\n      if (delIndex === -1) {\n        throw new Error('The Value object doesn\\'t have the current Node in it\\'s \\'to\\' property ');\n      }\n      this._allData[node.inputs[i]].to.splice(delIndex, 1);\n    }\n\n    // clear node indices consuming this output Value\n    this._allData[outputValueIndex]._to = [];\n\n    // if the output of this node is a graph output, adjust the index appropriately\n    const index = this._allOutputIndices.indexOf(outputValueIndex);\n    if (index !== -1) {\n      this._allOutputIndices[index] = inputValueIndex;\n    }\n\n    // override the inputs for nodes consuming this node's output with the input to this node\n    if (nodesConsumingOutput && nodesConsumingOutput.length > 0) {\n      for (const nodeIndex of nodesConsumingOutput) {\n        const replaceIndex = this._nodes[nodeIndex].inputs.indexOf(outputValueIndex);\n        // should not happen\n        if (replaceIndex === -1) {\n          throw new Error('The Node object doesn\\'t have the output Value in it\\'s \\'inputs\\' property ');\n        }\n        this._nodes[nodeIndex].inputs[replaceIndex] = inputValueIndex;\n        this._allData[inputValueIndex].to.push(nodeIndex);\n      }\n    }\n  }\n\n  removeAllDropoutNodes() {\n    let nodeIndex = 0;\n    for (const node of this._nodes) {\n      // weed out 'Dropout' nodes so that no time is wasted in execution\n      if (node.opType === 'Dropout') {\n        // the node should have exactly 1 input and 1 or 2 outputs\n        if (node.inputs.length !== 1) {\n          throw new Error('Dropout nodes should only contain one input. ');\n        }\n        if (node.outputs.length !== 1 && node.outputs.length !== 2) {\n          throw new Error('Dropout nodes should contain either 1 or 2 output(s)');\n        }\n        // the second output should not be referenced by any other node\n        if (node.outputs.length === 2 && this._allData[node.outputs[1]]._to.length !== 0) {\n          throw new Error('Dropout nodes\\'s second output should not be referenced by other nodes');\n        }\n        this.deleteNode(nodeIndex);\n      }\n      nodeIndex++;\n    }\n  }\n\n  removeAllIdentityNodes() {\n    let nodeIndex = 0;\n    for (const node of this._nodes) {\n      // weed out 'Identity' nodes so that no time is wasted in execution\n      if (node.opType === 'Identity') {\n        this.deleteNode(nodeIndex);\n      }\n      nodeIndex++;\n    }\n  }\n\n  isActivation(n: Node): boolean {\n    switch (n.opType) {\n      // TODO: add other activation methods\n      case 'Relu':\n      case 'Sigmoid':\n      case 'Clip':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  fuseConvActivationNodes() {\n    for (const node of this._nodes) {\n      if (node.opType === 'Conv') {\n        const next = this._allData[node.outputs[0]]._to;\n        if (next.length === 1 && this.isActivation(this._nodes[next[0]])) {\n          const child = this._nodes[next[0]];\n          if (child.opType === 'Clip') {\n            if (child.inputs.length === 1) {\n              try {\n                node.attributes.set(\n                    'activation_params', 'floats',\n                    [child.attributes.getFloat('min'), child.attributes.getFloat('max')]);\n              } catch (e) {\n                node.attributes.set('activation_params', 'floats', [MIN_CLIP, MAX_CLIP]);\n              }\n            } else if (\n                child.inputs.length >= 3 && this._allData[child.inputs[1]].tensor !== undefined &&\n                this._allData[child.inputs[2]].tensor !== undefined) {\n              node.attributes.set('activation_params', 'floats', [\n                this._allData[child.inputs[1]].tensor!.floatData[0], this._allData[child.inputs[2]].tensor!.floatData[0]\n              ]);\n            } else {\n              // Skip fusion with clip node since clip min and clip max are not coming from initializer\n              continue;\n            }\n          }\n          node.attributes.set('activation', 'string', (child.opType));\n          this.deleteNode(next[0]);\n        }\n      }\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Env} from 'onnxruntime-common';\n\nimport {WebGLContext} from './backends/webgl/webgl-context';\n\nexport declare namespace Logger {\n  export interface SeverityTypeMap {\n    verbose: 'v';\n    info: 'i';\n    warning: 'w';\n    error: 'e';\n    fatal: 'f';\n  }\n\n  export type Severity = keyof SeverityTypeMap;\n\n  export type Provider = 'none'|'console';\n\n  /**\n   * Logging config that used to control the behavior of logger\n   */\n  export interface Config {\n    /**\n     * Specify the logging provider. 'console' by default\n     */\n    provider?: Provider;\n    /**\n     * Specify the minimal logger serverity. 'warning' by default\n     */\n    minimalSeverity?: Logger.Severity;\n    /**\n     * Whether to output date time in log. true by default\n     */\n    logDateTime?: boolean;\n    /**\n     * Whether to output source information (Not yet supported). false by default\n     */\n    logSourceLocation?: boolean;\n  }\n\n  export interface CategorizedLogger {\n    verbose(content: string): void;\n    info(content: string): void;\n    warning(content: string): void;\n    error(content: string): void;\n    fatal(content: string): void;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport interface Logger {\n  (category: string): Logger.CategorizedLogger;\n\n  verbose(content: string): void;\n  verbose(category: string, content: string): void;\n  info(content: string): void;\n  info(category: string, content: string): void;\n  warning(content: string): void;\n  warning(category: string, content: string): void;\n  error(content: string): void;\n  error(category: string, content: string): void;\n  fatal(content: string): void;\n  fatal(category: string, content: string): void;\n\n  /**\n   * Reset the logger configuration.\n   * @param config specify an optional default config\n   */\n  reset(config?: Logger.Config): void;\n  /**\n   * Set the logger's behavior on the given category\n   * @param category specify a category string. If '*' is specified, all previous configuration will be overwritten. If\n   * '' is specified, the default behavior will be updated.\n   * @param config the config object to indicate the logger's behavior\n   */\n  set(category: string, config: Logger.Config): void;\n\n  /**\n   * Set the logger's behavior from ort-common env\n   * @param env the env used to set logger. Currently only setting loglevel is supported through Env.\n   */\n  setWithEnv(env: Env): void;\n}\n\ninterface LoggerProvider {\n  log(severity: Logger.Severity, content: string, category?: string): void;\n}\nclass NoOpLoggerProvider implements LoggerProvider {\n  log(_severity: Logger.Severity, _content: string, _category?: string) {\n    // do nothing\n  }\n}\nclass ConsoleLoggerProvider implements LoggerProvider {\n  log(severity: Logger.Severity, content: string, category?: string) {\n    // eslint-disable-next-line no-console\n    console.log(`${this.color(severity)} ${category ? '\\x1b[35m' + category + '\\x1b[0m ' : ''}${content}`);\n  }\n\n  private color(severity: Logger.Severity) {\n    switch (severity) {\n      case 'verbose':\n        return '\\x1b[34;40mv\\x1b[0m';\n      case 'info':\n        return '\\x1b[32mi\\x1b[0m';\n      case 'warning':\n        return '\\x1b[30;43mw\\x1b[0m';\n      case 'error':\n        return '\\x1b[31;40me\\x1b[0m';\n      case 'fatal':\n        return '\\x1b[101mf\\x1b[0m';\n      default:\n        throw new Error(`unsupported severity: ${severity}`);\n    }\n  }\n}\n\nconst SEVERITY_VALUE = {\n  verbose: 1000,\n  info: 2000,\n  warning: 4000,\n  error: 5000,\n  fatal: 6000\n};\n\nconst LOGGER_PROVIDER_MAP: {readonly [provider: string]: Readonly<LoggerProvider>} = {\n  ['none']: new NoOpLoggerProvider(),\n  ['console']: new ConsoleLoggerProvider()\n};\nconst LOGGER_DEFAULT_CONFIG = {\n  provider: 'console',\n  minimalSeverity: 'warning',\n  logDateTime: true,\n  logSourceLocation: false\n};\nlet LOGGER_CONFIG_MAP:\n    {[category: string]: Readonly<Required<Logger.Config>>} = {['']: LOGGER_DEFAULT_CONFIG as Required<Logger.Config>};\n\nfunction log(category: string): Logger.CategorizedLogger;\nfunction log(severity: Logger.Severity, content: string): void;\nfunction log(severity: Logger.Severity, category: string, content: string): void;\nfunction log(severity: Logger.Severity, arg1: string, arg2?: string): void;\nfunction log(\n    arg0: string|Logger.Severity, arg1?: string, arg2?: string|number, arg3?: number): Logger.CategorizedLogger|void {\n  if (arg1 === undefined) {\n    // log(category: string): Logger.CategorizedLogger;\n    return createCategorizedLogger(arg0);\n  } else if (arg2 === undefined) {\n    // log(severity, content);\n    logInternal(arg0 as Logger.Severity, arg1, 1);\n  } else if (typeof arg2 === 'number' && arg3 === undefined) {\n    // log(severity, content, stack)\n    logInternal(arg0 as Logger.Severity, arg1, arg2);\n  } else if (typeof arg2 === 'string' && arg3 === undefined) {\n    // log(severity, category, content)\n    logInternal(arg0 as Logger.Severity, arg2, 1, arg1);\n  } else if (typeof arg2 === 'string' && typeof arg3 === 'number') {\n    // log(severity, category, content, stack)\n    logInternal(arg0 as Logger.Severity, arg2, arg3, arg1);\n  } else {\n    throw new TypeError('input is valid');\n  }\n}\n\nfunction createCategorizedLogger(category: string): Logger.CategorizedLogger {\n  return {\n    verbose: log.verbose.bind(null, category),\n    info: log.info.bind(null, category),\n    warning: log.warning.bind(null, category),\n    error: log.error.bind(null, category),\n    fatal: log.fatal.bind(null, category)\n  };\n}\n\n// NOTE: argument 'category' is put the last parameter beacause typescript\n// doesn't allow optional argument put in front of required argument. This\n// order is different from a usual logging API.\nfunction logInternal(severity: Logger.Severity, content: string, stack: number, category?: string) {\n  const config = LOGGER_CONFIG_MAP[category || ''] || LOGGER_CONFIG_MAP[''];\n  if (SEVERITY_VALUE[severity] < SEVERITY_VALUE[config.minimalSeverity]) {\n    return;\n  }\n\n  if (config.logDateTime) {\n    content = `${new Date().toISOString()}|${content}`;\n  }\n\n  if (config.logSourceLocation) {\n    // TODO: calculate source location from 'stack'\n  }\n\n  LOGGER_PROVIDER_MAP[config.provider].log(severity, content, category);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nnamespace log {\n  export function verbose(content: string): void;\n  export function verbose(category: string, content: string): void;\n  export function verbose(arg0: string, arg1?: string) {\n    log('verbose', arg0, arg1);\n  }\n  export function info(content: string): void;\n  export function info(category: string, content: string): void;\n  export function info(arg0: string, arg1?: string) {\n    log('info', arg0, arg1);\n  }\n  export function warning(content: string): void;\n  export function warning(category: string, content: string): void;\n  export function warning(arg0: string, arg1?: string) {\n    log('warning', arg0, arg1);\n  }\n  export function error(content: string): void;\n  export function error(category: string, content: string): void;\n  export function error(arg0: string, arg1?: string) {\n    log('error', arg0, arg1);\n  }\n  export function fatal(content: string): void;\n  export function fatal(category: string, content: string): void;\n  export function fatal(arg0: string, arg1?: string) {\n    log('fatal', arg0, arg1);\n  }\n\n  export function reset(config?: Logger.Config): void {\n    LOGGER_CONFIG_MAP = {};\n    set('', config || {});\n  }\n  export function set(category: string, config: Logger.Config): void {\n    if (category === '*') {\n      reset(config);\n    } else {\n      const previousConfig = LOGGER_CONFIG_MAP[category] || LOGGER_DEFAULT_CONFIG;\n      LOGGER_CONFIG_MAP[category] = {\n        provider: config.provider || previousConfig.provider,\n        minimalSeverity: config.minimalSeverity || previousConfig.minimalSeverity,\n        logDateTime: (config.logDateTime === undefined) ? previousConfig.logDateTime : config.logDateTime,\n        logSourceLocation: (config.logSourceLocation === undefined) ? previousConfig.logSourceLocation :\n                                                                      config.logSourceLocation\n      };\n    }\n\n    // TODO: we want to support wildcard or regex?\n  }\n\n  export function setWithEnv(env: Env): void {\n    const config: Logger.Config = {};\n    if (env.logLevel) {\n      config.minimalSeverity = env.logLevel as Logger.Severity;\n    }\n    set('', config);\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare, @typescript-eslint/naming-convention\nexport const Logger: Logger = log;\n\nexport declare namespace Profiler {\n  export interface Config {\n    maxNumberEvents?: number;\n    flushBatchSize?: number;\n    flushIntervalInMilliseconds?: number;\n  }\n\n  export type EventCategory = 'session'|'node'|'op'|'backend';\n\n  export interface Event {\n    end(): void|Promise<void>;\n  }\n}\n// TODO\n// class WebGLEvent implements Profiler.Event {}\n\nclass Event implements Profiler.Event {\n  constructor(\n      public category: Profiler.EventCategory, public name: string, public startTime: number,\n      private endCallback: (e: Event) => void|Promise<void>, public timer?: WebGLQuery, public ctx?: WebGLContext) {}\n\n  async end() {\n    return this.endCallback(this);\n  }\n\n  async checkTimer(): Promise<number> {\n    if (this.ctx === undefined || this.timer === undefined) {\n      throw new Error('No webgl timer found');\n    } else {\n      this.ctx.endTimer();\n      return this.ctx.waitForQueryAndGetTime(this.timer);\n    }\n  }\n}\n\nclass EventRecord {\n  constructor(\n      public category: Profiler.EventCategory, public name: string, public startTime: number, public endTime: number) {}\n}\n\nexport class Profiler {\n  static create(config?: Profiler.Config): Profiler {\n    if (config === undefined) {\n      return new this();\n    }\n    return new this(config.maxNumberEvents, config.flushBatchSize, config.flushIntervalInMilliseconds);\n  }\n\n  private constructor(maxNumberEvents?: number, flushBatchSize?: number, flushIntervalInMilliseconds?: number) {\n    this._started = false;\n    this._maxNumberEvents = maxNumberEvents === undefined ? 10000 : maxNumberEvents;\n    this._flushBatchSize = flushBatchSize === undefined ? 10 : flushBatchSize;\n    this._flushIntervalInMilliseconds = flushIntervalInMilliseconds === undefined ? 5000 : flushIntervalInMilliseconds;\n  }\n\n  // start profiling\n  start() {\n    this._started = true;\n    this._timingEvents = [];\n    this._flushTime = now();\n    this._flushPointer = 0;\n  }\n\n  // stop profiling\n  stop() {\n    this._started = false;\n    for (; this._flushPointer < this._timingEvents.length; this._flushPointer++) {\n      this.logOneEvent(this._timingEvents[this._flushPointer]);\n    }\n  }\n\n  // create an event scope for the specific function\n  event<T>(category: Profiler.EventCategory, name: string, func: () => T, ctx?: WebGLContext): T;\n  event<T>(category: Profiler.EventCategory, name: string, func: () => Promise<T>, ctx?: WebGLContext): Promise<T>;\n\n  event<T>(category: Profiler.EventCategory, name: string, func: () => T | Promise<T>, ctx?: WebGLContext): T\n      |Promise<T> {\n    const event = this._started ? this.begin(category, name, ctx) : undefined;\n    let isPromise = false;\n\n    const res = func();\n\n    // we consider a then-able object is a promise\n    if (res && typeof (res as Promise<T>).then === 'function') {\n      isPromise = true;\n      return new Promise<T>((resolve, reject) => {\n        (res as Promise<T>)\n            .then(\n                async value => {  // fulfilled\n                  if (event) {\n                    await event.end();\n                  }\n                  resolve(value);\n                },\n                async reason => {  // rejected\n                  if (event) {\n                    await event.end();\n                  }\n                  reject(reason);\n                });\n      });\n    }\n    if (!isPromise && event) {\n      const eventRes = event.end();\n      if (eventRes && typeof eventRes.then === 'function') {\n        return new Promise<T>((resolve, reject) => {\n          (eventRes).then(\n              () => {  // fulfilled\n                resolve(res);\n              },\n              (reason) => {  // rejected\n                reject(reason);\n              });\n        });\n      }\n    }\n    return res;\n  }\n\n  // begin an event\n  begin(category: Profiler.EventCategory, name: string, ctx?: WebGLContext): Event {\n    if (!this._started) {\n      throw new Error('profiler is not started yet');\n    }\n    if (ctx === undefined) {\n      const startTime = now();\n      this.flush(startTime);\n      return new Event(category, name, startTime, e => this.endSync(e));\n    } else {\n      const timer: WebGLQuery = ctx.beginTimer();\n      return new Event(category, name, 0, async e => this.end(e), timer, ctx);\n    }\n  }\n\n  // end the specific event\n  private async end(event: Event): Promise<void> {\n    const endTime: number = await event.checkTimer();\n    if (this._timingEvents.length < this._maxNumberEvents) {\n      this._timingEvents.push(new EventRecord(event.category, event.name, event.startTime, endTime));\n      this.flush(endTime);\n    }\n  }\n\n  private endSync(event: Event): void {\n    const endTime: number = now();\n    if (this._timingEvents.length < this._maxNumberEvents) {\n      this._timingEvents.push(new EventRecord(event.category, event.name, event.startTime, endTime));\n      this.flush(endTime);\n    }\n  }\n\n  private logOneEvent(event: EventRecord) {\n    Logger.verbose(\n        `Profiler.${event.category}`,\n        `${(event.endTime - event.startTime).toFixed(2)}ms on event '${event.name}' at ${event.endTime.toFixed(2)}`);\n  }\n\n  private flush(currentTime: number) {\n    if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize ||\n        currentTime - this._flushTime >= this._flushIntervalInMilliseconds) {\n      // should flush when either batch size accumlated or interval elepsed\n\n      for (const previousPointer = this._flushPointer; this._flushPointer < previousPointer + this._flushBatchSize &&\n           this._flushPointer < this._timingEvents.length;\n           this._flushPointer++) {\n        this.logOneEvent(this._timingEvents[this._flushPointer]);\n      }\n\n      this._flushTime = now();\n    }\n  }\n\n  get started() {\n    return this._started;\n  }\n  private _started = false;\n  private _timingEvents: EventRecord[];\n\n  private readonly _maxNumberEvents: number;\n\n  private readonly _flushBatchSize: number;\n  private readonly _flushIntervalInMilliseconds: number;\n\n  private _flushTime: number;\n  private _flushPointer = 0;\n}\n\n/**\n * returns a number to represent the current timestamp in a resolution as high as possible.\n */\nexport const now = (typeof performance !== 'undefined' && performance.now) ? () => performance.now() : Date.now;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {flatbuffers} from 'flatbuffers';\n\nimport {Graph} from './graph';\nimport {OpSet} from './opset';\nimport {onnxruntime} from './ort-schema/flatbuffers/ort-generated';\nimport {onnx} from './ort-schema/protobuf/onnx';\nimport {LongUtil} from './util';\n\nimport ortFbs = onnxruntime.experimental.fbs;\n\nexport class Model {\n  // empty model\n  constructor() {}\n\n  load(buf: Uint8Array, graphInitializer?: Graph.Initializer, isOrtFormat?: boolean): void {\n    if (!isOrtFormat) {\n      // isOrtFormat === false || isOrtFormat === undefined\n      try {\n        this.loadFromOnnxFormat(buf, graphInitializer);\n        return;\n      } catch (e) {\n        if (isOrtFormat !== undefined) {\n          throw e;\n        }\n      }\n    }\n\n    this.loadFromOrtFormat(buf, graphInitializer);\n  }\n\n  private loadFromOnnxFormat(buf: Uint8Array, graphInitializer?: Graph.Initializer): void {\n    const modelProto = onnx.ModelProto.decode(buf);\n    const irVersion = LongUtil.longToNumber(modelProto.irVersion);\n    if (irVersion < 3) {\n      throw new Error('only support ONNX model with IR_VERSION>=3');\n    }\n\n    this._opsets =\n        modelProto.opsetImport.map(i => ({domain: i.domain as string, version: LongUtil.longToNumber(i.version!)}));\n\n    this._graph = Graph.from(modelProto.graph!, graphInitializer);\n  }\n\n  private loadFromOrtFormat(buf: Uint8Array, graphInitializer?: Graph.Initializer): void {\n    const fb = new flatbuffers.ByteBuffer(buf);\n    const ortModel = ortFbs.InferenceSession.getRootAsInferenceSession(fb).model()!;\n    const irVersion = LongUtil.longToNumber(ortModel.irVersion());\n    if (irVersion < 3) {\n      throw new Error('only support ONNX model with IR_VERSION>=3');\n    }\n    this._opsets = [];\n    for (let i = 0; i < ortModel.opsetImportLength(); i++) {\n      const opsetId = ortModel.opsetImport(i)!;\n      this._opsets.push({domain: opsetId?.domain() as string, version: LongUtil.longToNumber(opsetId.version()!)});\n    }\n\n    this._graph = Graph.from(ortModel.graph()!, graphInitializer);\n  }\n\n  private _graph: Graph;\n  get graph(): Graph {\n    return this._graph;\n  }\n\n  private _opsets: OpSet[];\n  get opsets(): readonly OpSet[] {\n    return this._opsets;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {InferenceHandler} from './backend';\nimport {Graph} from './graph';\nimport {Tensor} from './tensor';\n\nexport type OperatorImplementation<T> = (inferenceHandler: InferenceHandler, inputs: Tensor[], context: T) => Tensor[];\nexport type OperatorInitialization<T> = (node: Graph.Node, graph: Graph) => T;\n\nexport interface Operator {\n  readonly impl: OperatorImplementation<unknown>;\n  readonly context: Graph.Node|unknown;\n}\n\nexport const NUMBER_TYPES: readonly Tensor.DataType[] =\n    ['float32', 'float64', 'int32', 'int16', 'int8', 'uint16', 'uint32', 'uint8'];\nexport const INT_TYPES: readonly Tensor.DataType[] = ['int32', 'int16', 'int8', 'uint16', 'uint32', 'uint8'];\nexport const FLOAT_TYPES: readonly Tensor.DataType[] = ['float32', 'float64'];\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Graph} from './graph';\nimport {OperatorImplementation, OperatorInitialization} from './operators';\n\nexport interface OpSet {\n  domain: string;\n  version: number;\n}\nexport declare namespace OpSet {\n  /**\n   * Domain of an opset, it can be an empty string(default value, represent for ai.onnx), or 'ai.onnx.ml'\n   */\n  type Domain = ''|'ai.onnx.ml'|'com.microsoft';\n  /**\n   * A resolve rule consists of 4 or 5 items: opType, opSetDomain, versionSelector, operatorImplementation and\n   * operatorInitialization (optional)\n   */\n  type ResolveRule = [\n    string, Domain, string, OperatorImplementation<Graph.Node>\n  ]|[string, Domain, string, OperatorImplementation<unknown>, OperatorInitialization<unknown>];\n}\n\nexport function resolveOperator(node: Graph.Node, opsets: readonly OpSet[], rules: readonly OpSet.ResolveRule[]) {\n  for (const rule of rules) {\n    const opType = rule[0];\n    const domain = rule[1];\n    const versionSelector = rule[2];\n    const opImpl = rule[3];\n    const opInit = rule[4];\n\n    if (node.opType === opType) {  // operator type matches\n      for (const opset of opsets) {\n        // opset '' and 'ai.onnx' are considered the same.\n        if (opset.domain === domain || (opset.domain === 'ai.onnx' && domain === '')) {  // opset domain found\n          if (matchSelector(opset.version, versionSelector)) {\n            return {opImpl, opInit};\n          }\n        }\n      }\n    }\n  }\n\n  throw new TypeError(`cannot resolve operator '${node.opType}' with opsets: ${\n      opsets.map(set => `${set.domain || 'ai.onnx'} v${set.version}`).join(', ')}`);\n}\n\nfunction matchSelector(version: number, selector: string): boolean {\n  if (selector.endsWith('+')) {\n    // minimum version match ('7+' expects version>=7)\n    const rangeStart = Number.parseInt(selector.substring(0, selector.length - 1), 10);\n    return !isNaN(rangeStart) && rangeStart <= version;\n  } else if (selector.split('-').length === 2) {\n    // range match ('6-8' expects 6<=version<=8)\n    const pair = selector.split('-');\n    const rangeStart = Number.parseInt(pair[0], 10);\n    const rangeEnd = Number.parseInt(pair[1], 10);\n    return !isNaN(rangeStart) && !isNaN(rangeEnd) && rangeStart <= version && version <= rangeEnd;\n  } else {\n    // exact match ('7' expects version===7)\n    return Number.parseInt(selector, 10) === version;\n  }\n}\n","// automatically generated by the FlatBuffers compiler, do not modify\n/* eslint-disable */\n\nimport {flatbuffers} from 'flatbuffers';\n\n/**\n * @enum {number}\n */\nexport namespace onnxruntime.experimental.fbs {\n  export enum AttributeType {\n    UNDEFINED = 0,\n    FLOAT = 1,\n    INT = 2,\n    STRING = 3,\n    TENSOR = 4,\n    GRAPH = 5,\n    FLOATS = 6,\n    INTS = 7,\n    STRINGS = 8,\n    TENSORS = 9,\n    GRAPHS = 10,\n    SPARSE_TENSOR = 11,\n    SPARSE_TENSORS = 12\n  }\n}\n\n/**\n * @enum {number}\n */\nexport namespace onnxruntime.experimental.fbs {\n  export enum DimensionValueType {UNKNOWN = 0, VALUE = 1, PARAM = 2}\n}\n\n/**\n * @enum {number}\n */\nexport namespace onnxruntime.experimental.fbs {\n  export enum TensorDataType {\n    UNDEFINED = 0,\n    FLOAT = 1,\n    UINT8 = 2,\n    INT8 = 3,\n    UINT16 = 4,\n    INT16 = 5,\n    INT32 = 6,\n    INT64 = 7,\n    STRING = 8,\n    BOOL = 9,\n    FLOAT16 = 10,\n    DOUBLE = 11,\n    UINT32 = 12,\n    UINT64 = 13,\n    COMPLEX64 = 14,\n    COMPLEX128 = 15,\n    BFLOAT16 = 16,\n    FLOAT8E4M3FN = 17,\n    FLOAT8E4M3FNUZ = 18,\n    FLOAT8E5M2 = 19,\n    FLOAT8E5M2FNUZ = 20,\n  }\n}\n\n/**\n * @enum {number}\n */\nexport namespace onnxruntime.experimental.fbs {\n  export enum NodeType {Primitive = 0, Fused = 1}\n}\n\n/**\n * @enum {number}\n */\nexport namespace onnxruntime.experimental.fbs {\n  export enum TypeInfoValue {NONE = 0, tensor_type = 1, sequence_type = 2, map_type = 3}\n}\n\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Shape {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Shape\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Shape {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Shape= obj\n     * @returns Shape\n     */\n    static getRootAsShape(bb: flatbuffers.ByteBuffer, obj?: Shape): Shape {\n      return (obj || new Shape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Shape= obj\n     * @returns Shape\n     */\n    static getSizePrefixedRootAsShape(bb: flatbuffers.ByteBuffer, obj?: Shape): Shape {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Shape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Dimension= obj\n     * @returns onnxruntime.experimental.fbs.Dimension\n     */\n    dim(index: number, obj?: onnxruntime.experimental.fbs.Dimension): onnxruntime.experimental.fbs.Dimension|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Dimension())\n                          .__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    dimLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startShape(builder: flatbuffers.Builder) {\n      builder.startObject(1);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset dimOffset\n     */\n    static addDim(builder: flatbuffers.Builder, dimOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, dimOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createDimVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startDimVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endShape(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createShape(builder: flatbuffers.Builder, dimOffset: flatbuffers.Offset): flatbuffers.Offset {\n      Shape.startShape(builder);\n      Shape.addDim(builder, dimOffset);\n      return Shape.endShape(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Dimension {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Dimension\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Dimension {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Dimension= obj\n     * @returns Dimension\n     */\n    static getRootAsDimension(bb: flatbuffers.ByteBuffer, obj?: Dimension): Dimension {\n      return (obj || new Dimension()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Dimension= obj\n     * @returns Dimension\n     */\n    static getSizePrefixedRootAsDimension(bb: flatbuffers.ByteBuffer, obj?: Dimension): Dimension {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Dimension()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.DimensionValue= obj\n     * @returns onnxruntime.experimental.fbs.DimensionValue|null\n     */\n    value(obj?: onnxruntime.experimental.fbs.DimensionValue): onnxruntime.experimental.fbs.DimensionValue|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? (obj || new onnxruntime.experimental.fbs.DimensionValue())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    denotation(): string|null;\n    denotation(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    denotation(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startDimension(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset valueOffset\n     */\n    static addValue(builder: flatbuffers.Builder, valueOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, valueOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset denotationOffset\n     */\n    static addDenotation(builder: flatbuffers.Builder, denotationOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, denotationOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endDimension(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createDimension(\n        builder: flatbuffers.Builder, valueOffset: flatbuffers.Offset,\n        denotationOffset: flatbuffers.Offset): flatbuffers.Offset {\n      Dimension.startDimension(builder);\n      Dimension.addValue(builder, valueOffset);\n      Dimension.addDenotation(builder, denotationOffset);\n      return Dimension.endDimension(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class DimensionValue {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns DimensionValue\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): DimensionValue {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param DimensionValue= obj\n     * @returns DimensionValue\n     */\n    static getRootAsDimensionValue(bb: flatbuffers.ByteBuffer, obj?: DimensionValue): DimensionValue {\n      return (obj || new DimensionValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param DimensionValue= obj\n     * @returns DimensionValue\n     */\n    static getSizePrefixedRootAsDimensionValue(bb: flatbuffers.ByteBuffer, obj?: DimensionValue): DimensionValue {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new DimensionValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.DimensionValueType\n     */\n    dimType(): onnxruntime.experimental.fbs.DimensionValueType {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? /**  */ (this.bb!.readInt8(this.bb_pos + offset)) :\n                      onnxruntime.experimental.fbs.DimensionValueType.UNKNOWN;\n    }\n\n    /**\n     * @returns flatbuffers.Long\n     */\n    dimValue(): flatbuffers.Long {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    dimParam(): string|null;\n    dimParam(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    dimParam(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startDimensionValue(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.DimensionValueType dimType\n     */\n    static addDimType(builder: flatbuffers.Builder, dimType: onnxruntime.experimental.fbs.DimensionValueType) {\n      builder.addFieldInt8(0, dimType, onnxruntime.experimental.fbs.DimensionValueType.UNKNOWN);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Long dimValue\n     */\n    static addDimValue(builder: flatbuffers.Builder, dimValue: flatbuffers.Long) {\n      builder.addFieldInt64(1, dimValue, builder.createLong(0, 0));\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset dimParamOffset\n     */\n    static addDimParam(builder: flatbuffers.Builder, dimParamOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, dimParamOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endDimensionValue(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createDimensionValue(\n        builder: flatbuffers.Builder, dimType: onnxruntime.experimental.fbs.DimensionValueType,\n        dimValue: flatbuffers.Long, dimParamOffset: flatbuffers.Offset): flatbuffers.Offset {\n      DimensionValue.startDimensionValue(builder);\n      DimensionValue.addDimType(builder, dimType);\n      DimensionValue.addDimValue(builder, dimValue);\n      DimensionValue.addDimParam(builder, dimParamOffset);\n      return DimensionValue.endDimensionValue(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class TensorTypeAndShape {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns TensorTypeAndShape\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): TensorTypeAndShape {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param TensorTypeAndShape= obj\n     * @returns TensorTypeAndShape\n     */\n    static getRootAsTensorTypeAndShape(bb: flatbuffers.ByteBuffer, obj?: TensorTypeAndShape): TensorTypeAndShape {\n      return (obj || new TensorTypeAndShape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param TensorTypeAndShape= obj\n     * @returns TensorTypeAndShape\n     */\n    static getSizePrefixedRootAsTensorTypeAndShape(bb: flatbuffers.ByteBuffer, obj?: TensorTypeAndShape):\n        TensorTypeAndShape {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new TensorTypeAndShape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.TensorDataType\n     */\n    elemType(): onnxruntime.experimental.fbs.TensorDataType {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? /**  */ (this.bb!.readInt32(this.bb_pos + offset)) :\n                      onnxruntime.experimental.fbs.TensorDataType.UNDEFINED;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Shape= obj\n     * @returns onnxruntime.experimental.fbs.Shape|null\n     */\n    shape(obj?: onnxruntime.experimental.fbs.Shape): onnxruntime.experimental.fbs.Shape|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Shape())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startTensorTypeAndShape(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.TensorDataType elemType\n     */\n    static addElemType(builder: flatbuffers.Builder, elemType: onnxruntime.experimental.fbs.TensorDataType) {\n      builder.addFieldInt32(0, elemType, onnxruntime.experimental.fbs.TensorDataType.UNDEFINED);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset shapeOffset\n     */\n    static addShape(builder: flatbuffers.Builder, shapeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, shapeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endTensorTypeAndShape(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createTensorTypeAndShape(\n        builder: flatbuffers.Builder, elemType: onnxruntime.experimental.fbs.TensorDataType,\n        shapeOffset: flatbuffers.Offset): flatbuffers.Offset {\n      TensorTypeAndShape.startTensorTypeAndShape(builder);\n      TensorTypeAndShape.addElemType(builder, elemType);\n      TensorTypeAndShape.addShape(builder, shapeOffset);\n      return TensorTypeAndShape.endTensorTypeAndShape(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class MapType {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns MapType\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): MapType {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param MapType= obj\n     * @returns MapType\n     */\n    static getRootAsMapType(bb: flatbuffers.ByteBuffer, obj?: MapType): MapType {\n      return (obj || new MapType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param MapType= obj\n     * @returns MapType\n     */\n    static getSizePrefixedRootAsMapType(bb: flatbuffers.ByteBuffer, obj?: MapType): MapType {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new MapType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.TensorDataType\n     */\n    keyType(): onnxruntime.experimental.fbs.TensorDataType {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? /**  */ (this.bb!.readInt32(this.bb_pos + offset)) :\n                      onnxruntime.experimental.fbs.TensorDataType.UNDEFINED;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.TypeInfo= obj\n     * @returns onnxruntime.experimental.fbs.TypeInfo|null\n     */\n    valueType(obj?: onnxruntime.experimental.fbs.TypeInfo): onnxruntime.experimental.fbs.TypeInfo|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? (obj || new onnxruntime.experimental.fbs.TypeInfo())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startMapType(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.TensorDataType keyType\n     */\n    static addKeyType(builder: flatbuffers.Builder, keyType: onnxruntime.experimental.fbs.TensorDataType) {\n      builder.addFieldInt32(0, keyType, onnxruntime.experimental.fbs.TensorDataType.UNDEFINED);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset valueTypeOffset\n     */\n    static addValueType(builder: flatbuffers.Builder, valueTypeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, valueTypeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endMapType(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createMapType(\n        builder: flatbuffers.Builder, keyType: onnxruntime.experimental.fbs.TensorDataType,\n        valueTypeOffset: flatbuffers.Offset): flatbuffers.Offset {\n      MapType.startMapType(builder);\n      MapType.addKeyType(builder, keyType);\n      MapType.addValueType(builder, valueTypeOffset);\n      return MapType.endMapType(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class SequenceType {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns SequenceType\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): SequenceType {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SequenceType= obj\n     * @returns SequenceType\n     */\n    static getRootAsSequenceType(bb: flatbuffers.ByteBuffer, obj?: SequenceType): SequenceType {\n      return (obj || new SequenceType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SequenceType= obj\n     * @returns SequenceType\n     */\n    static getSizePrefixedRootAsSequenceType(bb: flatbuffers.ByteBuffer, obj?: SequenceType): SequenceType {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new SequenceType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.TypeInfo= obj\n     * @returns onnxruntime.experimental.fbs.TypeInfo|null\n     */\n    elemType(obj?: onnxruntime.experimental.fbs.TypeInfo): onnxruntime.experimental.fbs.TypeInfo|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? (obj || new onnxruntime.experimental.fbs.TypeInfo())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startSequenceType(builder: flatbuffers.Builder) {\n      builder.startObject(1);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset elemTypeOffset\n     */\n    static addElemType(builder: flatbuffers.Builder, elemTypeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, elemTypeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endSequenceType(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createSequenceType(builder: flatbuffers.Builder, elemTypeOffset: flatbuffers.Offset): flatbuffers.Offset {\n      SequenceType.startSequenceType(builder);\n      SequenceType.addElemType(builder, elemTypeOffset);\n      return SequenceType.endSequenceType(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class EdgeEnd {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns EdgeEnd\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): EdgeEnd {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @returns number\n     */\n    nodeIndex(): number {\n      return this.bb!.readUint32(this.bb_pos);\n    }\n\n    /**\n     * @returns number\n     */\n    srcArgIndex(): number {\n      return this.bb!.readInt32(this.bb_pos + 4);\n    }\n\n    /**\n     * @returns number\n     */\n    dstArgIndex(): number {\n      return this.bb!.readInt32(this.bb_pos + 8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number node_index\n     * @param number src_arg_index\n     * @param number dst_arg_index\n     * @returns flatbuffers.Offset\n     */\n    static createEdgeEnd(\n        builder: flatbuffers.Builder, node_index: number, src_arg_index: number,\n        dst_arg_index: number): flatbuffers.Offset {\n      builder.prep(4, 12);\n      builder.writeInt32(dst_arg_index);\n      builder.writeInt32(src_arg_index);\n      builder.writeInt32(node_index);\n      return builder.offset();\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class NodeEdge {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns NodeEdge\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): NodeEdge {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param NodeEdge= obj\n     * @returns NodeEdge\n     */\n    static getRootAsNodeEdge(bb: flatbuffers.ByteBuffer, obj?: NodeEdge): NodeEdge {\n      return (obj || new NodeEdge()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param NodeEdge= obj\n     * @returns NodeEdge\n     */\n    static getSizePrefixedRootAsNodeEdge(bb: flatbuffers.ByteBuffer, obj?: NodeEdge): NodeEdge {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new NodeEdge()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @returns number\n     */\n    nodeIndex(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.EdgeEnd= obj\n     * @returns onnxruntime.experimental.fbs.EdgeEnd\n     */\n    inputEdges(index: number, obj?: onnxruntime.experimental.fbs.EdgeEnd): onnxruntime.experimental.fbs.EdgeEnd|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? (obj || new onnxruntime.experimental.fbs.EdgeEnd())\n                          .__init(this.bb!.__vector(this.bb_pos + offset) + index * 12, this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    inputEdgesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.EdgeEnd= obj\n     * @returns onnxruntime.experimental.fbs.EdgeEnd\n     */\n    outputEdges(index: number, obj?: onnxruntime.experimental.fbs.EdgeEnd): onnxruntime.experimental.fbs.EdgeEnd|null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? (obj || new onnxruntime.experimental.fbs.EdgeEnd())\n                          .__init(this.bb!.__vector(this.bb_pos + offset) + index * 12, this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    outputEdgesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startNodeEdge(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number nodeIndex\n     */\n    static addNodeIndex(builder: flatbuffers.Builder, nodeIndex: number) {\n      builder.addFieldInt32(0, nodeIndex, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset inputEdgesOffset\n     */\n    static addInputEdges(builder: flatbuffers.Builder, inputEdgesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, inputEdgesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startInputEdgesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(12, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset outputEdgesOffset\n     */\n    static addOutputEdges(builder: flatbuffers.Builder, outputEdgesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, outputEdgesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startOutputEdgesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(12, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endNodeEdge(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createNodeEdge(\n        builder: flatbuffers.Builder, nodeIndex: number, inputEdgesOffset: flatbuffers.Offset,\n        outputEdgesOffset: flatbuffers.Offset): flatbuffers.Offset {\n      NodeEdge.startNodeEdge(builder);\n      NodeEdge.addNodeIndex(builder, nodeIndex);\n      NodeEdge.addInputEdges(builder, inputEdgesOffset);\n      NodeEdge.addOutputEdges(builder, outputEdgesOffset);\n      return NodeEdge.endNodeEdge(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Node {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Node\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Node {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Node= obj\n     * @returns Node\n     */\n    static getRootAsNode(bb: flatbuffers.ByteBuffer, obj?: Node): Node {\n      return (obj || new Node()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Node= obj\n     * @returns Node\n     */\n    static getSizePrefixedRootAsNode(bb: flatbuffers.ByteBuffer, obj?: Node): Node {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Node()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    name(): string|null;\n    name(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    name(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    docString(): string|null;\n    docString(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    docString(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    domain(): string|null;\n    domain(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    domain(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    sinceVersion(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 10);\n      return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    index(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    opType(): string|null;\n    opType(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    opType(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.NodeType\n     */\n    type(): onnxruntime.experimental.fbs.NodeType {\n      let offset = this.bb!.__offset(this.bb_pos, 16);\n      return offset ? /**  */ (this.bb!.readInt32(this.bb_pos + offset)) :\n                      onnxruntime.experimental.fbs.NodeType.Primitive;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    executionProviderType(): string|null;\n    executionProviderType(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    executionProviderType(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 18);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    inputs(index: number): string;\n    inputs(index: number, optionalEncoding: flatbuffers.Encoding): string|Uint8Array;\n    inputs(index: number, optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    inputsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    outputs(index: number): string;\n    outputs(index: number, optionalEncoding: flatbuffers.Encoding): string|Uint8Array;\n    outputs(index: number, optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 22);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    outputsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 22);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Attribute= obj\n     * @returns onnxruntime.experimental.fbs.Attribute\n     */\n    attributes(index: number, obj?: onnxruntime.experimental.fbs.Attribute): onnxruntime.experimental.fbs.Attribute\n        |null {\n      let offset = this.bb!.__offset(this.bb_pos, 24);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Attribute())\n                          .__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    attributesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 24);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @returns number\n     */\n    inputArgCounts(index: number): number|null {\n      let offset = this.bb!.__offset(this.bb_pos, 26);\n      return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    inputArgCountsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 26);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns Int32Array\n     */\n    inputArgCountsArray(): Int32Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 26);\n      return offset ?\n          new Int32Array(\n              this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),\n              this.bb!.__vector_len(this.bb_pos + offset)) :\n          null;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    implicitInputs(index: number): string;\n    implicitInputs(index: number, optionalEncoding: flatbuffers.Encoding): string|Uint8Array;\n    implicitInputs(index: number, optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 28);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    implicitInputsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 28);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startNode(builder: flatbuffers.Builder) {\n      builder.startObject(13);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nameOffset\n     */\n    static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, nameOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset docStringOffset\n     */\n    static addDocString(builder: flatbuffers.Builder, docStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, docStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset domainOffset\n     */\n    static addDomain(builder: flatbuffers.Builder, domainOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, domainOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number sinceVersion\n     */\n    static addSinceVersion(builder: flatbuffers.Builder, sinceVersion: number) {\n      builder.addFieldInt32(3, sinceVersion, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number index\n     */\n    static addIndex(builder: flatbuffers.Builder, index: number) {\n      builder.addFieldInt32(4, index, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset opTypeOffset\n     */\n    static addOpType(builder: flatbuffers.Builder, opTypeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(5, opTypeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.NodeType type\n     */\n    static addType(builder: flatbuffers.Builder, type: onnxruntime.experimental.fbs.NodeType) {\n      builder.addFieldInt32(6, type, onnxruntime.experimental.fbs.NodeType.Primitive);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset executionProviderTypeOffset\n     */\n    static addExecutionProviderType(builder: flatbuffers.Builder, executionProviderTypeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(7, executionProviderTypeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset inputsOffset\n     */\n    static addInputs(builder: flatbuffers.Builder, inputsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(8, inputsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createInputsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startInputsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset outputsOffset\n     */\n    static addOutputs(builder: flatbuffers.Builder, outputsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(9, outputsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createOutputsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startOutputsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset attributesOffset\n     */\n    static addAttributes(builder: flatbuffers.Builder, attributesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(10, attributesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createAttributesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startAttributesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset inputArgCountsOffset\n     */\n    static addInputArgCounts(builder: flatbuffers.Builder, inputArgCountsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(11, inputArgCountsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<number> data\n     * @returns flatbuffers.Offset\n     */\n    static createInputArgCountsVector(builder: flatbuffers.Builder, data: number[]|Uint8Array): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt32(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startInputArgCountsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset implicitInputsOffset\n     */\n    static addImplicitInputs(builder: flatbuffers.Builder, implicitInputsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(12, implicitInputsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createImplicitInputsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startImplicitInputsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endNode(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createNode(\n        builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset, docStringOffset: flatbuffers.Offset,\n        domainOffset: flatbuffers.Offset, sinceVersion: number, index: number, opTypeOffset: flatbuffers.Offset,\n        type: onnxruntime.experimental.fbs.NodeType, executionProviderTypeOffset: flatbuffers.Offset,\n        inputsOffset: flatbuffers.Offset, outputsOffset: flatbuffers.Offset, attributesOffset: flatbuffers.Offset,\n        inputArgCountsOffset: flatbuffers.Offset, implicitInputsOffset: flatbuffers.Offset): flatbuffers.Offset {\n      Node.startNode(builder);\n      Node.addName(builder, nameOffset);\n      Node.addDocString(builder, docStringOffset);\n      Node.addDomain(builder, domainOffset);\n      Node.addSinceVersion(builder, sinceVersion);\n      Node.addIndex(builder, index);\n      Node.addOpType(builder, opTypeOffset);\n      Node.addType(builder, type);\n      Node.addExecutionProviderType(builder, executionProviderTypeOffset);\n      Node.addInputs(builder, inputsOffset);\n      Node.addOutputs(builder, outputsOffset);\n      Node.addAttributes(builder, attributesOffset);\n      Node.addInputArgCounts(builder, inputArgCountsOffset);\n      Node.addImplicitInputs(builder, implicitInputsOffset);\n      return Node.endNode(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class ValueInfo {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns ValueInfo\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): ValueInfo {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param ValueInfo= obj\n     * @returns ValueInfo\n     */\n    static getRootAsValueInfo(bb: flatbuffers.ByteBuffer, obj?: ValueInfo): ValueInfo {\n      return (obj || new ValueInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param ValueInfo= obj\n     * @returns ValueInfo\n     */\n    static getSizePrefixedRootAsValueInfo(bb: flatbuffers.ByteBuffer, obj?: ValueInfo): ValueInfo {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new ValueInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    name(): string|null;\n    name(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    name(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    docString(): string|null;\n    docString(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    docString(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.TypeInfo= obj\n     * @returns onnxruntime.experimental.fbs.TypeInfo|null\n     */\n    type(obj?: onnxruntime.experimental.fbs.TypeInfo): onnxruntime.experimental.fbs.TypeInfo|null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? (obj || new onnxruntime.experimental.fbs.TypeInfo())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startValueInfo(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nameOffset\n     */\n    static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, nameOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset docStringOffset\n     */\n    static addDocString(builder: flatbuffers.Builder, docStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, docStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset typeOffset\n     */\n    static addType(builder: flatbuffers.Builder, typeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, typeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endValueInfo(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createValueInfo(\n        builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset, docStringOffset: flatbuffers.Offset,\n        typeOffset: flatbuffers.Offset): flatbuffers.Offset {\n      ValueInfo.startValueInfo(builder);\n      ValueInfo.addName(builder, nameOffset);\n      ValueInfo.addDocString(builder, docStringOffset);\n      ValueInfo.addType(builder, typeOffset);\n      return ValueInfo.endValueInfo(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class TypeInfo {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns TypeInfo\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): TypeInfo {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param TypeInfo= obj\n     * @returns TypeInfo\n     */\n    static getRootAsTypeInfo(bb: flatbuffers.ByteBuffer, obj?: TypeInfo): TypeInfo {\n      return (obj || new TypeInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param TypeInfo= obj\n     * @returns TypeInfo\n     */\n    static getSizePrefixedRootAsTypeInfo(bb: flatbuffers.ByteBuffer, obj?: TypeInfo): TypeInfo {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new TypeInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    denotation(): string|null;\n    denotation(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    denotation(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.TypeInfoValue\n     */\n    valueType(): onnxruntime.experimental.fbs.TypeInfoValue {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? /**  */ (this.bb!.readUint8(this.bb_pos + offset)) :\n                      onnxruntime.experimental.fbs.TypeInfoValue.NONE;\n    }\n\n    /**\n     * @param flatbuffers.Table obj\n     * @returns ?flatbuffers.Table\n     */\n    value<T extends flatbuffers.Table>(obj: T): T|null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startTypeInfo(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset denotationOffset\n     */\n    static addDenotation(builder: flatbuffers.Builder, denotationOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, denotationOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.TypeInfoValue valueType\n     */\n    static addValueType(builder: flatbuffers.Builder, valueType: onnxruntime.experimental.fbs.TypeInfoValue) {\n      builder.addFieldInt8(1, valueType, onnxruntime.experimental.fbs.TypeInfoValue.NONE);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset valueOffset\n     */\n    static addValue(builder: flatbuffers.Builder, valueOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, valueOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endTypeInfo(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createTypeInfo(\n        builder: flatbuffers.Builder, denotationOffset: flatbuffers.Offset,\n        valueType: onnxruntime.experimental.fbs.TypeInfoValue, valueOffset: flatbuffers.Offset): flatbuffers.Offset {\n      TypeInfo.startTypeInfo(builder);\n      TypeInfo.addDenotation(builder, denotationOffset);\n      TypeInfo.addValueType(builder, valueType);\n      TypeInfo.addValue(builder, valueOffset);\n      return TypeInfo.endTypeInfo(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class OperatorSetId {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns OperatorSetId\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): OperatorSetId {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param OperatorSetId= obj\n     * @returns OperatorSetId\n     */\n    static getRootAsOperatorSetId(bb: flatbuffers.ByteBuffer, obj?: OperatorSetId): OperatorSetId {\n      return (obj || new OperatorSetId()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param OperatorSetId= obj\n     * @returns OperatorSetId\n     */\n    static getSizePrefixedRootAsOperatorSetId(bb: flatbuffers.ByteBuffer, obj?: OperatorSetId): OperatorSetId {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new OperatorSetId()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    domain(): string|null;\n    domain(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    domain(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns flatbuffers.Long\n     */\n    version(): flatbuffers.Long {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startOperatorSetId(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset domainOffset\n     */\n    static addDomain(builder: flatbuffers.Builder, domainOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, domainOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Long version\n     */\n    static addVersion(builder: flatbuffers.Builder, version: flatbuffers.Long) {\n      builder.addFieldInt64(1, version, builder.createLong(0, 0));\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endOperatorSetId(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createOperatorSetId(\n        builder: flatbuffers.Builder, domainOffset: flatbuffers.Offset, version: flatbuffers.Long): flatbuffers.Offset {\n      OperatorSetId.startOperatorSetId(builder);\n      OperatorSetId.addDomain(builder, domainOffset);\n      OperatorSetId.addVersion(builder, version);\n      return OperatorSetId.endOperatorSetId(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Tensor {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Tensor\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Tensor {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Tensor= obj\n     * @returns Tensor\n     */\n    static getRootAsTensor(bb: flatbuffers.ByteBuffer, obj?: Tensor): Tensor {\n      return (obj || new Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Tensor= obj\n     * @returns Tensor\n     */\n    static getSizePrefixedRootAsTensor(bb: flatbuffers.ByteBuffer, obj?: Tensor): Tensor {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    name(): string|null;\n    name(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    name(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    docString(): string|null;\n    docString(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    docString(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param number index\n     * @returns flatbuffers.Long\n     */\n    dims(index: number): flatbuffers.Long|null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.readInt64(this.bb!.__vector(this.bb_pos + offset) + index * 8) :\n                      this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @returns number\n     */\n    dimsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.TensorDataType\n     */\n    dataType(): onnxruntime.experimental.fbs.TensorDataType {\n      let offset = this.bb!.__offset(this.bb_pos, 10);\n      return offset ? /**  */ (this.bb!.readInt32(this.bb_pos + offset)) :\n                      onnxruntime.experimental.fbs.TensorDataType.UNDEFINED;\n    }\n\n    /**\n     * @param number index\n     * @returns number\n     */\n    rawData(index: number): number|null {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    rawDataLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns Uint8Array\n     */\n    rawDataArray(): Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ?\n          new Uint8Array(\n              this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),\n              this.bb!.__vector_len(this.bb_pos + offset)) :\n          null;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    stringData(index: number): string;\n    stringData(index: number, optionalEncoding: flatbuffers.Encoding): string|Uint8Array;\n    stringData(index: number, optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    stringDataLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startTensor(builder: flatbuffers.Builder) {\n      builder.startObject(6);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nameOffset\n     */\n    static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, nameOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset docStringOffset\n     */\n    static addDocString(builder: flatbuffers.Builder, docStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, docStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset dimsOffset\n     */\n    static addDims(builder: flatbuffers.Builder, dimsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, dimsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Long> data\n     * @returns flatbuffers.Offset\n     */\n    static createDimsVector(builder: flatbuffers.Builder, data: flatbuffers.Long[]): flatbuffers.Offset {\n      builder.startVector(8, data.length, 8);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt64(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startDimsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(8, numElems, 8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.TensorDataType dataType\n     */\n    static addDataType(builder: flatbuffers.Builder, dataType: onnxruntime.experimental.fbs.TensorDataType) {\n      builder.addFieldInt32(3, dataType, onnxruntime.experimental.fbs.TensorDataType.UNDEFINED);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset rawDataOffset\n     */\n    static addRawData(builder: flatbuffers.Builder, rawDataOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(4, rawDataOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<number> data\n     * @returns flatbuffers.Offset\n     */\n    static createRawDataVector(builder: flatbuffers.Builder, data: number[]|Uint8Array): flatbuffers.Offset {\n      builder.startVector(1, data.length, 1);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt8(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startRawDataVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(1, numElems, 1);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset stringDataOffset\n     */\n    static addStringData(builder: flatbuffers.Builder, stringDataOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(5, stringDataOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createStringDataVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startStringDataVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endTensor(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createTensor(\n        builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset, docStringOffset: flatbuffers.Offset,\n        dimsOffset: flatbuffers.Offset, dataType: onnxruntime.experimental.fbs.TensorDataType,\n        rawDataOffset: flatbuffers.Offset, stringDataOffset: flatbuffers.Offset): flatbuffers.Offset {\n      Tensor.startTensor(builder);\n      Tensor.addName(builder, nameOffset);\n      Tensor.addDocString(builder, docStringOffset);\n      Tensor.addDims(builder, dimsOffset);\n      Tensor.addDataType(builder, dataType);\n      Tensor.addRawData(builder, rawDataOffset);\n      Tensor.addStringData(builder, stringDataOffset);\n      return Tensor.endTensor(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class SparseTensor {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns SparseTensor\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): SparseTensor {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SparseTensor= obj\n     * @returns SparseTensor\n     */\n    static getRootAsSparseTensor(bb: flatbuffers.ByteBuffer, obj?: SparseTensor): SparseTensor {\n      return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SparseTensor= obj\n     * @returns SparseTensor\n     */\n    static getSizePrefixedRootAsSparseTensor(bb: flatbuffers.ByteBuffer, obj?: SparseTensor): SparseTensor {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Tensor= obj\n     * @returns onnxruntime.experimental.fbs.Tensor|null\n     */\n    values(obj?: onnxruntime.experimental.fbs.Tensor): onnxruntime.experimental.fbs.Tensor|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Tensor())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Tensor= obj\n     * @returns onnxruntime.experimental.fbs.Tensor|null\n     */\n    indices(obj?: onnxruntime.experimental.fbs.Tensor): onnxruntime.experimental.fbs.Tensor|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Tensor())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param number index\n     * @returns flatbuffers.Long\n     */\n    dims(index: number): flatbuffers.Long|null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.readInt64(this.bb!.__vector(this.bb_pos + offset) + index * 8) :\n                      this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @returns number\n     */\n    dimsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startSparseTensor(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset valuesOffset\n     */\n    static addValues(builder: flatbuffers.Builder, valuesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, valuesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset indicesOffset\n     */\n    static addIndices(builder: flatbuffers.Builder, indicesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, indicesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset dimsOffset\n     */\n    static addDims(builder: flatbuffers.Builder, dimsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, dimsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Long> data\n     * @returns flatbuffers.Offset\n     */\n    static createDimsVector(builder: flatbuffers.Builder, data: flatbuffers.Long[]): flatbuffers.Offset {\n      builder.startVector(8, data.length, 8);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt64(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startDimsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(8, numElems, 8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endSparseTensor(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createSparseTensor(\n        builder: flatbuffers.Builder, valuesOffset: flatbuffers.Offset, indicesOffset: flatbuffers.Offset,\n        dimsOffset: flatbuffers.Offset): flatbuffers.Offset {\n      SparseTensor.startSparseTensor(builder);\n      SparseTensor.addValues(builder, valuesOffset);\n      SparseTensor.addIndices(builder, indicesOffset);\n      SparseTensor.addDims(builder, dimsOffset);\n      return SparseTensor.endSparseTensor(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Attribute {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Attribute\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Attribute {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Attribute= obj\n     * @returns Attribute\n     */\n    static getRootAsAttribute(bb: flatbuffers.ByteBuffer, obj?: Attribute): Attribute {\n      return (obj || new Attribute()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Attribute= obj\n     * @returns Attribute\n     */\n    static getSizePrefixedRootAsAttribute(bb: flatbuffers.ByteBuffer, obj?: Attribute): Attribute {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Attribute()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    name(): string|null;\n    name(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    name(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    docString(): string|null;\n    docString(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    docString(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.AttributeType\n     */\n    type(): onnxruntime.experimental.fbs.AttributeType {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? /**  */ (this.bb!.readInt32(this.bb_pos + offset)) :\n                      onnxruntime.experimental.fbs.AttributeType.UNDEFINED;\n    }\n\n    /**\n     * @returns number\n     */\n    f(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 10);\n      return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;\n    }\n\n    /**\n     * @returns flatbuffers.Long\n     */\n    i(): flatbuffers.Long {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    s(): string|null;\n    s(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    s(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Tensor= obj\n     * @returns onnxruntime.experimental.fbs.Tensor|null\n     */\n    t(obj?: onnxruntime.experimental.fbs.Tensor): onnxruntime.experimental.fbs.Tensor|null {\n      let offset = this.bb!.__offset(this.bb_pos, 16);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Tensor())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Graph= obj\n     * @returns onnxruntime.experimental.fbs.Graph|null\n     */\n    g(obj?: onnxruntime.experimental.fbs.Graph): onnxruntime.experimental.fbs.Graph|null {\n      let offset = this.bb!.__offset(this.bb_pos, 18);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Graph())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param number index\n     * @returns number\n     */\n    floats(index: number): number|null {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset ? this.bb!.readFloat32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    floatsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns Float32Array\n     */\n    floatsArray(): Float32Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset ?\n          new Float32Array(\n              this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),\n              this.bb!.__vector_len(this.bb_pos + offset)) :\n          null;\n    }\n\n    /**\n     * @param number index\n     * @returns flatbuffers.Long\n     */\n    ints(index: number): flatbuffers.Long|null {\n      let offset = this.bb!.__offset(this.bb_pos, 22);\n      return offset ? this.bb!.readInt64(this.bb!.__vector(this.bb_pos + offset) + index * 8) :\n                      this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @returns number\n     */\n    intsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 22);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    strings(index: number): string;\n    strings(index: number, optionalEncoding: flatbuffers.Encoding): string|Uint8Array;\n    strings(index: number, optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 24);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    stringsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 24);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Tensor= obj\n     * @returns onnxruntime.experimental.fbs.Tensor\n     */\n    tensors(index: number, obj?: onnxruntime.experimental.fbs.Tensor): onnxruntime.experimental.fbs.Tensor|null {\n      let offset = this.bb!.__offset(this.bb_pos, 26);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Tensor())\n                          .__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    tensorsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 26);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Graph= obj\n     * @returns onnxruntime.experimental.fbs.Graph\n     */\n    graphs(index: number, obj?: onnxruntime.experimental.fbs.Graph): onnxruntime.experimental.fbs.Graph|null {\n      let offset = this.bb!.__offset(this.bb_pos, 28);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Graph())\n                          .__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    graphsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 28);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startAttribute(builder: flatbuffers.Builder) {\n      builder.startObject(13);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nameOffset\n     */\n    static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, nameOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset docStringOffset\n     */\n    static addDocString(builder: flatbuffers.Builder, docStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, docStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.AttributeType type\n     */\n    static addType(builder: flatbuffers.Builder, type: onnxruntime.experimental.fbs.AttributeType) {\n      builder.addFieldInt32(2, type, onnxruntime.experimental.fbs.AttributeType.UNDEFINED);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number f\n     */\n    static addF(builder: flatbuffers.Builder, f: number) {\n      builder.addFieldFloat32(3, f, 0.0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Long i\n     */\n    static addI(builder: flatbuffers.Builder, i: flatbuffers.Long) {\n      builder.addFieldInt64(4, i, builder.createLong(0, 0));\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset sOffset\n     */\n    static addS(builder: flatbuffers.Builder, sOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(5, sOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset tOffset\n     */\n    static addT(builder: flatbuffers.Builder, tOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(6, tOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset gOffset\n     */\n    static addG(builder: flatbuffers.Builder, gOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(7, gOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset floatsOffset\n     */\n    static addFloats(builder: flatbuffers.Builder, floatsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(8, floatsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<number> data\n     * @returns flatbuffers.Offset\n     */\n    static createFloatsVector(builder: flatbuffers.Builder, data: number[]|Uint8Array): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addFloat32(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startFloatsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset intsOffset\n     */\n    static addInts(builder: flatbuffers.Builder, intsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(9, intsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Long> data\n     * @returns flatbuffers.Offset\n     */\n    static createIntsVector(builder: flatbuffers.Builder, data: flatbuffers.Long[]): flatbuffers.Offset {\n      builder.startVector(8, data.length, 8);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt64(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startIntsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(8, numElems, 8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset stringsOffset\n     */\n    static addStrings(builder: flatbuffers.Builder, stringsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(10, stringsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createStringsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startStringsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset tensorsOffset\n     */\n    static addTensors(builder: flatbuffers.Builder, tensorsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(11, tensorsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createTensorsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startTensorsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset graphsOffset\n     */\n    static addGraphs(builder: flatbuffers.Builder, graphsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(12, graphsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createGraphsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startGraphsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endAttribute(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createAttribute(\n        builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset, docStringOffset: flatbuffers.Offset,\n        type: onnxruntime.experimental.fbs.AttributeType, f: number, i: flatbuffers.Long, sOffset: flatbuffers.Offset,\n        tOffset: flatbuffers.Offset, gOffset: flatbuffers.Offset, floatsOffset: flatbuffers.Offset,\n        intsOffset: flatbuffers.Offset, stringsOffset: flatbuffers.Offset, tensorsOffset: flatbuffers.Offset,\n        graphsOffset: flatbuffers.Offset): flatbuffers.Offset {\n      Attribute.startAttribute(builder);\n      Attribute.addName(builder, nameOffset);\n      Attribute.addDocString(builder, docStringOffset);\n      Attribute.addType(builder, type);\n      Attribute.addF(builder, f);\n      Attribute.addI(builder, i);\n      Attribute.addS(builder, sOffset);\n      Attribute.addT(builder, tOffset);\n      Attribute.addG(builder, gOffset);\n      Attribute.addFloats(builder, floatsOffset);\n      Attribute.addInts(builder, intsOffset);\n      Attribute.addStrings(builder, stringsOffset);\n      Attribute.addTensors(builder, tensorsOffset);\n      Attribute.addGraphs(builder, graphsOffset);\n      return Attribute.endAttribute(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Graph {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Graph\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Graph {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Graph= obj\n     * @returns Graph\n     */\n    static getRootAsGraph(bb: flatbuffers.ByteBuffer, obj?: Graph): Graph {\n      return (obj || new Graph()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Graph= obj\n     * @returns Graph\n     */\n    static getSizePrefixedRootAsGraph(bb: flatbuffers.ByteBuffer, obj?: Graph): Graph {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Graph()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Tensor= obj\n     * @returns onnxruntime.experimental.fbs.Tensor\n     */\n    initializers(index: number, obj?: onnxruntime.experimental.fbs.Tensor): onnxruntime.experimental.fbs.Tensor|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Tensor())\n                          .__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    initializersLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.ValueInfo= obj\n     * @returns onnxruntime.experimental.fbs.ValueInfo\n     */\n    nodeArgs(index: number, obj?: onnxruntime.experimental.fbs.ValueInfo): onnxruntime.experimental.fbs.ValueInfo|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? (obj || new onnxruntime.experimental.fbs.ValueInfo())\n                          .__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    nodeArgsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Node= obj\n     * @returns onnxruntime.experimental.fbs.Node\n     */\n    nodes(index: number, obj?: onnxruntime.experimental.fbs.Node): onnxruntime.experimental.fbs.Node|null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Node())\n                          .__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    nodesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    maxNodeIndex(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 10);\n      return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.NodeEdge= obj\n     * @returns onnxruntime.experimental.fbs.NodeEdge\n     */\n    nodeEdges(index: number, obj?: onnxruntime.experimental.fbs.NodeEdge): onnxruntime.experimental.fbs.NodeEdge|null {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? (obj || new onnxruntime.experimental.fbs.NodeEdge())\n                          .__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    nodeEdgesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    inputs(index: number): string;\n    inputs(index: number, optionalEncoding: flatbuffers.Encoding): string|Uint8Array;\n    inputs(index: number, optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    inputsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    outputs(index: number): string;\n    outputs(index: number, optionalEncoding: flatbuffers.Encoding): string|Uint8Array;\n    outputs(index: number, optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 16);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    outputsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 16);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.SparseTensor= obj\n     * @returns onnxruntime.experimental.fbs.SparseTensor\n     */\n    sparseInitializers(index: number, obj?: onnxruntime.experimental.fbs.SparseTensor):\n        onnxruntime.experimental.fbs.SparseTensor|null {\n      let offset = this.bb!.__offset(this.bb_pos, 18);\n      return offset ? (obj || new onnxruntime.experimental.fbs.SparseTensor())\n                          .__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    sparseInitializersLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 18);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startGraph(builder: flatbuffers.Builder) {\n      builder.startObject(8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset initializersOffset\n     */\n    static addInitializers(builder: flatbuffers.Builder, initializersOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, initializersOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createInitializersVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startInitializersVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nodeArgsOffset\n     */\n    static addNodeArgs(builder: flatbuffers.Builder, nodeArgsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, nodeArgsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createNodeArgsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startNodeArgsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nodesOffset\n     */\n    static addNodes(builder: flatbuffers.Builder, nodesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, nodesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createNodesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startNodesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number maxNodeIndex\n     */\n    static addMaxNodeIndex(builder: flatbuffers.Builder, maxNodeIndex: number) {\n      builder.addFieldInt32(3, maxNodeIndex, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nodeEdgesOffset\n     */\n    static addNodeEdges(builder: flatbuffers.Builder, nodeEdgesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(4, nodeEdgesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createNodeEdgesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startNodeEdgesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset inputsOffset\n     */\n    static addInputs(builder: flatbuffers.Builder, inputsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(5, inputsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createInputsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startInputsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset outputsOffset\n     */\n    static addOutputs(builder: flatbuffers.Builder, outputsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(6, outputsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createOutputsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startOutputsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset sparseInitializersOffset\n     */\n    static addSparseInitializers(builder: flatbuffers.Builder, sparseInitializersOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(7, sparseInitializersOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createSparseInitializersVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]):\n        flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startSparseInitializersVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endGraph(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createGraph(\n        builder: flatbuffers.Builder, initializersOffset: flatbuffers.Offset, nodeArgsOffset: flatbuffers.Offset,\n        nodesOffset: flatbuffers.Offset, maxNodeIndex: number, nodeEdgesOffset: flatbuffers.Offset,\n        inputsOffset: flatbuffers.Offset, outputsOffset: flatbuffers.Offset,\n        sparseInitializersOffset: flatbuffers.Offset): flatbuffers.Offset {\n      Graph.startGraph(builder);\n      Graph.addInitializers(builder, initializersOffset);\n      Graph.addNodeArgs(builder, nodeArgsOffset);\n      Graph.addNodes(builder, nodesOffset);\n      Graph.addMaxNodeIndex(builder, maxNodeIndex);\n      Graph.addNodeEdges(builder, nodeEdgesOffset);\n      Graph.addInputs(builder, inputsOffset);\n      Graph.addOutputs(builder, outputsOffset);\n      Graph.addSparseInitializers(builder, sparseInitializersOffset);\n      return Graph.endGraph(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Model {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Model\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Model {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Model= obj\n     * @returns Model\n     */\n    static getRootAsModel(bb: flatbuffers.ByteBuffer, obj?: Model): Model {\n      return (obj || new Model()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Model= obj\n     * @returns Model\n     */\n    static getSizePrefixedRootAsModel(bb: flatbuffers.ByteBuffer, obj?: Model): Model {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Model()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @returns flatbuffers.Long\n     */\n    irVersion(): flatbuffers.Long {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.OperatorSetId= obj\n     * @returns onnxruntime.experimental.fbs.OperatorSetId\n     */\n    opsetImport(index: number, obj?: onnxruntime.experimental.fbs.OperatorSetId):\n        onnxruntime.experimental.fbs.OperatorSetId|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? (obj || new onnxruntime.experimental.fbs.OperatorSetId())\n                          .__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    opsetImportLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    producerName(): string|null;\n    producerName(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    producerName(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    producerVersion(): string|null;\n    producerVersion(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    producerVersion(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 10);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    domain(): string|null;\n    domain(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    domain(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns flatbuffers.Long\n     */\n    modelVersion(): flatbuffers.Long {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    docString(): string|null;\n    docString(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    docString(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 16);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Graph= obj\n     * @returns onnxruntime.experimental.fbs.Graph|null\n     */\n    graph(obj?: onnxruntime.experimental.fbs.Graph): onnxruntime.experimental.fbs.Graph|null {\n      let offset = this.bb!.__offset(this.bb_pos, 18);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Graph())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    graphDocString(): string|null;\n    graphDocString(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    graphDocString(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startModel(builder: flatbuffers.Builder) {\n      builder.startObject(9);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Long irVersion\n     */\n    static addIrVersion(builder: flatbuffers.Builder, irVersion: flatbuffers.Long) {\n      builder.addFieldInt64(0, irVersion, builder.createLong(0, 0));\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset opsetImportOffset\n     */\n    static addOpsetImport(builder: flatbuffers.Builder, opsetImportOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, opsetImportOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createOpsetImportVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startOpsetImportVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset producerNameOffset\n     */\n    static addProducerName(builder: flatbuffers.Builder, producerNameOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, producerNameOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset producerVersionOffset\n     */\n    static addProducerVersion(builder: flatbuffers.Builder, producerVersionOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(3, producerVersionOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset domainOffset\n     */\n    static addDomain(builder: flatbuffers.Builder, domainOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(4, domainOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Long modelVersion\n     */\n    static addModelVersion(builder: flatbuffers.Builder, modelVersion: flatbuffers.Long) {\n      builder.addFieldInt64(5, modelVersion, builder.createLong(0, 0));\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset docStringOffset\n     */\n    static addDocString(builder: flatbuffers.Builder, docStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(6, docStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset graphOffset\n     */\n    static addGraph(builder: flatbuffers.Builder, graphOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(7, graphOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset graphDocStringOffset\n     */\n    static addGraphDocString(builder: flatbuffers.Builder, graphDocStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(8, graphDocStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endModel(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createModel(\n        builder: flatbuffers.Builder, irVersion: flatbuffers.Long, opsetImportOffset: flatbuffers.Offset,\n        producerNameOffset: flatbuffers.Offset, producerVersionOffset: flatbuffers.Offset,\n        domainOffset: flatbuffers.Offset, modelVersion: flatbuffers.Long, docStringOffset: flatbuffers.Offset,\n        graphOffset: flatbuffers.Offset, graphDocStringOffset: flatbuffers.Offset): flatbuffers.Offset {\n      Model.startModel(builder);\n      Model.addIrVersion(builder, irVersion);\n      Model.addOpsetImport(builder, opsetImportOffset);\n      Model.addProducerName(builder, producerNameOffset);\n      Model.addProducerVersion(builder, producerVersionOffset);\n      Model.addDomain(builder, domainOffset);\n      Model.addModelVersion(builder, modelVersion);\n      Model.addDocString(builder, docStringOffset);\n      Model.addGraph(builder, graphOffset);\n      Model.addGraphDocString(builder, graphDocStringOffset);\n      return Model.endModel(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class KernelCreateInfos {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns KernelCreateInfos\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): KernelCreateInfos {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param KernelCreateInfos= obj\n     * @returns KernelCreateInfos\n     */\n    static getRootAsKernelCreateInfos(bb: flatbuffers.ByteBuffer, obj?: KernelCreateInfos): KernelCreateInfos {\n      return (obj || new KernelCreateInfos()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param KernelCreateInfos= obj\n     * @returns KernelCreateInfos\n     */\n    static getSizePrefixedRootAsKernelCreateInfos(bb: flatbuffers.ByteBuffer, obj?: KernelCreateInfos):\n        KernelCreateInfos {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new KernelCreateInfos()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param number index\n     * @returns number\n     */\n    nodeIndices(index: number): number|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.readUint32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    nodeIndicesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns Uint32Array\n     */\n    nodeIndicesArray(): Uint32Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ?\n          new Uint32Array(\n              this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),\n              this.bb!.__vector_len(this.bb_pos + offset)) :\n          null;\n    }\n\n    /**\n     * @param number index\n     * @returns flatbuffers.Long\n     */\n    kernelDefHashes(index: number): flatbuffers.Long|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.readUint64(this.bb!.__vector(this.bb_pos + offset) + index * 8) :\n                      this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @returns number\n     */\n    kernelDefHashesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startKernelCreateInfos(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nodeIndicesOffset\n     */\n    static addNodeIndices(builder: flatbuffers.Builder, nodeIndicesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, nodeIndicesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<number> data\n     * @returns flatbuffers.Offset\n     */\n    static createNodeIndicesVector(builder: flatbuffers.Builder, data: number[]|Uint8Array): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt32(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startNodeIndicesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset kernelDefHashesOffset\n     */\n    static addKernelDefHashes(builder: flatbuffers.Builder, kernelDefHashesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, kernelDefHashesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Long> data\n     * @returns flatbuffers.Offset\n     */\n    static createKernelDefHashesVector(builder: flatbuffers.Builder, data: flatbuffers.Long[]): flatbuffers.Offset {\n      builder.startVector(8, data.length, 8);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt64(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startKernelDefHashesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(8, numElems, 8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endKernelCreateInfos(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createKernelCreateInfos(\n        builder: flatbuffers.Builder, nodeIndicesOffset: flatbuffers.Offset,\n        kernelDefHashesOffset: flatbuffers.Offset): flatbuffers.Offset {\n      KernelCreateInfos.startKernelCreateInfos(builder);\n      KernelCreateInfos.addNodeIndices(builder, nodeIndicesOffset);\n      KernelCreateInfos.addKernelDefHashes(builder, kernelDefHashesOffset);\n      return KernelCreateInfos.endKernelCreateInfos(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class SubGraphSessionState {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns SubGraphSessionState\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): SubGraphSessionState {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SubGraphSessionState= obj\n     * @returns SubGraphSessionState\n     */\n    static getRootAsSubGraphSessionState(bb: flatbuffers.ByteBuffer, obj?: SubGraphSessionState): SubGraphSessionState {\n      return (obj || new SubGraphSessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SubGraphSessionState= obj\n     * @returns SubGraphSessionState\n     */\n    static getSizePrefixedRootAsSubGraphSessionState(bb: flatbuffers.ByteBuffer, obj?: SubGraphSessionState):\n        SubGraphSessionState {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new SubGraphSessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    graphId(): string|null;\n    graphId(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    graphId(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.SessionState= obj\n     * @returns onnxruntime.experimental.fbs.SessionState|null\n     */\n    sessionState(obj?: onnxruntime.experimental.fbs.SessionState): onnxruntime.experimental.fbs.SessionState|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? (obj || new onnxruntime.experimental.fbs.SessionState())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startSubGraphSessionState(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset graphIdOffset\n     */\n    static addGraphId(builder: flatbuffers.Builder, graphIdOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, graphIdOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset sessionStateOffset\n     */\n    static addSessionState(builder: flatbuffers.Builder, sessionStateOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, sessionStateOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endSubGraphSessionState(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      builder.requiredField(offset, 4);  // graph_id\n      return offset;\n    }\n\n    static createSubGraphSessionState(\n        builder: flatbuffers.Builder, graphIdOffset: flatbuffers.Offset,\n        sessionStateOffset: flatbuffers.Offset): flatbuffers.Offset {\n      SubGraphSessionState.startSubGraphSessionState(builder);\n      SubGraphSessionState.addGraphId(builder, graphIdOffset);\n      SubGraphSessionState.addSessionState(builder, sessionStateOffset);\n      return SubGraphSessionState.endSubGraphSessionState(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class SessionState {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns SessionState\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): SessionState {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SessionState= obj\n     * @returns SessionState\n     */\n    static getRootAsSessionState(bb: flatbuffers.ByteBuffer, obj?: SessionState): SessionState {\n      return (obj || new SessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SessionState= obj\n     * @returns SessionState\n     */\n    static getSizePrefixedRootAsSessionState(bb: flatbuffers.ByteBuffer, obj?: SessionState): SessionState {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new SessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.KernelCreateInfos= obj\n     * @returns onnxruntime.experimental.fbs.KernelCreateInfos|null\n     */\n    kernels(obj?: onnxruntime.experimental.fbs.KernelCreateInfos): onnxruntime.experimental.fbs.KernelCreateInfos|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? (obj || new onnxruntime.experimental.fbs.KernelCreateInfos())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.SubGraphSessionState= obj\n     * @returns onnxruntime.experimental.fbs.SubGraphSessionState\n     */\n    subGraphSessionStates(index: number, obj?: onnxruntime.experimental.fbs.SubGraphSessionState):\n        onnxruntime.experimental.fbs.SubGraphSessionState|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? (obj || new onnxruntime.experimental.fbs.SubGraphSessionState())\n                          .__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    subGraphSessionStatesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startSessionState(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset kernelsOffset\n     */\n    static addKernels(builder: flatbuffers.Builder, kernelsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, kernelsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset subGraphSessionStatesOffset\n     */\n    static addSubGraphSessionStates(builder: flatbuffers.Builder, subGraphSessionStatesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, subGraphSessionStatesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createSubGraphSessionStatesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]):\n        flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startSubGraphSessionStatesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endSessionState(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createSessionState(\n        builder: flatbuffers.Builder, kernelsOffset: flatbuffers.Offset,\n        subGraphSessionStatesOffset: flatbuffers.Offset): flatbuffers.Offset {\n      SessionState.startSessionState(builder);\n      SessionState.addKernels(builder, kernelsOffset);\n      SessionState.addSubGraphSessionStates(builder, subGraphSessionStatesOffset);\n      return SessionState.endSessionState(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class InferenceSession {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns InferenceSession\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): InferenceSession {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param InferenceSession= obj\n     * @returns InferenceSession\n     */\n    static getRootAsInferenceSession(bb: flatbuffers.ByteBuffer, obj?: InferenceSession): InferenceSession {\n      return (obj || new InferenceSession()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param InferenceSession= obj\n     * @returns InferenceSession\n     */\n    static getSizePrefixedRootAsInferenceSession(bb: flatbuffers.ByteBuffer, obj?: InferenceSession): InferenceSession {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new InferenceSession()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @returns boolean\n     */\n    static bufferHasIdentifier(bb: flatbuffers.ByteBuffer): boolean {\n      return bb.__has_identifier('ORTM');\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    ortVersion(): string|null;\n    ortVersion(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    ortVersion(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Model= obj\n     * @returns onnxruntime.experimental.fbs.Model|null\n     */\n    model(obj?: onnxruntime.experimental.fbs.Model): onnxruntime.experimental.fbs.Model|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Model())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.SessionState= obj\n     * @returns onnxruntime.experimental.fbs.SessionState|null\n     */\n    sessionState(obj?: onnxruntime.experimental.fbs.SessionState): onnxruntime.experimental.fbs.SessionState|null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? (obj || new onnxruntime.experimental.fbs.SessionState())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startInferenceSession(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset ortVersionOffset\n     */\n    static addOrtVersion(builder: flatbuffers.Builder, ortVersionOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, ortVersionOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset modelOffset\n     */\n    static addModel(builder: flatbuffers.Builder, modelOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, modelOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset sessionStateOffset\n     */\n    static addSessionState(builder: flatbuffers.Builder, sessionStateOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, sessionStateOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endInferenceSession(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset offset\n     */\n    static finishInferenceSessionBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset) {\n      builder.finish(offset, 'ORTM');\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset offset\n     */\n    static finishSizePrefixedInferenceSessionBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset) {\n      builder.finish(offset, 'ORTM', true);\n    }\n\n    static createInferenceSession(\n        builder: flatbuffers.Builder, ortVersionOffset: flatbuffers.Offset, modelOffset: flatbuffers.Offset,\n        sessionStateOffset: flatbuffers.Offset): flatbuffers.Offset {\n      InferenceSession.startInferenceSession(builder);\n      InferenceSession.addOrtVersion(builder, ortVersionOffset);\n      InferenceSession.addModel(builder, modelOffset);\n      InferenceSession.addSessionState(builder, sessionStateOffset);\n      return InferenceSession.endInferenceSession(builder);\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {InferenceSession, SessionHandler, Tensor} from 'onnxruntime-common';\n\nimport {Session} from './session';\nimport {Tensor as OnnxjsTensor} from './tensor';\n\nexport class OnnxjsSessionHandler implements SessionHandler {\n  constructor(private session: Session) {\n    this.inputNames = this.session.inputNames;\n    this.outputNames = this.session.outputNames;\n  }\n\n  async dispose(): Promise<void> {}\n  inputNames: readonly string[];\n  outputNames: readonly string[];\n  async run(\n      feeds: SessionHandler.FeedsType, _fetches: SessionHandler.FetchesType,\n      _options: InferenceSession.RunOptions): Promise<SessionHandler.ReturnType> {\n    const inputMap = new Map<string, OnnxjsTensor>();\n    for (const name in feeds) {\n      if (Object.hasOwnProperty.call(feeds, name)) {\n        const feed = feeds[name];\n        inputMap.set(\n            name,\n            new OnnxjsTensor(\n                feed.dims, feed.type as OnnxjsTensor.DataType, undefined, undefined,\n                feed.data as OnnxjsTensor.NumberType));\n      }\n    }\n    const outputMap = await this.session.run(inputMap);\n    const output: SessionHandler.ReturnType = {};\n    outputMap.forEach((tensor, name) => {\n      output[name] = new Tensor(tensor.type, tensor.data, tensor.dims);\n    });\n    return output;\n  }\n  startProfiling(): void {\n    this.session.startProfiling();\n  }\n  endProfiling(): void {\n    this.session.endProfiling();\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {readFile} from 'fs';\nimport {promisify} from 'util';\n\nimport {resolveBackend, SessionHandlerType} from './backend';\nimport {ExecutionPlan} from './execution-plan';\nimport {Graph} from './graph';\nimport {Profiler} from './instrument';\nimport {Model} from './model';\nimport {Operator} from './operators';\nimport {Tensor} from './tensor';\n\nexport declare namespace Session {\n  export interface Config {\n    backendHint?: string;\n    profiler?: Profiler.Config;\n  }\n\n  export interface Context {\n    profiler: Readonly<Profiler>;\n    graphInputTypes?: Tensor.DataType[];\n    graphInputDims?: Array<readonly number[]>;\n  }\n}\n\nexport class Session {\n  constructor(config: Session.Config = {}) {\n    this._initialized = false;\n    this.backendHint = config.backendHint;\n    this.profiler = Profiler.create(config.profiler);\n    this.context = {profiler: this.profiler, graphInputTypes: [], graphInputDims: []};\n  }\n\n  get inputNames(): readonly string[] {\n    return this._model.graph.getInputNames();\n  }\n  get outputNames(): readonly string[] {\n    return this._model.graph.getOutputNames();\n  }\n\n  startProfiling() {\n    this.profiler.start();\n  }\n\n  endProfiling() {\n    this.profiler.stop();\n  }\n\n  async loadModel(uri: string): Promise<void>;\n  async loadModel(buffer: ArrayBuffer, byteOffset?: number, length?: number): Promise<void>;\n  async loadModel(buffer: Uint8Array): Promise<void>;\n  async loadModel(arg: string|ArrayBuffer|Uint8Array, byteOffset?: number, length?: number): Promise<void> {\n    await this.profiler.event('session', 'Session.loadModel', async () => {\n      // resolve backend and session handler\n      const backend = await resolveBackend(this.backendHint);\n      this.sessionHandler = backend.createSessionHandler(this.context);\n\n      this._model = new Model();\n      if (typeof arg === 'string') {\n        const isOrtFormat = arg.endsWith('.ort');\n        if (typeof process !== 'undefined' && process.versions && process.versions.node) {\n          // node\n          const buf = await promisify(readFile)(arg);\n          this.initialize(buf, isOrtFormat);\n        } else {\n          // browser\n          const response = await fetch(arg);\n          const buf = await response.arrayBuffer();\n          this.initialize(new Uint8Array(buf), isOrtFormat);\n        }\n      } else if (!ArrayBuffer.isView(arg)) {\n        // load model from ArrayBuffer\n        const arr = new Uint8Array(arg, byteOffset || 0, length || arg.byteLength);\n        this.initialize(arr);\n      } else {\n        // load model from Uint8array\n        this.initialize(arg);\n      }\n    });\n  }\n\n  private initialize(modelProtoBlob: Uint8Array, isOrtFormat?: boolean): void {\n    if (this._initialized) {\n      throw new Error('already initialized');\n    }\n\n    this.profiler.event('session', 'Session.initialize', () => {\n      // load graph\n      const graphInitializer =\n          this.sessionHandler.transformGraph ? this.sessionHandler as Graph.Initializer : undefined;\n      this._model.load(modelProtoBlob, graphInitializer, isOrtFormat);\n\n      // graph is completely initialzied at this stage , let the interested handlers know\n      if (this.sessionHandler.onGraphInitialized) {\n        this.sessionHandler.onGraphInitialized(this._model.graph);\n      }\n      // initialize each operator in the graph\n      this.initializeOps(this._model.graph);\n\n      // instantiate an ExecutionPlan object to be used by the Session object\n      this._executionPlan = new ExecutionPlan(this._model.graph, this._ops, this.profiler);\n    });\n\n    this._initialized = true;\n  }\n\n  async run(inputs: Map<string, Tensor>|Tensor[]): Promise<Map<string, Tensor>> {\n    if (!this._initialized) {\n      throw new Error('session not initialized yet');\n    }\n\n    return this.profiler.event('session', 'Session.run', async () => {\n      const inputTensors = this.normalizeAndValidateInputs(inputs);\n\n      const outputTensors = await this._executionPlan.execute(this.sessionHandler, inputTensors);\n\n      return this.createOutput(outputTensors);\n    });\n  }\n\n  private normalizeAndValidateInputs(inputs: Map<string, Tensor>|Tensor[]): Tensor[] {\n    const modelInputNames = this._model.graph.getInputNames();\n\n    // normalize inputs\n    // inputs: Tensor[]\n    if (Array.isArray(inputs)) {\n      if (inputs.length !== modelInputNames.length) {\n        throw new Error(`incorrect input array length: expected ${modelInputNames.length} but got ${inputs.length}`);\n      }\n    }\n    // convert map to array\n    // inputs: Map<string, Tensor>\n    else {\n      if (inputs.size !== modelInputNames.length) {\n        throw new Error(`incorrect input map size: expected ${modelInputNames.length} but got ${inputs.size}`);\n      }\n\n      const sortedInputs = new Array<Tensor>(inputs.size);\n      let sortedInputsIndex = 0;\n      for (let i = 0; i < modelInputNames.length; ++i) {\n        const tensor = inputs.get(modelInputNames[i]);\n        if (!tensor) {\n          throw new Error(`missing input tensor for: '${name}'`);\n        }\n        sortedInputs[sortedInputsIndex++] = tensor;\n      }\n\n      inputs = sortedInputs;\n    }\n\n    // validate dims requirements\n    // First session run - graph input data is not cached for the session\n    if (!this.context.graphInputTypes || this.context.graphInputTypes.length === 0 || !this.context.graphInputDims ||\n        this.context.graphInputDims.length === 0) {\n      const modelInputIndices = this._model.graph.getInputIndices();\n      const modelValues = this._model.graph.getValues();\n\n      const graphInputDims = new Array<readonly number[]>(modelInputIndices.length);\n\n      for (let i = 0; i < modelInputIndices.length; ++i) {\n        const graphInput = modelValues[modelInputIndices[i]];\n        graphInputDims[i] = graphInput.type!.shape.dims;\n\n        // cached for second and subsequent runs.\n        // Some parts of the framework works on the assumption that the graph and types and shapes are static\n        this.context.graphInputTypes!.push(graphInput.type!.tensorType);\n        this.context.graphInputDims!.push(inputs[i].dims);\n      }\n\n      this.validateInputTensorDims(graphInputDims, inputs, true);\n    }\n\n    // Second and subsequent session runs - graph input data is cached for the session\n    else {\n      this.validateInputTensorDims(this.context.graphInputDims, inputs, false);\n    }\n\n    // validate types requirement\n    this.validateInputTensorTypes(this.context.graphInputTypes!, inputs);\n\n    return inputs;\n  }\n\n  private validateInputTensorTypes(graphInputTypes: Tensor.DataType[], givenInputs: Tensor[]) {\n    for (let i = 0; i < givenInputs.length; i++) {\n      const expectedType = graphInputTypes[i];\n      const actualType = givenInputs[i].type;\n      if (expectedType !== actualType) {\n        throw new Error(`input tensor[${i}] check failed: expected type '${expectedType}' but got ${actualType}`);\n      }\n    }\n  }\n\n  private validateInputTensorDims(\n      graphInputDims: Array<readonly number[]>, givenInputs: Tensor[], noneDimSupported: boolean) {\n    for (let i = 0; i < givenInputs.length; i++) {\n      const expectedDims = graphInputDims[i];\n      const actualDims = givenInputs[i].dims;\n      if (!this.compareTensorDims(expectedDims, actualDims, noneDimSupported)) {\n        throw new Error(`input tensor[${i}] check failed: expected shape '[${expectedDims.join(',')}]' but got [${\n            actualDims.join(',')}]`);\n      }\n    }\n  }\n\n  private compareTensorDims(expectedDims: readonly number[], actualDims: readonly number[], noneDimSupported: boolean):\n      boolean {\n    if (expectedDims.length !== actualDims.length) {\n      return false;\n    }\n\n    for (let i = 0; i < expectedDims.length; ++i) {\n      if (expectedDims[i] !== actualDims[i] && (!noneDimSupported || expectedDims[i] !== 0)) {\n        // data shape mis-match AND not a 'None' dimension.\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private createOutput(outputTensors: Tensor[]): Map<string, Tensor> {\n    const modelOutputNames = this._model.graph.getOutputNames();\n    if (outputTensors.length !== modelOutputNames.length) {\n      throw new Error('expected number of outputs do not match number of generated outputs');\n    }\n\n    const output = new Map<string, Tensor>();\n    for (let i = 0; i < modelOutputNames.length; ++i) {\n      output.set(modelOutputNames[i], outputTensors[i]);\n    }\n\n    return output;\n  }\n\n  private initializeOps(graph: Graph): void {\n    const nodes = graph.getNodes();\n    this._ops = new Array(nodes.length);\n\n    for (let i = 0; i < nodes.length; i++) {\n      this._ops[i] = this.sessionHandler.resolve(nodes[i], this._model.opsets, graph);\n    }\n  }\n\n  private _model: Model;\n  private _initialized: boolean;\n\n  private _ops: Operator[];\n  private _executionPlan: ExecutionPlan;\n\n  private backendHint?: string;\n\n  private sessionHandler: SessionHandlerType;\n  private context: Session.Context;\n  private profiler: Readonly<Profiler>;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Guid} from 'guid-typescript';\nimport Long from 'long';\n\nimport {onnxruntime} from './ort-schema/flatbuffers/ort-generated';\nimport {onnx} from './ort-schema/protobuf/onnx';\nimport {decodeUtf8String, ProtoUtil, ShapeUtil} from './util';\n\nimport ortFbs = onnxruntime.experimental.fbs;\n\nexport declare namespace Tensor {\n  export interface DataTypeMap {\n    bool: Uint8Array;\n    float32: Float32Array;\n    float64: Float64Array;\n    string: string[];\n    int8: Int8Array;\n    uint8: Uint8Array;\n    int16: Int16Array;\n    uint16: Uint16Array;\n    int32: Int32Array;\n    uint32: Uint32Array;\n    int64: BigInt64Array;\n  }\n\n  export type DataType = keyof DataTypeMap;\n\n  export type StringType = Tensor.DataTypeMap['string'];\n  export type BooleanType = Tensor.DataTypeMap['bool'];\n  export type IntegerType = Tensor.DataTypeMap['int8']|Tensor.DataTypeMap['uint8']|Tensor.DataTypeMap['int16']|\n                            Tensor.DataTypeMap['uint16']|Tensor.DataTypeMap['int32']|Tensor.DataTypeMap['uint32'];\n  export type FloatType = Tensor.DataTypeMap['float32']|Tensor.DataTypeMap['float64'];\n  export type NumberType = BooleanType|IntegerType|FloatType;\n\n  export type Id = Guid;\n}\n\ntype TensorData = Tensor.DataTypeMap[Tensor.DataType];\n\ntype DataProvider = (id: Tensor.Id) => TensorData;\ntype AsyncDataProvider = (id: Tensor.Id) => Promise<TensorData>;\n\nexport class Tensor {\n  /**\n   * get the underlying tensor data\n   */\n  get data(): TensorData {\n    if (this.cache === undefined) {\n      const data = this.dataProvider!(this.dataId);\n      if (data.length !== this.size) {\n        throw new Error('Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.');\n      }\n      this.cache = data;\n    }\n    return this.cache;\n  }\n\n  /**\n   * get the underlying string tensor data. Should only use when type is STRING\n   */\n  get stringData() {\n    if (this.type !== 'string') {\n      throw new TypeError('data type is not string');\n    }\n\n    return this.data as Tensor.StringType;\n  }\n\n  /**\n   * get the underlying integer tensor data. Should only use when type is one of the following: (UINT8, INT8, UINT16,\n   * INT16, INT32, UINT32, BOOL)\n   */\n  get integerData() {\n    switch (this.type) {\n      case 'uint8':\n      case 'int8':\n      case 'uint16':\n      case 'int16':\n      case 'int32':\n      case 'uint32':\n      case 'bool':\n        return this.data as Tensor.IntegerType;\n\n      default:\n        throw new TypeError('data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)');\n    }\n  }\n\n  /**\n   * get the underlying float tensor data. Should only use when type is one of the following: (FLOAT, DOUBLE)\n   */\n  get floatData() {\n    switch (this.type) {\n      case 'float32':\n      case 'float64':\n        return this.data as Tensor.FloatType;\n\n      default:\n        throw new TypeError('data type is not float (float32, float64)');\n    }\n  }\n\n  /**\n   * get the underlying number tensor data. Should only use when type is one of the following: (UINT8, INT8, UINT16,\n   * INT16, INT32, UINT32, BOOL, FLOAT, DOUBLE)\n   */\n  get numberData() {\n    if (this.type !== 'string') {\n      return this.data as Tensor.NumberType;\n    }\n    throw new TypeError('type cannot be non-number (string)');\n  }\n\n  /**\n   * get value of an element at the given indices\n   */\n  get(indices: readonly number[]): Tensor.DataTypeMap[Tensor.DataType][number] {\n    return this.data[ShapeUtil.indicesToOffset(indices, this.strides)];\n  }\n\n  /**\n   * set value of an element at the given indices\n   */\n  set(indices: readonly number[], value: Tensor.DataTypeMap[Tensor.DataType][number]) {\n    this.data[ShapeUtil.indicesToOffset(indices, this.strides)] = value;\n  }\n\n  /**\n   * get the underlying tensor data asynchronously\n   */\n  async getData(): Promise<TensorData> {\n    if (this.cache === undefined) {\n      this.cache = await this.asyncDataProvider!(this.dataId);\n    }\n    return this.cache;\n  }\n\n  /**\n   * get the number of elements in the tensor\n   */\n  public readonly size: number;\n\n  private _strides: readonly number[];\n  /**\n   * get the strides for each dimension\n   */\n  get strides(): readonly number[] {\n    if (!this._strides) {\n      this._strides = ShapeUtil.computeStrides(this.dims);\n    }\n    return this._strides;\n  }\n\n  constructor(\n      /**\n       * get the dimensions of the tensor\n       */\n      public readonly dims: readonly number[],\n      /**\n       * get the type of the tensor\n       */\n      public readonly type: Tensor.DataType, private dataProvider?: DataProvider,\n      private asyncDataProvider?: AsyncDataProvider, private cache?: TensorData,\n      /**\n       * get the data ID that used to map to a tensor data\n       */\n      public readonly dataId: Guid = Guid.create()) {\n    this.size = ShapeUtil.validateDimsAndCalcSize(dims);\n    const size = this.size;\n    const empty = (dataProvider === undefined && asyncDataProvider === undefined && cache === undefined);\n\n    if (cache !== undefined) {\n      if (cache.length !== size) {\n        throw new RangeError('Input dims doesn\\'t match data length.');\n      }\n    }\n\n    if (type === 'string') {\n      if (cache !== undefined && (!Array.isArray(cache) || !cache.every(i => typeof i === 'string'))) {\n        throw new TypeError('cache should be a string array');\n      }\n\n      if (empty) {\n        this.cache = new Array<string>(size);\n      }\n    } else {\n      if (cache !== undefined) {\n        const constructor = dataviewConstructor(type);\n        if (!(cache instanceof constructor)) {\n          throw new TypeError(`cache should be type ${constructor.name}`);\n        }\n      }\n\n      if (empty) {\n        const buf = new ArrayBuffer(size * sizeof(type));\n        this.cache = createView(buf, type);\n      }\n    }\n  }\n\n  /**\n   * Construct new Tensor from a ONNX Tensor object\n   * @param tensorProto the ONNX Tensor\n   */\n  static fromProto(tensorProto: onnx.ITensorProto): Tensor {\n    if (!tensorProto) {\n      throw new Error('cannot construct Value from an empty tensor');\n    }\n    const type = ProtoUtil.tensorDataTypeFromProto(tensorProto.dataType!);\n    const dims = ProtoUtil.tensorDimsFromProto(tensorProto.dims!);\n\n    const value = new Tensor(dims, type);\n\n    if (type === 'string') {\n      // When it's STRING type, the value should always be stored in field\n      // 'stringData'\n      tensorProto.stringData!.forEach((str, i) => {\n        value.data[i] = decodeUtf8String(str);\n      });\n\n    } else if (\n        tensorProto.rawData && typeof tensorProto.rawData.byteLength === 'number' &&\n        tensorProto.rawData.byteLength > 0) {\n      // NOT considering segment for now (IMPORTANT)\n\n      // populate value from rawData\n      const dataDest = value.data;\n      const dataSource =\n          new DataView(tensorProto.rawData.buffer, tensorProto.rawData.byteOffset, tensorProto.rawData.byteLength);\n      const elementSize = sizeofProto(tensorProto.dataType!);\n      const length = tensorProto.rawData.byteLength / elementSize;\n\n      if (tensorProto.rawData.byteLength % elementSize !== 0) {\n        throw new Error('invalid buffer length');\n      }\n      if (dataDest.length !== length) {\n        throw new Error('buffer length mismatch');\n      }\n\n      for (let i = 0; i < length; i++) {\n        const n = readProto(dataSource, tensorProto.dataType!, i * elementSize);\n        dataDest[i] = n;\n      }\n    } else {\n      // populate value from array\n      let array: Array<number|Long>;\n      switch (tensorProto.dataType) {\n        case onnx.TensorProto.DataType.FLOAT:\n          array = tensorProto.floatData!;\n          break;\n        case onnx.TensorProto.DataType.INT32:\n        case onnx.TensorProto.DataType.INT16:\n        case onnx.TensorProto.DataType.UINT16:\n        case onnx.TensorProto.DataType.INT8:\n        case onnx.TensorProto.DataType.UINT8:\n        case onnx.TensorProto.DataType.BOOL:\n          array = tensorProto.int32Data!;\n          break;\n        case onnx.TensorProto.DataType.INT64:\n          array = tensorProto.int64Data!;\n          break;\n        case onnx.TensorProto.DataType.DOUBLE:\n          array = tensorProto.doubleData!;\n          break;\n        case onnx.TensorProto.DataType.UINT32:\n        case onnx.TensorProto.DataType.UINT64:\n          array = tensorProto.uint64Data!;\n          break;\n        default:\n          // should never run here\n          throw new Error('unspecific error');\n      }\n\n      if (array === null || array === undefined) {\n        throw new Error('failed to populate data from a tensorproto value');\n      }\n\n      const data = value.data;\n      if (data.length !== array.length) {\n        throw new Error('array length mismatch');\n      }\n\n      for (let i = 0; i < array.length; i++) {\n        const element = array[i];\n        if (Long.isLong(element)) {\n          data[i] = longToNumber(element, tensorProto.dataType);\n        } else {\n          data[i] = element;\n        }\n      }\n    }\n\n    return value;\n  }\n\n  /**\n   * Construct new Tensor from raw data\n   * @param data the raw data object. Should be a string array for 'string' tensor, and the corresponding typed array\n   * for other types of tensor.\n   * @param dims the dimensions of the tensor\n   * @param type the type of the tensor\n   */\n  static fromData(data: Tensor.DataTypeMap[Tensor.DataType], dims: readonly number[], type: Tensor.DataType) {\n    return new Tensor(dims, type, undefined, undefined, data);\n  }\n\n  static fromOrtTensor(ortTensor: ortFbs.Tensor) {\n    if (!ortTensor) {\n      throw new Error('cannot construct Value from an empty tensor');\n    }\n    const dims = ProtoUtil.tensorDimsFromORTFormat(ortTensor);\n    const type = ProtoUtil.tensorDataTypeFromProto(ortTensor.dataType());\n\n    const value = new Tensor(dims, type);\n\n    if (type === 'string') {\n      // When it's STRING type, the value should always be stored in field\n      // 'stringData'\n      for (let i = 0; i < ortTensor.stringDataLength(); i++) {\n        value.data[i] = ortTensor.stringData(i);\n      }\n\n    } else if (\n        ortTensor.rawDataArray() && typeof ortTensor.rawDataLength() === 'number' && ortTensor.rawDataLength() > 0) {\n      // NOT considering segment for now (IMPORTANT)\n\n      // populate value from rawData\n      const dataDest = value.data;\n      const dataSource = new DataView(\n          ortTensor.rawDataArray()!.buffer, ortTensor.rawDataArray()!.byteOffset, ortTensor.rawDataLength());\n      const elementSize = sizeofProto(ortTensor.dataType());\n      const length = ortTensor.rawDataLength() / elementSize;\n\n      if (ortTensor.rawDataLength() % elementSize !== 0) {\n        throw new Error('invalid buffer length');\n      }\n      if (dataDest.length !== length) {\n        throw new Error('buffer length mismatch');\n      }\n\n      for (let i = 0; i < length; i++) {\n        const n = readProto(dataSource, ortTensor.dataType(), i * elementSize);\n        dataDest[i] = n;\n      }\n    }\n    return value;\n  }\n}\n\nfunction sizeof(type: Tensor.DataType): number {\n  switch (type) {\n    case 'bool':\n    case 'int8':\n    case 'uint8':\n      return 1;\n    case 'int16':\n    case 'uint16':\n      return 2;\n    case 'int32':\n    case 'uint32':\n    case 'float32':\n      return 4;\n    case 'float64':\n      return 8;\n    default:\n      throw new Error(`cannot calculate sizeof() on type ${type}`);\n  }\n}\n\nfunction sizeofProto(type: onnx.TensorProto.DataType|ortFbs.TensorDataType): number {\n  switch (type) {\n    case onnx.TensorProto.DataType.UINT8:\n    case onnx.TensorProto.DataType.INT8:\n    case onnx.TensorProto.DataType.BOOL:\n      return 1;\n    case onnx.TensorProto.DataType.UINT16:\n    case onnx.TensorProto.DataType.INT16:\n      return 2;\n    case onnx.TensorProto.DataType.FLOAT:\n    case onnx.TensorProto.DataType.INT32:\n    case onnx.TensorProto.DataType.UINT32:\n      return 4;\n    case onnx.TensorProto.DataType.INT64:\n    case onnx.TensorProto.DataType.DOUBLE:\n    case onnx.TensorProto.DataType.UINT64:\n      return 8;\n    default:\n      throw new Error(`cannot calculate sizeof() on type ${onnx.TensorProto.DataType[type]}`);\n  }\n}\n\nfunction createView(dataBuffer: ArrayBuffer, type: Tensor.DataType) {\n  return new (dataviewConstructor(type))(dataBuffer);\n}\n\nfunction dataviewConstructor(type: Tensor.DataType) {\n  switch (type) {\n    case 'bool':\n    case 'uint8':\n      return Uint8Array;\n    case 'int8':\n      return Int8Array;\n    case 'int16':\n      return Int16Array;\n    case 'uint16':\n      return Uint16Array;\n    case 'int32':\n      return Int32Array;\n    case 'uint32':\n      return Uint32Array;\n    case 'int64':\n      return BigInt64Array;\n    case 'float32':\n      return Float32Array;\n    case 'float64':\n      return Float64Array;\n    default:\n      // should never run to here\n      throw new Error('unspecified error');\n  }\n}\n\n// convert a long number to a 32-bit integer (cast-down)\nfunction longToNumber(i: Long, type: onnx.TensorProto.DataType|ortFbs.TensorDataType): number {\n  // INT64, UINT32, UINT64\n  if (type === onnx.TensorProto.DataType.INT64 || type === ortFbs.TensorDataType.INT64) {\n    if (i.greaterThanOrEqual(2147483648) || i.lessThan(-2147483648)) {\n      throw new TypeError('int64 is not supported');\n    }\n  } else if (\n      type === onnx.TensorProto.DataType.UINT32 || type === ortFbs.TensorDataType.UINT32 ||\n      type === onnx.TensorProto.DataType.UINT64 || type === ortFbs.TensorDataType.UINT64) {\n    if (i.greaterThanOrEqual(4294967296) || i.lessThan(0)) {\n      throw new TypeError('uint64 is not supported');\n    }\n  } else {\n    throw new TypeError(`not a LONG type: ${onnx.TensorProto.DataType[type]}`);\n  }\n\n  return i.toNumber();\n}\n\n// read one value from TensorProto\nfunction readProto(view: DataView, type: onnx.TensorProto.DataType|ortFbs.TensorDataType, byteOffset: number): number {\n  switch (type) {\n    case onnx.TensorProto.DataType.BOOL:\n    case onnx.TensorProto.DataType.UINT8:\n      return view.getUint8(byteOffset);\n    case onnx.TensorProto.DataType.INT8:\n      return view.getInt8(byteOffset);\n    case onnx.TensorProto.DataType.UINT16:\n      return view.getUint16(byteOffset, true);\n    case onnx.TensorProto.DataType.INT16:\n      return view.getInt16(byteOffset, true);\n    case onnx.TensorProto.DataType.FLOAT:\n      return view.getFloat32(byteOffset, true);\n    case onnx.TensorProto.DataType.INT32:\n      return view.getInt32(byteOffset, true);\n    case onnx.TensorProto.DataType.UINT32:\n      return view.getUint32(byteOffset, true);\n    case onnx.TensorProto.DataType.INT64:\n      return longToNumber(\n          Long.fromBits(view.getUint32(byteOffset, true), view.getUint32(byteOffset + 4, true), false), type);\n    case onnx.TensorProto.DataType.DOUBLE:\n      return view.getFloat64(byteOffset, true);\n    case onnx.TensorProto.DataType.UINT64:\n      return longToNumber(\n          Long.fromBits(view.getUint32(byteOffset, true), view.getUint32(byteOffset + 4, true), true), type);\n    default:\n      throw new Error(`cannot read from DataView for type ${onnx.TensorProto.DataType[type]}`);\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {flatbuffers} from 'flatbuffers';\nimport Long from 'long';\n\nimport {Graph} from './graph';\nimport {onnxruntime} from './ort-schema/flatbuffers/ort-generated';\nimport {onnx} from './ort-schema/protobuf/onnx';\nimport {Tensor} from './tensor';\n\n// check the inputs shape before running an OP.\n// return true when the inputs pass the check\n// return false when the inputs do not fit the requirement\n// throw exception when fatal error or not implemented\nexport function checkInputsShape(inputs: Tensor[], ...expectedDimensions: number[]): boolean {\n  if (!inputs || inputs.length !== expectedDimensions.length) {\n    return false;\n  }\n  for (let i = 0; i < inputs.length; i++) {\n    if (!inputs[i].dims || inputs[i].dims.length !== expectedDimensions[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Evaluates the given expression and asserts error message if condition is unmet.\nexport function assert(expr: boolean, msg: () => string) {\n  if (!expr) {\n    throw new Error(typeof msg === 'string' ? msg : msg());\n  }\n}\n\nexport class ArrayUtil {\n  /**\n   * Verifies if 2 input arrays contain the same elements.\n   * @param n1 Array 1\n   * @param n2 Array 2\n   * @returns Whether these 2 are equal\n   */\n  static arraysEqual(\n      n1: readonly number[]|Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Uint8ClampedArray|\n      Float32Array|Float64Array,\n      n2: readonly number[]|Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Uint8ClampedArray|\n      Float32Array|Float64Array) {\n    if (n1.length !== n2.length) {\n      return false;\n    }\n    for (let i = 0; i < n1.length; i++) {\n      if (n1[i] !== n2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nexport class MatMulUtil {\n  /**\n   * Fix the input shapes for MatMul operation if they need fixing\n   * @param dimsA The shape of tensor A. Should be an array of positive integers\n   * @param dimsB The shape of tensor B. Should be an array of positive integers\n   * @returns A tuple containing the preprocessed input shapes as required by ONNX specifications\n   */\n  static preprocessInputShapes(dimsA: readonly number[], dimsB: readonly number[]):\n      [readonly number[], readonly number[]] {\n    // If the first argument is 1-D, it is promoted to a matrix by prepending\n    // a 1 to its dimensions. After matrix multiplication the prepended 1 is\n    // removed.\n    const a = (dimsA.length === 1) ? [1, dimsA[0]] : dimsA;\n\n    // If the second argument is 1-D, it is promoted to a matrix by appending\n    // a 1 to its dimensions. After matrix multiplication the appended 1 is\n    // removed.\n    const b = (dimsB.length === 1) ? [dimsB[0], 1] : dimsB;\n\n    return [a, b];\n  }\n\n  /**\n   * Fix the output shape computed for MatMul operation if it needs fixing\n   * @param outputShape The computed outputShape. Should be an array (atleast of length 2) of positive integers.\n   * This will be mutated.\n   * @param aRank The rank of tensor A.\n   * @param bRank The rank of tensor B.\n   */\n  static postprocessOutputShape(outputShape: number[], aRank: number, bRank: number) {\n    // Remove prepended dimension if first input is 1d\n    if (aRank === 1) {\n      // outputShape = outputShape.slice(0, outputShape.length - 2).concat(outputShape.slice(outputShape.length - 1));\n      outputShape.splice(outputShape.length - 2, 1);\n    }\n    // Remove appended dimension if second input is 1d\n    if (bRank === 1) {\n      outputShape.pop();\n    }\n  }\n\n  /**\n   * Calculate the expected shape when matrix multiplication\n   * @param a The shape of tensor A. Should be a tuple of 2 positive integers\n   * @param b The shape of tensor B. Should be a tuple of 2 positive integers\n   * @returns The expected shape of the result, or undefined if N/A\n   */\n  static calcMatMulShape(a: [number, number], b: [number, number]): [number, number]|undefined {\n    return (a[1] !== b[0]) ? undefined : [a[0], b[1]];\n  }\n}\n\nexport class BroadcastUtil {\n  /**\n   * Calculate the expected shape when broadcasting 2 tensors\n   * @param a The shape of tensor A. Should be an array of positive integers\n   * @param b The shape of tensor B. Should be an array of positive integers\n   * @param isMatMul Whether the operation is MatMul\n   * @returns The expected shape of the result, or undefined if N/A\n   */\n  static calcShape(adims: readonly number[], bdims: readonly number[], isMatMul = false): readonly number[]|undefined {\n    const arank = adims.length;\n    const brank = bdims.length;\n    if (arank === 0) {\n      return bdims;\n    }\n    if (brank === 0) {\n      return adims;\n    }\n    const crank = Math.max(adims.length, bdims.length);\n    const cdims = new Array<number>(crank);\n\n    // calculate the last 2 dimension if it is MatMul\n    if (isMatMul) {\n      if (arank < 2 || brank < 2) {\n        return undefined;\n      }\n      const cShapeMatMul =\n          MatMulUtil.calcMatMulShape([adims[arank - 2], adims[arank - 1]], [bdims[brank - 2], bdims[brank - 1]]);\n      if (cShapeMatMul === undefined) {\n        return undefined;\n      }\n      [cdims[crank - 2], cdims[crank - 1]] = cShapeMatMul;\n    }\n\n    for (let i = isMatMul ? 3 : 1; i <= crank; i++) {\n      const aLen = arank - i < 0 ? 1 : adims[arank - i];\n      const bLen = brank - i < 0 ? 1 : bdims[brank - i];\n\n      if (aLen !== bLen && aLen > 1 && bLen > 1) {\n        return undefined;\n      }\n      cdims[crank - i] = Math.max(aLen, bLen);\n    }\n\n    return cdims;\n  }\n\n  /**\n   * Given the indices of a broadcasted tensor, calculate the original indices\n   * @param broadcastedIndices The given indices of the broadcasted tensor.\n   * @param originalShape The original shape of the tensor before broadcas\n   * @returns The calculated indices that maps to the original tensor.\n   */\n  static index(broadcastedIndices: readonly number[], originalShape: readonly number[]): number[] {\n    // NOTE 1: we assume the parameter broadcastedIndices is valid. ie. it should have the same\n    // length as the broadcasted shape, and for each dimension the index should\n    // not be out of range.\n    const originalIndices = new Array(originalShape.length);\n    BroadcastUtil.fillIndex(broadcastedIndices, originalShape, originalIndices);\n    return originalIndices;\n  }\n\n  /**\n   * Given the indices of a broadcasted tensor, calculate the original indices\n   * @param broadcastedIndices The given indices of the broadcasted tensor.\n   * @param originalShape The original shape of the tensor before broadcast\n   * @param originalIndices The mapping of broadcastedIndices to the originalIndices (output parameter - will be\n   *     mutated).\n   */\n  static fillIndex(broadcastedIndices: readonly number[], originalShape: readonly number[], originalIndices: number[]) {\n    // NOTE 1: we assume the parameter broadcastedIndices is valid. ie. it should have the same length as the\n    // broadcasted shape, and for each dimension the index should not be out of range.\n    // NOTE 2: we assume the parameter originalIndices has the same length as the originalShape\n    const dimOffset = broadcastedIndices.length - originalShape.length;\n    for (let i = 0; i < originalShape.length; i++) {\n      originalIndices[i] = broadcastedIndices[dimOffset + i] % originalShape[i];\n    }\n  }\n\n  /**\n   * Perform the broadcasting operation on the specific operator\n   * @param a The input tensor A\n   * @param b The input tensor B\n   * @param op The operator lambda function\n   * @param inplace Whether to write the result back to A.\n   * @returns The result tensor, or undefined if input not broadcastable.\n   */\n  static calc(\n      a: Tensor, b: Tensor, op: (a: string|number, b: string|number) => (string | number), inplace: boolean,\n      resultType?: Tensor.DataType): Tensor|undefined {\n    const outputShape = BroadcastUtil.calcShape(a.dims, b.dims);\n\n    if (outputShape) {\n      if (inplace && !ShapeUtil.areEqual(outputShape, a.dims)) {\n        // B is not broadcastable to A, failed to calculate inplace.\n        return undefined;\n      }\n\n      const size = ShapeUtil.size(outputShape);\n      const c = inplace ? a : new Tensor(outputShape, resultType || a.type);\n\n      // both inputs are scalars\n      if (outputShape.length === 0) {\n        c.set([], op(a.get([]) as number, b.get([]) as number));\n      }\n\n      // atleast one input is a non-scalar\n      else {\n        const outputIndices = new Array<number>(outputShape.length);\n        const originalIndicesA = new Array(a.dims.length);\n        const originalIndicesB = new Array(b.dims.length);\n        let valA: string|number = 0;\n        let valB: string|number = 0;\n        let isAScalar = false;\n        let isBScalar = false;\n        if (a.dims.length === 0) {\n          valA = a.get([]) as number;\n          isAScalar = true;\n        }\n        if (b.dims.length === 0) {\n          valB = b.get([]) as number;\n          isBScalar = true;\n        }\n        let rest: number;\n        for (let i = 0; i < size; i++) {\n          // traversal indices\n          rest = i;\n          for (let j = outputShape.length - 1; j >= 0; j--) {\n            outputIndices[j] = rest % outputShape[j];\n            rest = Math.floor(rest / outputShape[j]);\n          }\n\n          if (!isAScalar) {\n            // map outputIndices (which is actually broadcasted) to the originalIndices\n            BroadcastUtil.fillIndex(outputIndices, a.dims, originalIndicesA);\n            valA = a.get(originalIndicesA) as number;\n          }\n          if (!isBScalar) {\n            BroadcastUtil.fillIndex(outputIndices, b.dims, originalIndicesB);\n            valB = b.get(originalIndicesB) as number;\n          }\n\n          c.set(outputIndices, op(valA, valB));\n        }\n      }\n\n      return c;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Determine if a shape is unidirectional broadcastable to another shape\n   * @param shape The input shape\n   * @param finalShape The desired shape after broadcasting\n   */\n  static isValidBroadcast(shape: readonly number[], finalShape: readonly number[]): boolean {\n    // align shape to the right\n    const inputRank = shape.length;\n    const finalRank = finalShape.length;\n    if (inputRank > finalRank) {\n      return false;\n    }\n    for (let i = 1; i <= inputRank; i++) {\n      if (shape[inputRank - i] !== 1 && shape[inputRank - i] !== finalShape[finalRank - i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determine the broadcasted dims in input shape based on the given output shape.\n   * Note that this function only returns the broadcasted dims.\n   * @param inputShape The input shape\n   * @param outputShape The output shape\n   * @returns The broadcasted dims in input shape.\n   */\n  static getBroadcastDims(inputShape: readonly number[], outputShape: readonly number[]): number[] {\n    const inRank = inputShape.length;\n    const dims: number[] = [];\n    for (let i = 0; i < inRank; i++) {\n      const dim = inRank - 1 - i;\n      const a = inputShape[dim] || 1;\n      const b = outputShape[outputShape.length - 1 - i] || 1;\n      if (b > 1 && a === 1) {\n        dims.unshift(dim);\n      }\n    }\n    return dims;\n  }\n}\n\n// copy array helper\n// mimics memcpy as much as possible\nexport function arrayCopyHelper(\n    target: number[]|Tensor.NumberType, source: number[]|Tensor.NumberType, targetIndex: number, sourceIndex: number,\n    blockSize: number) {\n  if (sourceIndex < 0 || sourceIndex >= source.length) {\n    throw new Error('sourceIndex out of bounds');\n  }\n  if (targetIndex < 0 || targetIndex >= target.length) {\n    throw new Error('targetIndex out of bounds');\n  }\n  if (sourceIndex + blockSize > source.length) {\n    throw new Error('source indices to be copied are outside bounds');\n  }\n  if (targetIndex + blockSize > target.length) {\n    throw new Error('target array is too small to hold result');\n  }\n\n  for (let offset = 0; offset < blockSize; offset++) {\n    target[targetIndex + offset] = source[sourceIndex + offset];\n  }\n}\n\nexport class GemmUtil {\n  // will make sure input shapes are compatible for this op\n  // and return back the shape of the output in the form of a tuple\n  // will throw exception if the input shapes are not compatible\n  static getShapeOfGemmResult(\n      leftShape: readonly number[], transLeft: boolean, rightShape: readonly number[], transRight: boolean,\n      biasShape?: readonly number[]): readonly number[] {\n    if (leftShape.length !== 2 || rightShape.length !== 2) {\n      throw new Error('shape need to be of size 2');\n    }\n\n    let M: number;\n    let K: number;\n    let N: number;\n\n    if (transLeft) {\n      M = leftShape[1];\n      K = leftShape[0];\n    } else {\n      M = leftShape[0];\n      K = leftShape[1];\n    }\n\n    let kDim = -1;\n\n    if (transRight) {\n      N = rightShape[0];\n      kDim = 1;\n    } else {\n      N = rightShape[1];\n      kDim = 0;\n    }\n\n    if (rightShape[kDim] !== K) {\n      throw new Error('dimension mismatch');\n    }\n\n    if (M <= 0 || N <= 0 || K <= 0) {\n      throw new Error('invalid shape specified');\n    }\n\n    if (biasShape && !BroadcastUtil.isValidBroadcast(biasShape, [M, N])) {\n      throw new Error('gemm: invalid bias shape for broadcast');\n    }\n\n    return [M, N, K];\n  }\n}\n\nexport class ProtoUtil {\n  static tensorDataTypeFromProto(typeProto: onnx.TensorProto.DataType|\n                                 onnxruntime.experimental.fbs.TensorDataType): Tensor.DataType {\n    switch (typeProto) {\n      case onnx.TensorProto.DataType.INT8:\n        return 'int8';\n      case onnx.TensorProto.DataType.UINT8:\n        return 'uint8';\n      case onnx.TensorProto.DataType.BOOL:\n        return 'bool';\n      case onnx.TensorProto.DataType.INT16:\n        return 'int16';\n      case onnx.TensorProto.DataType.UINT16:\n        return 'uint16';\n      case onnx.TensorProto.DataType.INT32:\n        return 'int32';\n      case onnx.TensorProto.DataType.UINT32:\n        return 'uint32';\n      case onnx.TensorProto.DataType.FLOAT:\n        return 'float32';\n      case onnx.TensorProto.DataType.DOUBLE:\n        return 'float64';\n      case onnx.TensorProto.DataType.STRING:\n        return 'string';\n\n      // For INT64/UINT64, reduce their value to 32-bits.\n      // Should throw exception when overflow\n      case onnx.TensorProto.DataType.INT64:\n        return 'int32';\n      case onnx.TensorProto.DataType.UINT64:\n        return 'uint32';\n\n      default:\n        throw new Error(`unsupported data type: ${onnx.TensorProto.DataType[typeProto]}`);\n    }\n  }\n\n  static tensorDataTypeStringToEnum(type: string): onnx.TensorProto.DataType {\n    switch (type) {\n      case 'int8':\n        return onnx.TensorProto.DataType.INT8;\n      case 'uint8':\n        return onnx.TensorProto.DataType.UINT8;\n      case 'bool':\n        return onnx.TensorProto.DataType.BOOL;\n      case 'int16':\n        return onnx.TensorProto.DataType.INT16;\n      case 'uint16':\n        return onnx.TensorProto.DataType.UINT16;\n      case 'int32':\n        return onnx.TensorProto.DataType.INT32;\n      case 'uint32':\n        return onnx.TensorProto.DataType.UINT32;\n      case 'float32':\n        return onnx.TensorProto.DataType.FLOAT;\n      case 'float64':\n        return onnx.TensorProto.DataType.DOUBLE;\n      case 'string':\n        return onnx.TensorProto.DataType.STRING;\n      case 'int64':\n        return onnx.TensorProto.DataType.INT64;\n      case 'uint64':\n        return onnx.TensorProto.DataType.UINT64;\n\n      default:\n        throw new Error(`unsupported data type: ${type}`);\n    }\n  }\n\n  static tensorDimsFromProto(dims: Array<number|Long>): number[] {\n    // get rid of Long type for dims\n    return dims.map(d => Long.isLong(d) ? d.toNumber() : d);\n  }\n\n  static tensorValueTypeFromProto(valueType: onnx.TypeProto.ITensor): Graph.ValueType {\n    return {\n      tensorType: ProtoUtil.tensorDataTypeFromProto(valueType.elemType!),\n      shape: {dims: ProtoUtil.tensorDimsFromProto(valueType.shape!.dim!.map(d => d.dimValue!))}\n    };\n  }\n\n  static tensorDimsFromORTFormat(tensor: onnxruntime.experimental.fbs.Tensor) {\n    const dims = [];\n    for (let i = 0; i < tensor.dimsLength(); i++) {\n      dims.push(LongUtil.longToNumber(tensor.dims(i)!));\n    }\n    return dims;\n  }\n\n  static tensorAttributesFromORTFormat(node: onnxruntime.experimental.fbs.Node) {\n    const attributes = [];\n    for (let i = 0; i < node.attributesLength(); i++) {\n      attributes.push(node.attributes(i)!);\n    }\n    return attributes;\n  }\n}\n\nexport class LongUtil {\n  // This function is called to get a number from long type of data for attribute, dim, and ir version,\n  // which values are signed integers.\n  // To make it more generic, add an optional paramter to convert to a unsigned number.\n  static longToNumber(n: Long|flatbuffers.Long|number, unsigned?: boolean) {\n    if (Long.isLong(n)) {\n      return n.toNumber();\n    } else if (n instanceof flatbuffers.Long) {\n      return Long.fromValue({low: n.low, high: n.high, unsigned: unsigned ?? false}).toNumber();\n    }\n    return n;\n  }\n  static isLong(n: unknown) {\n    return Long.isLong(n) || n instanceof flatbuffers.Long;\n  }\n}\n\nexport class ShapeUtil {\n  static size(dims: readonly number[]): number {\n    return ShapeUtil.getSizeFromDimensionRange(dims, 0, dims.length);\n  }\n\n  // `axis` inclusive\n  static sizeFromDimension(dims: readonly number[], axis: number): number {\n    if (axis < 0 || axis > dims.length) {\n      throw new Error(`invalid dimension of ${axis} for sizeFromDimension as Tensor has ${dims.length} dimensions.`);\n    }\n    return ShapeUtil.getSizeFromDimensionRange(dims, axis, dims.length);\n  }\n\n  // `axis` exclusive\n  static sizeToDimension(dims: readonly number[], axis: number): number {\n    if (axis < 0 || axis > dims.length) {\n      throw new Error(`invalid dimension of ${axis} for sizeToDimension as Tensor has ${dims.length} dimensions.`);\n    }\n    return ShapeUtil.getSizeFromDimensionRange(dims, 0, axis);\n  }\n\n  static getSizeFromDimensionRange(dims: readonly number[], start: number, end: number): number {\n    let size = 1;\n    for (let i = start; i < end; i++) {\n      // safety check as this method is called by multiple other methods requiring size.\n      // size cannot be 0 or negative.\n      if (dims[i] <= 0) {\n        throw new Error(\n            // eslint-disable-next-line max-len\n            'cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.');\n      }\n      size *= dims[i];\n    }\n    return size;\n  }\n\n  static computeStrides(dims: readonly number[]): readonly number[] {\n    const rank = dims.length;\n    if (rank === 0) {\n      return [];\n    } else if (rank === 1) {\n      return [1];\n    }\n    const strides = new Array(rank);\n    strides[rank - 1] = 1;\n    strides[rank - 2] = dims[rank - 1];\n    for (let i = rank - 3; i >= 0; --i) {\n      strides[i] = strides[i + 1] * dims[i + 1];\n    }\n    return strides;\n  }\n\n  static transpose(dims: readonly number[]): readonly number[] {\n    const copy = dims.slice();\n    return copy.reverse();\n  }\n\n  static indicesToOffset(indices: readonly number[], strides: readonly number[], axis?: number): number {\n    if (axis === undefined) {\n      axis = indices.length;\n    }\n    let offset = 0;\n    for (let i = 0; i < axis; ++i) {\n      offset += strides[i] * indices[i];\n    }\n    return offset;\n  }\n\n  static offsetToIndices(offset: number, strides: readonly number[]): readonly number[] {\n    const rank = strides.length;\n    if (rank === 0) {\n      return [];\n    } else if (rank === 1) {\n      return [offset * strides[0]];\n    }\n    const indices: number[] = new Array(strides.length);\n    for (let i = 0; i < indices.length - 1; ++i) {\n      indices[i] = Math.floor(offset / strides[i]);\n      offset -= indices[i] * strides[i];\n    }\n    indices[indices.length - 1] = offset;\n    return indices;\n  }\n\n  /**\n   * normailze axis of range [-r, r) into [0, r).\n   */\n  static normalizeAxis(axis: number, tensorRank: number): number {\n    if (axis < -tensorRank && axis >= tensorRank) {\n      throw new Error('unsupported axis for this operation.');\n    }\n    return axis < 0 ? axis + tensorRank : axis;\n  }\n\n  static normalizeAxes(axes: readonly number[], tensorRank: number): number[] {\n    return axes.map(x => this.normalizeAxis(x, tensorRank));\n  }\n\n  // Increment an index into a tensor (in lexicographic\n  // ordering), wrapping around the specified upper_bound.\n  /**\n   * Increment an index into a tensor (in lexicographic ordering), wrapping around the specified upper_bound.\n   * @param index Given index to increment (Will be mutated)\n   * @param dims The dimensions of the tensor for which the given index corresponds to\n   * @param axisToIncrementOn The 1-indexed axis to increment on. If undefined, axisToIncrementOn == rank\n   */\n  static incrementIndex(index: number[], dims: readonly number[], axisToIncrementOn?: number) {\n    if (dims.length === 0 || index.length === 0) {\n      throw new Error('Index incrementing unsupported for scalar Tensor');\n    }\n    if (axisToIncrementOn === undefined) {\n      axisToIncrementOn = dims.length;\n    } else {\n      if (axisToIncrementOn <= 0 || axisToIncrementOn > dims.length) {\n        throw new Error('Incorrect axis to increment on');\n      }\n    }\n\n    for (let k = axisToIncrementOn - 1; k >= 0; --k) {\n      index[k]++;\n      if (index[k] < dims[k]) {\n        break;\n      }\n      index[k] = 0;\n    }\n  }\n\n  /**\n   * Produces a new dimensions array based on the values in the 'originalDimensions' and 'shape' array\n   * Used in Reshape\n   * @param originalDims Original Shape array\n   * @param shapeHints array containing values to compute the new dimensions\n   * For example:\n   * originalDims = [2,2] and shapeHints = [0,-1] will return [2,2]\n   * originalDims = [2,2] and shapeHints = [4] will return [4]\n   * originalDims = [2,2] and shapeHints = [5] will throw an exception\n   * https://github.com/onnx/onnx/blob/main/docs/Operators.md#Reshape\n   */\n\n  static calculateReshapedDims(originalDims: readonly number[], shapeHints: ArrayLike<number>): number[] {\n    // reshape to a Scalar Tensor\n    if (shapeHints.length === 0) {\n      if (originalDims.length === 0 || ShapeUtil.size(originalDims) === 1) {\n        return [];\n      } else {\n        throw new Error('cannot reshape to a scalar Tensor');\n      }\n    }\n\n    const nDims = shapeHints.length;\n    const reshapedDims = new Array<number>(nDims);\n    let unknownDimension = -1;\n    let newTensorSize = 1;\n    for (let i = 0; i < nDims; i++) {\n      if (shapeHints[i] < -1) {\n        throw new Error('a dimension in shape hints cannot be less than -1');\n      }\n      if (shapeHints[i] === -1) {\n        if (unknownDimension !== -1) {\n          throw new Error('at most one dimension in shape hints can be -1');\n        }\n        unknownDimension = i;\n      } else {\n        if (shapeHints[i] === 0) {\n          if (i >= originalDims.length) {\n            throw new Error('the dimension with value zero exceeds the dimension size of the input tensor');\n          }\n          reshapedDims[i] = originalDims[i];\n        } else {\n          reshapedDims[i] = shapeHints[i];\n        }\n        newTensorSize *= reshapedDims[i];\n      }\n    }\n\n    const oldTensorSize = ShapeUtil.size(originalDims);\n    if (unknownDimension !== -1) {\n      if (oldTensorSize % newTensorSize !== 0) {\n        throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${\n            originalDims}] Output shape: [${shapeHints}]`);\n      }\n      reshapedDims[unknownDimension] = oldTensorSize / newTensorSize;\n    }\n    // validate sizes from originalDims and reshapedDims match\n    else {\n      if (newTensorSize !== oldTensorSize) {\n        throw new Error('reshapedDims and originalDims don\\'t have matching sizes');\n      }\n    }\n    return reshapedDims;\n  }\n\n  /**\n   * Sorts a given array based on the indices in the Perm array\n   * Used in Transpose\n   * @param a Array to be sorted such as dims or strides\n   * @param perm Perm given; if null a will be reversed\n   */\n  static sortBasedOnPerm(a: readonly number[], perm?: readonly number[]): readonly number[] {\n    if (perm) {\n      return perm.map((v) => a[v]);\n    } else {\n      return a.slice().reverse();\n    }\n  }\n\n  /**\n   * Pads a given shape according to the padding values\n   * @param dims shape of the Tensor to be padded\n   * @param pad pad values\n   */\n  static padShape(dims: readonly number[], pad: readonly number[]): readonly number[] {\n    const rank = dims.length;\n    return dims.map((v, i) => v + pad[i] + pad[i + rank]);\n  }\n\n  /**\n   * Determines if the two shapes are identical\n   * @param shape1\n   * @param shape2\n   */\n  static areEqual(shape1: readonly number[], shape2: readonly number[]): boolean {\n    if (shape1.length !== shape2.length) {\n      return false;\n    }\n    return shape1.every((v, i) => v === shape2[i]);\n  }\n\n  /**\n   * Validates if the given `dims` or `shape` is valid in ONNX.js context and returns data size\n   * @param dims - input `dims` that needs to be checked\n   */\n  static validateDimsAndCalcSize(dims: readonly number[]): number {\n    if (dims.length > 6) {\n      throw new TypeError('Only rank 0 to 6 is supported for tensor shape.');\n    }\n    let size = 1;\n    for (const n of dims) {\n      if (!Number.isInteger(n)) {\n        throw new TypeError(`Invalid shape: ${n} is not an integer`);\n      }\n      if (n < 0 || n > 2147483647) {\n        throw new TypeError(`Invalid shape: length ${n} is not allowed`);\n      }\n      size *= n;\n    }\n    return size;\n  }\n\n  /**\n   * Determines the shape of output tensor y = flatten(x, axis)\n   * @param dims - shape of input tensor\n   * @param axis - flatten axis, in the range [-r, r]\n   */\n  static flattenShape(dims: readonly number[], axis: number): readonly number[] {\n    if (axis < 0) {\n      axis += dims.length;\n    }\n    const total = dims.reduce((x, y) => x * y, 1);\n    const right = dims.slice(axis).reduce((x, y) => x * y, 1);\n    const outputDims = [total / right, right];\n\n    return outputDims;\n  }\n\n  /**\n   * Determines the shape of output tensor y = squeeze(x, axes)\n   * @param dims - shape of input tensor\n   * @param axes - squeeze axes\n   */\n  static squeezeShape(dims: readonly number[], axes: readonly number[]): readonly number[] {\n    const outputDims = new Array<number>();\n\n    // sanity check\n    axes = ShapeUtil.normalizeAxes(axes, dims.length);\n\n    for (let i = 0; i < dims.length; i++) {\n      const inSqueezeList = axes.indexOf(i) >= 0;\n      if (inSqueezeList && dims[i] !== 1) {\n        throw new Error('squeeze an axis of size different than 1');\n      }\n\n      if ((axes.length === 0 && dims[i] > 1) || (axes.length > 0 && !inSqueezeList)) {\n        outputDims.push(dims[i]);\n      }\n    }\n\n    return outputDims;\n  }\n\n  /**\n   * Determines the shape of output tensor y = unsqueeze(x, axes)\n   * @param dims - shape of input tensor\n   * @param axes - unsqueeze axes\n   */\n  static unsqueezeShape(dims: readonly number[], axes: readonly number[]): readonly number[] {\n    const outputDims = new Array<number>(dims.length + axes.length);\n\n    // initialize the array elements to 0\n    outputDims.fill(0);\n\n    // set all axes indices to 1 in outputDims and check for duplicates\n    for (let i = 0; i < axes.length; i++) {\n      const axis = ShapeUtil.normalizeAxis(axes[i], outputDims.length);\n      if (axis >= outputDims.length) {\n        throw new Error('\\'axes\\' has an out of range axis');\n      }\n      if (outputDims[axis] !== 0) {\n        throw new Error('\\'axes\\' has a duplicate axis');\n      }\n\n      outputDims[axis] = 1;\n    }\n\n    // fill in the zero entries of outputDims with the input tensor's shape\n    let inputDimsIterator = 0;\n    for (let i = 0; i < outputDims.length; i++) {\n      if (outputDims[i] === 0) {\n        outputDims[i] = dims[inputDimsIterator++];\n      }\n    }\n\n    // sanity check assertion. 'inputDimsIterator'\n    // should be equal to the length of 'dims'\n    if (inputDimsIterator !== dims.length) {\n      throw new Error('the unsqueezed dimension could not be established');\n    }\n\n    return outputDims;\n  }\n}\n\n// bunch of helper methods that do a variety of math operations\nexport class MathUtil {\n  // y = (x*x) + y\n  static sqr(\n      target: number[]|Tensor.NumberType, source: number[]|Tensor.NumberType, targetIndex: number, sourceIndex: number,\n      blockSize: number) {\n    if (sourceIndex < 0 || sourceIndex >= source.length) {\n      throw new Error('sourceIndex out of bounds');\n    }\n    if (targetIndex < 0 || targetIndex >= target.length) {\n      throw new Error('targetIndex out of bounds');\n    }\n    if (sourceIndex + blockSize > source.length) {\n      throw new Error('source indices to be copied are outside bounds');\n    }\n    if (targetIndex + blockSize > target.length) {\n      throw new Error('target array is too small to hold result');\n    }\n\n    for (let offset = 0; offset < blockSize; offset++) {\n      target[targetIndex + offset] += Math.pow(source[sourceIndex + offset], 2);\n    }\n  }\n\n  // y = ax + y\n  static axpy(\n      target: number[]|Tensor.NumberType, source: number[]|Tensor.NumberType, targetIndex: number, sourceIndex: number,\n      blockSize: number, alpha: number) {\n    if (sourceIndex < 0 || sourceIndex >= source.length) {\n      throw new Error('sourceIndex out of bounds');\n    }\n    if (targetIndex < 0 || targetIndex >= target.length) {\n      throw new Error('targetIndex out of bounds');\n    }\n    if (sourceIndex + blockSize > source.length) {\n      throw new Error('source indices to be copied are outside bounds');\n    }\n    if (targetIndex + blockSize > target.length) {\n      throw new Error('target array is too small to hold result');\n    }\n\n    for (let offset = 0; offset < blockSize; offset++) {\n      target[targetIndex + offset] += (alpha * source[sourceIndex + offset]);\n    }\n  }\n\n  // y = pow(x, b)\n  static powx(\n      target: number[]|Tensor.NumberType, source: number[]|Tensor.NumberType, targetIndex: number, sourceIndex: number,\n      blockSize: number, b: number) {\n    if (sourceIndex < 0 || sourceIndex >= source.length) {\n      throw new Error('sourceIndex out of bounds');\n    }\n    if (targetIndex < 0 || targetIndex >= target.length) {\n      throw new Error('targetIndex out of bounds');\n    }\n    if (sourceIndex + blockSize > source.length) {\n      throw new Error('source indices to be copied are outside bounds');\n    }\n    if (targetIndex + blockSize > target.length) {\n      throw new Error('target array is too small to hold result');\n    }\n\n    for (let offset = 0; offset < blockSize; offset++) {\n      target[targetIndex + offset] = Math.pow(source[sourceIndex + offset], b);\n    }\n  }\n\n  // y = x * y\n  static mul(\n      target: number[]|Tensor.NumberType, source: number[]|Tensor.NumberType, targetIndex: number, sourceIndex: number,\n      blockSize: number) {\n    if (sourceIndex < 0 || sourceIndex >= source.length) {\n      throw new Error('sourceIndex out of bounds');\n    }\n    if (targetIndex < 0 || targetIndex >= target.length) {\n      throw new Error('targetIndex out of bounds');\n    }\n    if (sourceIndex + blockSize > source.length) {\n      throw new Error('source indices to be copied are outside bounds');\n    }\n    if (targetIndex + blockSize > target.length) {\n      throw new Error('target array is too small to hold result');\n    }\n\n    for (let offset = 0; offset < blockSize; offset++) {\n      target[targetIndex + offset] = (source[sourceIndex + offset] * target[targetIndex + offset]);\n    }\n  }\n}\n\nexport class SplitUtil {\n  /**\n   * Calculates new Shapes from existing one and the splits given along the axis provides\n   * @param dims Shape of the Tensor to be splitted into two or more Shapes\n   * @param axis The dimension along which the Tensor will be split\n   * @param splits Offsets for the start of each split\n   */\n  static splitShape(dims: readonly number[], axis: number, split: number[], numOutputs?: number):\n      [number[][], number[]] {\n    if (split.length === 0) {\n      if (!numOutputs) {\n        throw new Error('need to know number of outputs when the \\'split\\' attribute is not specified');\n      }\n      SplitUtil.determineSplit(dims[axis], numOutputs, split);\n    }\n\n    const shapes: number[][] = [];\n    const offsets = [0];\n    for (let i = 0; i < split.length; ++i) {\n      if (i !== 0) {\n        offsets.push(offsets[i - 1] + split[i - 1]);\n      }\n      const shape = dims.slice();\n      shape[axis] = split[i];\n      shapes.push(shape);\n    }\n    return [shapes, offsets];\n  }\n\n  static determineSplit(numElementsAlongAxis: number, numOutputs: number, split: number[]) {\n    // If 'split' is not specified by the user, we need to partition the number of elements equally among the outputs\n    if (numElementsAlongAxis % numOutputs !== 0) {\n      throw new Error('cannot split tensor to equal sized parts');\n    }\n    for (let i = 0; i < numOutputs; ++i) {\n      split.push(numElementsAlongAxis / numOutputs);\n    }\n  }\n}\n\nexport class ReduceUtil {\n  /**\n   * Perform reduce operations on the specific operator\n   * @param a Input tensor data\n   * @param axes The dimensions along which the Tensor will be reduced\n   * @param keepdims If set to true, the axes which are reduced are left in the\n   *    result as dimensions with size one.\n   * @param op1 The operation to be performed on each element in the tensor\n   * @param op2 The operation to be performed between elements in the tensor\n   */\n  static calcReduce(\n      a: Tensor, axes: number[], keepdims: boolean, op1: (b: number) => number,\n      op2: (a: number, b: number) => number): Tensor {\n    const dims = a.dims.slice(0);\n    // if axes is not set, perform reduce on all axes\n    if (axes.length === 0) {\n      dims.forEach((d, ind) => axes.push(ind));\n    }\n    // get a temporary broadcastable output shape\n    const outputDims = ReduceUtil.calcReduceShape(dims, axes, true);\n\n    // loop through the output and calculate result one by one\n    const size = ShapeUtil.size(outputDims);\n    const y = new Tensor(outputDims, a.type);\n    const strides = ShapeUtil.computeStrides(outputDims);\n    const inputStrides = ShapeUtil.computeStrides(dims);\n    const indicesY = new Array(dims.length);\n    for (let i = 0; i < size; i++) {\n      const indices = ShapeUtil.offsetToIndices(i, strides);\n      // map index\n      BroadcastUtil.fillIndex(indices, dims, indicesY);\n      y.set(\n          indices,\n          ReduceUtil.calcReduceByAxis(\n              a.numberData, axes, dims, 0, ShapeUtil.indicesToOffset(indicesY, inputStrides), op1, op2));\n    }\n\n    if (keepdims) {\n      return y;\n    } else {\n      // keepdims == 0, calculate the expected shape\n      return new Tensor(\n          ReduceUtil.calcReduceShape(dims, axes, keepdims), y.type, undefined, undefined, y.data, y.dataId);\n    }\n  }\n\n  /**\n   * Perform reduce operations on the specific operator on specific axes\n   * @param a Input tensor data\n   * @param axes The dimensions along which the Tensor will be reduced\n   * @param dims The input dimension.\n   * @param curAxisInd Index in axes specifying the current dimension along\n   *      which the tensor will be reduced\n   * @param pos The current index of element to perform operation\n   * @param op1 The operation to be performed on each element in the tensor\n   * @param op2 The operation to be performed between elements in the tensor\n   */\n  static calcReduceByAxis(\n      input: Tensor.NumberType, axes: number[], dims: number[], curAxisInd: number, pos: number,\n      op1: (b: number) => number, op2: (a: number, b: number) => number): number {\n    let res = 0;\n    if (curAxisInd >= axes.length) {\n      return op1(input[pos]);\n    }\n    const axis = axes[curAxisInd];\n    const step = axis >= dims.length ? 1 : ShapeUtil.size(dims.slice(axis + 1));\n    for (let i = 0; i < dims[axis]; i++) {\n      res = i === 0 ? ReduceUtil.calcReduceByAxis(input, axes, dims, curAxisInd + 1, pos, op1, op2) :\n                      op2(res, ReduceUtil.calcReduceByAxis(input, axes, dims, curAxisInd + 1, pos, op1, op2));\n      pos += step;\n    }\n    return res;\n  }\n\n  /**\n   * Calculate the expected shape of a reduce operation\n   * @param dims The input tensor dimension\n   * @param axes The dimensions along which the Tensor will be reduced\n   * @param keepdims If set to true, the axes which are reduced are left in the\n   *    result as dimensions with size one.\n   */\n  static calcReduceShape(dims: readonly number[], axes: readonly number[], keepDims: boolean): number[] {\n    const outputDims = dims.slice();\n    for (let i = 0; i < axes.length; i++) {\n      if (keepDims) {\n        outputDims[axes[i]] = 1;\n      } else {\n        outputDims[axes[i]] = 0;\n      }\n    }\n    return outputDims.filter(dim => dim !== 0);\n  }\n}\n\nexport class PoolConvUtil {\n  /**\n   * Adjust the kernel, strides, pads to correct rank. Set to default value if not present\n   * @param isGlobalOperator If true, perform global pooling.\n   * @param inputDims The input tensor dimension.\n   * @param kernelShape The size of the kernel along each axis.\n   * @param strides Stride along each axis.\n   * @param dilations Dilation along each axis.\n   * @param pads Padding for the beginning and ending along each axis.\n   */\n  static adjustPoolAttributes(\n      isGlobalOperator: boolean, inputDims: readonly number[], kernelShape: number[], strides: number[],\n      dilations: number[], pads: number[]) {\n    if (!isGlobalOperator && kernelShape.length !== inputDims.length - 2) {\n      throw new Error('length of specified kernel shapes should be 2 less than length of input dimensions');\n    }\n\n    if (isGlobalOperator) {\n      // adjust kernel shape to cover the input dims\n      for (let dim = 0; dim < inputDims.length - 2; dim++) {\n        if (dim >= kernelShape.length) {\n          kernelShape.push(inputDims[dim + 2]);\n        } else {\n          kernelShape[dim] = inputDims[dim + 2];\n        }\n      }\n    }\n\n    // adjust strides length to match kernel shape length\n    for (let dim = 0; dim < kernelShape.length; dim++) {\n      if (dim < strides.length) {\n        if (strides[dim] < 0) {\n          throw new Error('strides should be greater than or equal to 1');\n        }\n      } else {\n        strides.push(1);\n      }\n    }\n\n    // adjust dilation value\n    for (let dim = 0; dim < kernelShape.length; dim++) {\n      if (dim < dilations.length) {\n        if (dilations[dim] < 0) {\n          throw new Error('dilations should be greater than or equal to 1');\n        }\n      } else {\n        dilations.push(1);\n      }\n    }\n\n    // adjust pads length to match 2 * kernel shape length\n    for (let dim = 0; dim < kernelShape.length * 2; dim++) {\n      if (dim < pads.length) {\n        if (pads[dim] < 0) {\n          throw new Error('pad should be greater than or equal to 1');\n        }\n      } else {\n        pads.push(0);\n      }\n    }\n\n    // sanity checks for values in kernel shapes and pads\n    for (let dim = 0; dim < kernelShape.length; dim++) {\n      if (kernelShape[dim] <= 0) {\n        throw new Error('kernel shapes need to be greater than 0');\n      }\n\n      if (pads[dim] >= kernelShape[dim] || pads[dim + kernelShape.length] >= kernelShape[dim]) {\n        throw new Error('pads should be smaller than kernel');\n      }\n    }\n  }\n\n  // adjust pad values based on 'autoPad' attribute\n  static adjustPadsBasedOnAutoPad(\n      inputDims: readonly number[], strides: readonly number[], dilations: readonly number[],\n      kernelShape: readonly number[], pads: number[], autoPad?: string) {\n    if (!autoPad) {\n      return;\n    }\n\n    if (pads.length !== 2 * (inputDims.length - 2)) {\n      throw new Error('length of pads should be twice the length of data dimensions');\n    }\n\n    if (strides.length !== (inputDims.length - 2)) {\n      throw new Error('length of strides should be the length of data dimensions');\n    }\n\n    if (kernelShape.length !== (inputDims.length - 2)) {\n      throw new Error('length of kernel shapes should be the length of data dimensions');\n    }\n\n    for (let dim = 0; dim < inputDims.length - 2; dim++) {\n      PoolConvUtil.adjustPadAndReturnShape(\n          inputDims[dim + 2], strides[dim], dilations[dim], kernelShape[dim], pads, dim, dim + inputDims.length - 2,\n          autoPad);\n    }\n  }\n\n  /**\n   * Calculate the output shape for Pool ops based on input attributes. (Should be used only for Pool ops)\n   * @param isGlobalOperator If true, perform global pooling.\n   * @param inputDims The input tensor dimension. (inputs[0].dims)\n   * @param strides Stride along each axis.\n   * @param dilations Dilation along each axis.\n   * @param kernelShape The size of the kernel along each axis.\n   * @param pads Padding for the beginning and ending along each axis.\n   * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each\n   *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.\n   */\n  static computePoolOutputShape(\n      isGlobalOperator: boolean, inputDims: readonly number[], strides: number[], dilations: number[],\n      kernelShape: number[], pads: number[], autoPad?: string): number[] {\n    if (inputDims.length <= 0) {\n      throw new Error('input shape must be of size greater than 0');\n    }\n\n    // Add batch size and number of channels of output\n    const outputDims = [inputDims[0], inputDims[1]];\n\n    PoolConvUtil.computeShapeHelper(\n        isGlobalOperator, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);\n    return outputDims;\n  }\n\n  /**\n   * Calculate the output shape for Conv op based on input attributes. (Should be used only for Conv op)\n   * @param inputDims The input tensor dimension. (inputs[0].dims)\n   * @param filterDims The filter tensor dimension. (inputs[1].dims)\n   * @param strides Stride along each axis.\n   * @param kernelShape The size of the kernel along each axis.\n   * @param pads Padding for the beginning and ending along each axis.\n   * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each\n   *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.\n   */\n  static computeConvOutputShape(\n      inputDims: readonly number[], filterDims: readonly number[], strides: number[], dilations: number[],\n      kernelShape: number[], pads: number[], autoPad?: string): number[] {\n    if (inputDims.length <= 0 || filterDims.length <= 0) {\n      throw new Error('invalid input tensor dims or invalid filter tensor dims');\n    }\n\n    // Add batch size and number of channels of output\n    const outputDims = [inputDims[0], filterDims[0]];\n\n    PoolConvUtil.computeShapeHelper(false, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);\n    return outputDims;\n  }\n\n  // will compute output shapes for data dimensions ONLY (i.e.) no batch size and channels\n  // called by computePoolOutputShape() and computeConvOutputShape()\n  // adjust pads based on 'autoPad' attribute prior to shape computation\n  private static computeShapeHelper(\n      isGlobalOperator: boolean, inputDims: readonly number[], outputDims: number[], strides: readonly number[],\n      dilations: readonly number[], kernelShape: readonly number[], pads: number[], autoPad?: string) {\n    if (isGlobalOperator) {\n      for (let dim = 0; dim < inputDims.length - 2; dim++) {\n        outputDims.push(1);\n      }\n    } else {\n      for (let dim = 0; dim < inputDims.length - 2; dim++) {\n        outputDims.push(PoolConvUtil.adjustPadAndReturnShape(\n            inputDims[dim + 2], strides[dim], dilations[dim], kernelShape[dim], pads, dim, dim + inputDims.length - 2,\n            autoPad));\n      }\n    }\n  }\n\n  // helper for computeShapeHelper() and adjustPadsBasedOnAutoPad()\n  // adjusts pad value for given 'autoPad' string and computes output shape along a particular dimension\n  private static adjustPadAndReturnShape(\n      inSize: number, stride: number, dilation: number, kernel: number, pads: number[], padHeadIndex: number,\n      padTailIndex: number, autoPad?: string): number {\n    const dkernel = dilation * (kernel - 1) + 1;\n    if (autoPad && autoPad !== 'NOTSET') {\n      switch (autoPad) {\n        case 'VALID':\n          pads[padHeadIndex] = 0;\n          pads[padTailIndex] = 0;\n          return Math.floor(((inSize - dkernel) / stride) + 1);\n        case 'SAME_LOWER':\n        case 'SAME_UPPER':\n          if (dilation !== 1) {\n            throw new Error('Dilation not supported for SAME_UPPER or SAME_LOWER');\n          } else {\n            const legacyTargetSize = (inSize + stride - 1) / stride;\n            const padNeeded = (legacyTargetSize - 1) * stride + kernel - inSize;\n            pads[padHeadIndex] =\n                (autoPad === 'SAME_LOWER') ? Math.floor((padNeeded + 1) / 2) : Math.floor(padNeeded / 2);\n            pads[padTailIndex] = padNeeded - pads[padHeadIndex];\n            return Math.floor(((inSize + padNeeded - kernel) / stride) + 1);\n          }\n        default:\n          throw new Error('Unsupported AutoPad type');\n      }\n    } else {\n      return Math.floor(((inSize + pads[padHeadIndex] + pads[padTailIndex] - dkernel) / stride) + 1);\n    }\n  }\n}\n\nexport const MIN_CLIP = -3.4028234663852886e+38;\nexport const MAX_CLIP = 3.4028234663852886e+38;\n\nexport function decodeUtf8String(buffer: Uint8Array): string {\n  return new TextDecoder().decode(buffer);\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n// This file is generated by /js/scripts/update-version.ts\n// Do not modify file content manually.\n\nexport const version = '1.16.3';\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Env, env, InferenceSession} from 'onnxruntime-common';\n\nimport {OrtWasmMessage, SerializableModeldata, SerializableSessionMetadata, SerializableTensor} from './proxy-messages';\nimport * as core from './wasm-core-impl';\nimport {initializeWebAssembly} from './wasm-factory';\n\nconst isProxy = (): boolean => !!env.wasm.proxy && typeof document !== 'undefined';\nlet proxyWorker: Worker|undefined;\nlet initializing = false;\nlet initialized = false;\nlet aborted = false;\n\n// resolve; reject\ntype PromiseCallbacks<T = void> = [(result: T) => void, (reason: unknown) => void];\n\nlet initWasmCallbacks: PromiseCallbacks;\nlet initOrtCallbacks: PromiseCallbacks;\nconst createSessionAllocateCallbacks: Array<PromiseCallbacks<SerializableModeldata>> = [];\nconst createSessionFinalizeCallbacks: Array<PromiseCallbacks<SerializableSessionMetadata>> = [];\nconst createSessionCallbacks: Array<PromiseCallbacks<SerializableSessionMetadata>> = [];\nconst releaseSessionCallbacks: Array<PromiseCallbacks<void>> = [];\nconst runCallbacks: Array<PromiseCallbacks<SerializableTensor[]>> = [];\nconst endProfilingCallbacks: Array<PromiseCallbacks<void>> = [];\n\nconst ensureWorker = (): void => {\n  if (initializing || !initialized || aborted || !proxyWorker) {\n    throw new Error('worker not ready');\n  }\n};\n\nconst onProxyWorkerMessage = (ev: MessageEvent<OrtWasmMessage>): void => {\n  switch (ev.data.type) {\n    case 'init-wasm':\n      initializing = false;\n      if (ev.data.err) {\n        aborted = true;\n        initWasmCallbacks[1](ev.data.err);\n      } else {\n        initialized = true;\n        initWasmCallbacks[0]();\n      }\n      break;\n    case 'init-ort':\n      if (ev.data.err) {\n        initOrtCallbacks[1](ev.data.err);\n      } else {\n        initOrtCallbacks[0]();\n      }\n      break;\n    case 'create_allocate':\n      if (ev.data.err) {\n        createSessionAllocateCallbacks.shift()![1](ev.data.err);\n      } else {\n        createSessionAllocateCallbacks.shift()![0](ev.data.out!);\n      }\n      break;\n    case 'create_finalize':\n      if (ev.data.err) {\n        createSessionFinalizeCallbacks.shift()![1](ev.data.err);\n      } else {\n        createSessionFinalizeCallbacks.shift()![0](ev.data.out!);\n      }\n      break;\n    case 'create':\n      if (ev.data.err) {\n        createSessionCallbacks.shift()![1](ev.data.err);\n      } else {\n        createSessionCallbacks.shift()![0](ev.data.out!);\n      }\n      break;\n    case 'release':\n      if (ev.data.err) {\n        releaseSessionCallbacks.shift()![1](ev.data.err);\n      } else {\n        releaseSessionCallbacks.shift()![0]();\n      }\n      break;\n    case 'run':\n      if (ev.data.err) {\n        runCallbacks.shift()![1](ev.data.err);\n      } else {\n        runCallbacks.shift()![0](ev.data.out!);\n      }\n      break;\n    case 'end-profiling':\n      if (ev.data.err) {\n        endProfilingCallbacks.shift()![1](ev.data.err);\n      } else {\n        endProfilingCallbacks.shift()![0]();\n      }\n      break;\n    default:\n  }\n};\n\nconst scriptSrc = typeof document !== 'undefined' ? (document?.currentScript as HTMLScriptElement)?.src : undefined;\n\nexport const initializeWebAssemblyInstance = async(): Promise<void> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    if (initialized) {\n      return;\n    }\n    if (initializing) {\n      throw new Error('multiple calls to \\'initWasm()\\' detected.');\n    }\n    if (aborted) {\n      throw new Error('previous call to \\'initWasm()\\' failed.');\n    }\n\n    initializing = true;\n\n    // overwrite wasm filepaths\n    if (env.wasm.wasmPaths === undefined) {\n      if (scriptSrc && scriptSrc.indexOf('blob:') !== 0) {\n        env.wasm.wasmPaths = scriptSrc.substr(0, +(scriptSrc).lastIndexOf('/') + 1);\n      }\n    }\n\n    return new Promise<void>((resolve, reject) => {\n      proxyWorker?.terminate();\n      // eslint-disable-next-line @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports\n      proxyWorker = require('worker-loader?inline=no-fallback!./proxy-worker/main').default() as Worker;\n      proxyWorker.onmessage = onProxyWorkerMessage;\n      initWasmCallbacks = [resolve, reject];\n      const message: OrtWasmMessage = {type: 'init-wasm', in : env.wasm};\n      proxyWorker.postMessage(message);\n    });\n\n  } else {\n    return initializeWebAssembly(env.wasm);\n  }\n};\n\nexport const initializeRuntime = async(env: Env): Promise<void> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    ensureWorker();\n    return new Promise<void>((resolve, reject) => {\n      initOrtCallbacks = [resolve, reject];\n      const message: OrtWasmMessage = {type: 'init-ort', in : env};\n      proxyWorker!.postMessage(message);\n    });\n  } else {\n    await core.initRuntime(env);\n  }\n};\n\nexport const createSessionAllocate = async(model: Uint8Array): Promise<SerializableModeldata> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    ensureWorker();\n    return new Promise<SerializableModeldata>((resolve, reject) => {\n      createSessionAllocateCallbacks.push([resolve, reject]);\n      const message: OrtWasmMessage = {type: 'create_allocate', in : {model}};\n      proxyWorker!.postMessage(message, [model.buffer]);\n    });\n  } else {\n    return core.createSessionAllocate(model);\n  }\n};\n\nexport const createSessionFinalize = async(modeldata: SerializableModeldata, options?: InferenceSession.SessionOptions):\n    Promise<SerializableSessionMetadata> => {\n      if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n        ensureWorker();\n        return new Promise<SerializableSessionMetadata>((resolve, reject) => {\n          createSessionFinalizeCallbacks.push([resolve, reject]);\n          const message: OrtWasmMessage = {type: 'create_finalize', in : {modeldata, options}};\n          proxyWorker!.postMessage(message);\n        });\n      } else {\n        return core.createSessionFinalize(modeldata, options);\n      }\n    };\n\nexport const createSession =\n    async(model: Uint8Array, options?: InferenceSession.SessionOptions): Promise<SerializableSessionMetadata> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    ensureWorker();\n    return new Promise<SerializableSessionMetadata>((resolve, reject) => {\n      createSessionCallbacks.push([resolve, reject]);\n      const message: OrtWasmMessage = {type: 'create', in : {model, options}};\n      proxyWorker!.postMessage(message, [model.buffer]);\n    });\n  } else {\n    return core.createSession(model, options);\n  }\n};\n\nexport const releaseSession = async(sessionId: number): Promise<void> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    ensureWorker();\n    return new Promise<void>((resolve, reject) => {\n      releaseSessionCallbacks.push([resolve, reject]);\n      const message: OrtWasmMessage = {type: 'release', in : sessionId};\n      proxyWorker!.postMessage(message);\n    });\n  } else {\n    core.releaseSession(sessionId);\n  }\n};\n\nexport const run = async(\n    sessionId: number, inputIndices: number[], inputs: SerializableTensor[], outputIndices: number[],\n    options: InferenceSession.RunOptions): Promise<SerializableTensor[]> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    ensureWorker();\n    return new Promise<SerializableTensor[]>((resolve, reject) => {\n      runCallbacks.push([resolve, reject]);\n      const message: OrtWasmMessage = {type: 'run', in : {sessionId, inputIndices, inputs, outputIndices, options}};\n      proxyWorker!.postMessage(message, core.extractTransferableBuffers(inputs));\n    });\n  } else {\n    return core.run(sessionId, inputIndices, inputs, outputIndices, options);\n  }\n};\n\nexport const endProfiling = async(sessionId: number): Promise<void> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    ensureWorker();\n    return new Promise<void>((resolve, reject) => {\n      endProfilingCallbacks.push([resolve, reject]);\n      const message: OrtWasmMessage = {type: 'end-profiling', in : sessionId};\n      proxyWorker!.postMessage(message);\n    });\n  } else {\n    core.endProfiling(sessionId);\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {InferenceSession} from 'onnxruntime-common';\n\nimport {getInstance} from './wasm-factory';\nimport {allocWasmString, checkLastError, iterateExtraOptions} from './wasm-utils';\n\nexport const setRunOptions = (options: InferenceSession.RunOptions): [number, number[]] => {\n  const wasm = getInstance();\n  let runOptionsHandle = 0;\n  const allocs: number[] = [];\n\n  const runOptions: InferenceSession.RunOptions = options || {};\n\n  try {\n    if (options?.logSeverityLevel === undefined) {\n      runOptions.logSeverityLevel = 2;  // Default to warning\n    } else if (\n        typeof options.logSeverityLevel !== 'number' || !Number.isInteger(options.logSeverityLevel) ||\n        options.logSeverityLevel < 0 || options.logSeverityLevel > 4) {\n      throw new Error(`log serverity level is not valid: ${options.logSeverityLevel}`);\n    }\n\n    if (options?.logVerbosityLevel === undefined) {\n      runOptions.logVerbosityLevel = 0;  // Default to 0\n    } else if (typeof options.logVerbosityLevel !== 'number' || !Number.isInteger(options.logVerbosityLevel)) {\n      throw new Error(`log verbosity level is not valid: ${options.logVerbosityLevel}`);\n    }\n\n    if (options?.terminate === undefined) {\n      runOptions.terminate = false;\n    }\n\n    let tagDataOffset = 0;\n    if (options?.tag !== undefined) {\n      tagDataOffset = allocWasmString(options.tag, allocs);\n    }\n\n    runOptionsHandle = wasm._OrtCreateRunOptions(\n        runOptions.logSeverityLevel!, runOptions.logVerbosityLevel!, !!runOptions.terminate!, tagDataOffset);\n    if (runOptionsHandle === 0) {\n      checkLastError('Can\\'t create run options.');\n    }\n\n    if (options?.extra !== undefined) {\n      iterateExtraOptions(options.extra, '', new WeakSet<Record<string, unknown>>(), (key, value) => {\n        const keyDataOffset = allocWasmString(key, allocs);\n        const valueDataOffset = allocWasmString(value, allocs);\n\n        if (wasm._OrtAddRunConfigEntry(runOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\n          checkLastError(`Can't set a run config entry: ${key} - ${value}.`);\n        }\n      });\n    }\n\n    return [runOptionsHandle, allocs];\n  } catch (e) {\n    if (runOptionsHandle !== 0) {\n      wasm._OrtReleaseRunOptions(runOptionsHandle);\n    }\n    allocs.forEach(alloc => wasm._free(alloc));\n    throw e;\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {readFile} from 'fs';\nimport {env, InferenceSession, SessionHandler, Tensor} from 'onnxruntime-common';\nimport {promisify} from 'util';\n\nimport {SerializableModeldata} from './proxy-messages';\nimport {createSession, createSessionAllocate, createSessionFinalize, endProfiling, initializeRuntime, releaseSession, run} from './proxy-wrapper';\n\nlet runtimeInitialized: boolean;\n\nexport class OnnxruntimeWebAssemblySessionHandler implements SessionHandler {\n  private sessionId: number;\n\n  inputNames: string[];\n  outputNames: string[];\n\n  async createSessionAllocate(path: string): Promise<SerializableModeldata> {\n    // fetch model from url and move to wasm heap. The arraybufffer that held the http\n    // response is freed once we return\n    const response = await fetch(path);\n    if (response.status !== 200) {\n      throw new Error(`failed to load model: ${path}`);\n    }\n    const arrayBuffer = await response.arrayBuffer();\n    return createSessionAllocate(new Uint8Array(arrayBuffer));\n  }\n\n  async loadModel(pathOrBuffer: string|Uint8Array, options?: InferenceSession.SessionOptions): Promise<void> {\n    if (!runtimeInitialized) {\n      await initializeRuntime(env);\n      runtimeInitialized = true;\n    }\n\n    if (typeof pathOrBuffer === 'string') {\n      if (typeof process !== 'undefined' && process.versions && process.versions.node) {\n        // node\n        const model = await promisify(readFile)(pathOrBuffer);\n        [this.sessionId, this.inputNames, this.outputNames] = await createSession(model, options);\n      } else {\n        // browser\n        // fetch model and move to wasm heap.\n        const modelData: SerializableModeldata = await this.createSessionAllocate(pathOrBuffer);\n        // create the session\n        [this.sessionId, this.inputNames, this.outputNames] = await createSessionFinalize(modelData, options);\n      }\n    } else {\n      [this.sessionId, this.inputNames, this.outputNames] = await createSession(pathOrBuffer, options);\n    }\n  }\n\n  async dispose(): Promise<void> {\n    return releaseSession(this.sessionId);\n  }\n\n  async run(feeds: SessionHandler.FeedsType, fetches: SessionHandler.FetchesType, options: InferenceSession.RunOptions):\n      Promise<SessionHandler.ReturnType> {\n    const inputArray: Tensor[] = [];\n    const inputIndices: number[] = [];\n    Object.entries(feeds).forEach(kvp => {\n      const name = kvp[0];\n      const tensor = kvp[1];\n      const index = this.inputNames.indexOf(name);\n      if (index === -1) {\n        throw new Error(`invalid input '${name}'`);\n      }\n      inputArray.push(tensor);\n      inputIndices.push(index);\n    });\n\n    const outputIndices: number[] = [];\n    Object.entries(fetches).forEach(kvp => {\n      const name = kvp[0];\n      // TODO: support pre-allocated output\n      const index = this.outputNames.indexOf(name);\n      if (index === -1) {\n        throw new Error(`invalid output '${name}'`);\n      }\n      outputIndices.push(index);\n    });\n\n    const outputs =\n        await run(this.sessionId, inputIndices, inputArray.map(t => [t.type, t.dims, t.data]), outputIndices, options);\n\n    const result: SessionHandler.ReturnType = {};\n    for (let i = 0; i < outputs.length; i++) {\n      result[this.outputNames[outputIndices[i]]] = new Tensor(outputs[i][0], outputs[i][2], outputs[i][1]);\n    }\n    return result;\n  }\n\n  startProfiling(): void {\n    // TODO: implement profiling\n  }\n\n  endProfiling(): void {\n    void endProfiling(this.sessionId);\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {InferenceSession} from 'onnxruntime-common';\n\nimport {getInstance} from './wasm-factory';\nimport {allocWasmString, checkLastError, iterateExtraOptions} from './wasm-utils';\n\nconst getGraphOptimzationLevel = (graphOptimizationLevel: string|unknown): number => {\n  switch (graphOptimizationLevel) {\n    case 'disabled':\n      return 0;\n    case 'basic':\n      return 1;\n    case 'extended':\n      return 2;\n    case 'all':\n      return 99;\n    default:\n      throw new Error(`unsupported graph optimization level: ${graphOptimizationLevel}`);\n  }\n};\n\nconst getExecutionMode = (executionMode: 'sequential'|'parallel'): number => {\n  switch (executionMode) {\n    case 'sequential':\n      return 0;\n    case 'parallel':\n      return 1;\n    default:\n      throw new Error(`unsupported execution mode: ${executionMode}`);\n  }\n};\n\nconst appendDefaultOptions = (options: InferenceSession.SessionOptions): void => {\n  if (!options.extra) {\n    options.extra = {};\n  }\n  if (!options.extra.session) {\n    options.extra.session = {};\n  }\n  const session = options.extra.session as Record<string, string>;\n  if (!session.use_ort_model_bytes_directly) {\n    // eslint-disable-next-line camelcase\n    session.use_ort_model_bytes_directly = '1';\n  }\n\n  // if using JSEP with WebGPU, always disable memory pattern\n  if (options.executionProviders &&\n      options.executionProviders.some(ep => (typeof ep === 'string' ? ep : ep.name) === 'webgpu')) {\n    options.enableMemPattern = false;\n  }\n};\n\nconst setExecutionProviders =\n    (sessionOptionsHandle: number, executionProviders: readonly InferenceSession.ExecutionProviderConfig[],\n     allocs: number[]): void => {\n      for (const ep of executionProviders) {\n        let epName = typeof ep === 'string' ? ep : ep.name;\n\n        // check EP name\n        switch (epName) {\n          case 'xnnpack':\n            epName = 'XNNPACK';\n            break;\n          case 'webnn':\n            epName = 'WEBNN';\n            if (typeof ep !== 'string') {\n              const webnnOptions = ep as InferenceSession.WebNNExecutionProviderOption;\n              if (webnnOptions?.deviceType) {\n                const keyDataOffset = allocWasmString('deviceType', allocs);\n                const valueDataOffset = allocWasmString(webnnOptions.deviceType, allocs);\n                if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !==\n                    0) {\n                  checkLastError(`Can't set a session config entry: 'deviceType' - ${webnnOptions.deviceType}.`);\n                }\n              }\n              if (webnnOptions?.powerPreference) {\n                const keyDataOffset = allocWasmString('powerPreference', allocs);\n                const valueDataOffset = allocWasmString(webnnOptions.powerPreference, allocs);\n                if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !==\n                    0) {\n                  checkLastError(\n                      `Can't set a session config entry: 'powerPreference' - ${webnnOptions.powerPreference}.`);\n                }\n              }\n            }\n            break;\n          case 'webgpu':\n            epName = 'JS';\n            break;\n          case 'wasm':\n          case 'cpu':\n            continue;\n          default:\n            throw new Error(`not supported execution provider: ${epName}`);\n        }\n\n        const epNameDataOffset = allocWasmString(epName, allocs);\n        if (getInstance()._OrtAppendExecutionProvider(sessionOptionsHandle, epNameDataOffset) !== 0) {\n          checkLastError(`Can't append execution provider: ${epName}.`);\n        }\n      }\n    };\n\nexport const setSessionOptions = (options?: InferenceSession.SessionOptions): [number, number[]] => {\n  const wasm = getInstance();\n  let sessionOptionsHandle = 0;\n  const allocs: number[] = [];\n\n  const sessionOptions: InferenceSession.SessionOptions = options || {};\n  appendDefaultOptions(sessionOptions);\n\n  try {\n    const graphOptimizationLevel = getGraphOptimzationLevel(sessionOptions.graphOptimizationLevel ?? 'all');\n    const executionMode = getExecutionMode(sessionOptions.executionMode ?? 'sequential');\n    const logIdDataOffset =\n        typeof sessionOptions.logId === 'string' ? allocWasmString(sessionOptions.logId, allocs) : 0;\n\n    const logSeverityLevel = sessionOptions.logSeverityLevel ?? 2;  // Default to 2 - warning\n    if (!Number.isInteger(logSeverityLevel) || logSeverityLevel < 0 || logSeverityLevel > 4) {\n      throw new Error(`log serverity level is not valid: ${logSeverityLevel}`);\n    }\n\n    const logVerbosityLevel = sessionOptions.logVerbosityLevel ?? 0;  // Default to 0 - verbose\n    if (!Number.isInteger(logVerbosityLevel) || logVerbosityLevel < 0 || logVerbosityLevel > 4) {\n      throw new Error(`log verbosity level is not valid: ${logVerbosityLevel}`);\n    }\n\n    const optimizedModelFilePathOffset = typeof sessionOptions.optimizedModelFilePath === 'string' ?\n        allocWasmString(sessionOptions.optimizedModelFilePath, allocs) :\n        0;\n\n    sessionOptionsHandle = wasm._OrtCreateSessionOptions(\n        graphOptimizationLevel, !!sessionOptions.enableCpuMemArena, !!sessionOptions.enableMemPattern, executionMode,\n        !!sessionOptions.enableProfiling, 0, logIdDataOffset, logSeverityLevel, logVerbosityLevel,\n        optimizedModelFilePathOffset);\n    if (sessionOptionsHandle === 0) {\n      checkLastError('Can\\'t create session options.');\n    }\n\n    if (sessionOptions.executionProviders) {\n      setExecutionProviders(sessionOptionsHandle, sessionOptions.executionProviders, allocs);\n    }\n\n    if (sessionOptions.extra !== undefined) {\n      iterateExtraOptions(sessionOptions.extra, '', new WeakSet<Record<string, unknown>>(), (key, value) => {\n        const keyDataOffset = allocWasmString(key, allocs);\n        const valueDataOffset = allocWasmString(value, allocs);\n\n        if (wasm._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\n          checkLastError(`Can't set a session config entry: ${key} - ${value}.`);\n        }\n      });\n    }\n\n    return [sessionOptionsHandle, allocs];\n  } catch (e) {\n    if (sessionOptionsHandle !== 0) {\n      wasm._OrtReleaseSessionOptions(sessionOptionsHandle);\n    }\n    allocs.forEach(alloc => wasm._free(alloc));\n    throw e;\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from 'onnxruntime-common';\n\n// This file includes common definitions. They do NOT have dependency on the WebAssembly instance.\n\n/**\n * Copied from ONNX definition. Use this to drop dependency 'onnx_proto' to decrease compiled .js file size.\n */\nexport const enum DataType {\n  undefined = 0,\n  float = 1,\n  uint8 = 2,\n  int8 = 3,\n  uint16 = 4,\n  int16 = 5,\n  int32 = 6,\n  int64 = 7,\n  string = 8,\n  bool = 9,\n  float16 = 10,\n  double = 11,\n  uint32 = 12,\n  uint64 = 13,\n  complex64 = 14,\n  complex128 = 15,\n  bfloat16 = 16\n}\n\n/**\n * Map string tensor data to enum value\n */\nexport const tensorDataTypeStringToEnum = (type: string): DataType => {\n  switch (type) {\n    case 'int8':\n      return DataType.int8;\n    case 'uint8':\n      return DataType.uint8;\n    case 'bool':\n      return DataType.bool;\n    case 'int16':\n      return DataType.int16;\n    case 'uint16':\n      return DataType.uint16;\n    case 'int32':\n      return DataType.int32;\n    case 'uint32':\n      return DataType.uint32;\n    case 'float16':\n      return DataType.float16;\n    case 'float32':\n      return DataType.float;\n    case 'float64':\n      return DataType.double;\n    case 'string':\n      return DataType.string;\n    case 'int64':\n      return DataType.int64;\n    case 'uint64':\n      return DataType.uint64;\n\n    default:\n      throw new Error(`unsupported data type: ${type}`);\n  }\n};\n\n/**\n * Map enum value to string tensor data\n */\nexport const tensorDataTypeEnumToString = (typeProto: DataType): Tensor.Type => {\n  switch (typeProto) {\n    case DataType.int8:\n      return 'int8';\n    case DataType.uint8:\n      return 'uint8';\n    case DataType.bool:\n      return 'bool';\n    case DataType.int16:\n      return 'int16';\n    case DataType.uint16:\n      return 'uint16';\n    case DataType.int32:\n      return 'int32';\n    case DataType.uint32:\n      return 'uint32';\n    case DataType.float16:\n      return 'float16';\n    case DataType.float:\n      return 'float32';\n    case DataType.double:\n      return 'float64';\n    case DataType.string:\n      return 'string';\n    case DataType.int64:\n      return 'int64';\n    case DataType.uint64:\n      return 'uint64';\n\n    default:\n      throw new Error(`unsupported data type: ${typeProto}`);\n  }\n};\n\n/**\n * get tensor element size in bytes by the given data type\n * @returns size in integer or undefined if the data type is not supported\n */\nexport const getTensorElementSize = (dateType: number): number|\n    undefined => [undefined, 4, 1, 1, 2, 2, 4, 8, undefined, 1, 2, 8, 4, 8, undefined, undefined, undefined][dateType];\n\n/**\n * get typed array constructor by the given tensor type\n */\nexport const tensorTypeToTypedArrayConstructor = (type: Tensor.Type): Float32ArrayConstructor|Uint8ArrayConstructor|\n    Int8ArrayConstructor|Uint16ArrayConstructor|Int16ArrayConstructor|Int32ArrayConstructor|BigInt64ArrayConstructor|\n    Uint8ArrayConstructor|Float64ArrayConstructor|Uint32ArrayConstructor|BigUint64ArrayConstructor => {\n      switch (type) {\n        case 'float16':\n          return Uint16Array;\n        case 'float32':\n          return Float32Array;\n        case 'uint8':\n          return Uint8Array;\n        case 'int8':\n          return Int8Array;\n        case 'uint16':\n          return Uint16Array;\n        case 'int16':\n          return Int16Array;\n        case 'int32':\n          return Int32Array;\n        case 'bool':\n          return Uint8Array;\n        case 'float64':\n          return Float64Array;\n        case 'uint32':\n          return Uint32Array;\n        case 'int64':\n          return BigInt64Array;\n        case 'uint64':\n          return BigUint64Array;\n        default:\n          throw new Error(`unsupported type: ${type}`);\n      }\n    };\n\n/**\n * Map string log level to integer value\n */\nexport const logLevelStringToEnum = (logLevel?: 'verbose'|'info'|'warning'|'error'|'fatal'): number => {\n  switch (logLevel) {\n    case 'verbose':\n      return 0;\n    case 'info':\n      return 1;\n    case 'warning':\n      return 2;\n    case 'error':\n      return 3;\n    case 'fatal':\n      return 4;\n    default:\n      throw new Error(`unsupported logging level: ${logLevel}`);\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Env, InferenceSession, Tensor} from 'onnxruntime-common';\n\nimport {SerializableModeldata, SerializableSessionMetadata, SerializableTensor} from './proxy-messages';\nimport {setRunOptions} from './run-options';\nimport {setSessionOptions} from './session-options';\nimport {logLevelStringToEnum, tensorDataTypeEnumToString, tensorDataTypeStringToEnum, tensorTypeToTypedArrayConstructor} from './wasm-common';\nimport {getInstance} from './wasm-factory';\nimport {allocWasmString, checkLastError} from './wasm-utils';\n\n/**\n * get the input/output count of the session.\n * @param sessionHandle the handle representing the session. should be non-zero.\n * @returns a tuple including 2 numbers, representing the input count and output count.\n */\nconst getSessionInputOutputCount = (sessionHandle: number): [number, number] => {\n  const wasm = getInstance();\n  const stack = wasm.stackSave();\n  try {\n    const dataOffset = wasm.stackAlloc(8);\n    const errorCode = wasm._OrtGetInputOutputCount(sessionHandle, dataOffset, dataOffset + 4);\n    if (errorCode !== 0) {\n      checkLastError('Can\\'t get session input/output count.');\n    }\n    return [wasm.HEAP32[dataOffset / 4], wasm.HEAP32[dataOffset / 4 + 1]];\n  } finally {\n    wasm.stackRestore(stack);\n  }\n};\n\n/**\n * initialize ORT environment.\n * @param numThreads SetGlobalIntraOpNumThreads(numThreads)\n * @param loggingLevel CreateEnv(static_cast<OrtLoggingLevel>(logging_level))\n */\nconst initOrt = (numThreads: number, loggingLevel: number): void => {\n  const errorCode = getInstance()._OrtInit(numThreads, loggingLevel);\n  if (errorCode !== 0) {\n    checkLastError('Can\\'t initialize onnxruntime.');\n  }\n};\n\n/**\n * intialize runtime environment.\n * @param env passed in the environment config object.\n */\nexport const initRuntime = async(env: Env): Promise<void> => {\n  // init ORT\n  initOrt(env.wasm.numThreads!, logLevelStringToEnum(env.logLevel));\n\n  if (!BUILD_DEFS.DISABLE_WEBGPU) {\n    // init JSEP if available\n\n    // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires\n    const initJsep = require('./jsep/init').init;\n    await initJsep(getInstance(), env);\n  }\n};\n\n/**\n *  tuple elements are: InferenceSession ID; inputNamesUTF8Encoded; outputNamesUTF8Encoded\n */\ntype SessionMetadata = [number, number[], number[]];\n\nconst activeSessions = new Map<number, SessionMetadata>();\n\n/**\n * allocate the memory and memcpy the model bytes, preparing for creating an instance of InferenceSession.\n * @returns a 2-elements tuple - the pointer and size of the allocated buffer\n */\nexport const createSessionAllocate = (model: Uint8Array): [number, number] => {\n  const wasm = getInstance();\n  const modelDataOffset = wasm._malloc(model.byteLength);\n  if (modelDataOffset === 0) {\n    throw new Error(`Can't create a session. failed to allocate a buffer of size ${model.byteLength}.`);\n  }\n  wasm.HEAPU8.set(model, modelDataOffset);\n  return [modelDataOffset, model.byteLength];\n};\n\n/**\n * create an inference session using the prepared buffer containing the model data.\n * @param modelData a 2-elements tuple containing the pointer and size of the model data buffer.\n * @param options an optional session options object.\n * @returns a 3-elements tuple containing [session handle, input names, output names]\n */\nexport const createSessionFinalize =\n    (modelData: SerializableModeldata, options?: InferenceSession.SessionOptions): SerializableSessionMetadata => {\n      const wasm = getInstance();\n\n      let sessionHandle = 0;\n      let sessionOptionsHandle = 0;\n      let allocs: number[] = [];\n      const inputNamesUTF8Encoded = [];\n      const outputNamesUTF8Encoded = [];\n\n      try {\n        [sessionOptionsHandle, allocs] = setSessionOptions(options);\n\n        sessionHandle = wasm._OrtCreateSession(modelData[0], modelData[1], sessionOptionsHandle);\n        if (sessionHandle === 0) {\n          checkLastError('Can\\'t create a session.');\n        }\n\n        const [inputCount, outputCount] = getSessionInputOutputCount(sessionHandle);\n\n        const inputNames = [];\n        const outputNames = [];\n        for (let i = 0; i < inputCount; i++) {\n          const name = wasm._OrtGetInputName(sessionHandle, i);\n          if (name === 0) {\n            checkLastError('Can\\'t get an input name.');\n          }\n          inputNamesUTF8Encoded.push(name);\n          inputNames.push(wasm.UTF8ToString(name));\n        }\n        for (let i = 0; i < outputCount; i++) {\n          const name = wasm._OrtGetOutputName(sessionHandle, i);\n          if (name === 0) {\n            checkLastError('Can\\'t get an output name.');\n          }\n          outputNamesUTF8Encoded.push(name);\n          outputNames.push(wasm.UTF8ToString(name));\n        }\n\n        activeSessions.set(sessionHandle, [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded]);\n        return [sessionHandle, inputNames, outputNames];\n      } catch (e) {\n        inputNamesUTF8Encoded.forEach(buf => wasm._OrtFree(buf));\n        outputNamesUTF8Encoded.forEach(buf => wasm._OrtFree(buf));\n\n        if (sessionHandle !== 0) {\n          wasm._OrtReleaseSession(sessionHandle);\n        }\n        throw e;\n      } finally {\n        wasm._free(modelData[0]);\n        if (sessionOptionsHandle !== 0) {\n          wasm._OrtReleaseSessionOptions(sessionOptionsHandle);\n        }\n        allocs.forEach(alloc => wasm._free(alloc));\n      }\n    };\n\n\n/**\n * create an instance of InferenceSession.\n * @returns the metadata of InferenceSession. 0-value handle for failure.\n */\nexport const createSession =\n    (model: Uint8Array, options?: InferenceSession.SessionOptions): SerializableSessionMetadata => {\n      const modelData: SerializableModeldata = createSessionAllocate(model);\n      return createSessionFinalize(modelData, options);\n    };\n\nexport const releaseSession = (sessionId: number): void => {\n  const wasm = getInstance();\n  const session = activeSessions.get(sessionId);\n  if (!session) {\n    throw new Error(`cannot release session. invalid session id: ${sessionId}`);\n  }\n  const [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded] = session;\n\n  inputNamesUTF8Encoded.forEach(buf => wasm._OrtFree(buf));\n  outputNamesUTF8Encoded.forEach(buf => wasm._OrtFree(buf));\n  wasm._OrtReleaseSession(sessionHandle);\n  activeSessions.delete(sessionId);\n};\n\n/**\n * perform inference run\n */\nexport const run = async(\n    sessionId: number, inputIndices: number[], inputs: SerializableTensor[], outputIndices: number[],\n    options: InferenceSession.RunOptions): Promise<SerializableTensor[]> => {\n  const wasm = getInstance();\n  const session = activeSessions.get(sessionId);\n  if (!session) {\n    throw new Error(`cannot run inference. invalid session id: ${sessionId}`);\n  }\n  const [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded] = session;\n\n  const inputCount = inputIndices.length;\n  const outputCount = outputIndices.length;\n\n  let runOptionsHandle = 0;\n  let runOptionsAllocs: number[] = [];\n\n  const inputValues: number[] = [];\n  const inputAllocs: number[] = [];\n\n  try {\n    [runOptionsHandle, runOptionsAllocs] = setRunOptions(options);\n\n    // create input tensors\n    for (let i = 0; i < inputCount; i++) {\n      const dataType = inputs[i][0];\n      const dims = inputs[i][1];\n      const data = inputs[i][2];\n\n      let dataOffset: number;\n      let dataByteLength: number;\n\n      if (Array.isArray(data)) {\n        // string tensor\n        dataByteLength = 4 * data.length;\n        dataOffset = wasm._malloc(dataByteLength);\n        inputAllocs.push(dataOffset);\n        let dataIndex = dataOffset / 4;\n        for (let i = 0; i < data.length; i++) {\n          if (typeof data[i] !== 'string') {\n            throw new TypeError(`tensor data at index ${i} is not a string`);\n          }\n          wasm.HEAPU32[dataIndex++] = allocWasmString(data[i], inputAllocs);\n        }\n      } else {\n        dataByteLength = data.byteLength;\n        dataOffset = wasm._malloc(dataByteLength);\n        inputAllocs.push(dataOffset);\n        wasm.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), dataOffset);\n      }\n\n      const stack = wasm.stackSave();\n      const dimsOffset = wasm.stackAlloc(4 * dims.length);\n      try {\n        let dimIndex = dimsOffset / 4;\n        dims.forEach(d => wasm.HEAP32[dimIndex++] = d);\n        const tensor = wasm._OrtCreateTensor(\n            tensorDataTypeStringToEnum(dataType), dataOffset, dataByteLength, dimsOffset, dims.length);\n        if (tensor === 0) {\n          checkLastError(`Can't create tensor for input[${i}].`);\n        }\n        inputValues.push(tensor);\n      } finally {\n        wasm.stackRestore(stack);\n      }\n    }\n\n    const beforeRunStack = wasm.stackSave();\n    const inputValuesOffset = wasm.stackAlloc(inputCount * 4);\n    const inputNamesOffset = wasm.stackAlloc(inputCount * 4);\n    const outputValuesOffset = wasm.stackAlloc(outputCount * 4);\n    const outputNamesOffset = wasm.stackAlloc(outputCount * 4);\n\n    try {\n      let inputValuesIndex = inputValuesOffset / 4;\n      let inputNamesIndex = inputNamesOffset / 4;\n      let outputValuesIndex = outputValuesOffset / 4;\n      let outputNamesIndex = outputNamesOffset / 4;\n      for (let i = 0; i < inputCount; i++) {\n        wasm.HEAPU32[inputValuesIndex++] = inputValues[i];\n        wasm.HEAPU32[inputNamesIndex++] = inputNamesUTF8Encoded[inputIndices[i]];\n      }\n      for (let i = 0; i < outputCount; i++) {\n        wasm.HEAPU32[outputValuesIndex++] = 0;\n        wasm.HEAPU32[outputNamesIndex++] = outputNamesUTF8Encoded[outputIndices[i]];\n      }\n\n      // support RunOptions\n      let errorCode = wasm._OrtRun(\n          sessionHandle, inputNamesOffset, inputValuesOffset, inputCount, outputNamesOffset, outputCount,\n          outputValuesOffset, runOptionsHandle);\n\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      const runPromise = wasm.jsepRunPromise;\n      if (runPromise && typeof runPromise.then !== 'undefined') {\n        errorCode = await runPromise;\n      }\n\n      const output: SerializableTensor[] = [];\n\n      if (errorCode !== 0) {\n        checkLastError('failed to call OrtRun().');\n      }\n\n      for (let i = 0; i < outputCount; i++) {\n        const tensor = wasm.HEAPU32[outputValuesOffset / 4 + i];\n\n        const beforeGetTensorDataStack = wasm.stackSave();\n        // stack allocate 4 pointer value\n        const tensorDataOffset = wasm.stackAlloc(4 * 4);\n\n        let type: Tensor.Type|undefined, dataOffset = 0;\n        try {\n          errorCode = wasm._OrtGetTensorData(\n              tensor, tensorDataOffset, tensorDataOffset + 4, tensorDataOffset + 8, tensorDataOffset + 12);\n          if (errorCode !== 0) {\n            checkLastError(`Can't access output tensor data on index ${i}.`);\n          }\n          let tensorDataIndex = tensorDataOffset / 4;\n          const dataType = wasm.HEAPU32[tensorDataIndex++];\n          dataOffset = wasm.HEAPU32[tensorDataIndex++];\n          const dimsOffset = wasm.HEAPU32[tensorDataIndex++];\n          const dimsLength = wasm.HEAPU32[tensorDataIndex++];\n          const dims = [];\n          for (let i = 0; i < dimsLength; i++) {\n            dims.push(wasm.HEAPU32[dimsOffset / 4 + i]);\n          }\n          wasm._OrtFree(dimsOffset);\n\n          const size = dims.length === 0 ? 1 : dims.reduce((a, b) => a * b);\n          type = tensorDataTypeEnumToString(dataType);\n          if (type === 'string') {\n            const stringData: string[] = [];\n            let dataIndex = dataOffset / 4;\n            for (let i = 0; i < size; i++) {\n              const offset = wasm.HEAPU32[dataIndex++];\n              const maxBytesToRead = i === size - 1 ? undefined : wasm.HEAPU32[dataIndex] - offset;\n              stringData.push(wasm.UTF8ToString(offset, maxBytesToRead));\n            }\n            output.push([type, dims, stringData]);\n          } else {\n            const typedArrayConstructor = tensorTypeToTypedArrayConstructor(type);\n            const data = new typedArrayConstructor(size);\n            new Uint8Array(data.buffer, data.byteOffset, data.byteLength)\n                .set(wasm.HEAPU8.subarray(dataOffset, dataOffset + data.byteLength));\n            output.push([type, dims, data]);\n          }\n        } finally {\n          wasm.stackRestore(beforeGetTensorDataStack);\n          if (type === 'string' && dataOffset) {\n            wasm._free(dataOffset);\n          }\n          wasm._OrtReleaseTensor(tensor);\n        }\n      }\n\n      return output;\n    } finally {\n      wasm.stackRestore(beforeRunStack);\n    }\n  } finally {\n    inputValues.forEach(v => wasm._OrtReleaseTensor(v));\n    inputAllocs.forEach(p => wasm._free(p));\n\n    if (runOptionsHandle !== 0) {\n      wasm._OrtReleaseRunOptions(runOptionsHandle);\n    }\n    runOptionsAllocs.forEach(p => wasm._free(p));\n  }\n};\n\n/**\n * end profiling\n */\nexport const endProfiling = (sessionId: number): void => {\n  const wasm = getInstance();\n  const session = activeSessions.get(sessionId);\n  if (!session) {\n    throw new Error('invalid session id');\n  }\n  const sessionHandle = session[0];\n\n  // profile file name is not used yet, but it must be freed.\n  const profileFileName = wasm._OrtEndProfiling(sessionHandle);\n  if (profileFileName === 0) {\n    checkLastError('Can\\'t get an profile file name.');\n  }\n  wasm._OrtFree(profileFileName);\n};\n\nexport const extractTransferableBuffers = (tensors: readonly SerializableTensor[]): ArrayBufferLike[] => {\n  const buffers: ArrayBufferLike[] = [];\n  for (const tensor of tensors) {\n    const data = tensor[2];\n    if (!Array.isArray(data) && data.buffer) {\n      buffers.push(data.buffer);\n    }\n  }\n  return buffers;\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Env} from 'onnxruntime-common';\nimport * as path from 'path';\n\nimport {OrtWasmModule} from './binding/ort-wasm';\nimport {OrtWasmThreadedModule} from './binding/ort-wasm-threaded';\n\n/* eslint-disable @typescript-eslint/no-require-imports */\nconst ortWasmFactory: EmscriptenModuleFactory<OrtWasmModule> =\n    BUILD_DEFS.DISABLE_WEBGPU ? require('./binding/ort-wasm.js') : require('./binding/ort-wasm-simd.jsep.js');\n\nconst ortWasmFactoryThreaded: EmscriptenModuleFactory<OrtWasmModule> = !BUILD_DEFS.DISABLE_WASM_THREAD ?\n    (BUILD_DEFS.DISABLE_WEBGPU ? require('./binding/ort-wasm-threaded.js') :\n                                 require('./binding/ort-wasm-simd-threaded.jsep.js')) :\n    ortWasmFactory;\n/* eslint-enable @typescript-eslint/no-require-imports */\n\nlet wasm: OrtWasmModule|undefined;\nlet initialized = false;\nlet initializing = false;\nlet aborted = false;\n\nconst isMultiThreadSupported = (): boolean => {\n  try {\n    // If 'SharedArrayBuffer' is not available, WebAssembly threads will not work.\n    if (typeof SharedArrayBuffer === 'undefined') {\n      return false;\n    }\n\n    // Test for transferability of SABs (for browsers. needed for Firefox)\n    // https://groups.google.com/forum/#!msg/mozilla.dev.platform/IHkBZlHETpA/dwsMNchWEQAJ\n    if (typeof MessageChannel !== 'undefined') {\n      new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));\n    }\n\n    // Test for WebAssembly threads capability (for both browsers and Node.js)\n    // This typed array is a WebAssembly program containing threaded instructions.\n    return WebAssembly.validate(new Uint8Array([\n      0, 97, 115, 109, 1, 0,  0,  0, 1, 4, 1,  96, 0,   0,  3, 2, 1,  0, 5,\n      4, 1,  3,   1,   1, 10, 11, 1, 9, 0, 65, 0,  254, 16, 2, 0, 26, 11\n    ]));\n  } catch (e) {\n    return false;\n  }\n};\n\nconst isSimdSupported = (): boolean => {\n  try {\n    // Test for WebAssembly SIMD capability (for both browsers and Node.js)\n    // This typed array is a WebAssembly program containing SIMD instructions.\n\n    // The binary data is generated from the following code by wat2wasm:\n    //\n    // (module\n    //   (type $t0 (func))\n    //   (func $f0 (type $t0)\n    //     (drop\n    //       (i32x4.dot_i16x8_s\n    //         (i8x16.splat\n    //           (i32.const 0))\n    //         (v128.const i32x4 0x00000000 0x00000000 0x00000000 0x00000000)))))\n\n    return WebAssembly.validate(new Uint8Array([\n      0,   97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 30, 1,   28,  0, 65, 0,\n      253, 15, 253, 12,  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0,  0,  253, 186, 1, 26, 11\n    ]));\n  } catch (e) {\n    return false;\n  }\n};\n\nconst getWasmFileName = (useSimd: boolean, useThreads: boolean) => {\n  if (useThreads) {\n    return useSimd ? 'ort-wasm-simd-threaded.wasm' : 'ort-wasm-threaded.wasm';\n  } else {\n    return useSimd ? 'ort-wasm-simd.wasm' : 'ort-wasm.wasm';\n  }\n};\n\nexport const initializeWebAssembly = async(flags: Env.WebAssemblyFlags): Promise<void> => {\n  if (initialized) {\n    return Promise.resolve();\n  }\n  if (initializing) {\n    throw new Error('multiple calls to \\'initializeWebAssembly()\\' detected.');\n  }\n  if (aborted) {\n    throw new Error('previous call to \\'initializeWebAssembly()\\' failed.');\n  }\n\n  initializing = true;\n\n  // wasm flags are already initialized\n  const timeout = flags.initTimeout!;\n  const numThreads = flags.numThreads!;\n  const simd = flags.simd!;\n\n  const useThreads = numThreads > 1 && isMultiThreadSupported();\n  const useSimd = simd && isSimdSupported();\n\n  const wasmPaths = flags.wasmPaths;\n  const wasmPrefixOverride = typeof wasmPaths === 'string' ? wasmPaths : undefined;\n  const wasmFileName = getWasmFileName(useSimd, useThreads);\n  const wasmPathOverride = typeof wasmPaths === 'object' ? wasmPaths[wasmFileName] : undefined;\n\n  let isTimeout = false;\n\n  const tasks: Array<Promise<void>> = [];\n\n  // promise for timeout\n  if (timeout > 0) {\n    tasks.push(new Promise((resolve) => {\n      setTimeout(() => {\n        isTimeout = true;\n        resolve();\n      }, timeout);\n    }));\n  }\n\n  // promise for module initialization\n  tasks.push(new Promise((resolve, reject) => {\n    const factory = useThreads ? ortWasmFactoryThreaded : ortWasmFactory;\n    const config: Partial<OrtWasmModule> = {\n      locateFile: (fileName: string, scriptDirectory: string) => {\n        if (!BUILD_DEFS.DISABLE_WASM_THREAD && useThreads && fileName.endsWith('.worker.js') &&\n            typeof Blob !== 'undefined') {\n          return URL.createObjectURL(new Blob(\n              [\n                // This require() function is handled by webpack to load file content of the corresponding .worker.js\n                // eslint-disable-next-line @typescript-eslint/no-require-imports\n                require('./binding/ort-wasm-threaded.worker.js')\n              ],\n              {type: 'text/javascript'}));\n        }\n\n        if (fileName.endsWith('.wasm')) {\n          if (wasmPathOverride) {\n            return wasmPathOverride;\n          }\n\n          const prefix = wasmPrefixOverride ?? scriptDirectory;\n\n          if (!BUILD_DEFS.DISABLE_WEBGPU) {\n            if (wasmFileName === 'ort-wasm-simd.wasm') {\n              return prefix + 'ort-wasm-simd.jsep.wasm';\n            } else if (wasmFileName === 'ort-wasm-simd-threaded.wasm') {\n              return prefix + 'ort-wasm-simd-threaded.jsep.wasm';\n            }\n          }\n\n          return prefix + wasmFileName;\n        }\n\n        return scriptDirectory + fileName;\n      }\n    };\n\n    if (!BUILD_DEFS.DISABLE_WASM_THREAD && useThreads) {\n      if (typeof Blob === 'undefined') {\n        config.mainScriptUrlOrBlob = path.join(__dirname, 'ort-wasm-threaded.js');\n      } else {\n        const scriptSourceCode = `var ortWasmThreaded=(function(){var _scriptDir;return ${factory.toString()}})();`;\n        config.mainScriptUrlOrBlob = new Blob([scriptSourceCode], {type: 'text/javascript'});\n      }\n    }\n\n    factory(config).then(\n        // wasm module initialized successfully\n        module => {\n          initializing = false;\n          initialized = true;\n          wasm = module;\n          resolve();\n        },\n        // wasm module failed to initialize\n        (what) => {\n          initializing = false;\n          aborted = true;\n          reject(what);\n        });\n  }));\n\n  await Promise.race(tasks);\n\n  if (isTimeout) {\n    throw new Error(`WebAssembly backend initializing failed due to timeout: ${timeout}ms`);\n  }\n};\n\nexport const getInstance = (): OrtWasmModule => {\n  if (initialized && wasm) {\n    return wasm;\n  }\n\n  throw new Error('WebAssembly is not initialized yet.');\n};\n\nexport const dispose = (): void => {\n  if (initialized && !initializing && !aborted) {\n    initializing = true;\n\n    (wasm as OrtWasmThreadedModule).PThread?.terminateAllThreads();\n    wasm = undefined;\n\n    initializing = false;\n    initialized = false;\n    aborted = true;\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {getInstance} from './wasm-factory';\n\nexport const allocWasmString = (data: string, allocs: number[]): number => {\n  const wasm = getInstance();\n\n  const dataLength = wasm.lengthBytesUTF8(data) + 1;\n  const dataOffset = wasm._malloc(dataLength);\n  wasm.stringToUTF8(data, dataOffset, dataLength);\n  allocs.push(dataOffset);\n\n  return dataOffset;\n};\n\ninterface ExtraOptionsHandler {\n  (name: string, value: string): void;\n}\n\nexport const iterateExtraOptions =\n    (options: Record<string, unknown>, prefix: string, seen: WeakSet<Record<string, unknown>>,\n     handler: ExtraOptionsHandler): void => {\n      if (typeof options == 'object' && options !== null) {\n        if (seen.has(options)) {\n          throw new Error('Circular reference in options');\n        } else {\n          seen.add(options);\n        }\n      }\n\n      Object.entries(options).forEach(([key, value]) => {\n        const name = (prefix) ? prefix + key : key;\n        if (typeof value === 'object') {\n          iterateExtraOptions(value as Record<string, unknown>, name + '.', seen, handler);\n        } else if (typeof value === 'string' || typeof value === 'number') {\n          handler(name, value.toString());\n        } else if (typeof value === 'boolean') {\n          handler(name, (value) ? '1' : '0');\n        } else {\n          throw new Error(`Can't handle extra config type: ${typeof value}`);\n        }\n      });\n    };\n\n/**\n * check web assembly API's last error and throw error if any error occurred.\n * @param message a message used when an error occurred.\n */\nexport const checkLastError = (message: string): void => {\n  const wasm = getInstance();\n\n  const stack = wasm.stackSave();\n  try {\n    const paramsOffset = wasm.stackAlloc(8);\n    wasm._OrtGetLastError(paramsOffset, paramsOffset + 4);\n    const errorCode = wasm.HEAP32[paramsOffset / 4];\n    const errorMessagePointer = wasm.HEAPU32[paramsOffset / 4 + 1];\n    const errorMessage = errorMessagePointer ? wasm.UTF8ToString(errorMessagePointer) : '';\n    throw new Error(`${message} ERROR_CODE: ${errorCode}, ERROR_MESSAGE: ${errorMessage}`);\n  } finally {\n    wasm.stackRestore(stack);\n  }\n};\n","\nimport worker from \"!!../../../../node_modules/worker-loader/dist/runtime/inline.js\";\n\nexport default function Worker_fn() {\n  return worker(\"/*!\\n* ONNX Runtime Web v1.16.3\\n* Copyright (c) Microsoft Corporation. All rights reserved.\\n* Licensed under the MIT License.\\n*/\\n(()=>{var e={918:(e,t,r)=>{\\\"use strict\\\";Object.defineProperty(t,\\\"__esModule\\\",{value:!0}),t.setRunOptions=void 0;const n=r(263),a=r(497);t.setRunOptions=e=>{const t=(0,n.getInstance)();let r=0;const o=[],i=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))i.logSeverityLevel=2;else if(\\\"number\\\"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))i.logVerbosityLevel=0;else if(\\\"number\\\"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(i.terminate=!1);let n=0;return void 0!==(null==e?void 0:e.tag)&&(n=(0,a.allocWasmString)(e.tag,o)),r=t._OrtCreateRunOptions(i.logSeverityLevel,i.logVerbosityLevel,!!i.terminate,n),0===r&&(0,a.checkLastError)(\\\"Can't create run options.\\\"),void 0!==(null==e?void 0:e.extra)&&(0,a.iterateExtraOptions)(e.extra,\\\"\\\",new WeakSet,((e,n)=>{const i=(0,a.allocWasmString)(e,o),s=(0,a.allocWasmString)(n,o);0!==t._OrtAddRunConfigEntry(r,i,s)&&(0,a.checkLastError)(`Can't set a run config entry: ${e} - ${n}.`)})),[r,o]}catch(e){throw 0!==r&&t._OrtReleaseRunOptions(r),o.forEach((e=>t._free(e))),e}}},622:(e,t,r)=>{\\\"use strict\\\";Object.defineProperty(t,\\\"__esModule\\\",{value:!0}),t.setSessionOptions=void 0;const n=r(263),a=r(497);t.setSessionOptions=e=>{var t,r,o,i;const s=(0,n.getInstance)();let u=0;const c=[],l=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly=\\\"1\\\"),e.executionProviders&&e.executionProviders.some((e=>\\\"webgpu\\\"===(\\\"string\\\"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(l);try{const e=(e=>{switch(e){case\\\"disabled\\\":return 0;case\\\"basic\\\":return 1;case\\\"extended\\\":return 2;case\\\"all\\\":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=l.graphOptimizationLevel)&&void 0!==t?t:\\\"all\\\"),f=(e=>{switch(e){case\\\"sequential\\\":return 0;case\\\"parallel\\\":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(r=l.executionMode)&&void 0!==r?r:\\\"sequential\\\"),d=\\\"string\\\"==typeof l.logId?(0,a.allocWasmString)(l.logId,c):0,p=null!==(o=l.logSeverityLevel)&&void 0!==o?o:2;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log serverity level is not valid: ${p}`);const g=null!==(i=l.logVerbosityLevel)&&void 0!==i?i:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);const h=\\\"string\\\"==typeof l.optimizedModelFilePath?(0,a.allocWasmString)(l.optimizedModelFilePath,c):0;return u=s._OrtCreateSessionOptions(e,!!l.enableCpuMemArena,!!l.enableMemPattern,f,!!l.enableProfiling,0,d,p,g,h),0===u&&(0,a.checkLastError)(\\\"Can't create session options.\\\"),l.executionProviders&&((e,t,r)=>{for(const o of t){let t=\\\"string\\\"==typeof o?o:o.name;switch(t){case\\\"xnnpack\\\":t=\\\"XNNPACK\\\";break;case\\\"webnn\\\":if(t=\\\"WEBNN\\\",\\\"string\\\"!=typeof o){const t=o;if(null==t?void 0:t.deviceType){const o=(0,a.allocWasmString)(\\\"deviceType\\\",r),i=(0,a.allocWasmString)(t.deviceType,r);0!==(0,n.getInstance)()._OrtAddSessionConfigEntry(e,o,i)&&(0,a.checkLastError)(`Can't set a session config entry: 'deviceType' - ${t.deviceType}.`)}if(null==t?void 0:t.powerPreference){const o=(0,a.allocWasmString)(\\\"powerPreference\\\",r),i=(0,a.allocWasmString)(t.powerPreference,r);0!==(0,n.getInstance)()._OrtAddSessionConfigEntry(e,o,i)&&(0,a.checkLastError)(`Can't set a session config entry: 'powerPreference' - ${t.powerPreference}.`)}}break;case\\\"webgpu\\\":t=\\\"JS\\\";break;case\\\"wasm\\\":case\\\"cpu\\\":continue;default:throw new Error(`not supported execution provider: ${t}`)}const i=(0,a.allocWasmString)(t,r);0!==(0,n.getInstance)()._OrtAppendExecutionProvider(e,i)&&(0,a.checkLastError)(`Can't append execution provider: ${t}.`)}})(u,l.executionProviders,c),void 0!==l.extra&&(0,a.iterateExtraOptions)(l.extra,\\\"\\\",new WeakSet,((e,t)=>{const r=(0,a.allocWasmString)(e,c),n=(0,a.allocWasmString)(t,c);0!==s._OrtAddSessionConfigEntry(u,r,n)&&(0,a.checkLastError)(`Can't set a session config entry: ${e} - ${t}.`)})),[u,c]}catch(e){throw 0!==u&&s._OrtReleaseSessionOptions(u),c.forEach((e=>s._free(e))),e}}},917:(e,t)=>{\\\"use strict\\\";Object.defineProperty(t,\\\"__esModule\\\",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case\\\"int8\\\":return 3;case\\\"uint8\\\":return 2;case\\\"bool\\\":return 9;case\\\"int16\\\":return 5;case\\\"uint16\\\":return 4;case\\\"int32\\\":return 6;case\\\"uint32\\\":return 12;case\\\"float16\\\":return 10;case\\\"float32\\\":return 1;case\\\"float64\\\":return 11;case\\\"string\\\":return 8;case\\\"int64\\\":return 7;case\\\"uint64\\\":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return\\\"int8\\\";case 2:return\\\"uint8\\\";case 9:return\\\"bool\\\";case 5:return\\\"int16\\\";case 4:return\\\"uint16\\\";case 6:return\\\"int32\\\";case 12:return\\\"uint32\\\";case 10:return\\\"float16\\\";case 1:return\\\"float32\\\";case 11:return\\\"float64\\\";case 8:return\\\"string\\\";case 7:return\\\"int64\\\";case 13:return\\\"uint64\\\";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case\\\"float16\\\":case\\\"uint16\\\":return Uint16Array;case\\\"float32\\\":return Float32Array;case\\\"uint8\\\":case\\\"bool\\\":return Uint8Array;case\\\"int8\\\":return Int8Array;case\\\"int16\\\":return Int16Array;case\\\"int32\\\":return Int32Array;case\\\"float64\\\":return Float64Array;case\\\"uint32\\\":return Uint32Array;case\\\"int64\\\":return BigInt64Array;case\\\"uint64\\\":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case\\\"verbose\\\":return 0;case\\\"info\\\":return 1;case\\\"warning\\\":return 2;case\\\"error\\\":return 3;case\\\"fatal\\\":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},259:(e,t,r)=>{\\\"use strict\\\";Object.defineProperty(t,\\\"__esModule\\\",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initRuntime=void 0;const n=r(918),a=r(622),o=r(917),i=r(263),s=r(497);t.initRuntime=async e=>{var t,r;t=e.wasm.numThreads,r=(0,o.logLevelStringToEnum)(e.logLevel),0!==(0,i.getInstance)()._OrtInit(t,r)&&(0,s.checkLastError)(\\\"Can't initialize onnxruntime.\\\")};const u=new Map;t.createSessionAllocate=e=>{const t=(0,i.getInstance)(),r=t._malloc(e.byteLength);if(0===r)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},t.createSessionFinalize=(e,t)=>{const r=(0,i.getInstance)();let n=0,o=0,c=[];const l=[],f=[];try{[o,c]=(0,a.setSessionOptions)(t),n=r._OrtCreateSession(e[0],e[1],o),0===n&&(0,s.checkLastError)(\\\"Can't create a session.\\\");const[d,p]=(e=>{const t=(0,i.getInstance)(),r=t.stackSave();try{const r=t.stackAlloc(8);return 0!==t._OrtGetInputOutputCount(e,r,r+4)&&(0,s.checkLastError)(\\\"Can't get session input/output count.\\\"),[t.HEAP32[r/4],t.HEAP32[r/4+1]]}finally{t.stackRestore(r)}})(n),g=[],h=[];for(let e=0;e<d;e++){const t=r._OrtGetInputName(n,e);0===t&&(0,s.checkLastError)(\\\"Can't get an input name.\\\"),l.push(t),g.push(r.UTF8ToString(t))}for(let e=0;e<p;e++){const t=r._OrtGetOutputName(n,e);0===t&&(0,s.checkLastError)(\\\"Can't get an output name.\\\"),f.push(t),h.push(r.UTF8ToString(t))}return u.set(n,[n,l,f]),[n,g,h]}catch(e){throw l.forEach((e=>r._OrtFree(e))),f.forEach((e=>r._OrtFree(e))),0!==n&&r._OrtReleaseSession(n),e}finally{r._free(e[0]),0!==o&&r._OrtReleaseSessionOptions(o),c.forEach((e=>r._free(e)))}},t.createSession=(e,r)=>{const n=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(n,r)},t.releaseSession=e=>{const t=(0,i.getInstance)(),r=u.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);const[n,a,o]=r;a.forEach((e=>t._OrtFree(e))),o.forEach((e=>t._OrtFree(e))),t._OrtReleaseSession(n),u.delete(e)},t.run=async(e,t,r,a,c)=>{const l=(0,i.getInstance)(),f=u.get(e);if(!f)throw new Error(`cannot run inference. invalid session id: ${e}`);const[d,p,g]=f,h=t.length,m=a.length;let y=0,v=[];const b=[],w=[];try{[y,v]=(0,n.setRunOptions)(c);for(let e=0;e<h;e++){const t=r[e][0],n=r[e][1],a=r[e][2];let i,u;if(Array.isArray(a)){u=4*a.length,i=l._malloc(u),w.push(i);let e=i/4;for(let t=0;t<a.length;t++){if(\\\"string\\\"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);l.HEAPU32[e++]=(0,s.allocWasmString)(a[t],w)}}else u=a.byteLength,i=l._malloc(u),w.push(i),l.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),i);const c=l.stackSave(),f=l.stackAlloc(4*n.length);try{let r=f/4;n.forEach((e=>l.HEAP32[r++]=e));const a=l._OrtCreateTensor((0,o.tensorDataTypeStringToEnum)(t),i,u,f,n.length);0===a&&(0,s.checkLastError)(`Can't create tensor for input[${e}].`),b.push(a)}finally{l.stackRestore(c)}}const e=l.stackSave(),i=l.stackAlloc(4*h),u=l.stackAlloc(4*h),f=l.stackAlloc(4*m),_=l.stackAlloc(4*m);try{let e=i/4,r=u/4,n=f/4,c=_/4;for(let n=0;n<h;n++)l.HEAPU32[e++]=b[n],l.HEAPU32[r++]=p[t[n]];for(let e=0;e<m;e++)l.HEAPU32[n++]=0,l.HEAPU32[c++]=g[a[e]];let v=l._OrtRun(d,u,i,h,_,m,f,y);const w=l.jsepRunPromise;w&&void 0!==w.then&&(v=await w);const O=[];0!==v&&(0,s.checkLastError)(\\\"failed to call OrtRun().\\\");for(let e=0;e<m;e++){const t=l.HEAPU32[f/4+e],r=l.stackSave(),n=l.stackAlloc(16);let a,i=0;try{v=l._OrtGetTensorData(t,n,n+4,n+8,n+12),0!==v&&(0,s.checkLastError)(`Can't access output tensor data on index ${e}.`);let r=n/4;const u=l.HEAPU32[r++];i=l.HEAPU32[r++];const c=l.HEAPU32[r++],f=l.HEAPU32[r++],d=[];for(let e=0;e<f;e++)d.push(l.HEAPU32[c/4+e]);l._OrtFree(c);const p=0===d.length?1:d.reduce(((e,t)=>e*t));if(a=(0,o.tensorDataTypeEnumToString)(u),\\\"string\\\"===a){const e=[];let t=i/4;for(let r=0;r<p;r++){const n=l.HEAPU32[t++],a=r===p-1?void 0:l.HEAPU32[t]-n;e.push(l.UTF8ToString(n,a))}O.push([a,d,e])}else{const e=new((0,o.tensorTypeToTypedArrayConstructor)(a))(p);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(l.HEAPU8.subarray(i,i+e.byteLength)),O.push([a,d,e])}}finally{l.stackRestore(r),\\\"string\\\"===a&&i&&l._free(i),l._OrtReleaseTensor(t)}}return O}finally{l.stackRestore(e)}}finally{b.forEach((e=>l._OrtReleaseTensor(e))),w.forEach((e=>l._free(e))),0!==y&&l._OrtReleaseRunOptions(y),v.forEach((e=>l._free(e)))}},t.endProfiling=e=>{const t=(0,i.getInstance)(),r=u.get(e);if(!r)throw new Error(\\\"invalid session id\\\");const n=r[0],a=t._OrtEndProfiling(n);0===a&&(0,s.checkLastError)(\\\"Can't get an profile file name.\\\"),t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const r of e){const e=r[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,r){\\\"use strict\\\";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!(\\\"get\\\"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,\\\"default\\\",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)\\\"default\\\"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&n(t,e,r);return a(t,e),t};Object.defineProperty(t,\\\"__esModule\\\",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const i=o(r(449)),s=r(932),u=r(474);let c,l=!1,f=!1,d=!1;t.initializeWebAssembly=async e=>{if(l)return Promise.resolve();if(f)throw new Error(\\\"multiple calls to 'initializeWebAssembly()' detected.\\\");if(d)throw new Error(\\\"previous call to 'initializeWebAssembly()' failed.\\\");f=!0;const t=e.initTimeout,n=e.numThreads,a=e.simd,o=n>1&&(()=>{try{return\\\"undefined\\\"!=typeof SharedArrayBuffer&&(\\\"undefined\\\"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),p=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),g=e.wasmPaths,h=\\\"string\\\"==typeof g?g:void 0,m=((e,t)=>t?e?\\\"ort-wasm-simd-threaded.wasm\\\":\\\"ort-wasm-threaded.wasm\\\":e?\\\"ort-wasm-simd.wasm\\\":\\\"ort-wasm.wasm\\\")(p,o),y=\\\"object\\\"==typeof g?g[m]:void 0;let v=!1;const b=[];if(t>0&&b.push(new Promise((e=>{setTimeout((()=>{v=!0,e()}),t)}))),b.push(new Promise(((e,t)=>{const n=o?u:s,a={locateFile:(e,t)=>o&&e.endsWith(\\\".worker.js\\\")&&\\\"undefined\\\"!=typeof Blob?URL.createObjectURL(new Blob([r(154)],{type:\\\"text/javascript\\\"})):e.endsWith(\\\".wasm\\\")?y||(null!=h?h:t)+m:t+e};if(o)if(\\\"undefined\\\"==typeof Blob)a.mainScriptUrlOrBlob=i.join(__dirname,\\\"ort-wasm-threaded.js\\\");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${n.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([e],{type:\\\"text/javascript\\\"})}n(a).then((t=>{f=!1,l=!0,c=t,e()}),(e=>{f=!1,d=!0,t(e)}))}))),await Promise.race(b),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(l&&c)return c;throw new Error(\\\"WebAssembly is not initialized yet.\\\")},t.dispose=()=>{var e;!l||f||d||(f=!0,null===(e=c.PThread)||void 0===e||e.terminateAllThreads(),c=void 0,f=!1,l=!1,d=!0)}},497:(e,t,r)=>{\\\"use strict\\\";Object.defineProperty(t,\\\"__esModule\\\",{value:!0}),t.checkLastError=t.iterateExtraOptions=t.allocWasmString=void 0;const n=r(263);t.allocWasmString=(e,t)=>{const r=(0,n.getInstance)(),a=r.lengthBytesUTF8(e)+1,o=r._malloc(a);return r.stringToUTF8(e,o,a),t.push(o),o},t.iterateExtraOptions=(e,r,n,a)=>{if(\\\"object\\\"==typeof e&&null!==e){if(n.has(e))throw new Error(\\\"Circular reference in options\\\");n.add(e)}Object.entries(e).forEach((([e,o])=>{const i=r?r+e:e;if(\\\"object\\\"==typeof o)(0,t.iterateExtraOptions)(o,i+\\\".\\\",n,a);else if(\\\"string\\\"==typeof o||\\\"number\\\"==typeof o)a(i,o.toString());else{if(\\\"boolean\\\"!=typeof o)throw new Error(\\\"Can't handle extra config type: \\\"+typeof o);a(i,o?\\\"1\\\":\\\"0\\\")}}))},t.checkLastError=e=>{const t=(0,n.getInstance)(),r=t.stackSave();try{const r=t.stackAlloc(8);t._OrtGetLastError(r,r+4);const n=t.HEAP32[r/4],a=t.HEAPU32[r/4+1],o=a?t.UTF8ToString(a):\\\"\\\";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${o}`)}finally{t.stackRestore(r)}}},474:(e,t,r)=>{var _scriptDir,n=(_scriptDir=\\\"undefined\\\"!=typeof document&&document.currentScript?document.currentScript.src:void 0,\\\"undefined\\\"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){function t(){return k.buffer!=x.buffer&&Y(),x}function n(){return k.buffer!=x.buffer&&Y(),I}function a(){return k.buffer!=x.buffer&&Y(),U}function o(){return k.buffer!=x.buffer&&Y(),L}function i(){return k.buffer!=x.buffer&&Y(),W}var s,u,c=e;c.ready=new Promise(((e,t)=>{s=e,u=t}));var l,f,d,p=Object.assign({},c),g=\\\"./this.program\\\",h=(e,t)=>{throw t},m=\\\"object\\\"==typeof window,y=\\\"function\\\"==typeof importScripts,v=\\\"object\\\"==typeof process&&\\\"object\\\"==typeof process.versions&&\\\"string\\\"==typeof process.versions.node,b=c.ENVIRONMENT_IS_PTHREAD||!1,w=\\\"\\\";function _(e){return c.locateFile?c.locateFile(e,w):w+e}if(v){var O=r(384),S=r(908);let t;w=y?S.dirname(w)+\\\"/\\\":__dirname+\\\"/\\\",l=(e,t)=>(e=e.startsWith(\\\"file://\\\")?new URL(e):S.normalize(e),O.readFileSync(e,t?void 0:\\\"utf8\\\")),d=e=>((e=l(e,!0)).buffer||(e=new Uint8Array(e)),e),f=(e,t,r,n=!0)=>{e=e.startsWith(\\\"file://\\\")?new URL(e):S.normalize(e),O.readFile(e,n?void 0:\\\"utf8\\\",((e,a)=>{e?r(e):t(n?a.buffer:a)}))},!c.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\\\\\\\/g,\\\"/\\\")),process.argv.slice(2),h=(e,t)=>{throw process.exitCode=e,t},c.inspect=()=>\\\"[Emscripten Module object]\\\";try{t=r(925)}catch(e){throw console.error('The \\\"worker_threads\\\" module is not supported in this node.js build - perhaps a newer version is needed?'),e}global.Worker=t.Worker}else(m||y)&&(y?w=self.location.href:\\\"undefined\\\"!=typeof document&&document.currentScript&&(w=document.currentScript.src),_scriptDir&&(w=_scriptDir),w=0!==w.indexOf(\\\"blob:\\\")?w.substr(0,w.replace(/[?#].*/,\\\"\\\").lastIndexOf(\\\"/\\\")+1):\\\"\\\",v||(l=e=>{var t=new XMLHttpRequest;return t.open(\\\"GET\\\",e,!1),t.send(null),t.responseText},y&&(d=e=>{var t=new XMLHttpRequest;return t.open(\\\"GET\\\",e,!1),t.responseType=\\\"arraybuffer\\\",t.send(null),new Uint8Array(t.response)}),f=(e,t,r)=>{var n=new XMLHttpRequest;n.open(\\\"GET\\\",e,!0),n.responseType=\\\"arraybuffer\\\",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)}));v&&\\\"undefined\\\"==typeof performance&&(global.performance=r(953).performance);var E=console.log.bind(console),A=console.error.bind(console);v&&(E=(...e)=>O.writeSync(1,e.join(\\\" \\\")+\\\"\\\\n\\\"),A=(...e)=>O.writeSync(2,e.join(\\\" \\\")+\\\"\\\\n\\\"));var T,M=c.print||E,R=c.printErr||A;Object.assign(c,p),p=null,c.thisProgram&&(g=c.thisProgram),c.quit&&(h=c.quit),c.wasmBinary&&(T=c.wasmBinary);var F=c.noExitRuntime||!0;\\\"object\\\"!=typeof WebAssembly&&te(\\\"no native wasm support detected\\\");var k,C,P,D,x,I,U,L,W,H=!1;function Y(){var e=k.buffer;c.HEAP8=x=new Int8Array(e),c.HEAP16=new Int16Array(e),c.HEAP32=U=new Int32Array(e),c.HEAPU8=I=new Uint8Array(e),c.HEAPU16=new Uint16Array(e),c.HEAPU32=L=new Uint32Array(e),c.HEAPF32=new Float32Array(e),c.HEAPF64=W=new Float64Array(e)}var j=c.INITIAL_MEMORY||16777216;if(5242880<=j||te(\\\"INITIAL_MEMORY should be larger than STACK_SIZE, was \\\"+j+\\\"! (STACK_SIZE=5242880)\\\"),b)k=c.wasmMemory;else if(c.wasmMemory)k=c.wasmMemory;else if(!((k=new WebAssembly.Memory({initial:j/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw R(\\\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\\\"),v&&R(\\\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)\\\"),Error(\\\"bad memory\\\");Y(),j=k.buffer.byteLength;var z,G=[],N=[],B=[],$=0;function q(){return F||0<$}var V,J,X=0,K=null,Z=null;function Q(){X++,c.monitorRunDependencies&&c.monitorRunDependencies(X)}function ee(){if(X--,c.monitorRunDependencies&&c.monitorRunDependencies(X),0==X&&(null!==K&&(clearInterval(K),K=null),Z)){var e=Z;Z=null,e()}}function te(e){throw c.onAbort&&c.onAbort(e),R(e=\\\"Aborted(\\\"+e+\\\")\\\"),H=!0,D=1,e=new WebAssembly.RuntimeError(e+\\\". Build with -sASSERTIONS for more info.\\\"),u(e),e}function re(e){return e.startsWith(\\\"data:application/octet-stream;base64,\\\")}function ne(e){if(e==V&&T)return new Uint8Array(T);if(d)return d(e);throw\\\"both async and sync fetching of the wasm failed\\\"}function ae(e,t,r){return function(e){if(!T&&(m||y)){if(\\\"function\\\"==typeof fetch&&!e.startsWith(\\\"file://\\\"))return fetch(e,{credentials:\\\"same-origin\\\"}).then((t=>{if(!t.ok)throw\\\"failed to load wasm binary file at '\\\"+e+\\\"'\\\";return t.arrayBuffer()})).catch((()=>ne(e)));if(f)return new Promise(((t,r)=>{f(e,(e=>t(new Uint8Array(e))),r)}))}return Promise.resolve().then((()=>ne(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(r,(e=>{R(\\\"failed to asynchronously prepare wasm: \\\"+e),te(e)}))}function oe(e){this.name=\\\"ExitStatus\\\",this.message=`Program terminated with exit(${e})`,this.status=e}function ie(e){e.terminate(),e.onmessage=()=>{}}function se(e){(e=ge.Fa[e])||te(),ge.fb(e)}function ue(e){var t=ge.Za();if(!t)return 6;ge.Ia.push(t),ge.Fa[e.Ha]=t,t.Ha=e.Ha;var r={cmd:\\\"run\\\",start_routine:e.gb,arg:e.Ya,pthread_ptr:e.Ha};return v&&t.unref(),t.postMessage(r,e.mb),0}re(V=\\\"ort-wasm-threaded.wasm\\\")||(V=_(V));var ce=\\\"undefined\\\"!=typeof TextDecoder?new TextDecoder(\\\"utf8\\\"):void 0,le=(e,t,r)=>{var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&ce)return ce.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,r):e.subarray(t,r));for(n=\\\"\\\";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n},fe=(e,t)=>(e>>>=0)?le(n(),e,t):\\\"\\\";function de(e){if(b)return qe(1,1,e);D=e,q()||(ge.hb(),c.onExit&&c.onExit(e),H=!0),h(e,new oe(e))}var pe=e=>{if(D=e,b)throw me(e),\\\"unwind\\\";de(e)},ge={La:[],Ia:[],Ta:[],Fa:{},Pa:function(){b?ge.ab():ge.$a()},$a:function(){G.unshift((()=>{Q(),ge.bb((()=>ee()))}))},ab:function(){ge.receiveObjectTransfer=ge.eb,ge.threadInitTLS=ge.Sa,ge.setExitStatus=ge.Ra,F=!1},Ra:function(e){D=e},rb:[\\\"$terminateWorker\\\"],hb:function(){for(var e of ge.Ia)ie(e);for(e of ge.La)ie(e);ge.La=[],ge.Ia=[],ge.Fa=[]},fb:function(e){var t=e.Ha;delete ge.Fa[t],ge.La.push(e),ge.Ia.splice(ge.Ia.indexOf(e),1),e.Ha=0,yt(t)},eb:function(){},Sa:function(){ge.Ta.forEach((e=>e()))},cb:e=>new Promise((t=>{e.onmessage=r=>{var n=(r=r.data).cmd;if(r.targetThread&&r.targetThread!=dt()){var a=ge.Fa[r.qb];a?a.postMessage(r,r.transferList):R('Internal error! Worker sent a message \\\"'+n+'\\\" to target pthread '+r.targetThread+\\\", but that thread no longer exists!\\\")}else\\\"checkMailbox\\\"===n?He():\\\"spawnThread\\\"===n?ue(r):\\\"cleanupThread\\\"===n?se(r.thread):\\\"killThread\\\"===n?(r=r.thread,n=ge.Fa[r],delete ge.Fa[r],ie(n),yt(r),ge.Ia.splice(ge.Ia.indexOf(n),1),n.Ha=0):\\\"cancelThread\\\"===n?ge.Fa[r.thread].postMessage({cmd:\\\"cancel\\\"}):\\\"loaded\\\"===n?(e.loaded=!0,t(e)):\\\"alert\\\"===n?alert(\\\"Thread \\\"+r.threadId+\\\": \\\"+r.text):\\\"setimmediate\\\"===r.target?e.postMessage(r):\\\"callHandler\\\"===n?c[r.handler](...r.args):n&&R(\\\"worker sent an unknown command \\\"+n)},e.onerror=e=>{throw R(\\\"worker sent an error! \\\"+e.filename+\\\":\\\"+e.lineno+\\\": \\\"+e.message),e},v&&(e.on(\\\"message\\\",(function(t){e.onmessage({data:t})})),e.on(\\\"error\\\",(function(t){e.onerror(t)})));var r,n=[];for(r of[\\\"onExit\\\",\\\"onAbort\\\",\\\"print\\\",\\\"printErr\\\"])c.hasOwnProperty(r)&&n.push(r);e.postMessage({cmd:\\\"load\\\",handlers:n,urlOrBlob:c.mainScriptUrlOrBlob||_scriptDir,wasmMemory:k,wasmModule:P})})),bb:function(e){e()},Xa:function(){var e=_(\\\"ort-wasm-threaded.worker.js\\\");e=new Worker(e),ge.La.push(e)},Za:function(){return 0==ge.La.length&&(ge.Xa(),ge.cb(ge.La[0])),ge.La.pop()}};c.PThread=ge;var he=e=>{for(;0<e.length;)e.shift()(c)};function me(e){if(b)return qe(2,0,e);pe(e)}c.establishStackSpace=function(){var e=dt(),t=a()[e+52>>2>>>0];e=a()[e+56>>2>>>0],_t(t,t-e),St(t)};var ye=[];function ve(e){this.Oa=e-24,this.Wa=function(e){o()[this.Oa+4>>2>>>0]=e},this.Va=function(e){o()[this.Oa+8>>2>>>0]=e},this.Pa=function(e,t){this.Ua(),this.Wa(e),this.Va(t)},this.Ua=function(){o()[this.Oa+16>>2>>>0]=0}}function be(e,t,r,n){return b?qe(3,1,e,t,r,n):we(e,t,r,n)}function we(e,t,r,n){if(e>>>=0,t>>>=0,r>>>=0,n>>>=0,\\\"undefined\\\"==typeof SharedArrayBuffer)return R(\\\"Current environment does not support SharedArrayBuffer, pthreads are not available!\\\"),6;var a=[];return b&&0===a.length?be(e,t,r,n):(e={gb:r,Ha:e,Ya:n,mb:a},b?(e.ob=\\\"spawnThread\\\",postMessage(e,a),0):ue(e))}function _e(e,t,r){return b?qe(4,1,e,t,r):0}function Oe(e,t){if(b)return qe(5,1,e,t)}c.invokeEntryPoint=function(e,t){var r=ye[e];r||(e>=ye.length&&(ye.length=e+1),ye[e]=r=z.get(e)),e=r(t),q()?ge.Ra(e):vt(e)};var Se=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t},Ee=(e,t,r,n)=>{if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(r>=n)break;t[r++>>>0]=i}else{if(2047>=i){if(r+1>=n)break;t[r++>>>0]=192|i>>6}else{if(65535>=i){if(r+2>=n)break;t[r++>>>0]=224|i>>12}else{if(r+3>=n)break;t[r++>>>0]=240|i>>18,t[r++>>>0]=128|i>>12&63}t[r++>>>0]=128|i>>6&63}t[r++>>>0]=128|63&i}}return t[r>>>0]=0,r-a},Ae=(e,t,r)=>Ee(e,n(),t,r);function Te(e,t){if(b)return qe(6,1,e,t)}function Me(e,t,r){if(b)return qe(7,1,e,t,r)}function Re(e,t,r){return b?qe(8,1,e,t,r):0}function Fe(e,t){if(b)return qe(9,1,e,t)}function ke(e,t,r){if(b)return qe(10,1,e,t,r)}function Ce(e,t,r,n){if(b)return qe(11,1,e,t,r,n)}function Pe(e,t,r,n){if(b)return qe(12,1,e,t,r,n)}function De(e,t,r,n){if(b)return qe(13,1,e,t,r,n)}function xe(e){if(b)return qe(14,1,e)}function Ie(e,t){if(b)return qe(15,1,e,t)}function Ue(e,t,r){if(b)return qe(16,1,e,t,r)}var Le=e=>{if(!H)try{if(e(),!q())try{b?vt(D):pe(D)}catch(e){e instanceof oe||\\\"unwind\\\"==e||h(1,e)}}catch(e){e instanceof oe||\\\"unwind\\\"==e||h(1,e)}};function We(e){e>>>=0,\\\"function\\\"==typeof Atomics.nb&&(Atomics.nb(a(),e>>2,e).value.then(He),e+=128,Atomics.store(a(),e>>2,1))}function He(){var e=dt();e&&(We(e),Le((()=>bt())))}c.__emscripten_thread_mailbox_await=We,c.checkMailbox=He;var Ye=e=>0==e%4&&(0!=e%100||0==e%400),je=[0,31,60,91,121,152,182,213,244,274,305,335],ze=[0,31,59,90,120,151,181,212,243,273,304,334];function Ge(e,t,r,n,a,o,i,s){return b?qe(17,1,e,t,r,n,a,o,i,s):-52}function Ne(e,t,r,n,a,o,i){if(b)return qe(18,1,e,t,r,n,a,o,i)}var Be=e=>{var t=Se(e)+1,r=pt(t);return r&&Ae(e,r,t),r},$e=e=>{var t=Ot();return e=e(),St(t),e};function qe(e,t){var r=arguments.length-2,n=arguments;return $e((()=>{for(var a=Et(8*r),o=a>>3,s=0;s<r;s++){var u=n[2+s];i()[o+s>>>0]=u}return mt(e,r,a,t)}))}var Ve,Je=[],Xe={},Ke=()=>{if(!Ve){var e,t={USER:\\\"web_user\\\",LOGNAME:\\\"web_user\\\",PATH:\\\"/\\\",PWD:\\\"/\\\",HOME:\\\"/home/web_user\\\",LANG:(\\\"object\\\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\\\"C\\\").replace(\\\"-\\\",\\\"_\\\")+\\\".UTF-8\\\",_:g||\\\"./this.program\\\"};for(e in Xe)void 0===Xe[e]?delete t[e]:t[e]=Xe[e];var r=[];for(e in t)r.push(`${e}=${t[e]}`);Ve=r}return Ve};function Ze(e,r){if(b)return qe(19,1,e,r);e>>>=0,r>>>=0;var n=0;return Ke().forEach((function(a,i){var s=r+n;for(i=o()[e+4*i>>2>>>0]=s,s=0;s<a.length;++s)t()[i++>>0>>>0]=a.charCodeAt(s);t()[i>>0>>>0]=0,n+=a.length+1})),0}function Qe(e,t){if(b)return qe(20,1,e,t);e>>>=0,t>>>=0;var r=Ke();o()[e>>2>>>0]=r.length;var n=0;return r.forEach((function(e){n+=e.length+1})),o()[t>>2>>>0]=n,0}function et(e){return b?qe(21,1,e):52}function tt(e,t,r,n){return b?qe(22,1,e,t,r,n):52}function rt(e,t,r,n,a){return b?qe(23,1,e,t,r,n,a):70}var nt=[null,[],[]];function at(e,t,r,a){if(b)return qe(24,1,e,t,r,a);t>>>=0,r>>>=0,a>>>=0;for(var i=0,s=0;s<r;s++){var u=o()[t>>2>>>0],c=o()[t+4>>2>>>0];t+=8;for(var l=0;l<c;l++){var f=n()[u+l>>>0],d=nt[e];0===f||10===f?((1===e?M:R)(le(d,0)),d.length=0):d.push(f)}i+=c}return o()[a>>2>>>0]=i,0}var ot=e=>(ot=(()=>{if(\\\"object\\\"==typeof crypto&&\\\"function\\\"==typeof crypto.getRandomValues)return e=>(e.set(crypto.getRandomValues(new Uint8Array(e.byteLength))),e);if(v)try{var e=r(760);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}te(\\\"initRandomDevice\\\")})())(e),it=[31,29,31,30,31,30,31,31,30,31,30,31],st=[31,28,31,30,31,30,31,31,30,31,30,31],ut=(e,r)=>{t().set(e,r>>>0)};function ct(e,t,r,n){function o(e,t,r){for(e=\\\"number\\\"==typeof e?e.toString():e||\\\"\\\";e.length<t;)e=r[0]+e;return e}function i(e,t){return o(e,t,\\\"0\\\")}function s(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function u(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function c(e){var t=e.Ja;for(e=new Date(new Date(e.Ka+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(Ye(e.getFullYear())?it:st)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=u(new Date(e.getFullYear(),0,4)),r=u(r),0>=s(t,e)?0>=s(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,r>>>=0,n>>>=0;var l=a()[n+40>>2>>>0];for(var f in n={kb:a()[n>>2>>>0],jb:a()[n+4>>2>>>0],Ma:a()[n+8>>2>>>0],Qa:a()[n+12>>2>>>0],Na:a()[n+16>>2>>>0],Ka:a()[n+20>>2>>>0],Ga:a()[n+24>>2>>>0],Ja:a()[n+28>>2>>>0],sb:a()[n+32>>2>>>0],ib:a()[n+36>>2>>>0],lb:l?fe(l):\\\"\\\"},r=fe(r),l={\\\"%c\\\":\\\"%a %b %d %H:%M:%S %Y\\\",\\\"%D\\\":\\\"%m/%d/%y\\\",\\\"%F\\\":\\\"%Y-%m-%d\\\",\\\"%h\\\":\\\"%b\\\",\\\"%r\\\":\\\"%I:%M:%S %p\\\",\\\"%R\\\":\\\"%H:%M\\\",\\\"%T\\\":\\\"%H:%M:%S\\\",\\\"%x\\\":\\\"%m/%d/%y\\\",\\\"%X\\\":\\\"%H:%M:%S\\\",\\\"%Ec\\\":\\\"%c\\\",\\\"%EC\\\":\\\"%C\\\",\\\"%Ex\\\":\\\"%m/%d/%y\\\",\\\"%EX\\\":\\\"%H:%M:%S\\\",\\\"%Ey\\\":\\\"%y\\\",\\\"%EY\\\":\\\"%Y\\\",\\\"%Od\\\":\\\"%d\\\",\\\"%Oe\\\":\\\"%e\\\",\\\"%OH\\\":\\\"%H\\\",\\\"%OI\\\":\\\"%I\\\",\\\"%Om\\\":\\\"%m\\\",\\\"%OM\\\":\\\"%M\\\",\\\"%OS\\\":\\\"%S\\\",\\\"%Ou\\\":\\\"%u\\\",\\\"%OU\\\":\\\"%U\\\",\\\"%OV\\\":\\\"%V\\\",\\\"%Ow\\\":\\\"%w\\\",\\\"%OW\\\":\\\"%W\\\",\\\"%Oy\\\":\\\"%y\\\"})r=r.replace(new RegExp(f,\\\"g\\\"),l[f]);var d=\\\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\\\".split(\\\" \\\"),p=\\\"January February March April May June July August September October November December\\\".split(\\\" \\\");for(f in l={\\\"%a\\\":e=>d[e.Ga].substring(0,3),\\\"%A\\\":e=>d[e.Ga],\\\"%b\\\":e=>p[e.Na].substring(0,3),\\\"%B\\\":e=>p[e.Na],\\\"%C\\\":e=>i((e.Ka+1900)/100|0,2),\\\"%d\\\":e=>i(e.Qa,2),\\\"%e\\\":e=>o(e.Qa,2,\\\" \\\"),\\\"%g\\\":e=>c(e).toString().substring(2),\\\"%G\\\":e=>c(e),\\\"%H\\\":e=>i(e.Ma,2),\\\"%I\\\":e=>(0==(e=e.Ma)?e=12:12<e&&(e-=12),i(e,2)),\\\"%j\\\":e=>{for(var t=0,r=0;r<=e.Na-1;t+=(Ye(e.Ka+1900)?it:st)[r++]);return i(e.Qa+t,3)},\\\"%m\\\":e=>i(e.Na+1,2),\\\"%M\\\":e=>i(e.jb,2),\\\"%n\\\":()=>\\\"\\\\n\\\",\\\"%p\\\":e=>0<=e.Ma&&12>e.Ma?\\\"AM\\\":\\\"PM\\\",\\\"%S\\\":e=>i(e.kb,2),\\\"%t\\\":()=>\\\"\\\\t\\\",\\\"%u\\\":e=>e.Ga||7,\\\"%U\\\":e=>i(Math.floor((e.Ja+7-e.Ga)/7),2),\\\"%V\\\":e=>{var t=Math.floor((e.Ja+7-(e.Ga+6)%7)/7);if(2>=(e.Ga+371-e.Ja-2)%7&&t++,t)53==t&&(4==(r=(e.Ga+371-e.Ja)%7)||3==r&&Ye(e.Ka)||(t=1));else{t=52;var r=(e.Ga+7-e.Ja-1)%7;(4==r||5==r&&Ye(e.Ka%400-1))&&t++}return i(t,2)},\\\"%w\\\":e=>e.Ga,\\\"%W\\\":e=>i(Math.floor((e.Ja+7-(e.Ga+6)%7)/7),2),\\\"%y\\\":e=>(e.Ka+1900).toString().substring(2),\\\"%Y\\\":e=>e.Ka+1900,\\\"%z\\\":e=>{var t=0<=(e=e.ib);return e=Math.abs(e)/60,(t?\\\"+\\\":\\\"-\\\")+String(\\\"0000\\\"+(e/60*100+e%60)).slice(-4)},\\\"%Z\\\":e=>e.lb,\\\"%%\\\":()=>\\\"%\\\"},r=r.replace(/%%/g,\\\"\\\\0\\\\0\\\"),l)r.includes(f)&&(r=r.replace(new RegExp(f,\\\"g\\\"),l[f](n)));return f=function(e){var t=Array(Se(e)+1);return Ee(e,t,0,t.length),t}(r=r.replace(/\\\\0\\\\0/g,\\\"%\\\")),f.length>t?0:(ut(f,e),f.length-1)}ge.Pa();var lt=[null,de,me,be,_e,Oe,Te,Me,Re,Fe,ke,Ce,Pe,De,xe,Ie,Ue,Ge,Ne,Ze,Qe,et,tt,rt,at],ft={b:function(e,t,r){throw new ve(e>>>=0).Pa(t>>>0,r>>>0),e},N:function(e){gt(e>>>0,!y,1,!m,131072,!1),ge.Sa()},k:function(e){e>>>=0,b?postMessage({cmd:\\\"cleanupThread\\\",thread:e}):se(e)},I:we,h:_e,T:Oe,E:Te,G:Me,U:Re,R:Fe,J:ke,Q:Ce,o:Pe,F:De,C:xe,S:Ie,D:Ue,q:()=>!0,A:function(e,t){(e>>>=0)==t>>>0?setTimeout((()=>He())):b?postMessage({targetThread:e,cmd:\\\"checkMailbox\\\"}):(e=ge.Fa[e])&&e.postMessage({cmd:\\\"checkMailbox\\\"})},L:function(){return-1},M:We,p:function(e){v&&ge.Fa[e>>>0].ref()},t:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),a()[r>>2>>>0]=e.getUTCSeconds(),a()[r+4>>2>>>0]=e.getUTCMinutes(),a()[r+8>>2>>>0]=e.getUTCHours(),a()[r+12>>2>>>0]=e.getUTCDate(),a()[r+16>>2>>>0]=e.getUTCMonth(),a()[r+20>>2>>>0]=e.getUTCFullYear()-1900,a()[r+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[r+28>>2>>>0]=e},u:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),a()[r>>2>>>0]=e.getSeconds(),a()[r+4>>2>>>0]=e.getMinutes(),a()[r+8>>2>>>0]=e.getHours(),a()[r+12>>2>>>0]=e.getDate(),a()[r+16>>2>>>0]=e.getMonth(),a()[r+20>>2>>>0]=e.getFullYear()-1900,a()[r+24>>2>>>0]=e.getDay(),t=(Ye(e.getFullYear())?je:ze)[e.getMonth()]+e.getDate()-1|0,a()[r+28>>2>>>0]=t,a()[r+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var n=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(t!=n&&e.getTimezoneOffset()==Math.min(n,t)),a()[r+32>>2>>>0]=e},v:function(e){e>>>=0;var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),r=a()[e+32>>2>>>0],n=t.getTimezoneOffset(),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=new Date(t.getFullYear(),0,1).getTimezoneOffset(),s=Math.min(i,o);return 0>r?a()[e+32>>2>>>0]=Number(o!=i&&s==n):0<r!=(s==n)&&(o=Math.max(i,o),t.setTime(t.getTime()+6e4*((0<r?s:o)-n))),a()[e+24>>2>>>0]=t.getDay(),r=(Ye(t.getFullYear())?je:ze)[t.getMonth()]+t.getDate()-1|0,a()[e+28>>2>>>0]=r,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,wt((J=e,1<=+Math.abs(J)?0<J?+Math.floor(J/4294967296)>>>0:~~+Math.ceil((J-+(~~J>>>0))/4294967296)>>>0:0)),e>>>0},r:Ge,s:Ne,z:function(e,t,r){function n(e){return(e=e.toTimeString().match(/\\\\(([A-Za-z ]+)\\\\)$/))?e[1]:\\\"GMT\\\"}e>>>=0,t>>>=0,r>>>=0;var i=(new Date).getFullYear(),s=new Date(i,0,1),u=new Date(i,6,1);i=s.getTimezoneOffset();var c=u.getTimezoneOffset(),l=Math.max(i,c);o()[e>>2>>>0]=60*l,a()[t>>2>>>0]=Number(i!=c),e=n(s),t=n(u),e=Be(e),t=Be(t),c<i?(o()[r>>2>>>0]=e,o()[r+4>>2>>>0]=t):(o()[r>>2>>>0]=t,o()[r+4>>2>>>0]=e)},c:()=>{te(\\\"\\\")},l:function(){},i:function(){return Date.now()},V:()=>{throw $+=1,\\\"unwind\\\"},B:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:function(){return v?r(993).cpus().length:navigator.hardwareConcurrency},K:function(e,t,r,n){for(ge.pb=t>>>0,Je.length=r,t=n>>>0>>3,n=0;n<r;n++)Je[n]=i()[t+n>>>0];return lt[e].apply(null,Je)},y:function(e){e>>>=0;var t=n().length;if(e<=t||4294901760<e)return!1;for(var r=1;4>=r;r*=2){var a=t*(1+.2/r);a=Math.min(a,e+100663296);var o=Math;a=Math.max(e,a);e:{o=o.min.call(o,4294901760,a+(65536-a%65536)%65536)-k.buffer.byteLength+65535>>>16;try{k.grow(o),Y();var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},O:Ze,P:Qe,j:pe,g:et,n:tt,w:rt,m:at,x:function(e,t){return e>>>=0,t>>>=0,ot(n().subarray(e>>>0,e+t>>>0)),0},a:k||c.wasmMemory,H:ct,d:function(e,t,r,n){return ct(e>>>0,t>>>0,r>>>0,n>>>0)}};!function(){function e(e,t){return e=e.exports,C=e=function(e){var t=e=>()=>e()>>>0,r=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.pthread_self=t(e.pthread_self),e.malloc=r(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=r(e.stackAlloc),e}(e),ge.Ta.push(C.sa),z=C.ta,N.unshift(C.W),P=t,ee(),e}var t={a:ft};if(Q(),c.instantiateWasm)try{return c.instantiateWasm(t,e)}catch(e){R(\\\"Module.instantiateWasm callback failed with error: \\\"+e),u(e)}(function(e,t){var r=V;return T||\\\"function\\\"!=typeof WebAssembly.instantiateStreaming||re(r)||r.startsWith(\\\"file://\\\")||v||\\\"function\\\"!=typeof fetch?ae(r,e,t):fetch(r,{credentials:\\\"same-origin\\\"}).then((n=>WebAssembly.instantiateStreaming(n,e).then(t,(function(n){return R(\\\"wasm streaming compile failed: \\\"+n),R(\\\"falling back to ArrayBuffer instantiation\\\"),ae(r,e,t)}))))})(t,(function(t){e(t.instance,t.module)})).catch(u)}(),c._OrtInit=(e,t)=>(c._OrtInit=C.X)(e,t),c._OrtGetLastError=(e,t)=>(c._OrtGetLastError=C.Y)(e,t),c._OrtCreateSessionOptions=(e,t,r,n,a,o,i,s,u,l)=>(c._OrtCreateSessionOptions=C.Z)(e,t,r,n,a,o,i,s,u,l),c._OrtAppendExecutionProvider=(e,t)=>(c._OrtAppendExecutionProvider=C._)(e,t),c._OrtAddSessionConfigEntry=(e,t,r)=>(c._OrtAddSessionConfigEntry=C.$)(e,t,r),c._OrtReleaseSessionOptions=e=>(c._OrtReleaseSessionOptions=C.aa)(e),c._OrtCreateSession=(e,t,r)=>(c._OrtCreateSession=C.ba)(e,t,r),c._OrtReleaseSession=e=>(c._OrtReleaseSession=C.ca)(e),c._OrtGetInputOutputCount=(e,t,r)=>(c._OrtGetInputOutputCount=C.da)(e,t,r),c._OrtGetInputName=(e,t)=>(c._OrtGetInputName=C.ea)(e,t),c._OrtGetOutputName=(e,t)=>(c._OrtGetOutputName=C.fa)(e,t),c._OrtFree=e=>(c._OrtFree=C.ga)(e),c._OrtCreateTensor=(e,t,r,n,a)=>(c._OrtCreateTensor=C.ha)(e,t,r,n,a),c._OrtGetTensorData=(e,t,r,n,a)=>(c._OrtGetTensorData=C.ia)(e,t,r,n,a),c._OrtReleaseTensor=e=>(c._OrtReleaseTensor=C.ja)(e),c._OrtCreateRunOptions=(e,t,r,n)=>(c._OrtCreateRunOptions=C.ka)(e,t,r,n),c._OrtAddRunConfigEntry=(e,t,r)=>(c._OrtAddRunConfigEntry=C.la)(e,t,r),c._OrtReleaseRunOptions=e=>(c._OrtReleaseRunOptions=C.ma)(e),c._OrtRun=(e,t,r,n,a,o,i,s)=>(c._OrtRun=C.na)(e,t,r,n,a,o,i,s),c._OrtEndProfiling=e=>(c._OrtEndProfiling=C.oa)(e);var dt=c._pthread_self=()=>(dt=c._pthread_self=C.pa)(),pt=c._malloc=e=>(pt=c._malloc=C.qa)(e);c._free=e=>(c._free=C.ra)(e),c.__emscripten_tls_init=()=>(c.__emscripten_tls_init=C.sa)();var gt=c.__emscripten_thread_init=(e,t,r,n,a,o)=>(gt=c.__emscripten_thread_init=C.ua)(e,t,r,n,a,o);c.__emscripten_thread_crashed=()=>(c.__emscripten_thread_crashed=C.va)();var ht,mt=(e,t,r,n)=>(mt=C.wa)(e,t,r,n),yt=e=>(yt=C.xa)(e),vt=c.__emscripten_thread_exit=e=>(vt=c.__emscripten_thread_exit=C.ya)(e),bt=c.__emscripten_check_mailbox=()=>(bt=c.__emscripten_check_mailbox=C.za)(),wt=e=>(wt=C.Aa)(e),_t=(e,t)=>(_t=C.Ba)(e,t),Ot=()=>(Ot=C.Ca)(),St=e=>(St=C.Da)(e),Et=e=>(Et=C.Ea)(e);function At(){function e(){if(!ht&&(ht=!0,c.calledRun=!0,!H)&&(b||he(N),s(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),!b)){if(c.postRun)for(\\\"function\\\"==typeof c.postRun&&(c.postRun=[c.postRun]);c.postRun.length;){var e=c.postRun.shift();B.unshift(e)}he(B)}}if(!(0<X))if(b)s(c),b||he(N),startWorker(c);else{if(c.preRun)for(\\\"function\\\"==typeof c.preRun&&(c.preRun=[c.preRun]);c.preRun.length;)G.unshift(c.preRun.shift());he(G),0<X||(c.setStatus?(c.setStatus(\\\"Running...\\\"),setTimeout((function(){setTimeout((function(){c.setStatus(\\\"\\\")}),1),e()}),1)):e())}}if(c.keepRuntimeAlive=q,c.wasmMemory=k,c.stackAlloc=Et,c.stackSave=Ot,c.stackRestore=St,c.UTF8ToString=fe,c.stringToUTF8=Ae,c.lengthBytesUTF8=Se,c.ExitStatus=oe,c.PThread=ge,Z=function e(){ht||At(),ht||(Z=e)},c.preInit)for(\\\"function\\\"==typeof c.preInit&&(c.preInit=[c.preInit]);0<c.preInit.length;)c.preInit.pop()();return At(),e.ready});e.exports=n},932:(e,t,r)=>{var _scriptDir,n=(_scriptDir=\\\"undefined\\\"!=typeof document&&document.currentScript?document.currentScript.src:void 0,\\\"undefined\\\"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){var t,n,a=e;a.ready=new Promise(((e,r)=>{t=e,n=r}));var o,i,s,u=Object.assign({},a),c=\\\"./this.program\\\",l=(e,t)=>{throw t},f=\\\"object\\\"==typeof window,d=\\\"function\\\"==typeof importScripts,p=\\\"object\\\"==typeof process&&\\\"object\\\"==typeof process.versions&&\\\"string\\\"==typeof process.versions.node,g=\\\"\\\";if(p){var h=r(384),m=r(908);g=d?m.dirname(g)+\\\"/\\\":__dirname+\\\"/\\\",o=(e,t)=>(e=e.startsWith(\\\"file://\\\")?new URL(e):m.normalize(e),h.readFileSync(e,t?void 0:\\\"utf8\\\")),s=e=>((e=o(e,!0)).buffer||(e=new Uint8Array(e)),e),i=(e,t,r,n=!0)=>{e=e.startsWith(\\\"file://\\\")?new URL(e):m.normalize(e),h.readFile(e,n?void 0:\\\"utf8\\\",((e,a)=>{e?r(e):t(n?a.buffer:a)}))},!a.thisProgram&&1<process.argv.length&&(c=process.argv[1].replace(/\\\\\\\\/g,\\\"/\\\")),process.argv.slice(2),l=(e,t)=>{throw process.exitCode=e,t},a.inspect=()=>\\\"[Emscripten Module object]\\\"}else(f||d)&&(d?g=self.location.href:\\\"undefined\\\"!=typeof document&&document.currentScript&&(g=document.currentScript.src),_scriptDir&&(g=_scriptDir),g=0!==g.indexOf(\\\"blob:\\\")?g.substr(0,g.replace(/[?#].*/,\\\"\\\").lastIndexOf(\\\"/\\\")+1):\\\"\\\",o=e=>{var t=new XMLHttpRequest;return t.open(\\\"GET\\\",e,!1),t.send(null),t.responseText},d&&(s=e=>{var t=new XMLHttpRequest;return t.open(\\\"GET\\\",e,!1),t.responseType=\\\"arraybuffer\\\",t.send(null),new Uint8Array(t.response)}),i=(e,t,r)=>{var n=new XMLHttpRequest;n.open(\\\"GET\\\",e,!0),n.responseType=\\\"arraybuffer\\\",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)});var y,v=a.print||console.log.bind(console),b=a.printErr||console.error.bind(console);Object.assign(a,u),u=null,a.thisProgram&&(c=a.thisProgram),a.quit&&(l=a.quit),a.wasmBinary&&(y=a.wasmBinary);var w=a.noExitRuntime||!0;\\\"object\\\"!=typeof WebAssembly&&W(\\\"no native wasm support detected\\\");var _,O,S,E,A,T,M=!1;function R(){var e=_.buffer;a.HEAP8=S=new Int8Array(e),a.HEAP16=new Int16Array(e),a.HEAP32=A=new Int32Array(e),a.HEAPU8=E=new Uint8Array(e),a.HEAPU16=new Uint16Array(e),a.HEAPU32=T=new Uint32Array(e),a.HEAPF32=new Float32Array(e),a.HEAPF64=new Float64Array(e)}var F=[],k=[],C=[];function P(){var e=a.preRun.shift();F.unshift(e)}var D,x,I=0,U=null,L=null;function W(e){throw a.onAbort&&a.onAbort(e),b(e=\\\"Aborted(\\\"+e+\\\")\\\"),M=!0,e=new WebAssembly.RuntimeError(e+\\\". Build with -sASSERTIONS for more info.\\\"),n(e),e}function H(e){return e.startsWith(\\\"data:application/octet-stream;base64,\\\")}if(!H(D=\\\"ort-wasm.wasm\\\")){var Y=D;D=a.locateFile?a.locateFile(Y,g):g+Y}function j(e){if(e==D&&y)return new Uint8Array(y);if(s)return s(e);throw\\\"both async and sync fetching of the wasm failed\\\"}function z(e,t,r){return function(e){if(!y&&(f||d)){if(\\\"function\\\"==typeof fetch&&!e.startsWith(\\\"file://\\\"))return fetch(e,{credentials:\\\"same-origin\\\"}).then((t=>{if(!t.ok)throw\\\"failed to load wasm binary file at '\\\"+e+\\\"'\\\";return t.arrayBuffer()})).catch((()=>j(e)));if(i)return new Promise(((t,r)=>{i(e,(e=>t(new Uint8Array(e))),r)}))}return Promise.resolve().then((()=>j(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(r,(e=>{b(\\\"failed to asynchronously prepare wasm: \\\"+e),W(e)}))}function G(e){this.name=\\\"ExitStatus\\\",this.message=`Program terminated with exit(${e})`,this.status=e}var N=e=>{for(;0<e.length;)e.shift()(a)};function B(e){this.qa=e-24,this.va=function(e){T[this.qa+4>>2>>>0]=e},this.ua=function(e){T[this.qa+8>>2>>>0]=e},this.sa=function(e,t){this.ta(),this.va(e),this.ua(t)},this.ta=function(){T[this.qa+16>>2>>>0]=0}}var $,q=\\\"undefined\\\"!=typeof TextDecoder?new TextDecoder(\\\"utf8\\\"):void 0,V=(e,t,r)=>{var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&q)return q.decode(e.subarray(t,r));for(n=\\\"\\\";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n},J=(e,t)=>(e>>>=0)?V(E,e,t):\\\"\\\",X=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t},K=(e,t,r,n)=>{if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(r>=n)break;t[r++>>>0]=i}else{if(2047>=i){if(r+1>=n)break;t[r++>>>0]=192|i>>6}else{if(65535>=i){if(r+2>=n)break;t[r++>>>0]=224|i>>12}else{if(r+3>=n)break;t[r++>>>0]=240|i>>18,t[r++>>>0]=128|i>>12&63}t[r++>>>0]=128|i>>6&63}t[r++>>>0]=128|63&i}}return t[r>>>0]=0,r-a},Z=e=>0==e%4&&(0!=e%100||0==e%400),Q=[0,31,60,91,121,152,182,213,244,274,305,335],ee=[0,31,59,90,120,151,181,212,243,273,304,334],te=e=>{var t=X(e)+1,r=le(t);return r&&K(e,E,r,t),r},re={},ne=()=>{if(!$){var e,t={USER:\\\"web_user\\\",LOGNAME:\\\"web_user\\\",PATH:\\\"/\\\",PWD:\\\"/\\\",HOME:\\\"/home/web_user\\\",LANG:(\\\"object\\\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\\\"C\\\").replace(\\\"-\\\",\\\"_\\\")+\\\".UTF-8\\\",_:c||\\\"./this.program\\\"};for(e in re)void 0===re[e]?delete t[e]:t[e]=re[e];var r=[];for(e in t)r.push(`${e}=${t[e]}`);$=r}return $},ae=[null,[],[]],oe=e=>(oe=(()=>{if(\\\"object\\\"==typeof crypto&&\\\"function\\\"==typeof crypto.getRandomValues)return e=>crypto.getRandomValues(e);if(p)try{var e=r(760);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}W(\\\"initRandomDevice\\\")})())(e),ie=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function ue(e,t,r,n){function a(e,t,r){for(e=\\\"number\\\"==typeof e?e.toString():e||\\\"\\\";e.length<t;)e=r[0]+e;return e}function o(e,t){return a(e,t,\\\"0\\\")}function i(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.ma;for(e=new Date(new Date(e.na+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(Z(e.getFullYear())?ie:se)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),r=s(r),0>=i(t,e)?0>=i(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,r>>>=0;var c=A[40+(n>>>=0)>>2>>>0];for(var l in n={ya:A[n>>2>>>0],xa:A[n+4>>2>>>0],oa:A[n+8>>2>>>0],ra:A[n+12>>2>>>0],pa:A[n+16>>2>>>0],na:A[n+20>>2>>>0],ha:A[n+24>>2>>>0],ma:A[n+28>>2>>>0],Aa:A[n+32>>2>>>0],wa:A[n+36>>2>>>0],za:c?J(c):\\\"\\\"},r=J(r),c={\\\"%c\\\":\\\"%a %b %d %H:%M:%S %Y\\\",\\\"%D\\\":\\\"%m/%d/%y\\\",\\\"%F\\\":\\\"%Y-%m-%d\\\",\\\"%h\\\":\\\"%b\\\",\\\"%r\\\":\\\"%I:%M:%S %p\\\",\\\"%R\\\":\\\"%H:%M\\\",\\\"%T\\\":\\\"%H:%M:%S\\\",\\\"%x\\\":\\\"%m/%d/%y\\\",\\\"%X\\\":\\\"%H:%M:%S\\\",\\\"%Ec\\\":\\\"%c\\\",\\\"%EC\\\":\\\"%C\\\",\\\"%Ex\\\":\\\"%m/%d/%y\\\",\\\"%EX\\\":\\\"%H:%M:%S\\\",\\\"%Ey\\\":\\\"%y\\\",\\\"%EY\\\":\\\"%Y\\\",\\\"%Od\\\":\\\"%d\\\",\\\"%Oe\\\":\\\"%e\\\",\\\"%OH\\\":\\\"%H\\\",\\\"%OI\\\":\\\"%I\\\",\\\"%Om\\\":\\\"%m\\\",\\\"%OM\\\":\\\"%M\\\",\\\"%OS\\\":\\\"%S\\\",\\\"%Ou\\\":\\\"%u\\\",\\\"%OU\\\":\\\"%U\\\",\\\"%OV\\\":\\\"%V\\\",\\\"%Ow\\\":\\\"%w\\\",\\\"%OW\\\":\\\"%W\\\",\\\"%Oy\\\":\\\"%y\\\"})r=r.replace(new RegExp(l,\\\"g\\\"),c[l]);var f=\\\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\\\".split(\\\" \\\"),d=\\\"January February March April May June July August September October November December\\\".split(\\\" \\\");for(l in c={\\\"%a\\\":e=>f[e.ha].substring(0,3),\\\"%A\\\":e=>f[e.ha],\\\"%b\\\":e=>d[e.pa].substring(0,3),\\\"%B\\\":e=>d[e.pa],\\\"%C\\\":e=>o((e.na+1900)/100|0,2),\\\"%d\\\":e=>o(e.ra,2),\\\"%e\\\":e=>a(e.ra,2,\\\" \\\"),\\\"%g\\\":e=>u(e).toString().substring(2),\\\"%G\\\":e=>u(e),\\\"%H\\\":e=>o(e.oa,2),\\\"%I\\\":e=>(0==(e=e.oa)?e=12:12<e&&(e-=12),o(e,2)),\\\"%j\\\":e=>{for(var t=0,r=0;r<=e.pa-1;t+=(Z(e.na+1900)?ie:se)[r++]);return o(e.ra+t,3)},\\\"%m\\\":e=>o(e.pa+1,2),\\\"%M\\\":e=>o(e.xa,2),\\\"%n\\\":()=>\\\"\\\\n\\\",\\\"%p\\\":e=>0<=e.oa&&12>e.oa?\\\"AM\\\":\\\"PM\\\",\\\"%S\\\":e=>o(e.ya,2),\\\"%t\\\":()=>\\\"\\\\t\\\",\\\"%u\\\":e=>e.ha||7,\\\"%U\\\":e=>o(Math.floor((e.ma+7-e.ha)/7),2),\\\"%V\\\":e=>{var t=Math.floor((e.ma+7-(e.ha+6)%7)/7);if(2>=(e.ha+371-e.ma-2)%7&&t++,t)53==t&&(4==(r=(e.ha+371-e.ma)%7)||3==r&&Z(e.na)||(t=1));else{t=52;var r=(e.ha+7-e.ma-1)%7;(4==r||5==r&&Z(e.na%400-1))&&t++}return o(t,2)},\\\"%w\\\":e=>e.ha,\\\"%W\\\":e=>o(Math.floor((e.ma+7-(e.ha+6)%7)/7),2),\\\"%y\\\":e=>(e.na+1900).toString().substring(2),\\\"%Y\\\":e=>e.na+1900,\\\"%z\\\":e=>{var t=0<=(e=e.wa);return e=Math.abs(e)/60,(t?\\\"+\\\":\\\"-\\\")+String(\\\"0000\\\"+(e/60*100+e%60)).slice(-4)},\\\"%Z\\\":e=>e.za,\\\"%%\\\":()=>\\\"%\\\"},r=r.replace(/%%/g,\\\"\\\\0\\\\0\\\"),c)r.includes(l)&&(r=r.replace(new RegExp(l,\\\"g\\\"),c[l](n)));return l=function(e){var t=Array(X(e)+1);return K(e,t,0,t.length),t}(r=r.replace(/\\\\0\\\\0/g,\\\"%\\\")),l.length>t?0:(S.set(l,e>>>0),l.length-1)}var ce={a:function(e,t,r){throw new B(e>>>=0).sa(t>>>0,r>>>0),e},e:function(){return 0},I:function(){},y:function(){},A:function(){},K:function(){return 0},G:function(){},B:function(){},F:function(){},g:function(){},z:function(){},w:function(){},H:function(){},x:function(){},k:()=>!0,n:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),A[r>>2>>>0]=e.getUTCSeconds(),A[r+4>>2>>>0]=e.getUTCMinutes(),A[r+8>>2>>>0]=e.getUTCHours(),A[r+12>>2>>>0]=e.getUTCDate(),A[r+16>>2>>>0]=e.getUTCMonth(),A[r+20>>2>>>0]=e.getUTCFullYear()-1900,A[r+24>>2>>>0]=e.getUTCDay(),A[r+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},o:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),A[r>>2>>>0]=e.getSeconds(),A[r+4>>2>>>0]=e.getMinutes(),A[r+8>>2>>>0]=e.getHours(),A[r+12>>2>>>0]=e.getDate(),A[r+16>>2>>>0]=e.getMonth(),A[r+20>>2>>>0]=e.getFullYear()-1900,A[r+24>>2>>>0]=e.getDay(),A[r+28>>2>>>0]=(Z(e.getFullYear())?Q:ee)[e.getMonth()]+e.getDate()-1|0,A[r+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var n=new Date(e.getFullYear(),0,1).getTimezoneOffset();A[r+32>>2>>>0]=0|(t!=n&&e.getTimezoneOffset()==Math.min(n,t))},p:function(e){e>>>=0;var t=new Date(A[e+20>>2>>>0]+1900,A[e+16>>2>>>0],A[e+12>>2>>>0],A[e+8>>2>>>0],A[e+4>>2>>>0],A[e>>2>>>0],0),r=A[e+32>>2>>>0],n=t.getTimezoneOffset(),a=new Date(t.getFullYear(),6,1).getTimezoneOffset(),o=new Date(t.getFullYear(),0,1).getTimezoneOffset(),i=Math.min(o,a);return 0>r?A[e+32>>2>>>0]=Number(a!=o&&i==n):0<r!=(i==n)&&(a=Math.max(o,a),t.setTime(t.getTime()+6e4*((0<r?i:a)-n))),A[e+24>>2>>>0]=t.getDay(),A[e+28>>2>>>0]=(Z(t.getFullYear())?Q:ee)[t.getMonth()]+t.getDate()-1|0,A[e>>2>>>0]=t.getSeconds(),A[e+4>>2>>>0]=t.getMinutes(),A[e+8>>2>>>0]=t.getHours(),A[e+12>>2>>>0]=t.getDate(),A[e+16>>2>>>0]=t.getMonth(),A[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,de((x=e,1<=+Math.abs(x)?0<x?+Math.floor(x/4294967296)>>>0:~~+Math.ceil((x-+(~~x>>>0))/4294967296)>>>0:0)),e>>>0},l:function(){return-52},m:function(){},u:function(e,t,r){function n(e){return(e=e.toTimeString().match(/\\\\(([A-Za-z ]+)\\\\)$/))?e[1]:\\\"GMT\\\"}r>>>=0;var a=(new Date).getFullYear(),o=new Date(a,0,1),i=new Date(a,6,1);a=o.getTimezoneOffset();var s=i.getTimezoneOffset();T[e>>>0>>2>>>0]=60*Math.max(a,s),A[t>>>0>>2>>>0]=Number(a!=s),e=n(o),t=n(i),e=te(e),t=te(t),s<a?(T[r>>2>>>0]=e,T[r+4>>2>>>0]=t):(T[r>>2>>>0]=t,T[r+4>>2>>>0]=e)},d:()=>{W(\\\"\\\")},h:function(){return Date.now()},v:function(){return 4294901760},b:()=>performance.now(),J:function(e,t,r){return t>>>=0,E.copyWithin(e>>>0>>>0,t>>>0,t+(r>>>0)>>>0)},t:function(e){e>>>=0;var t=E.length;if(4294901760<e)return!1;for(var r=1;4>=r;r*=2){var n=t*(1+.2/r);n=Math.min(n,e+100663296);var a=Math;n=Math.max(e,n);e:{a=a.min.call(a,4294901760,n+(65536-n%65536)%65536)-_.buffer.byteLength+65535>>>16;try{_.grow(a),R();var o=1;break e}catch(e){}o=void 0}if(o)return!0}return!1},D:function(e,t){e>>>=0,t>>>=0;var r=0;return ne().forEach((function(n,a){var o=t+r;for(a=T[e+4*a>>2>>>0]=o,o=0;o<n.length;++o)S[a++>>0>>>0]=n.charCodeAt(o);S[a>>0>>>0]=0,r+=n.length+1})),0},E:function(e,t){e>>>=0,t>>>=0;var r=ne();T[e>>2>>>0]=r.length;var n=0;return r.forEach((function(e){n+=e.length+1})),T[t>>2>>>0]=n,0},s:e=>{w||(a.onExit&&a.onExit(e),M=!0),l(e,new G(e))},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(e,t,r,n){t>>>=0,r>>>=0,n>>>=0;for(var a=0,o=0;o<r;o++){var i=T[t>>2>>>0],s=T[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var c=E[i+u>>>0],l=ae[e];0===c||10===c?((1===e?v:b)(V(l,0)),l.length=0):l.push(c)}a+=s}return T[n>>2>>>0]=a,0},r:function(e,t){return e>>>=0,oe(E.subarray(e>>>0,e+(t>>>0)>>>0)),0},C:ue,c:function(e,t,r,n){return ue(e>>>0,t>>>0,r>>>0,n>>>0)}};!function(){function e(e){if(e=e.exports,O=e=function(e){var t=e=>()=>e()>>>0,r=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.malloc=r(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=r(e.stackAlloc),e}(e),_=O.L,R(),k.unshift(O.M),I--,a.monitorRunDependencies&&a.monitorRunDependencies(I),0==I&&(null!==U&&(clearInterval(U),U=null),L)){var t=L;L=null,t()}return e}var t={a:ce};if(I++,a.monitorRunDependencies&&a.monitorRunDependencies(I),a.instantiateWasm)try{return a.instantiateWasm(t,e)}catch(e){b(\\\"Module.instantiateWasm callback failed with error: \\\"+e),n(e)}(function(e,t){var r=D;return y||\\\"function\\\"!=typeof WebAssembly.instantiateStreaming||H(r)||r.startsWith(\\\"file://\\\")||p||\\\"function\\\"!=typeof fetch?z(r,e,t):fetch(r,{credentials:\\\"same-origin\\\"}).then((n=>WebAssembly.instantiateStreaming(n,e).then(t,(function(n){return b(\\\"wasm streaming compile failed: \\\"+n),b(\\\"falling back to ArrayBuffer instantiation\\\"),z(r,e,t)}))))})(t,(function(t){e(t.instance)})).catch(n)}(),a._OrtInit=(e,t)=>(a._OrtInit=O.N)(e,t),a._OrtGetLastError=(e,t)=>(a._OrtGetLastError=O.O)(e,t),a._OrtCreateSessionOptions=(e,t,r,n,o,i,s,u,c,l)=>(a._OrtCreateSessionOptions=O.P)(e,t,r,n,o,i,s,u,c,l),a._OrtAppendExecutionProvider=(e,t)=>(a._OrtAppendExecutionProvider=O.Q)(e,t),a._OrtAddSessionConfigEntry=(e,t,r)=>(a._OrtAddSessionConfigEntry=O.R)(e,t,r),a._OrtReleaseSessionOptions=e=>(a._OrtReleaseSessionOptions=O.S)(e),a._OrtCreateSession=(e,t,r)=>(a._OrtCreateSession=O.T)(e,t,r),a._OrtReleaseSession=e=>(a._OrtReleaseSession=O.U)(e),a._OrtGetInputOutputCount=(e,t,r)=>(a._OrtGetInputOutputCount=O.V)(e,t,r),a._OrtGetInputName=(e,t)=>(a._OrtGetInputName=O.W)(e,t),a._OrtGetOutputName=(e,t)=>(a._OrtGetOutputName=O.X)(e,t),a._OrtFree=e=>(a._OrtFree=O.Y)(e),a._OrtCreateTensor=(e,t,r,n,o)=>(a._OrtCreateTensor=O.Z)(e,t,r,n,o),a._OrtGetTensorData=(e,t,r,n,o)=>(a._OrtGetTensorData=O._)(e,t,r,n,o),a._OrtReleaseTensor=e=>(a._OrtReleaseTensor=O.$)(e),a._OrtCreateRunOptions=(e,t,r,n)=>(a._OrtCreateRunOptions=O.aa)(e,t,r,n),a._OrtAddRunConfigEntry=(e,t,r)=>(a._OrtAddRunConfigEntry=O.ba)(e,t,r),a._OrtReleaseRunOptions=e=>(a._OrtReleaseRunOptions=O.ca)(e),a._OrtRun=(e,t,r,n,o,i,s,u)=>(a._OrtRun=O.da)(e,t,r,n,o,i,s,u),a._OrtEndProfiling=e=>(a._OrtEndProfiling=O.ea)(e);var le=a._malloc=e=>(le=a._malloc=O.fa)(e);a._free=e=>(a._free=O.ga)(e);var fe,de=e=>(de=O.ia)(e),pe=()=>(pe=O.ja)(),ge=e=>(ge=O.ka)(e),he=e=>(he=O.la)(e);function me(){function e(){if(!fe&&(fe=!0,a.calledRun=!0,!M)){if(N(k),t(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),a.postRun)for(\\\"function\\\"==typeof a.postRun&&(a.postRun=[a.postRun]);a.postRun.length;){var e=a.postRun.shift();C.unshift(e)}N(C)}}if(!(0<I)){if(a.preRun)for(\\\"function\\\"==typeof a.preRun&&(a.preRun=[a.preRun]);a.preRun.length;)P();N(F),0<I||(a.setStatus?(a.setStatus(\\\"Running...\\\"),setTimeout((function(){setTimeout((function(){a.setStatus(\\\"\\\")}),1),e()}),1)):e())}}if(a.stackAlloc=he,a.stackSave=pe,a.stackRestore=ge,a.UTF8ToString=J,a.stringToUTF8=(e,t,r)=>K(e,E,t,r),a.lengthBytesUTF8=X,L=function e(){fe||me(),fe||(L=e)},a.preInit)for(\\\"function\\\"==typeof a.preInit&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();return me(),e.ready});e.exports=n},154:e=>{\\\"use strict\\\";e.exports='\\\"use strict\\\";var e={},a=\\\"object\\\"==typeof process&&\\\"object\\\"==typeof process.versions&&\\\"string\\\"==typeof process.versions.node;if(a){var r=require(\\\"worker_threads\\\"),t=r.parentPort;t.on(\\\"message\\\",(e=>onmessage({data:e})));var s=require(\\\"fs\\\");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:e=>(0,eval)(s.readFileSync(e,\\\"utf8\\\")+\\\"//# sourceURL=\\\"+e),postMessage:e=>t.postMessage(e),performance:global.performance||{now:Date.now}})}var o=!1,d=function(){var e=Array.prototype.slice.call(arguments).join(\\\" \\\");a?s.writeSync(2,e+\\\"\\\\\\\\n\\\"):console.error(e)};self.alert=function(){var a=Array.prototype.slice.call(arguments).join(\\\" \\\");postMessage({cmd:\\\"alert\\\",text:a,threadId:e._pthread_self()})},e.instantiateWasm=(a,r)=>{var t=e.wasmModule;return e.wasmModule=null,r(new WebAssembly.Instance(t,a))},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=function a(r){try{if(\\\"load\\\"===r.data.cmd){let s=[];self.onmessage=e=>s.push(e),self.startWorker=r=>{e=r,postMessage({cmd:\\\"loaded\\\"});for(let e of s)a(e);self.onmessage=a},e.wasmModule=r.data.wasmModule;for(const a of r.data.handlers)e[a]=(...e)=>{postMessage({cmd:\\\"callHandler\\\",handler:a,args:e})};if(e.wasmMemory=r.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,\\\"string\\\"==typeof r.data.urlOrBlob)importScripts(r.data.urlOrBlob);else{var t=URL.createObjectURL(r.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(e)}else if(\\\"run\\\"===r.data.cmd){e.__emscripten_thread_init(r.data.pthread_ptr,0,0,1),e.__emscripten_thread_mailbox_await(r.data.pthread_ptr),e.establishStackSpace(),e.PThread.receiveObjectTransfer(r.data),e.PThread.threadInitTLS(),o||(o=!0);try{e.invokeEntryPoint(r.data.start_routine,r.data.arg)}catch(e){if(\\\"unwind\\\"!=e)throw e}}else\\\"cancel\\\"===r.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):\\\"setimmediate\\\"===r.data.target||(\\\"checkMailbox\\\"===r.data.cmd?o&&e.checkMailbox():r.data.cmd&&(d(\\\"worker.js received unknown command \\\"+r.data.cmd),d(r.data)))}catch(a){throw e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),a}};\\\\n'},760:()=>{},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},t={};function r(n){var a=t[n];if(void 0!==a)return a.exports;var o=t[n]={exports:{}};return e[n].call(o.exports,o,o.exports,r),o.exports}(()=>{\\\"use strict\\\";const e=r(259),t=r(263);self.onmessage=r=>{switch(r.data.type){case\\\"init-wasm\\\":try{(0,t.initializeWebAssembly)(r.data.in).then((()=>postMessage({type:\\\"init-wasm\\\"})),(e=>postMessage({type:\\\"init-wasm\\\",err:e})))}catch(e){postMessage({type:\\\"init-wasm\\\",err:e})}break;case\\\"init-ort\\\":try{(0,e.initRuntime)(r.data.in).then((()=>postMessage({type:\\\"init-ort\\\"})),(e=>postMessage({type:\\\"init-ort\\\",err:e}))),postMessage({type:\\\"init-ort\\\"})}catch(e){postMessage({type:\\\"init-ort\\\",err:e})}break;case\\\"create_allocate\\\":try{const{model:t}=r.data.in,n=(0,e.createSessionAllocate)(t);postMessage({type:\\\"create_allocate\\\",out:n})}catch(e){postMessage({type:\\\"create_allocate\\\",err:e})}break;case\\\"create_finalize\\\":try{const{modeldata:t,options:n}=r.data.in,a=(0,e.createSessionFinalize)(t,n);postMessage({type:\\\"create_finalize\\\",out:a})}catch(e){postMessage({type:\\\"create_finalize\\\",err:e})}break;case\\\"create\\\":try{const{model:t,options:n}=r.data.in,a=(0,e.createSession)(t,n);postMessage({type:\\\"create\\\",out:a})}catch(e){postMessage({type:\\\"create\\\",err:e})}break;case\\\"release\\\":try{const t=r.data.in;(0,e.releaseSession)(t),postMessage({type:\\\"release\\\"})}catch(e){postMessage({type:\\\"release\\\",err:e})}break;case\\\"run\\\":try{const{sessionId:t,inputIndices:n,inputs:a,outputIndices:o,options:i}=r.data.in;(0,e.run)(t,n,a,o,i).then((t=>{postMessage({type:\\\"run\\\",out:t},(0,e.extractTransferableBuffers)(t))}),(e=>{postMessage({type:\\\"run\\\",err:e})}))}catch(e){postMessage({type:\\\"run\\\",err:e})}break;case\\\"end-profiling\\\":try{const t=r.data.in;(0,e.endProfiling)(t),postMessage({type:\\\"end-profiling\\\"})}catch(e){postMessage({type:\\\"end-profiling\\\",err:e})}}}})()})();\\n\", \"Worker\", undefined, undefined);\n}\n","\"use strict\";\n\n/* eslint-env browser */\n\n/* eslint-disable no-undef, no-use-before-define, new-cap */\nmodule.exports = function (content, workerConstructor, workerOptions, url) {\n  var globalScope = self || window;\n\n  try {\n    try {\n      var blob;\n\n      try {\n        // New API\n        blob = new globalScope.Blob([content]);\n      } catch (e) {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = globalScope.BlobBuilder || globalScope.WebKitBlobBuilder || globalScope.MozBlobBuilder || globalScope.MSBlobBuilder;\n        blob = new BlobBuilder();\n        blob.append(content);\n        blob = blob.getBlob();\n      }\n\n      var URL = globalScope.URL || globalScope.webkitURL;\n      var objectURL = URL.createObjectURL(blob);\n      var worker = new globalScope[workerConstructor](objectURL, workerOptions);\n      URL.revokeObjectURL(objectURL);\n      return worker;\n    } catch (e) {\n      return new globalScope[workerConstructor](\"data:application/javascript,\".concat(encodeURIComponent(content)), workerOptions);\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error(\"Inline worker is not supported\");\n    }\n\n    return new globalScope[workerConstructor](url, workerOptions);\n  }\n};","/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.onnx = (function() {\n\n    /**\n     * Namespace onnx.\n     * @exports onnx\n     * @namespace\n     */\n    var onnx = {};\n\n    /**\n     * Version enum.\n     * @name onnx.Version\n     * @enum {number}\n     * @property {number} _START_VERSION=0 _START_VERSION value\n     * @property {number} IR_VERSION_2017_10_10=1 IR_VERSION_2017_10_10 value\n     * @property {number} IR_VERSION_2017_10_30=2 IR_VERSION_2017_10_30 value\n     * @property {number} IR_VERSION_2017_11_3=3 IR_VERSION_2017_11_3 value\n     * @property {number} IR_VERSION_2019_1_22=4 IR_VERSION_2019_1_22 value\n     * @property {number} IR_VERSION_2019_3_18=5 IR_VERSION_2019_3_18 value\n     * @property {number} IR_VERSION_2019_9_19=6 IR_VERSION_2019_9_19 value\n     * @property {number} IR_VERSION_2020_5_8=7 IR_VERSION_2020_5_8 value\n     * @property {number} IR_VERSION_2021_7_30=8 IR_VERSION_2021_7_30 value\n     * @property {number} IR_VERSION=9 IR_VERSION value\n     */\n    onnx.Version = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"_START_VERSION\"] = 0;\n        values[valuesById[1] = \"IR_VERSION_2017_10_10\"] = 1;\n        values[valuesById[2] = \"IR_VERSION_2017_10_30\"] = 2;\n        values[valuesById[3] = \"IR_VERSION_2017_11_3\"] = 3;\n        values[valuesById[4] = \"IR_VERSION_2019_1_22\"] = 4;\n        values[valuesById[5] = \"IR_VERSION_2019_3_18\"] = 5;\n        values[valuesById[6] = \"IR_VERSION_2019_9_19\"] = 6;\n        values[valuesById[7] = \"IR_VERSION_2020_5_8\"] = 7;\n        values[valuesById[8] = \"IR_VERSION_2021_7_30\"] = 8;\n        values[valuesById[9] = \"IR_VERSION\"] = 9;\n        return values;\n    })();\n\n    onnx.AttributeProto = (function() {\n\n        /**\n         * Properties of an AttributeProto.\n         * @memberof onnx\n         * @interface IAttributeProto\n         * @property {string|null} [name] AttributeProto name\n         * @property {string|null} [refAttrName] AttributeProto refAttrName\n         * @property {string|null} [docString] AttributeProto docString\n         * @property {onnx.AttributeProto.AttributeType|null} [type] AttributeProto type\n         * @property {number|null} [f] AttributeProto f\n         * @property {number|Long|null} [i] AttributeProto i\n         * @property {Uint8Array|null} [s] AttributeProto s\n         * @property {onnx.ITensorProto|null} [t] AttributeProto t\n         * @property {onnx.IGraphProto|null} [g] AttributeProto g\n         * @property {onnx.ISparseTensorProto|null} [sparseTensor] AttributeProto sparseTensor\n         * @property {onnx.ITypeProto|null} [tp] AttributeProto tp\n         * @property {Array.<number>|null} [floats] AttributeProto floats\n         * @property {Array.<number|Long>|null} [ints] AttributeProto ints\n         * @property {Array.<Uint8Array>|null} [strings] AttributeProto strings\n         * @property {Array.<onnx.ITensorProto>|null} [tensors] AttributeProto tensors\n         * @property {Array.<onnx.IGraphProto>|null} [graphs] AttributeProto graphs\n         * @property {Array.<onnx.ISparseTensorProto>|null} [sparseTensors] AttributeProto sparseTensors\n         * @property {Array.<onnx.ITypeProto>|null} [typeProtos] AttributeProto typeProtos\n         */\n\n        /**\n         * Constructs a new AttributeProto.\n         * @memberof onnx\n         * @classdesc Represents an AttributeProto.\n         * @implements IAttributeProto\n         * @constructor\n         * @param {onnx.IAttributeProto=} [properties] Properties to set\n         */\n        function AttributeProto(properties) {\n            this.floats = [];\n            this.ints = [];\n            this.strings = [];\n            this.tensors = [];\n            this.graphs = [];\n            this.sparseTensors = [];\n            this.typeProtos = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * AttributeProto name.\n         * @member {string} name\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.name = \"\";\n\n        /**\n         * AttributeProto refAttrName.\n         * @member {string} refAttrName\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.refAttrName = \"\";\n\n        /**\n         * AttributeProto docString.\n         * @member {string} docString\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.docString = \"\";\n\n        /**\n         * AttributeProto type.\n         * @member {onnx.AttributeProto.AttributeType} type\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.type = 0;\n\n        /**\n         * AttributeProto f.\n         * @member {number} f\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.f = 0;\n\n        /**\n         * AttributeProto i.\n         * @member {number|Long} i\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.i = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * AttributeProto s.\n         * @member {Uint8Array} s\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.s = $util.newBuffer([]);\n\n        /**\n         * AttributeProto t.\n         * @member {onnx.ITensorProto|null|undefined} t\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.t = null;\n\n        /**\n         * AttributeProto g.\n         * @member {onnx.IGraphProto|null|undefined} g\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.g = null;\n\n        /**\n         * AttributeProto sparseTensor.\n         * @member {onnx.ISparseTensorProto|null|undefined} sparseTensor\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.sparseTensor = null;\n\n        /**\n         * AttributeProto tp.\n         * @member {onnx.ITypeProto|null|undefined} tp\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.tp = null;\n\n        /**\n         * AttributeProto floats.\n         * @member {Array.<number>} floats\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.floats = $util.emptyArray;\n\n        /**\n         * AttributeProto ints.\n         * @member {Array.<number|Long>} ints\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.ints = $util.emptyArray;\n\n        /**\n         * AttributeProto strings.\n         * @member {Array.<Uint8Array>} strings\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.strings = $util.emptyArray;\n\n        /**\n         * AttributeProto tensors.\n         * @member {Array.<onnx.ITensorProto>} tensors\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.tensors = $util.emptyArray;\n\n        /**\n         * AttributeProto graphs.\n         * @member {Array.<onnx.IGraphProto>} graphs\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.graphs = $util.emptyArray;\n\n        /**\n         * AttributeProto sparseTensors.\n         * @member {Array.<onnx.ISparseTensorProto>} sparseTensors\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.sparseTensors = $util.emptyArray;\n\n        /**\n         * AttributeProto typeProtos.\n         * @member {Array.<onnx.ITypeProto>} typeProtos\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.typeProtos = $util.emptyArray;\n\n        /**\n         * Creates a new AttributeProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.AttributeProto\n         * @static\n         * @param {onnx.IAttributeProto=} [properties] Properties to set\n         * @returns {onnx.AttributeProto} AttributeProto instance\n         */\n        AttributeProto.create = function create(properties) {\n            return new AttributeProto(properties);\n        };\n\n        /**\n         * Encodes the specified AttributeProto message. Does not implicitly {@link onnx.AttributeProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.AttributeProto\n         * @static\n         * @param {onnx.IAttributeProto} message AttributeProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        AttributeProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n            if (message.f != null && Object.hasOwnProperty.call(message, \"f\"))\n                writer.uint32(/* id 2, wireType 5 =*/21).float(message.f);\n            if (message.i != null && Object.hasOwnProperty.call(message, \"i\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.i);\n            if (message.s != null && Object.hasOwnProperty.call(message, \"s\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.s);\n            if (message.t != null && Object.hasOwnProperty.call(message, \"t\"))\n                $root.onnx.TensorProto.encode(message.t, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n            if (message.g != null && Object.hasOwnProperty.call(message, \"g\"))\n                $root.onnx.GraphProto.encode(message.g, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n            if (message.floats != null && message.floats.length) {\n                writer.uint32(/* id 7, wireType 2 =*/58).fork();\n                for (var i = 0; i < message.floats.length; ++i)\n                    writer.float(message.floats[i]);\n                writer.ldelim();\n            }\n            if (message.ints != null && message.ints.length) {\n                writer.uint32(/* id 8, wireType 2 =*/66).fork();\n                for (var i = 0; i < message.ints.length; ++i)\n                    writer.int64(message.ints[i]);\n                writer.ldelim();\n            }\n            if (message.strings != null && message.strings.length)\n                for (var i = 0; i < message.strings.length; ++i)\n                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.strings[i]);\n            if (message.tensors != null && message.tensors.length)\n                for (var i = 0; i < message.tensors.length; ++i)\n                    $root.onnx.TensorProto.encode(message.tensors[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();\n            if (message.graphs != null && message.graphs.length)\n                for (var i = 0; i < message.graphs.length; ++i)\n                    $root.onnx.GraphProto.encode(message.graphs[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();\n            if (message.docString != null && Object.hasOwnProperty.call(message, \"docString\"))\n                writer.uint32(/* id 13, wireType 2 =*/106).string(message.docString);\n            if (message.tp != null && Object.hasOwnProperty.call(message, \"tp\"))\n                $root.onnx.TypeProto.encode(message.tp, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();\n            if (message.typeProtos != null && message.typeProtos.length)\n                for (var i = 0; i < message.typeProtos.length; ++i)\n                    $root.onnx.TypeProto.encode(message.typeProtos[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();\n            if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                writer.uint32(/* id 20, wireType 0 =*/160).int32(message.type);\n            if (message.refAttrName != null && Object.hasOwnProperty.call(message, \"refAttrName\"))\n                writer.uint32(/* id 21, wireType 2 =*/170).string(message.refAttrName);\n            if (message.sparseTensor != null && Object.hasOwnProperty.call(message, \"sparseTensor\"))\n                $root.onnx.SparseTensorProto.encode(message.sparseTensor, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();\n            if (message.sparseTensors != null && message.sparseTensors.length)\n                for (var i = 0; i < message.sparseTensors.length; ++i)\n                    $root.onnx.SparseTensorProto.encode(message.sparseTensors[i], writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified AttributeProto message, length delimited. Does not implicitly {@link onnx.AttributeProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.AttributeProto\n         * @static\n         * @param {onnx.IAttributeProto} message AttributeProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        AttributeProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an AttributeProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.AttributeProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.AttributeProto} AttributeProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        AttributeProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.AttributeProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1: {\n                        message.name = reader.string();\n                        break;\n                    }\n                case 21: {\n                        message.refAttrName = reader.string();\n                        break;\n                    }\n                case 13: {\n                        message.docString = reader.string();\n                        break;\n                    }\n                case 20: {\n                        message.type = reader.int32();\n                        break;\n                    }\n                case 2: {\n                        message.f = reader.float();\n                        break;\n                    }\n                case 3: {\n                        message.i = reader.int64();\n                        break;\n                    }\n                case 4: {\n                        message.s = reader.bytes();\n                        break;\n                    }\n                case 5: {\n                        message.t = $root.onnx.TensorProto.decode(reader, reader.uint32());\n                        break;\n                    }\n                case 6: {\n                        message.g = $root.onnx.GraphProto.decode(reader, reader.uint32());\n                        break;\n                    }\n                case 22: {\n                        message.sparseTensor = $root.onnx.SparseTensorProto.decode(reader, reader.uint32());\n                        break;\n                    }\n                case 14: {\n                        message.tp = $root.onnx.TypeProto.decode(reader, reader.uint32());\n                        break;\n                    }\n                case 7: {\n                        if (!(message.floats && message.floats.length))\n                            message.floats = [];\n                        if ((tag & 7) === 2) {\n                            var end2 = reader.uint32() + reader.pos;\n                            while (reader.pos < end2)\n                                message.floats.push(reader.float());\n                        } else\n                            message.floats.push(reader.float());\n                        break;\n                    }\n                case 8: {\n                        if (!(message.ints && message.ints.length))\n                            message.ints = [];\n                        if ((tag & 7) === 2) {\n                            var end2 = reader.uint32() + reader.pos;\n                            while (reader.pos < end2)\n                                message.ints.push(reader.int64());\n                        } else\n                            message.ints.push(reader.int64());\n                        break;\n                    }\n                case 9: {\n                        if (!(message.strings && message.strings.length))\n                            message.strings = [];\n                        message.strings.push(reader.bytes());\n                        break;\n                    }\n                case 10: {\n                        if (!(message.tensors && message.tensors.length))\n                            message.tensors = [];\n                        message.tensors.push($root.onnx.TensorProto.decode(reader, reader.uint32()));\n                        break;\n                    }\n                case 11: {\n                        if (!(message.graphs && message.graphs.length))\n                            message.graphs = [];\n                        message.graphs.push($root.onnx.GraphProto.decode(reader, reader.uint32()));\n                        break;\n                    }\n                case 23: {\n                        if (!(message.sparseTensors && message.sparseTensors.length))\n                            message.sparseTensors = [];\n                        message.sparseTensors.push($root.onnx.SparseTensorProto.decode(reader, reader.uint32()));\n                        break;\n                    }\n                case 15: {\n                        if (!(message.typeProtos && message.typeProtos.length))\n                            message.typeProtos = [];\n                        message.typeProtos.push($root.onnx.TypeProto.decode(reader, reader.uint32()));\n                        break;\n                    }\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an AttributeProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.AttributeProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.AttributeProto} AttributeProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        AttributeProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an AttributeProto message.\n         * @function verify\n         * @memberof onnx.AttributeProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        AttributeProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                if (!$util.isString(message.name))\n                    return \"name: string expected\";\n            if (message.refAttrName != null && message.hasOwnProperty(\"refAttrName\"))\n                if (!$util.isString(message.refAttrName))\n                    return \"refAttrName: string expected\";\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                if (!$util.isString(message.docString))\n                    return \"docString: string expected\";\n            if (message.type != null && message.hasOwnProperty(\"type\"))\n                switch (message.type) {\n                default:\n                    return \"type: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 11:\n                case 13:\n                case 6:\n                case 7:\n                case 8:\n                case 9:\n                case 10:\n                case 12:\n                case 14:\n                    break;\n                }\n            if (message.f != null && message.hasOwnProperty(\"f\"))\n                if (typeof message.f !== \"number\")\n                    return \"f: number expected\";\n            if (message.i != null && message.hasOwnProperty(\"i\"))\n                if (!$util.isInteger(message.i) && !(message.i && $util.isInteger(message.i.low) && $util.isInteger(message.i.high)))\n                    return \"i: integer|Long expected\";\n            if (message.s != null && message.hasOwnProperty(\"s\"))\n                if (!(message.s && typeof message.s.length === \"number\" || $util.isString(message.s)))\n                    return \"s: buffer expected\";\n            if (message.t != null && message.hasOwnProperty(\"t\")) {\n                var error = $root.onnx.TensorProto.verify(message.t);\n                if (error)\n                    return \"t.\" + error;\n            }\n            if (message.g != null && message.hasOwnProperty(\"g\")) {\n                var error = $root.onnx.GraphProto.verify(message.g);\n                if (error)\n                    return \"g.\" + error;\n            }\n            if (message.sparseTensor != null && message.hasOwnProperty(\"sparseTensor\")) {\n                var error = $root.onnx.SparseTensorProto.verify(message.sparseTensor);\n                if (error)\n                    return \"sparseTensor.\" + error;\n            }\n            if (message.tp != null && message.hasOwnProperty(\"tp\")) {\n                var error = $root.onnx.TypeProto.verify(message.tp);\n                if (error)\n                    return \"tp.\" + error;\n            }\n            if (message.floats != null && message.hasOwnProperty(\"floats\")) {\n                if (!Array.isArray(message.floats))\n                    return \"floats: array expected\";\n                for (var i = 0; i < message.floats.length; ++i)\n                    if (typeof message.floats[i] !== \"number\")\n                        return \"floats: number[] expected\";\n            }\n            if (message.ints != null && message.hasOwnProperty(\"ints\")) {\n                if (!Array.isArray(message.ints))\n                    return \"ints: array expected\";\n                for (var i = 0; i < message.ints.length; ++i)\n                    if (!$util.isInteger(message.ints[i]) && !(message.ints[i] && $util.isInteger(message.ints[i].low) && $util.isInteger(message.ints[i].high)))\n                        return \"ints: integer|Long[] expected\";\n            }\n            if (message.strings != null && message.hasOwnProperty(\"strings\")) {\n                if (!Array.isArray(message.strings))\n                    return \"strings: array expected\";\n                for (var i = 0; i < message.strings.length; ++i)\n                    if (!(message.strings[i] && typeof message.strings[i].length === \"number\" || $util.isString(message.strings[i])))\n                        return \"strings: buffer[] expected\";\n            }\n            if (message.tensors != null && message.hasOwnProperty(\"tensors\")) {\n                if (!Array.isArray(message.tensors))\n                    return \"tensors: array expected\";\n                for (var i = 0; i < message.tensors.length; ++i) {\n                    var error = $root.onnx.TensorProto.verify(message.tensors[i]);\n                    if (error)\n                        return \"tensors.\" + error;\n                }\n            }\n            if (message.graphs != null && message.hasOwnProperty(\"graphs\")) {\n                if (!Array.isArray(message.graphs))\n                    return \"graphs: array expected\";\n                for (var i = 0; i < message.graphs.length; ++i) {\n                    var error = $root.onnx.GraphProto.verify(message.graphs[i]);\n                    if (error)\n                        return \"graphs.\" + error;\n                }\n            }\n            if (message.sparseTensors != null && message.hasOwnProperty(\"sparseTensors\")) {\n                if (!Array.isArray(message.sparseTensors))\n                    return \"sparseTensors: array expected\";\n                for (var i = 0; i < message.sparseTensors.length; ++i) {\n                    var error = $root.onnx.SparseTensorProto.verify(message.sparseTensors[i]);\n                    if (error)\n                        return \"sparseTensors.\" + error;\n                }\n            }\n            if (message.typeProtos != null && message.hasOwnProperty(\"typeProtos\")) {\n                if (!Array.isArray(message.typeProtos))\n                    return \"typeProtos: array expected\";\n                for (var i = 0; i < message.typeProtos.length; ++i) {\n                    var error = $root.onnx.TypeProto.verify(message.typeProtos[i]);\n                    if (error)\n                        return \"typeProtos.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates an AttributeProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.AttributeProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.AttributeProto} AttributeProto\n         */\n        AttributeProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.AttributeProto)\n                return object;\n            var message = new $root.onnx.AttributeProto();\n            if (object.name != null)\n                message.name = String(object.name);\n            if (object.refAttrName != null)\n                message.refAttrName = String(object.refAttrName);\n            if (object.docString != null)\n                message.docString = String(object.docString);\n            switch (object.type) {\n            default:\n                if (typeof object.type === \"number\") {\n                    message.type = object.type;\n                    break;\n                }\n                break;\n            case \"UNDEFINED\":\n            case 0:\n                message.type = 0;\n                break;\n            case \"FLOAT\":\n            case 1:\n                message.type = 1;\n                break;\n            case \"INT\":\n            case 2:\n                message.type = 2;\n                break;\n            case \"STRING\":\n            case 3:\n                message.type = 3;\n                break;\n            case \"TENSOR\":\n            case 4:\n                message.type = 4;\n                break;\n            case \"GRAPH\":\n            case 5:\n                message.type = 5;\n                break;\n            case \"SPARSE_TENSOR\":\n            case 11:\n                message.type = 11;\n                break;\n            case \"TYPE_PROTO\":\n            case 13:\n                message.type = 13;\n                break;\n            case \"FLOATS\":\n            case 6:\n                message.type = 6;\n                break;\n            case \"INTS\":\n            case 7:\n                message.type = 7;\n                break;\n            case \"STRINGS\":\n            case 8:\n                message.type = 8;\n                break;\n            case \"TENSORS\":\n            case 9:\n                message.type = 9;\n                break;\n            case \"GRAPHS\":\n            case 10:\n                message.type = 10;\n                break;\n            case \"SPARSE_TENSORS\":\n            case 12:\n                message.type = 12;\n                break;\n            case \"TYPE_PROTOS\":\n            case 14:\n                message.type = 14;\n                break;\n            }\n            if (object.f != null)\n                message.f = Number(object.f);\n            if (object.i != null)\n                if ($util.Long)\n                    (message.i = $util.Long.fromValue(object.i)).unsigned = false;\n                else if (typeof object.i === \"string\")\n                    message.i = parseInt(object.i, 10);\n                else if (typeof object.i === \"number\")\n                    message.i = object.i;\n                else if (typeof object.i === \"object\")\n                    message.i = new $util.LongBits(object.i.low >>> 0, object.i.high >>> 0).toNumber();\n            if (object.s != null)\n                if (typeof object.s === \"string\")\n                    $util.base64.decode(object.s, message.s = $util.newBuffer($util.base64.length(object.s)), 0);\n                else if (object.s.length >= 0)\n                    message.s = object.s;\n            if (object.t != null) {\n                if (typeof object.t !== \"object\")\n                    throw TypeError(\".onnx.AttributeProto.t: object expected\");\n                message.t = $root.onnx.TensorProto.fromObject(object.t);\n            }\n            if (object.g != null) {\n                if (typeof object.g !== \"object\")\n                    throw TypeError(\".onnx.AttributeProto.g: object expected\");\n                message.g = $root.onnx.GraphProto.fromObject(object.g);\n            }\n            if (object.sparseTensor != null) {\n                if (typeof object.sparseTensor !== \"object\")\n                    throw TypeError(\".onnx.AttributeProto.sparseTensor: object expected\");\n                message.sparseTensor = $root.onnx.SparseTensorProto.fromObject(object.sparseTensor);\n            }\n            if (object.tp != null) {\n                if (typeof object.tp !== \"object\")\n                    throw TypeError(\".onnx.AttributeProto.tp: object expected\");\n                message.tp = $root.onnx.TypeProto.fromObject(object.tp);\n            }\n            if (object.floats) {\n                if (!Array.isArray(object.floats))\n                    throw TypeError(\".onnx.AttributeProto.floats: array expected\");\n                message.floats = [];\n                for (var i = 0; i < object.floats.length; ++i)\n                    message.floats[i] = Number(object.floats[i]);\n            }\n            if (object.ints) {\n                if (!Array.isArray(object.ints))\n                    throw TypeError(\".onnx.AttributeProto.ints: array expected\");\n                message.ints = [];\n                for (var i = 0; i < object.ints.length; ++i)\n                    if ($util.Long)\n                        (message.ints[i] = $util.Long.fromValue(object.ints[i])).unsigned = false;\n                    else if (typeof object.ints[i] === \"string\")\n                        message.ints[i] = parseInt(object.ints[i], 10);\n                    else if (typeof object.ints[i] === \"number\")\n                        message.ints[i] = object.ints[i];\n                    else if (typeof object.ints[i] === \"object\")\n                        message.ints[i] = new $util.LongBits(object.ints[i].low >>> 0, object.ints[i].high >>> 0).toNumber();\n            }\n            if (object.strings) {\n                if (!Array.isArray(object.strings))\n                    throw TypeError(\".onnx.AttributeProto.strings: array expected\");\n                message.strings = [];\n                for (var i = 0; i < object.strings.length; ++i)\n                    if (typeof object.strings[i] === \"string\")\n                        $util.base64.decode(object.strings[i], message.strings[i] = $util.newBuffer($util.base64.length(object.strings[i])), 0);\n                    else if (object.strings[i].length >= 0)\n                        message.strings[i] = object.strings[i];\n            }\n            if (object.tensors) {\n                if (!Array.isArray(object.tensors))\n                    throw TypeError(\".onnx.AttributeProto.tensors: array expected\");\n                message.tensors = [];\n                for (var i = 0; i < object.tensors.length; ++i) {\n                    if (typeof object.tensors[i] !== \"object\")\n                        throw TypeError(\".onnx.AttributeProto.tensors: object expected\");\n                    message.tensors[i] = $root.onnx.TensorProto.fromObject(object.tensors[i]);\n                }\n            }\n            if (object.graphs) {\n                if (!Array.isArray(object.graphs))\n                    throw TypeError(\".onnx.AttributeProto.graphs: array expected\");\n                message.graphs = [];\n                for (var i = 0; i < object.graphs.length; ++i) {\n                    if (typeof object.graphs[i] !== \"object\")\n                        throw TypeError(\".onnx.AttributeProto.graphs: object expected\");\n                    message.graphs[i] = $root.onnx.GraphProto.fromObject(object.graphs[i]);\n                }\n            }\n            if (object.sparseTensors) {\n                if (!Array.isArray(object.sparseTensors))\n                    throw TypeError(\".onnx.AttributeProto.sparseTensors: array expected\");\n                message.sparseTensors = [];\n                for (var i = 0; i < object.sparseTensors.length; ++i) {\n                    if (typeof object.sparseTensors[i] !== \"object\")\n                        throw TypeError(\".onnx.AttributeProto.sparseTensors: object expected\");\n                    message.sparseTensors[i] = $root.onnx.SparseTensorProto.fromObject(object.sparseTensors[i]);\n                }\n            }\n            if (object.typeProtos) {\n                if (!Array.isArray(object.typeProtos))\n                    throw TypeError(\".onnx.AttributeProto.typeProtos: array expected\");\n                message.typeProtos = [];\n                for (var i = 0; i < object.typeProtos.length; ++i) {\n                    if (typeof object.typeProtos[i] !== \"object\")\n                        throw TypeError(\".onnx.AttributeProto.typeProtos: object expected\");\n                    message.typeProtos[i] = $root.onnx.TypeProto.fromObject(object.typeProtos[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an AttributeProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.AttributeProto\n         * @static\n         * @param {onnx.AttributeProto} message AttributeProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        AttributeProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.floats = [];\n                object.ints = [];\n                object.strings = [];\n                object.tensors = [];\n                object.graphs = [];\n                object.typeProtos = [];\n                object.sparseTensors = [];\n            }\n            if (options.defaults) {\n                object.name = \"\";\n                object.f = 0;\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.i = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.i = options.longs === String ? \"0\" : 0;\n                if (options.bytes === String)\n                    object.s = \"\";\n                else {\n                    object.s = [];\n                    if (options.bytes !== Array)\n                        object.s = $util.newBuffer(object.s);\n                }\n                object.t = null;\n                object.g = null;\n                object.docString = \"\";\n                object.tp = null;\n                object.type = options.enums === String ? \"UNDEFINED\" : 0;\n                object.refAttrName = \"\";\n                object.sparseTensor = null;\n            }\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                object.name = message.name;\n            if (message.f != null && message.hasOwnProperty(\"f\"))\n                object.f = options.json && !isFinite(message.f) ? String(message.f) : message.f;\n            if (message.i != null && message.hasOwnProperty(\"i\"))\n                if (typeof message.i === \"number\")\n                    object.i = options.longs === String ? String(message.i) : message.i;\n                else\n                    object.i = options.longs === String ? $util.Long.prototype.toString.call(message.i) : options.longs === Number ? new $util.LongBits(message.i.low >>> 0, message.i.high >>> 0).toNumber() : message.i;\n            if (message.s != null && message.hasOwnProperty(\"s\"))\n                object.s = options.bytes === String ? $util.base64.encode(message.s, 0, message.s.length) : options.bytes === Array ? Array.prototype.slice.call(message.s) : message.s;\n            if (message.t != null && message.hasOwnProperty(\"t\"))\n                object.t = $root.onnx.TensorProto.toObject(message.t, options);\n            if (message.g != null && message.hasOwnProperty(\"g\"))\n                object.g = $root.onnx.GraphProto.toObject(message.g, options);\n            if (message.floats && message.floats.length) {\n                object.floats = [];\n                for (var j = 0; j < message.floats.length; ++j)\n                    object.floats[j] = options.json && !isFinite(message.floats[j]) ? String(message.floats[j]) : message.floats[j];\n            }\n            if (message.ints && message.ints.length) {\n                object.ints = [];\n                for (var j = 0; j < message.ints.length; ++j)\n                    if (typeof message.ints[j] === \"number\")\n                        object.ints[j] = options.longs === String ? String(message.ints[j]) : message.ints[j];\n                    else\n                        object.ints[j] = options.longs === String ? $util.Long.prototype.toString.call(message.ints[j]) : options.longs === Number ? new $util.LongBits(message.ints[j].low >>> 0, message.ints[j].high >>> 0).toNumber() : message.ints[j];\n            }\n            if (message.strings && message.strings.length) {\n                object.strings = [];\n                for (var j = 0; j < message.strings.length; ++j)\n                    object.strings[j] = options.bytes === String ? $util.base64.encode(message.strings[j], 0, message.strings[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.strings[j]) : message.strings[j];\n            }\n            if (message.tensors && message.tensors.length) {\n                object.tensors = [];\n                for (var j = 0; j < message.tensors.length; ++j)\n                    object.tensors[j] = $root.onnx.TensorProto.toObject(message.tensors[j], options);\n            }\n            if (message.graphs && message.graphs.length) {\n                object.graphs = [];\n                for (var j = 0; j < message.graphs.length; ++j)\n                    object.graphs[j] = $root.onnx.GraphProto.toObject(message.graphs[j], options);\n            }\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                object.docString = message.docString;\n            if (message.tp != null && message.hasOwnProperty(\"tp\"))\n                object.tp = $root.onnx.TypeProto.toObject(message.tp, options);\n            if (message.typeProtos && message.typeProtos.length) {\n                object.typeProtos = [];\n                for (var j = 0; j < message.typeProtos.length; ++j)\n                    object.typeProtos[j] = $root.onnx.TypeProto.toObject(message.typeProtos[j], options);\n            }\n            if (message.type != null && message.hasOwnProperty(\"type\"))\n                object.type = options.enums === String ? $root.onnx.AttributeProto.AttributeType[message.type] === undefined ? message.type : $root.onnx.AttributeProto.AttributeType[message.type] : message.type;\n            if (message.refAttrName != null && message.hasOwnProperty(\"refAttrName\"))\n                object.refAttrName = message.refAttrName;\n            if (message.sparseTensor != null && message.hasOwnProperty(\"sparseTensor\"))\n                object.sparseTensor = $root.onnx.SparseTensorProto.toObject(message.sparseTensor, options);\n            if (message.sparseTensors && message.sparseTensors.length) {\n                object.sparseTensors = [];\n                for (var j = 0; j < message.sparseTensors.length; ++j)\n                    object.sparseTensors[j] = $root.onnx.SparseTensorProto.toObject(message.sparseTensors[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this AttributeProto to JSON.\n         * @function toJSON\n         * @memberof onnx.AttributeProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        AttributeProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * Gets the default type url for AttributeProto\n         * @function getTypeUrl\n         * @memberof onnx.AttributeProto\n         * @static\n         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n         * @returns {string} The default type url\n         */\n        AttributeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === undefined) {\n                typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/onnx.AttributeProto\";\n        };\n\n        /**\n         * AttributeType enum.\n         * @name onnx.AttributeProto.AttributeType\n         * @enum {number}\n         * @property {number} UNDEFINED=0 UNDEFINED value\n         * @property {number} FLOAT=1 FLOAT value\n         * @property {number} INT=2 INT value\n         * @property {number} STRING=3 STRING value\n         * @property {number} TENSOR=4 TENSOR value\n         * @property {number} GRAPH=5 GRAPH value\n         * @property {number} SPARSE_TENSOR=11 SPARSE_TENSOR value\n         * @property {number} TYPE_PROTO=13 TYPE_PROTO value\n         * @property {number} FLOATS=6 FLOATS value\n         * @property {number} INTS=7 INTS value\n         * @property {number} STRINGS=8 STRINGS value\n         * @property {number} TENSORS=9 TENSORS value\n         * @property {number} GRAPHS=10 GRAPHS value\n         * @property {number} SPARSE_TENSORS=12 SPARSE_TENSORS value\n         * @property {number} TYPE_PROTOS=14 TYPE_PROTOS value\n         */\n        AttributeProto.AttributeType = (function() {\n            var valuesById = {}, values = Object.create(valuesById);\n            values[valuesById[0] = \"UNDEFINED\"] = 0;\n            values[valuesById[1] = \"FLOAT\"] = 1;\n            values[valuesById[2] = \"INT\"] = 2;\n            values[valuesById[3] = \"STRING\"] = 3;\n            values[valuesById[4] = \"TENSOR\"] = 4;\n            values[valuesById[5] = \"GRAPH\"] = 5;\n            values[valuesById[11] = \"SPARSE_TENSOR\"] = 11;\n            values[valuesById[13] = \"TYPE_PROTO\"] = 13;\n            values[valuesById[6] = \"FLOATS\"] = 6;\n            values[valuesById[7] = \"INTS\"] = 7;\n            values[valuesById[8] = \"STRINGS\"] = 8;\n            values[valuesById[9] = \"TENSORS\"] = 9;\n            values[valuesById[10] = \"GRAPHS\"] = 10;\n            values[valuesById[12] = \"SPARSE_TENSORS\"] = 12;\n            values[valuesById[14] = \"TYPE_PROTOS\"] = 14;\n            return values;\n        })();\n\n        return AttributeProto;\n    })();\n\n    onnx.ValueInfoProto = (function() {\n\n        /**\n         * Properties of a ValueInfoProto.\n         * @memberof onnx\n         * @interface IValueInfoProto\n         * @property {string|null} [name] ValueInfoProto name\n         * @property {onnx.ITypeProto|null} [type] ValueInfoProto type\n         * @property {string|null} [docString] ValueInfoProto docString\n         */\n\n        /**\n         * Constructs a new ValueInfoProto.\n         * @memberof onnx\n         * @classdesc Represents a ValueInfoProto.\n         * @implements IValueInfoProto\n         * @constructor\n         * @param {onnx.IValueInfoProto=} [properties] Properties to set\n         */\n        function ValueInfoProto(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ValueInfoProto name.\n         * @member {string} name\n         * @memberof onnx.ValueInfoProto\n         * @instance\n         */\n        ValueInfoProto.prototype.name = \"\";\n\n        /**\n         * ValueInfoProto type.\n         * @member {onnx.ITypeProto|null|undefined} type\n         * @memberof onnx.ValueInfoProto\n         * @instance\n         */\n        ValueInfoProto.prototype.type = null;\n\n        /**\n         * ValueInfoProto docString.\n         * @member {string} docString\n         * @memberof onnx.ValueInfoProto\n         * @instance\n         */\n        ValueInfoProto.prototype.docString = \"\";\n\n        /**\n         * Creates a new ValueInfoProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.ValueInfoProto\n         * @static\n         * @param {onnx.IValueInfoProto=} [properties] Properties to set\n         * @returns {onnx.ValueInfoProto} ValueInfoProto instance\n         */\n        ValueInfoProto.create = function create(properties) {\n            return new ValueInfoProto(properties);\n        };\n\n        /**\n         * Encodes the specified ValueInfoProto message. Does not implicitly {@link onnx.ValueInfoProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.ValueInfoProto\n         * @static\n         * @param {onnx.IValueInfoProto} message ValueInfoProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ValueInfoProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n            if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                $root.onnx.TypeProto.encode(message.type, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.docString != null && Object.hasOwnProperty.call(message, \"docString\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.docString);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified ValueInfoProto message, length delimited. Does not implicitly {@link onnx.ValueInfoProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.ValueInfoProto\n         * @static\n         * @param {onnx.IValueInfoProto} message ValueInfoProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ValueInfoProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a ValueInfoProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.ValueInfoProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.ValueInfoProto} ValueInfoProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ValueInfoProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.ValueInfoProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1: {\n                        message.name = reader.string();\n                        break;\n                    }\n                case 2: {\n                        message.type = $root.onnx.TypeProto.decode(reader, reader.uint32());\n                        break;\n                    }\n                case 3: {\n                        message.docString = reader.string();\n                        break;\n                    }\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a ValueInfoProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.ValueInfoProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.ValueInfoProto} ValueInfoProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ValueInfoProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a ValueInfoProto message.\n         * @function verify\n         * @memberof onnx.ValueInfoProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        ValueInfoProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                if (!$util.isString(message.name))\n                    return \"name: string expected\";\n            if (message.type != null && message.hasOwnProperty(\"type\")) {\n                var error = $root.onnx.TypeProto.verify(message.type);\n                if (error)\n                    return \"type.\" + error;\n            }\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                if (!$util.isString(message.docString))\n                    return \"docString: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a ValueInfoProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.ValueInfoProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.ValueInfoProto} ValueInfoProto\n         */\n        ValueInfoProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.ValueInfoProto)\n                return object;\n            var message = new $root.onnx.ValueInfoProto();\n            if (object.name != null)\n                message.name = String(object.name);\n            if (object.type != null) {\n                if (typeof object.type !== \"object\")\n                    throw TypeError(\".onnx.ValueInfoProto.type: object expected\");\n                message.type = $root.onnx.TypeProto.fromObject(object.type);\n            }\n            if (object.docString != null)\n                message.docString = String(object.docString);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a ValueInfoProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.ValueInfoProto\n         * @static\n         * @param {onnx.ValueInfoProto} message ValueInfoProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        ValueInfoProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.name = \"\";\n                object.type = null;\n                object.docString = \"\";\n            }\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                object.name = message.name;\n            if (message.type != null && message.hasOwnProperty(\"type\"))\n                object.type = $root.onnx.TypeProto.toObject(message.type, options);\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                object.docString = message.docString;\n            return object;\n        };\n\n        /**\n         * Converts this ValueInfoProto to JSON.\n         * @function toJSON\n         * @memberof onnx.ValueInfoProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        ValueInfoProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * Gets the default type url for ValueInfoProto\n         * @function getTypeUrl\n         * @memberof onnx.ValueInfoProto\n         * @static\n         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n         * @returns {string} The default type url\n         */\n        ValueInfoProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === undefined) {\n                typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/onnx.ValueInfoProto\";\n        };\n\n        return ValueInfoProto;\n    })();\n\n    onnx.NodeProto = (function() {\n\n        /**\n         * Properties of a NodeProto.\n         * @memberof onnx\n         * @interface INodeProto\n         * @property {Array.<string>|null} [input] NodeProto input\n         * @property {Array.<string>|null} [output] NodeProto output\n         * @property {string|null} [name] NodeProto name\n         * @property {string|null} [opType] NodeProto opType\n         * @property {string|null} [domain] NodeProto domain\n         * @property {Array.<onnx.IAttributeProto>|null} [attribute] NodeProto attribute\n         * @property {string|null} [docString] NodeProto docString\n         */\n\n        /**\n         * Constructs a new NodeProto.\n         * @memberof onnx\n         * @classdesc Represents a NodeProto.\n         * @implements INodeProto\n         * @constructor\n         * @param {onnx.INodeProto=} [properties] Properties to set\n         */\n        function NodeProto(properties) {\n            this.input = [];\n            this.output = [];\n            this.attribute = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * NodeProto input.\n         * @member {Array.<string>} input\n         * @memberof onnx.NodeProto\n         * @instance\n         */\n        NodeProto.prototype.input = $util.emptyArray;\n\n        /**\n         * NodeProto output.\n         * @member {Array.<string>} output\n         * @memberof onnx.NodeProto\n         * @instance\n         */\n        NodeProto.prototype.output = $util.emptyArray;\n\n        /**\n         * NodeProto name.\n         * @member {string} name\n         * @memberof onnx.NodeProto\n         * @instance\n         */\n        NodeProto.prototype.name = \"\";\n\n        /**\n         * NodeProto opType.\n         * @member {string} opType\n         * @memberof onnx.NodeProto\n         * @instance\n         */\n        NodeProto.prototype.opType = \"\";\n\n        /**\n         * NodeProto domain.\n         * @member {string} domain\n         * @memberof onnx.NodeProto\n         * @instance\n         */\n        NodeProto.prototype.domain = \"\";\n\n        /**\n         * NodeProto attribute.\n         * @member {Array.<onnx.IAttributeProto>} attribute\n         * @memberof onnx.NodeProto\n         * @instance\n         */\n        NodeProto.prototype.attribute = $util.emptyArray;\n\n        /**\n         * NodeProto docString.\n         * @member {string} docString\n         * @memberof onnx.NodeProto\n         * @instance\n         */\n        NodeProto.prototype.docString = \"\";\n\n        /**\n         * Creates a new NodeProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.NodeProto\n         * @static\n         * @param {onnx.INodeProto=} [properties] Properties to set\n         * @returns {onnx.NodeProto} NodeProto instance\n         */\n        NodeProto.create = function create(properties) {\n            return new NodeProto(properties);\n        };\n\n        /**\n         * Encodes the specified NodeProto message. Does not implicitly {@link onnx.NodeProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.NodeProto\n         * @static\n         * @param {onnx.INodeProto} message NodeProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        NodeProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.input != null && message.input.length)\n                for (var i = 0; i < message.input.length; ++i)\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.input[i]);\n            if (message.output != null && message.output.length)\n                for (var i = 0; i < message.output.length; ++i)\n                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.output[i]);\n            if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);\n            if (message.opType != null && Object.hasOwnProperty.call(message, \"opType\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).string(message.opType);\n            if (message.attribute != null && message.attribute.length)\n                for (var i = 0; i < message.attribute.length; ++i)\n                    $root.onnx.AttributeProto.encode(message.attribute[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n            if (message.docString != null && Object.hasOwnProperty.call(message, \"docString\"))\n                writer.uint32(/* id 6, wireType 2 =*/50).string(message.docString);\n            if (message.domain != null && Object.hasOwnProperty.call(message, \"domain\"))\n                writer.uint32(/* id 7, wireType 2 =*/58).string(message.domain);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified NodeProto message, length delimited. Does not implicitly {@link onnx.NodeProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.NodeProto\n         * @static\n         * @param {onnx.INodeProto} message NodeProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        NodeProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a NodeProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.NodeProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.NodeProto} NodeProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        NodeProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.NodeProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1: {\n                        if (!(message.input && message.input.length))\n                            message.input = [];\n                        message.input.push(reader.string());\n                        break;\n                    }\n                case 2: {\n                        if (!(message.output && message.output.length))\n                            message.output = [];\n                        message.output.push(reader.string());\n                        break;\n                    }\n                case 3: {\n                        message.name = reader.string();\n                        break;\n                    }\n                case 4: {\n                        message.opType = reader.string();\n                        break;\n                    }\n                case 7: {\n                        message.domain = reader.string();\n                        break;\n                    }\n                case 5: {\n                        if (!(message.attribute && message.attribute.length))\n                            message.attribute = [];\n                        message.attribute.push($root.onnx.AttributeProto.decode(reader, reader.uint32()));\n                        break;\n                    }\n                case 6: {\n                        message.docString = reader.string();\n                        break;\n                    }\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a NodeProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.NodeProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.NodeProto} NodeProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        NodeProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a NodeProto message.\n         * @function verify\n         * @memberof onnx.NodeProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        NodeProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.input != null && message.hasOwnProperty(\"input\")) {\n                if (!Array.isArray(message.input))\n                    return \"input: array expected\";\n                for (var i = 0; i < message.input.length; ++i)\n                    if (!$util.isString(message.input[i]))\n                        return \"input: string[] expected\";\n            }\n            if (message.output != null && message.hasOwnProperty(\"output\")) {\n                if (!Array.isArray(message.output))\n                    return \"output: array expected\";\n                for (var i = 0; i < message.output.length; ++i)\n                    if (!$util.isString(message.output[i]))\n                        return \"output: string[] expected\";\n            }\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                if (!$util.isString(message.name))\n                    return \"name: string expected\";\n            if (message.opType != null && message.hasOwnProperty(\"opType\"))\n                if (!$util.isString(message.opType))\n                    return \"opType: string expected\";\n            if (message.domain != null && message.hasOwnProperty(\"domain\"))\n                if (!$util.isString(message.domain))\n                    return \"domain: string expected\";\n            if (message.attribute != null && message.hasOwnProperty(\"attribute\")) {\n                if (!Array.isArray(message.attribute))\n                    return \"attribute: array expected\";\n                for (var i = 0; i < message.attribute.length; ++i) {\n                    var error = $root.onnx.AttributeProto.verify(message.attribute[i]);\n                    if (error)\n                        return \"attribute.\" + error;\n                }\n            }\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                if (!$util.isString(message.docString))\n                    return \"docString: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a NodeProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.NodeProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.NodeProto} NodeProto\n         */\n        NodeProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.NodeProto)\n                return object;\n            var message = new $root.onnx.NodeProto();\n            if (object.input) {\n                if (!Array.isArray(object.input))\n                    throw TypeError(\".onnx.NodeProto.input: array expected\");\n                message.input = [];\n                for (var i = 0; i < object.input.length; ++i)\n                    message.input[i] = String(object.input[i]);\n            }\n            if (object.output) {\n                if (!Array.isArray(object.output))\n                    throw TypeError(\".onnx.NodeProto.output: array expected\");\n                message.output = [];\n                for (var i = 0; i < object.output.length; ++i)\n                    message.output[i] = String(object.output[i]);\n            }\n            if (object.name != null)\n                message.name = String(object.name);\n            if (object.opType != null)\n                message.opType = String(object.opType);\n            if (object.domain != null)\n                message.domain = String(object.domain);\n            if (object.attribute) {\n                if (!Array.isArray(object.attribute))\n                    throw TypeError(\".onnx.NodeProto.attribute: array expected\");\n                message.attribute = [];\n                for (var i = 0; i < object.attribute.length; ++i) {\n                    if (typeof object.attribute[i] !== \"object\")\n                        throw TypeError(\".onnx.NodeProto.attribute: object expected\");\n                    message.attribute[i] = $root.onnx.AttributeProto.fromObject(object.attribute[i]);\n                }\n            }\n            if (object.docString != null)\n                message.docString = String(object.docString);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a NodeProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.NodeProto\n         * @static\n         * @param {onnx.NodeProto} message NodeProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        NodeProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.input = [];\n                object.output = [];\n                object.attribute = [];\n            }\n            if (options.defaults) {\n                object.name = \"\";\n                object.opType = \"\";\n                object.docString = \"\";\n                object.domain = \"\";\n            }\n            if (message.input && message.input.length) {\n                object.input = [];\n                for (var j = 0; j < message.input.length; ++j)\n                    object.input[j] = message.input[j];\n            }\n            if (message.output && message.output.length) {\n                object.output = [];\n                for (var j = 0; j < message.output.length; ++j)\n                    object.output[j] = message.output[j];\n            }\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                object.name = message.name;\n            if (message.opType != null && message.hasOwnProperty(\"opType\"))\n                object.opType = message.opType;\n            if (message.attribute && message.attribute.length) {\n                object.attribute = [];\n                for (var j = 0; j < message.attribute.length; ++j)\n                    object.attribute[j] = $root.onnx.AttributeProto.toObject(message.attribute[j], options);\n            }\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                object.docString = message.docString;\n            if (message.domain != null && message.hasOwnProperty(\"domain\"))\n                object.domain = message.domain;\n            return object;\n        };\n\n        /**\n         * Converts this NodeProto to JSON.\n         * @function toJSON\n         * @memberof onnx.NodeProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        NodeProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * Gets the default type url for NodeProto\n         * @function getTypeUrl\n         * @memberof onnx.NodeProto\n         * @static\n         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n         * @returns {string} The default type url\n         */\n        NodeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === undefined) {\n                typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/onnx.NodeProto\";\n        };\n\n        return NodeProto;\n    })();\n\n    onnx.TrainingInfoProto = (function() {\n\n        /**\n         * Properties of a TrainingInfoProto.\n         * @memberof onnx\n         * @interface ITrainingInfoProto\n         * @property {onnx.IGraphProto|null} [initialization] TrainingInfoProto initialization\n         * @property {onnx.IGraphProto|null} [algorithm] TrainingInfoProto algorithm\n         * @property {Array.<onnx.IStringStringEntryProto>|null} [initializationBinding] TrainingInfoProto initializationBinding\n         * @property {Array.<onnx.IStringStringEntryProto>|null} [updateBinding] TrainingInfoProto updateBinding\n         */\n\n        /**\n         * Constructs a new TrainingInfoProto.\n         * @memberof onnx\n         * @classdesc Represents a TrainingInfoProto.\n         * @implements ITrainingInfoProto\n         * @constructor\n         * @param {onnx.ITrainingInfoProto=} [properties] Properties to set\n         */\n        function TrainingInfoProto(properties) {\n            this.initializationBinding = [];\n            this.updateBinding = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * TrainingInfoProto initialization.\n         * @member {onnx.IGraphProto|null|undefined} initialization\n         * @memberof onnx.TrainingInfoProto\n         * @instance\n         */\n        TrainingInfoProto.prototype.initialization = null;\n\n        /**\n         * TrainingInfoProto algorithm.\n         * @member {onnx.IGraphProto|null|undefined} algorithm\n         * @memberof onnx.TrainingInfoProto\n         * @instance\n         */\n        TrainingInfoProto.prototype.algorithm = null;\n\n        /**\n         * TrainingInfoProto initializationBinding.\n         * @member {Array.<onnx.IStringStringEntryProto>} initializationBinding\n         * @memberof onnx.TrainingInfoProto\n         * @instance\n         */\n        TrainingInfoProto.prototype.initializationBinding = $util.emptyArray;\n\n        /**\n         * TrainingInfoProto updateBinding.\n         * @member {Array.<onnx.IStringStringEntryProto>} updateBinding\n         * @memberof onnx.TrainingInfoProto\n         * @instance\n         */\n        TrainingInfoProto.prototype.updateBinding = $util.emptyArray;\n\n        /**\n         * Creates a new TrainingInfoProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.TrainingInfoProto\n         * @static\n         * @param {onnx.ITrainingInfoProto=} [properties] Properties to set\n         * @returns {onnx.TrainingInfoProto} TrainingInfoProto instance\n         */\n        TrainingInfoProto.create = function create(properties) {\n            return new TrainingInfoProto(properties);\n        };\n\n        /**\n         * Encodes the specified TrainingInfoProto message. Does not implicitly {@link onnx.TrainingInfoProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.TrainingInfoProto\n         * @static\n         * @param {onnx.ITrainingInfoProto} message TrainingInfoProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TrainingInfoProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.initialization != null && Object.hasOwnProperty.call(message, \"initialization\"))\n                $root.onnx.GraphProto.encode(message.initialization, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.algorithm != null && Object.hasOwnProperty.call(message, \"algorithm\"))\n                $root.onnx.GraphProto.encode(message.algorithm, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.initializationBinding != null && message.initializationBinding.length)\n                for (var i = 0; i < message.initializationBinding.length; ++i)\n                    $root.onnx.StringStringEntryProto.encode(message.initializationBinding[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.updateBinding != null && message.updateBinding.length)\n                for (var i = 0; i < message.updateBinding.length; ++i)\n                    $root.onnx.StringStringEntryProto.encode(message.updateBinding[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified TrainingInfoProto message, length delimited. Does not implicitly {@link onnx.TrainingInfoProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.TrainingInfoProto\n         * @static\n         * @param {onnx.ITrainingInfoProto} message TrainingInfoProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TrainingInfoProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a TrainingInfoProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.TrainingInfoProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.TrainingInfoProto} TrainingInfoProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TrainingInfoProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TrainingInfoProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1: {\n                        message.initialization = $root.onnx.GraphProto.decode(reader, reader.uint32());\n                        break;\n                    }\n                case 2: {\n                        message.algorithm = $root.onnx.GraphProto.decode(reader, reader.uint32());\n                        break;\n                    }\n                case 3: {\n                        if (!(message.initializationBinding && message.initializationBinding.length))\n                            message.initializationBinding = [];\n                        message.initializationBinding.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));\n                        break;\n                    }\n                case 4: {\n                        if (!(message.updateBinding && message.updateBinding.length))\n                            message.updateBinding = [];\n                        message.updateBinding.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));\n                        break;\n                    }\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a TrainingInfoProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.TrainingInfoProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.TrainingInfoProto} TrainingInfoProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TrainingInfoProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a TrainingInfoProto message.\n         * @function verify\n         * @memberof onnx.TrainingInfoProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        TrainingInfoProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.initialization != null && message.hasOwnProperty(\"initialization\")) {\n                var error = $root.onnx.GraphProto.verify(message.initialization);\n                if (error)\n                    return \"initialization.\" + error;\n            }\n            if (message.algorithm != null && message.hasOwnProperty(\"algorithm\")) {\n                var error = $root.onnx.GraphProto.verify(message.algorithm);\n                if (error)\n                    return \"algorithm.\" + error;\n            }\n            if (message.initializationBinding != null && message.hasOwnProperty(\"initializationBinding\")) {\n                if (!Array.isArray(message.initializationBinding))\n                    return \"initializationBinding: array expected\";\n                for (var i = 0; i < message.initializationBinding.length; ++i) {\n                    var error = $root.onnx.StringStringEntryProto.verify(message.initializationBinding[i]);\n                    if (error)\n                        return \"initializationBinding.\" + error;\n                }\n            }\n            if (message.updateBinding != null && message.hasOwnProperty(\"updateBinding\")) {\n                if (!Array.isArray(message.updateBinding))\n                    return \"updateBinding: array expected\";\n                for (var i = 0; i < message.updateBinding.length; ++i) {\n                    var error = $root.onnx.StringStringEntryProto.verify(message.updateBinding[i]);\n                    if (error)\n                        return \"updateBinding.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a TrainingInfoProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.TrainingInfoProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.TrainingInfoProto} TrainingInfoProto\n         */\n        TrainingInfoProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.TrainingInfoProto)\n                return object;\n            var message = new $root.onnx.TrainingInfoProto();\n            if (object.initialization != null) {\n                if (typeof object.initialization !== \"object\")\n                    throw TypeError(\".onnx.TrainingInfoProto.initialization: object expected\");\n                message.initialization = $root.onnx.GraphProto.fromObject(object.initialization);\n            }\n            if (object.algorithm != null) {\n                if (typeof object.algorithm !== \"object\")\n                    throw TypeError(\".onnx.TrainingInfoProto.algorithm: object expected\");\n                message.algorithm = $root.onnx.GraphProto.fromObject(object.algorithm);\n            }\n            if (object.initializationBinding) {\n                if (!Array.isArray(object.initializationBinding))\n                    throw TypeError(\".onnx.TrainingInfoProto.initializationBinding: array expected\");\n                message.initializationBinding = [];\n                for (var i = 0; i < object.initializationBinding.length; ++i) {\n                    if (typeof object.initializationBinding[i] !== \"object\")\n                        throw TypeError(\".onnx.TrainingInfoProto.initializationBinding: object expected\");\n                    message.initializationBinding[i] = $root.onnx.StringStringEntryProto.fromObject(object.initializationBinding[i]);\n                }\n            }\n            if (object.updateBinding) {\n                if (!Array.isArray(object.updateBinding))\n                    throw TypeError(\".onnx.TrainingInfoProto.updateBinding: array expected\");\n                message.updateBinding = [];\n                for (var i = 0; i < object.updateBinding.length; ++i) {\n                    if (typeof object.updateBinding[i] !== \"object\")\n                        throw TypeError(\".onnx.TrainingInfoProto.updateBinding: object expected\");\n                    message.updateBinding[i] = $root.onnx.StringStringEntryProto.fromObject(object.updateBinding[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a TrainingInfoProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.TrainingInfoProto\n         * @static\n         * @param {onnx.TrainingInfoProto} message TrainingInfoProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        TrainingInfoProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.initializationBinding = [];\n                object.updateBinding = [];\n            }\n            if (options.defaults) {\n                object.initialization = null;\n                object.algorithm = null;\n            }\n            if (message.initialization != null && message.hasOwnProperty(\"initialization\"))\n                object.initialization = $root.onnx.GraphProto.toObject(message.initialization, options);\n            if (message.algorithm != null && message.hasOwnProperty(\"algorithm\"))\n                object.algorithm = $root.onnx.GraphProto.toObject(message.algorithm, options);\n            if (message.initializationBinding && message.initializationBinding.length) {\n                object.initializationBinding = [];\n                for (var j = 0; j < message.initializationBinding.length; ++j)\n                    object.initializationBinding[j] = $root.onnx.StringStringEntryProto.toObject(message.initializationBinding[j], options);\n            }\n            if (message.updateBinding && message.updateBinding.length) {\n                object.updateBinding = [];\n                for (var j = 0; j < message.updateBinding.length; ++j)\n                    object.updateBinding[j] = $root.onnx.StringStringEntryProto.toObject(message.updateBinding[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this TrainingInfoProto to JSON.\n         * @function toJSON\n         * @memberof onnx.TrainingInfoProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        TrainingInfoProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * Gets the default type url for TrainingInfoProto\n         * @function getTypeUrl\n         * @memberof onnx.TrainingInfoProto\n         * @static\n         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n         * @returns {string} The default type url\n         */\n        TrainingInfoProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === undefined) {\n                typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/onnx.TrainingInfoProto\";\n        };\n\n        return TrainingInfoProto;\n    })();\n\n    onnx.ModelProto = (function() {\n\n        /**\n         * Properties of a ModelProto.\n         * @memberof onnx\n         * @interface IModelProto\n         * @property {number|Long|null} [irVersion] ModelProto irVersion\n         * @property {Array.<onnx.IOperatorSetIdProto>|null} [opsetImport] ModelProto opsetImport\n         * @property {string|null} [producerName] ModelProto producerName\n         * @property {string|null} [producerVersion] ModelProto producerVersion\n         * @property {string|null} [domain] ModelProto domain\n         * @property {number|Long|null} [modelVersion] ModelProto modelVersion\n         * @property {string|null} [docString] ModelProto docString\n         * @property {onnx.IGraphProto|null} [graph] ModelProto graph\n         * @property {Array.<onnx.IStringStringEntryProto>|null} [metadataProps] ModelProto metadataProps\n         * @property {Array.<onnx.ITrainingInfoProto>|null} [trainingInfo] ModelProto trainingInfo\n         * @property {Array.<onnx.IFunctionProto>|null} [functions] ModelProto functions\n         */\n\n        /**\n         * Constructs a new ModelProto.\n         * @memberof onnx\n         * @classdesc Represents a ModelProto.\n         * @implements IModelProto\n         * @constructor\n         * @param {onnx.IModelProto=} [properties] Properties to set\n         */\n        function ModelProto(properties) {\n            this.opsetImport = [];\n            this.metadataProps = [];\n            this.trainingInfo = [];\n            this.functions = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ModelProto irVersion.\n         * @member {number|Long} irVersion\n         * @memberof onnx.ModelProto\n         * @instance\n         */\n        ModelProto.prototype.irVersion = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * ModelProto opsetImport.\n         * @member {Array.<onnx.IOperatorSetIdProto>} opsetImport\n         * @memberof onnx.ModelProto\n         * @instance\n         */\n        ModelProto.prototype.opsetImport = $util.emptyArray;\n\n        /**\n         * ModelProto producerName.\n         * @member {string} producerName\n         * @memberof onnx.ModelProto\n         * @instance\n         */\n        ModelProto.prototype.producerName = \"\";\n\n        /**\n         * ModelProto producerVersion.\n         * @member {string} producerVersion\n         * @memberof onnx.ModelProto\n         * @instance\n         */\n        ModelProto.prototype.producerVersion = \"\";\n\n        /**\n         * ModelProto domain.\n         * @member {string} domain\n         * @memberof onnx.ModelProto\n         * @instance\n         */\n        ModelProto.prototype.domain = \"\";\n\n        /**\n         * ModelProto modelVersion.\n         * @member {number|Long} modelVersion\n         * @memberof onnx.ModelProto\n         * @instance\n         */\n        ModelProto.prototype.modelVersion = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * ModelProto docString.\n         * @member {string} docString\n         * @memberof onnx.ModelProto\n         * @instance\n         */\n        ModelProto.prototype.docString = \"\";\n\n        /**\n         * ModelProto graph.\n         * @member {onnx.IGraphProto|null|undefined} graph\n         * @memberof onnx.ModelProto\n         * @instance\n         */\n        ModelProto.prototype.graph = null;\n\n        /**\n         * ModelProto metadataProps.\n         * @member {Array.<onnx.IStringStringEntryProto>} metadataProps\n         * @memberof onnx.ModelProto\n         * @instance\n         */\n        ModelProto.prototype.metadataProps = $util.emptyArray;\n\n        /**\n         * ModelProto trainingInfo.\n         * @member {Array.<onnx.ITrainingInfoProto>} trainingInfo\n         * @memberof onnx.ModelProto\n         * @instance\n         */\n        ModelProto.prototype.trainingInfo = $util.emptyArray;\n\n        /**\n         * ModelProto functions.\n         * @member {Array.<onnx.IFunctionProto>} functions\n         * @memberof onnx.ModelProto\n         * @instance\n         */\n        ModelProto.prototype.functions = $util.emptyArray;\n\n        /**\n         * Creates a new ModelProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.ModelProto\n         * @static\n         * @param {onnx.IModelProto=} [properties] Properties to set\n         * @returns {onnx.ModelProto} ModelProto instance\n         */\n        ModelProto.create = function create(properties) {\n            return new ModelProto(properties);\n        };\n\n        /**\n         * Encodes the specified ModelProto message. Does not implicitly {@link onnx.ModelProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.ModelProto\n         * @static\n         * @param {onnx.IModelProto} message ModelProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ModelProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.irVersion != null && Object.hasOwnProperty.call(message, \"irVersion\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.irVersion);\n            if (message.producerName != null && Object.hasOwnProperty.call(message, \"producerName\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.producerName);\n            if (message.producerVersion != null && Object.hasOwnProperty.call(message, \"producerVersion\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.producerVersion);\n            if (message.domain != null && Object.hasOwnProperty.call(message, \"domain\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).string(message.domain);\n            if (message.modelVersion != null && Object.hasOwnProperty.call(message, \"modelVersion\"))\n                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.modelVersion);\n            if (message.docString != null && Object.hasOwnProperty.call(message, \"docString\"))\n                writer.uint32(/* id 6, wireType 2 =*/50).string(message.docString);\n            if (message.graph != null && Object.hasOwnProperty.call(message, \"graph\"))\n                $root.onnx.GraphProto.encode(message.graph, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n            if (message.opsetImport != null && message.opsetImport.length)\n                for (var i = 0; i < message.opsetImport.length; ++i)\n                    $root.onnx.OperatorSetIdProto.encode(message.opsetImport[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n            if (message.metadataProps != null && message.metadataProps.length)\n                for (var i = 0; i < message.metadataProps.length; ++i)\n                    $root.onnx.StringStringEntryProto.encode(message.metadataProps[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();\n            if (message.trainingInfo != null && message.trainingInfo.length)\n                for (var i = 0; i < message.trainingInfo.length; ++i)\n                    $root.onnx.TrainingInfoProto.encode(message.trainingInfo[i], writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();\n            if (message.functions != null && message.functions.length)\n                for (var i = 0; i < message.functions.length; ++i)\n                    $root.onnx.FunctionProto.encode(message.functions[i], writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified ModelProto message, length delimited. Does not implicitly {@link onnx.ModelProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.ModelProto\n         * @static\n         * @param {onnx.IModelProto} message ModelProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ModelProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a ModelProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.ModelProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.ModelProto} ModelProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ModelProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.ModelProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1: {\n                        message.irVersion = reader.int64();\n                        break;\n                    }\n                case 8: {\n                        if (!(message.opsetImport && message.opsetImport.length))\n                            message.opsetImport = [];\n                        message.opsetImport.push($root.onnx.OperatorSetIdProto.decode(reader, reader.uint32()));\n                        break;\n                    }\n                case 2: {\n                        message.producerName = reader.string();\n                        break;\n                    }\n                case 3: {\n                        message.producerVersion = reader.string();\n                        break;\n                    }\n                case 4: {\n                        message.domain = reader.string();\n                        break;\n                    }\n                case 5: {\n                        message.modelVersion = reader.int64();\n                        break;\n                    }\n                case 6: {\n                        message.docString = reader.string();\n                        break;\n                    }\n                case 7: {\n                        message.graph = $root.onnx.GraphProto.decode(reader, reader.uint32());\n                        break;\n                    }\n                case 14: {\n                        if (!(message.metadataProps && message.metadataProps.length))\n                            message.metadataProps = [];\n                        message.metadataProps.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));\n                        break;\n                    }\n                case 20: {\n                        if (!(message.trainingInfo && message.trainingInfo.length))\n                            message.trainingInfo = [];\n                        message.trainingInfo.push($root.onnx.TrainingInfoProto.decode(reader, reader.uint32()));\n                        break;\n                    }\n                case 25: {\n                        if (!(message.functions && message.functions.length))\n                            message.functions = [];\n                        message.functions.push($root.onnx.FunctionProto.decode(reader, reader.uint32()));\n                        break;\n                    }\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a ModelProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.ModelProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.ModelProto} ModelProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ModelProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a ModelProto message.\n         * @function verify\n         * @memberof onnx.ModelProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        ModelProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.irVersion != null && message.hasOwnProperty(\"irVersion\"))\n                if (!$util.isInteger(message.irVersion) && !(message.irVersion && $util.isInteger(message.irVersion.low) && $util.isInteger(message.irVersion.high)))\n                    return \"irVersion: integer|Long expected\";\n            if (message.opsetImport != null && message.hasOwnProperty(\"opsetImport\")) {\n                if (!Array.isArray(message.opsetImport))\n                    return \"opsetImport: array expected\";\n                for (var i = 0; i < message.opsetImport.length; ++i) {\n                    var error = $root.onnx.OperatorSetIdProto.verify(message.opsetImport[i]);\n                    if (error)\n                        return \"opsetImport.\" + error;\n                }\n            }\n            if (message.producerName != null && message.hasOwnProperty(\"producerName\"))\n                if (!$util.isString(message.producerName))\n                    return \"producerName: string expected\";\n            if (message.producerVersion != null && message.hasOwnProperty(\"producerVersion\"))\n                if (!$util.isString(message.producerVersion))\n                    return \"producerVersion: string expected\";\n            if (message.domain != null && message.hasOwnProperty(\"domain\"))\n                if (!$util.isString(message.domain))\n                    return \"domain: string expected\";\n            if (message.modelVersion != null && message.hasOwnProperty(\"modelVersion\"))\n                if (!$util.isInteger(message.modelVersion) && !(message.modelVersion && $util.isInteger(message.modelVersion.low) && $util.isInteger(message.modelVersion.high)))\n                    return \"modelVersion: integer|Long expected\";\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                if (!$util.isString(message.docString))\n                    return \"docString: string expected\";\n            if (message.graph != null && message.hasOwnProperty(\"graph\")) {\n                var error = $root.onnx.GraphProto.verify(message.graph);\n                if (error)\n                    return \"graph.\" + error;\n            }\n            if (message.metadataProps != null && message.hasOwnProperty(\"metadataProps\")) {\n                if (!Array.isArray(message.metadataProps))\n                    return \"metadataProps: array expected\";\n                for (var i = 0; i < message.metadataProps.length; ++i) {\n                    var error = $root.onnx.StringStringEntryProto.verify(message.metadataProps[i]);\n                    if (error)\n                        return \"metadataProps.\" + error;\n                }\n            }\n            if (message.trainingInfo != null && message.hasOwnProperty(\"trainingInfo\")) {\n                if (!Array.isArray(message.trainingInfo))\n                    return \"trainingInfo: array expected\";\n                for (var i = 0; i < message.trainingInfo.length; ++i) {\n                    var error = $root.onnx.TrainingInfoProto.verify(message.trainingInfo[i]);\n                    if (error)\n                        return \"trainingInfo.\" + error;\n                }\n            }\n            if (message.functions != null && message.hasOwnProperty(\"functions\")) {\n                if (!Array.isArray(message.functions))\n                    return \"functions: array expected\";\n                for (var i = 0; i < message.functions.length; ++i) {\n                    var error = $root.onnx.FunctionProto.verify(message.functions[i]);\n                    if (error)\n                        return \"functions.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a ModelProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.ModelProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.ModelProto} ModelProto\n         */\n        ModelProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.ModelProto)\n                return object;\n            var message = new $root.onnx.ModelProto();\n            if (object.irVersion != null)\n                if ($util.Long)\n                    (message.irVersion = $util.Long.fromValue(object.irVersion)).unsigned = false;\n                else if (typeof object.irVersion === \"string\")\n                    message.irVersion = parseInt(object.irVersion, 10);\n                else if (typeof object.irVersion === \"number\")\n                    message.irVersion = object.irVersion;\n                else if (typeof object.irVersion === \"object\")\n                    message.irVersion = new $util.LongBits(object.irVersion.low >>> 0, object.irVersion.high >>> 0).toNumber();\n            if (object.opsetImport) {\n                if (!Array.isArray(object.opsetImport))\n                    throw TypeError(\".onnx.ModelProto.opsetImport: array expected\");\n                message.opsetImport = [];\n                for (var i = 0; i < object.opsetImport.length; ++i) {\n                    if (typeof object.opsetImport[i] !== \"object\")\n                        throw TypeError(\".onnx.ModelProto.opsetImport: object expected\");\n                    message.opsetImport[i] = $root.onnx.OperatorSetIdProto.fromObject(object.opsetImport[i]);\n                }\n            }\n            if (object.producerName != null)\n                message.producerName = String(object.producerName);\n            if (object.producerVersion != null)\n                message.producerVersion = String(object.producerVersion);\n            if (object.domain != null)\n                message.domain = String(object.domain);\n            if (object.modelVersion != null)\n                if ($util.Long)\n                    (message.modelVersion = $util.Long.fromValue(object.modelVersion)).unsigned = false;\n                else if (typeof object.modelVersion === \"string\")\n                    message.modelVersion = parseInt(object.modelVersion, 10);\n                else if (typeof object.modelVersion === \"number\")\n                    message.modelVersion = object.modelVersion;\n                else if (typeof object.modelVersion === \"object\")\n                    message.modelVersion = new $util.LongBits(object.modelVersion.low >>> 0, object.modelVersion.high >>> 0).toNumber();\n            if (object.docString != null)\n                message.docString = String(object.docString);\n            if (object.graph != null) {\n                if (typeof object.graph !== \"object\")\n                    throw TypeError(\".onnx.ModelProto.graph: object expected\");\n                message.graph = $root.onnx.GraphProto.fromObject(object.graph);\n            }\n            if (object.metadataProps) {\n                if (!Array.isArray(object.metadataProps))\n                    throw TypeError(\".onnx.ModelProto.metadataProps: array expected\");\n                message.metadataProps = [];\n                for (var i = 0; i < object.metadataProps.length; ++i) {\n                    if (typeof object.metadataProps[i] !== \"object\")\n                        throw TypeError(\".onnx.ModelProto.metadataProps: object expected\");\n                    message.metadataProps[i] = $root.onnx.StringStringEntryProto.fromObject(object.metadataProps[i]);\n                }\n            }\n            if (object.trainingInfo) {\n                if (!Array.isArray(object.trainingInfo))\n                    throw TypeError(\".onnx.ModelProto.trainingInfo: array expected\");\n                message.trainingInfo = [];\n                for (var i = 0; i < object.trainingInfo.length; ++i) {\n                    if (typeof object.trainingInfo[i] !== \"object\")\n                        throw TypeError(\".onnx.ModelProto.trainingInfo: object expected\");\n                    message.trainingInfo[i] = $root.onnx.TrainingInfoProto.fromObject(object.trainingInfo[i]);\n                }\n            }\n            if (object.functions) {\n                if (!Array.isArray(object.functions))\n                    throw TypeError(\".onnx.ModelProto.functions: array expected\");\n                message.functions = [];\n                for (var i = 0; i < object.functions.length; ++i) {\n                    if (typeof object.functions[i] !== \"object\")\n                        throw TypeError(\".onnx.ModelProto.functions: object expected\");\n                    message.functions[i] = $root.onnx.FunctionProto.fromObject(object.functions[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a ModelProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.ModelProto\n         * @static\n         * @param {onnx.ModelProto} message ModelProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        ModelProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.opsetImport = [];\n                object.metadataProps = [];\n                object.trainingInfo = [];\n                object.functions = [];\n            }\n            if (options.defaults) {\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.irVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.irVersion = options.longs === String ? \"0\" : 0;\n                object.producerName = \"\";\n                object.producerVersion = \"\";\n                object.domain = \"\";\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.modelVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.modelVersion = options.longs === String ? \"0\" : 0;\n                object.docString = \"\";\n                object.graph = null;\n            }\n            if (message.irVersion != null && message.hasOwnProperty(\"irVersion\"))\n                if (typeof message.irVersion === \"number\")\n                    object.irVersion = options.longs === String ? String(message.irVersion) : message.irVersion;\n                else\n                    object.irVersion = options.longs === String ? $util.Long.prototype.toString.call(message.irVersion) : options.longs === Number ? new $util.LongBits(message.irVersion.low >>> 0, message.irVersion.high >>> 0).toNumber() : message.irVersion;\n            if (message.producerName != null && message.hasOwnProperty(\"producerName\"))\n                object.producerName = message.producerName;\n            if (message.producerVersion != null && message.hasOwnProperty(\"producerVersion\"))\n                object.producerVersion = message.producerVersion;\n            if (message.domain != null && message.hasOwnProperty(\"domain\"))\n                object.domain = message.domain;\n            if (message.modelVersion != null && message.hasOwnProperty(\"modelVersion\"))\n                if (typeof message.modelVersion === \"number\")\n                    object.modelVersion = options.longs === String ? String(message.modelVersion) : message.modelVersion;\n                else\n                    object.modelVersion = options.longs === String ? $util.Long.prototype.toString.call(message.modelVersion) : options.longs === Number ? new $util.LongBits(message.modelVersion.low >>> 0, message.modelVersion.high >>> 0).toNumber() : message.modelVersion;\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                object.docString = message.docString;\n            if (message.graph != null && message.hasOwnProperty(\"graph\"))\n                object.graph = $root.onnx.GraphProto.toObject(message.graph, options);\n            if (message.opsetImport && message.opsetImport.length) {\n                object.opsetImport = [];\n                for (var j = 0; j < message.opsetImport.length; ++j)\n                    object.opsetImport[j] = $root.onnx.OperatorSetIdProto.toObject(message.opsetImport[j], options);\n            }\n            if (message.metadataProps && message.metadataProps.length) {\n                object.metadataProps = [];\n                for (var j = 0; j < message.metadataProps.length; ++j)\n                    object.metadataProps[j] = $root.onnx.StringStringEntryProto.toObject(message.metadataProps[j], options);\n            }\n            if (message.trainingInfo && message.trainingInfo.length) {\n                object.trainingInfo = [];\n                for (var j = 0; j < message.trainingInfo.length; ++j)\n                    object.trainingInfo[j] = $root.onnx.TrainingInfoProto.toObject(message.trainingInfo[j], options);\n            }\n            if (message.functions && message.functions.length) {\n                object.functions = [];\n                for (var j = 0; j < message.functions.length; ++j)\n                    object.functions[j] = $root.onnx.FunctionProto.toObject(message.functions[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this ModelProto to JSON.\n         * @function toJSON\n         * @memberof onnx.ModelProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        ModelProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * Gets the default type url for ModelProto\n         * @function getTypeUrl\n         * @memberof onnx.ModelProto\n         * @static\n         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n         * @returns {string} The default type url\n         */\n        ModelProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === undefined) {\n                typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/onnx.ModelProto\";\n        };\n\n        return ModelProto;\n    })();\n\n    onnx.StringStringEntryProto = (function() {\n\n        /**\n         * Properties of a StringStringEntryProto.\n         * @memberof onnx\n         * @interface IStringStringEntryProto\n         * @property {string|null} [key] StringStringEntryProto key\n         * @property {string|null} [value] StringStringEntryProto value\n         */\n\n        /**\n         * Constructs a new StringStringEntryProto.\n         * @memberof onnx\n         * @classdesc Represents a StringStringEntryProto.\n         * @implements IStringStringEntryProto\n         * @constructor\n         * @param {onnx.IStringStringEntryProto=} [properties] Properties to set\n         */\n        function StringStringEntryProto(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * StringStringEntryProto key.\n         * @member {string} key\n         * @memberof onnx.StringStringEntryProto\n         * @instance\n         */\n        StringStringEntryProto.prototype.key = \"\";\n\n        /**\n         * StringStringEntryProto value.\n         * @member {string} value\n         * @memberof onnx.StringStringEntryProto\n         * @instance\n         */\n        StringStringEntryProto.prototype.value = \"\";\n\n        /**\n         * Creates a new StringStringEntryProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.StringStringEntryProto\n         * @static\n         * @param {onnx.IStringStringEntryProto=} [properties] Properties to set\n         * @returns {onnx.StringStringEntryProto} StringStringEntryProto instance\n         */\n        StringStringEntryProto.create = function create(properties) {\n            return new StringStringEntryProto(properties);\n        };\n\n        /**\n         * Encodes the specified StringStringEntryProto message. Does not implicitly {@link onnx.StringStringEntryProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.StringStringEntryProto\n         * @static\n         * @param {onnx.IStringStringEntryProto} message StringStringEntryProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        StringStringEntryProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && Object.hasOwnProperty.call(message, \"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);\n            if (message.value != null && Object.hasOwnProperty.call(message, \"value\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified StringStringEntryProto message, length delimited. Does not implicitly {@link onnx.StringStringEntryProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.StringStringEntryProto\n         * @static\n         * @param {onnx.IStringStringEntryProto} message StringStringEntryProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        StringStringEntryProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a StringStringEntryProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.StringStringEntryProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.StringStringEntryProto} StringStringEntryProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        StringStringEntryProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.StringStringEntryProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1: {\n                        message.key = reader.string();\n                        break;\n                    }\n                case 2: {\n                        message.value = reader.string();\n                        break;\n                    }\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a StringStringEntryProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.StringStringEntryProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.StringStringEntryProto} StringStringEntryProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        StringStringEntryProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a StringStringEntryProto message.\n         * @function verify\n         * @memberof onnx.StringStringEntryProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        StringStringEntryProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!$util.isString(message.key))\n                    return \"key: string expected\";\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                if (!$util.isString(message.value))\n                    return \"value: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a StringStringEntryProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.StringStringEntryProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.StringStringEntryProto} StringStringEntryProto\n         */\n        StringStringEntryProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.StringStringEntryProto)\n                return object;\n            var message = new $root.onnx.StringStringEntryProto();\n            if (object.key != null)\n                message.key = String(object.key);\n            if (object.value != null)\n                message.value = String(object.value);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a StringStringEntryProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.StringStringEntryProto\n         * @static\n         * @param {onnx.StringStringEntryProto} message StringStringEntryProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        StringStringEntryProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.key = \"\";\n                object.value = \"\";\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = message.key;\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                object.value = message.value;\n            return object;\n        };\n\n        /**\n         * Converts this StringStringEntryProto to JSON.\n         * @function toJSON\n         * @memberof onnx.StringStringEntryProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        StringStringEntryProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * Gets the default type url for StringStringEntryProto\n         * @function getTypeUrl\n         * @memberof onnx.StringStringEntryProto\n         * @static\n         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n         * @returns {string} The default type url\n         */\n        StringStringEntryProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === undefined) {\n                typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/onnx.StringStringEntryProto\";\n        };\n\n        return StringStringEntryProto;\n    })();\n\n    onnx.TensorAnnotation = (function() {\n\n        /**\n         * Properties of a TensorAnnotation.\n         * @memberof onnx\n         * @interface ITensorAnnotation\n         * @property {string|null} [tensorName] TensorAnnotation tensorName\n         * @property {Array.<onnx.IStringStringEntryProto>|null} [quantParameterTensorNames] TensorAnnotation quantParameterTensorNames\n         */\n\n        /**\n         * Constructs a new TensorAnnotation.\n         * @memberof onnx\n         * @classdesc Represents a TensorAnnotation.\n         * @implements ITensorAnnotation\n         * @constructor\n         * @param {onnx.ITensorAnnotation=} [properties] Properties to set\n         */\n        function TensorAnnotation(properties) {\n            this.quantParameterTensorNames = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * TensorAnnotation tensorName.\n         * @member {string} tensorName\n         * @memberof onnx.TensorAnnotation\n         * @instance\n         */\n        TensorAnnotation.prototype.tensorName = \"\";\n\n        /**\n         * TensorAnnotation quantParameterTensorNames.\n         * @member {Array.<onnx.IStringStringEntryProto>} quantParameterTensorNames\n         * @memberof onnx.TensorAnnotation\n         * @instance\n         */\n        TensorAnnotation.prototype.quantParameterTensorNames = $util.emptyArray;\n\n        /**\n         * Creates a new TensorAnnotation instance using the specified properties.\n         * @function create\n         * @memberof onnx.TensorAnnotation\n         * @static\n         * @param {onnx.ITensorAnnotation=} [properties] Properties to set\n         * @returns {onnx.TensorAnnotation} TensorAnnotation instance\n         */\n        TensorAnnotation.create = function create(properties) {\n            return new TensorAnnotation(properties);\n        };\n\n        /**\n         * Encodes the specified TensorAnnotation message. Does not implicitly {@link onnx.TensorAnnotation.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.TensorAnnotation\n         * @static\n         * @param {onnx.ITensorAnnotation} message TensorAnnotation message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TensorAnnotation.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.tensorName != null && Object.hasOwnProperty.call(message, \"tensorName\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tensorName);\n            if (message.quantParameterTensorNames != null && message.quantParameterTensorNames.length)\n                for (var i = 0; i < message.quantParameterTensorNames.length; ++i)\n                    $root.onnx.StringStringEntryProto.encode(message.quantParameterTensorNames[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified TensorAnnotation message, length delimited. Does not implicitly {@link onnx.TensorAnnotation.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.TensorAnnotation\n         * @static\n         * @param {onnx.ITensorAnnotation} message TensorAnnotation message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TensorAnnotation.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a TensorAnnotation message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.TensorAnnotation\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.TensorAnnotation} TensorAnnotation\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TensorAnnotation.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TensorAnnotation();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1: {\n                        message.tensorName = reader.string();\n                        break;\n                    }\n                case 2: {\n                        if (!(message.quantParameterTensorNames && message.quantParameterTensorNames.length))\n                            message.quantParameterTensorNames = [];\n                        message.quantParameterTensorNames.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));\n                        break;\n                    }\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a TensorAnnotation message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.TensorAnnotation\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.TensorAnnotation} TensorAnnotation\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TensorAnnotation.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a TensorAnnotation message.\n         * @function verify\n         * @memberof onnx.TensorAnnotation\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        TensorAnnotation.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.tensorName != null && message.hasOwnProperty(\"tensorName\"))\n                if (!$util.isString(message.tensorName))\n                    return \"tensorName: string expected\";\n            if (message.quantParameterTensorNames != null && message.hasOwnProperty(\"quantParameterTensorNames\")) {\n                if (!Array.isArray(message.quantParameterTensorNames))\n                    return \"quantParameterTensorNames: array expected\";\n                for (var i = 0; i < message.quantParameterTensorNames.length; ++i) {\n                    var error = $root.onnx.StringStringEntryProto.verify(message.quantParameterTensorNames[i]);\n                    if (error)\n                        return \"quantParameterTensorNames.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a TensorAnnotation message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.TensorAnnotation\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.TensorAnnotation} TensorAnnotation\n         */\n        TensorAnnotation.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.TensorAnnotation)\n                return object;\n            var message = new $root.onnx.TensorAnnotation();\n            if (object.tensorName != null)\n                message.tensorName = String(object.tensorName);\n            if (object.quantParameterTensorNames) {\n                if (!Array.isArray(object.quantParameterTensorNames))\n                    throw TypeError(\".onnx.TensorAnnotation.quantParameterTensorNames: array expected\");\n                message.quantParameterTensorNames = [];\n                for (var i = 0; i < object.quantParameterTensorNames.length; ++i) {\n                    if (typeof object.quantParameterTensorNames[i] !== \"object\")\n                        throw TypeError(\".onnx.TensorAnnotation.quantParameterTensorNames: object expected\");\n                    message.quantParameterTensorNames[i] = $root.onnx.StringStringEntryProto.fromObject(object.quantParameterTensorNames[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a TensorAnnotation message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.TensorAnnotation\n         * @static\n         * @param {onnx.TensorAnnotation} message TensorAnnotation\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        TensorAnnotation.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.quantParameterTensorNames = [];\n            if (options.defaults)\n                object.tensorName = \"\";\n            if (message.tensorName != null && message.hasOwnProperty(\"tensorName\"))\n                object.tensorName = message.tensorName;\n            if (message.quantParameterTensorNames && message.quantParameterTensorNames.length) {\n                object.quantParameterTensorNames = [];\n                for (var j = 0; j < message.quantParameterTensorNames.length; ++j)\n                    object.quantParameterTensorNames[j] = $root.onnx.StringStringEntryProto.toObject(message.quantParameterTensorNames[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this TensorAnnotation to JSON.\n         * @function toJSON\n         * @memberof onnx.TensorAnnotation\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        TensorAnnotation.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * Gets the default type url for TensorAnnotation\n         * @function getTypeUrl\n         * @memberof onnx.TensorAnnotation\n         * @static\n         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n         * @returns {string} The default type url\n         */\n        TensorAnnotation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === undefined) {\n                typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/onnx.TensorAnnotation\";\n        };\n\n        return TensorAnnotation;\n    })();\n\n    onnx.GraphProto = (function() {\n\n        /**\n         * Properties of a GraphProto.\n         * @memberof onnx\n         * @interface IGraphProto\n         * @property {Array.<onnx.INodeProto>|null} [node] GraphProto node\n         * @property {string|null} [name] GraphProto name\n         * @property {Array.<onnx.ITensorProto>|null} [initializer] GraphProto initializer\n         * @property {Array.<onnx.ISparseTensorProto>|null} [sparseInitializer] GraphProto sparseInitializer\n         * @property {string|null} [docString] GraphProto docString\n         * @property {Array.<onnx.IValueInfoProto>|null} [input] GraphProto input\n         * @property {Array.<onnx.IValueInfoProto>|null} [output] GraphProto output\n         * @property {Array.<onnx.IValueInfoProto>|null} [valueInfo] GraphProto valueInfo\n         * @property {Array.<onnx.ITensorAnnotation>|null} [quantizationAnnotation] GraphProto quantizationAnnotation\n         */\n\n        /**\n         * Constructs a new GraphProto.\n         * @memberof onnx\n         * @classdesc Represents a GraphProto.\n         * @implements IGraphProto\n         * @constructor\n         * @param {onnx.IGraphProto=} [properties] Properties to set\n         */\n        function GraphProto(properties) {\n            this.node = [];\n            this.initializer = [];\n            this.sparseInitializer = [];\n            this.input = [];\n            this.output = [];\n            this.valueInfo = [];\n            this.quantizationAnnotation = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * GraphProto node.\n         * @member {Array.<onnx.INodeProto>} node\n         * @memberof onnx.GraphProto\n         * @instance\n         */\n        GraphProto.prototype.node = $util.emptyArray;\n\n        /**\n         * GraphProto name.\n         * @member {string} name\n         * @memberof onnx.GraphProto\n         * @instance\n         */\n        GraphProto.prototype.name = \"\";\n\n        /**\n         * GraphProto initializer.\n         * @member {Array.<onnx.ITensorProto>} initializer\n         * @memberof onnx.GraphProto\n         * @instance\n         */\n        GraphProto.prototype.initializer = $util.emptyArray;\n\n        /**\n         * GraphProto sparseInitializer.\n         * @member {Array.<onnx.ISparseTensorProto>} sparseInitializer\n         * @memberof onnx.GraphProto\n         * @instance\n         */\n        GraphProto.prototype.sparseInitializer = $util.emptyArray;\n\n        /**\n         * GraphProto docString.\n         * @member {string} docString\n         * @memberof onnx.GraphProto\n         * @instance\n         */\n        GraphProto.prototype.docString = \"\";\n\n        /**\n         * GraphProto input.\n         * @member {Array.<onnx.IValueInfoProto>} input\n         * @memberof onnx.GraphProto\n         * @instance\n         */\n        GraphProto.prototype.input = $util.emptyArray;\n\n        /**\n         * GraphProto output.\n         * @member {Array.<onnx.IValueInfoProto>} output\n         * @memberof onnx.GraphProto\n         * @instance\n         */\n        GraphProto.prototype.output = $util.emptyArray;\n\n        /**\n         * GraphProto valueInfo.\n         * @member {Array.<onnx.IValueInfoProto>} valueInfo\n         * @memberof onnx.GraphProto\n         * @instance\n         */\n        GraphProto.prototype.valueInfo = $util.emptyArray;\n\n        /**\n         * GraphProto quantizationAnnotation.\n         * @member {Array.<onnx.ITensorAnnotation>} quantizationAnnotation\n         * @memberof onnx.GraphProto\n         * @instance\n         */\n        GraphProto.prototype.quantizationAnnotation = $util.emptyArray;\n\n        /**\n         * Creates a new GraphProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.GraphProto\n         * @static\n         * @param {onnx.IGraphProto=} [properties] Properties to set\n         * @returns {onnx.GraphProto} GraphProto instance\n         */\n        GraphProto.create = function create(properties) {\n            return new GraphProto(properties);\n        };\n\n        /**\n         * Encodes the specified GraphProto message. Does not implicitly {@link onnx.GraphProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.GraphProto\n         * @static\n         * @param {onnx.IGraphProto} message GraphProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        GraphProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.node != null && message.node.length)\n                for (var i = 0; i < message.node.length; ++i)\n                    $root.onnx.NodeProto.encode(message.node[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);\n            if (message.initializer != null && message.initializer.length)\n                for (var i = 0; i < message.initializer.length; ++i)\n                    $root.onnx.TensorProto.encode(message.initializer[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n            if (message.docString != null && Object.hasOwnProperty.call(message, \"docString\"))\n                writer.uint32(/* id 10, wireType 2 =*/82).string(message.docString);\n            if (message.input != null && message.input.length)\n                for (var i = 0; i < message.input.length; ++i)\n                    $root.onnx.ValueInfoProto.encode(message.input[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();\n            if (message.output != null && message.output.length)\n                for (var i = 0; i < message.output.length; ++i)\n                    $root.onnx.ValueInfoProto.encode(message.output[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();\n            if (message.valueInfo != null && message.valueInfo.length)\n                for (var i = 0; i < message.valueInfo.length; ++i)\n                    $root.onnx.ValueInfoProto.encode(message.valueInfo[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();\n            if (message.quantizationAnnotation != null && message.quantizationAnnotation.length)\n                for (var i = 0; i < message.quantizationAnnotation.length; ++i)\n                    $root.onnx.TensorAnnotation.encode(message.quantizationAnnotation[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();\n            if (message.sparseInitializer != null && message.sparseInitializer.length)\n                for (var i = 0; i < message.sparseInitializer.length; ++i)\n                    $root.onnx.SparseTensorProto.encode(message.sparseInitializer[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified GraphProto message, length delimited. Does not implicitly {@link onnx.GraphProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.GraphProto\n         * @static\n         * @param {onnx.IGraphProto} message GraphProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        GraphProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a GraphProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.GraphProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.GraphProto} GraphProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        GraphProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.GraphProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1: {\n                        if (!(message.node && message.node.length))\n                            message.node = [];\n                        message.node.push($root.onnx.NodeProto.decode(reader, reader.uint32()));\n                        break;\n                    }\n                case 2: {\n                        message.name = reader.string();\n                        break;\n                    }\n                case 5: {\n                        if (!(message.initializer && message.initializer.length))\n                            message.initializer = [];\n                        message.initializer.push($root.onnx.TensorProto.decode(reader, reader.uint32()));\n                        break;\n                    }\n                case 15: {\n                        if (!(message.sparseInitializer && message.sparseInitializer.length))\n                            message.sparseInitializer = [];\n                        message.sparseInitializer.push($root.onnx.SparseTensorProto.decode(reader, reader.uint32()));\n                        break;\n                    }\n                case 10: {\n                        message.docString = reader.string();\n                        break;\n                    }\n                case 11: {\n                        if (!(message.input && message.input.length))\n                            message.input = [];\n                        message.input.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));\n                        break;\n                    }\n                case 12: {\n                        if (!(message.output && message.output.length))\n                            message.output = [];\n                        message.output.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));\n                        break;\n                    }\n                case 13: {\n                        if (!(message.valueInfo && message.valueInfo.length))\n                            message.valueInfo = [];\n                        message.valueInfo.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));\n                        break;\n                    }\n                case 14: {\n                        if (!(message.quantizationAnnotation && message.quantizationAnnotation.length))\n                            message.quantizationAnnotation = [];\n                        message.quantizationAnnotation.push($root.onnx.TensorAnnotation.decode(reader, reader.uint32()));\n                        break;\n                    }\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a GraphProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.GraphProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.GraphProto} GraphProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        GraphProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a GraphProto message.\n         * @function verify\n         * @memberof onnx.GraphProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        GraphProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.node != null && message.hasOwnProperty(\"node\")) {\n                if (!Array.isArray(message.node))\n                    return \"node: array expected\";\n                for (var i = 0; i < message.node.length; ++i) {\n                    var error = $root.onnx.NodeProto.verify(message.node[i]);\n                    if (error)\n                        return \"node.\" + error;\n                }\n            }\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                if (!$util.isString(message.name))\n                    return \"name: string expected\";\n            if (message.initializer != null && message.hasOwnProperty(\"initializer\")) {\n                if (!Array.isArray(message.initializer))\n                    return \"initializer: array expected\";\n                for (var i = 0; i < message.initializer.length; ++i) {\n                    var error = $root.onnx.TensorProto.verify(message.initializer[i]);\n                    if (error)\n                        return \"initializer.\" + error;\n                }\n            }\n            if (message.sparseInitializer != null && message.hasOwnProperty(\"sparseInitializer\")) {\n                if (!Array.isArray(message.sparseInitializer))\n                    return \"sparseInitializer: array expected\";\n                for (var i = 0; i < message.sparseInitializer.length; ++i) {\n                    var error = $root.onnx.SparseTensorProto.verify(message.sparseInitializer[i]);\n                    if (error)\n                        return \"sparseInitializer.\" + error;\n                }\n            }\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                if (!$util.isString(message.docString))\n                    return \"docString: string expected\";\n            if (message.input != null && message.hasOwnProperty(\"input\")) {\n                if (!Array.isArray(message.input))\n                    return \"input: array expected\";\n                for (var i = 0; i < message.input.length; ++i) {\n                    var error = $root.onnx.ValueInfoProto.verify(message.input[i]);\n                    if (error)\n                        return \"input.\" + error;\n                }\n            }\n            if (message.output != null && message.hasOwnProperty(\"output\")) {\n                if (!Array.isArray(message.output))\n                    return \"output: array expected\";\n                for (var i = 0; i < message.output.length; ++i) {\n                    var error = $root.onnx.ValueInfoProto.verify(message.output[i]);\n                    if (error)\n                        return \"output.\" + error;\n                }\n            }\n            if (message.valueInfo != null && message.hasOwnProperty(\"valueInfo\")) {\n                if (!Array.isArray(message.valueInfo))\n                    return \"valueInfo: array expected\";\n                for (var i = 0; i < message.valueInfo.length; ++i) {\n                    var error = $root.onnx.ValueInfoProto.verify(message.valueInfo[i]);\n                    if (error)\n                        return \"valueInfo.\" + error;\n                }\n            }\n            if (message.quantizationAnnotation != null && message.hasOwnProperty(\"quantizationAnnotation\")) {\n                if (!Array.isArray(message.quantizationAnnotation))\n                    return \"quantizationAnnotation: array expected\";\n                for (var i = 0; i < message.quantizationAnnotation.length; ++i) {\n                    var error = $root.onnx.TensorAnnotation.verify(message.quantizationAnnotation[i]);\n                    if (error)\n                        return \"quantizationAnnotation.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a GraphProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.GraphProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.GraphProto} GraphProto\n         */\n        GraphProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.GraphProto)\n                return object;\n            var message = new $root.onnx.GraphProto();\n            if (object.node) {\n                if (!Array.isArray(object.node))\n                    throw TypeError(\".onnx.GraphProto.node: array expected\");\n                message.node = [];\n                for (var i = 0; i < object.node.length; ++i) {\n                    if (typeof object.node[i] !== \"object\")\n                        throw TypeError(\".onnx.GraphProto.node: object expected\");\n                    message.node[i] = $root.onnx.NodeProto.fromObject(object.node[i]);\n                }\n            }\n            if (object.name != null)\n                message.name = String(object.name);\n            if (object.initializer) {\n                if (!Array.isArray(object.initializer))\n                    throw TypeError(\".onnx.GraphProto.initializer: array expected\");\n                message.initializer = [];\n                for (var i = 0; i < object.initializer.length; ++i) {\n                    if (typeof object.initializer[i] !== \"object\")\n                        throw TypeError(\".onnx.GraphProto.initializer: object expected\");\n                    message.initializer[i] = $root.onnx.TensorProto.fromObject(object.initializer[i]);\n                }\n            }\n            if (object.sparseInitializer) {\n                if (!Array.isArray(object.sparseInitializer))\n                    throw TypeError(\".onnx.GraphProto.sparseInitializer: array expected\");\n                message.sparseInitializer = [];\n                for (var i = 0; i < object.sparseInitializer.length; ++i) {\n                    if (typeof object.sparseInitializer[i] !== \"object\")\n                        throw TypeError(\".onnx.GraphProto.sparseInitializer: object expected\");\n                    message.sparseInitializer[i] = $root.onnx.SparseTensorProto.fromObject(object.sparseInitializer[i]);\n                }\n            }\n            if (object.docString != null)\n                message.docString = String(object.docString);\n            if (object.input) {\n                if (!Array.isArray(object.input))\n                    throw TypeError(\".onnx.GraphProto.input: array expected\");\n                message.input = [];\n                for (var i = 0; i < object.input.length; ++i) {\n                    if (typeof object.input[i] !== \"object\")\n                        throw TypeError(\".onnx.GraphProto.input: object expected\");\n                    message.input[i] = $root.onnx.ValueInfoProto.fromObject(object.input[i]);\n                }\n            }\n            if (object.output) {\n                if (!Array.isArray(object.output))\n                    throw TypeError(\".onnx.GraphProto.output: array expected\");\n                message.output = [];\n                for (var i = 0; i < object.output.length; ++i) {\n                    if (typeof object.output[i] !== \"object\")\n                        throw TypeError(\".onnx.GraphProto.output: object expected\");\n                    message.output[i] = $root.onnx.ValueInfoProto.fromObject(object.output[i]);\n                }\n            }\n            if (object.valueInfo) {\n                if (!Array.isArray(object.valueInfo))\n                    throw TypeError(\".onnx.GraphProto.valueInfo: array expected\");\n                message.valueInfo = [];\n                for (var i = 0; i < object.valueInfo.length; ++i) {\n                    if (typeof object.valueInfo[i] !== \"object\")\n                        throw TypeError(\".onnx.GraphProto.valueInfo: object expected\");\n                    message.valueInfo[i] = $root.onnx.ValueInfoProto.fromObject(object.valueInfo[i]);\n                }\n            }\n            if (object.quantizationAnnotation) {\n                if (!Array.isArray(object.quantizationAnnotation))\n                    throw TypeError(\".onnx.GraphProto.quantizationAnnotation: array expected\");\n                message.quantizationAnnotation = [];\n                for (var i = 0; i < object.quantizationAnnotation.length; ++i) {\n                    if (typeof object.quantizationAnnotation[i] !== \"object\")\n                        throw TypeError(\".onnx.GraphProto.quantizationAnnotation: object expected\");\n                    message.quantizationAnnotation[i] = $root.onnx.TensorAnnotation.fromObject(object.quantizationAnnotation[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a GraphProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.GraphProto\n         * @static\n         * @param {onnx.GraphProto} message GraphProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        GraphProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.node = [];\n                object.initializer = [];\n                object.input = [];\n                object.output = [];\n                object.valueInfo = [];\n                object.quantizationAnnotation = [];\n                object.sparseInitializer = [];\n            }\n            if (options.defaults) {\n                object.name = \"\";\n                object.docString = \"\";\n            }\n            if (message.node && message.node.length) {\n                object.node = [];\n                for (var j = 0; j < message.node.length; ++j)\n                    object.node[j] = $root.onnx.NodeProto.toObject(message.node[j], options);\n            }\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                object.name = message.name;\n            if (message.initializer && message.initializer.length) {\n                object.initializer = [];\n                for (var j = 0; j < message.initializer.length; ++j)\n                    object.initializer[j] = $root.onnx.TensorProto.toObject(message.initializer[j], options);\n            }\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                object.docString = message.docString;\n            if (message.input && message.input.length) {\n                object.input = [];\n                for (var j = 0; j < message.input.length; ++j)\n                    object.input[j] = $root.onnx.ValueInfoProto.toObject(message.input[j], options);\n            }\n            if (message.output && message.output.length) {\n                object.output = [];\n                for (var j = 0; j < message.output.length; ++j)\n                    object.output[j] = $root.onnx.ValueInfoProto.toObject(message.output[j], options);\n            }\n            if (message.valueInfo && message.valueInfo.length) {\n                object.valueInfo = [];\n                for (var j = 0; j < message.valueInfo.length; ++j)\n                    object.valueInfo[j] = $root.onnx.ValueInfoProto.toObject(message.valueInfo[j], options);\n            }\n            if (message.quantizationAnnotation && message.quantizationAnnotation.length) {\n                object.quantizationAnnotation = [];\n                for (var j = 0; j < message.quantizationAnnotation.length; ++j)\n                    object.quantizationAnnotation[j] = $root.onnx.TensorAnnotation.toObject(message.quantizationAnnotation[j], options);\n            }\n            if (message.sparseInitializer && message.sparseInitializer.length) {\n                object.sparseInitializer = [];\n                for (var j = 0; j < message.sparseInitializer.length; ++j)\n                    object.sparseInitializer[j] = $root.onnx.SparseTensorProto.toObject(message.sparseInitializer[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this GraphProto to JSON.\n         * @function toJSON\n         * @memberof onnx.GraphProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        GraphProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * Gets the default type url for GraphProto\n         * @function getTypeUrl\n         * @memberof onnx.GraphProto\n         * @static\n         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n         * @returns {string} The default type url\n         */\n        GraphProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === undefined) {\n                typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/onnx.GraphProto\";\n        };\n\n        return GraphProto;\n    })();\n\n    onnx.TensorProto = (function() {\n\n        /**\n         * Properties of a TensorProto.\n         * @memberof onnx\n         * @interface ITensorProto\n         * @property {Array.<number|Long>|null} [dims] TensorProto dims\n         * @property {number|null} [dataType] TensorProto dataType\n         * @property {onnx.TensorProto.ISegment|null} [segment] TensorProto segment\n         * @property {Array.<number>|null} [floatData] TensorProto floatData\n         * @property {Array.<number>|null} [int32Data] TensorProto int32Data\n         * @property {Array.<Uint8Array>|null} [stringData] TensorProto stringData\n         * @property {Array.<number|Long>|null} [int64Data] TensorProto int64Data\n         * @property {string|null} [name] TensorProto name\n         * @property {string|null} [docString] TensorProto docString\n         * @property {Uint8Array|null} [rawData] TensorProto rawData\n         * @property {Array.<onnx.IStringStringEntryProto>|null} [externalData] TensorProto externalData\n         * @property {onnx.TensorProto.DataLocation|null} [dataLocation] TensorProto dataLocation\n         * @property {Array.<number>|null} [doubleData] TensorProto doubleData\n         * @property {Array.<number|Long>|null} [uint64Data] TensorProto uint64Data\n         */\n\n        /**\n         * Constructs a new TensorProto.\n         * @memberof onnx\n         * @classdesc Represents a TensorProto.\n         * @implements ITensorProto\n         * @constructor\n         * @param {onnx.ITensorProto=} [properties] Properties to set\n         */\n        function TensorProto(properties) {\n            this.dims = [];\n            this.floatData = [];\n            this.int32Data = [];\n            this.stringData = [];\n            this.int64Data = [];\n            this.externalData = [];\n            this.doubleData = [];\n            this.uint64Data = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * TensorProto dims.\n         * @member {Array.<number|Long>} dims\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.dims = $util.emptyArray;\n\n        /**\n         * TensorProto dataType.\n         * @member {number} dataType\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.dataType = 0;\n\n        /**\n         * TensorProto segment.\n         * @member {onnx.TensorProto.ISegment|null|undefined} segment\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.segment = null;\n\n        /**\n         * TensorProto floatData.\n         * @member {Array.<number>} floatData\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.floatData = $util.emptyArray;\n\n        /**\n         * TensorProto int32Data.\n         * @member {Array.<number>} int32Data\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.int32Data = $util.emptyArray;\n\n        /**\n         * TensorProto stringData.\n         * @member {Array.<Uint8Array>} stringData\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.stringData = $util.emptyArray;\n\n        /**\n         * TensorProto int64Data.\n         * @member {Array.<number|Long>} int64Data\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.int64Data = $util.emptyArray;\n\n        /**\n         * TensorProto name.\n         * @member {string} name\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.name = \"\";\n\n        /**\n         * TensorProto docString.\n         * @member {string} docString\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.docString = \"\";\n\n        /**\n         * TensorProto rawData.\n         * @member {Uint8Array} rawData\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.rawData = $util.newBuffer([]);\n\n        /**\n         * TensorProto externalData.\n         * @member {Array.<onnx.IStringStringEntryProto>} externalData\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.externalData = $util.emptyArray;\n\n        /**\n         * TensorProto dataLocation.\n         * @member {onnx.TensorProto.DataLocation} dataLocation\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.dataLocation = 0;\n\n        /**\n         * TensorProto doubleData.\n         * @member {Array.<number>} doubleData\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.doubleData = $util.emptyArray;\n\n        /**\n         * TensorProto uint64Data.\n         * @member {Array.<number|Long>} uint64Data\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.uint64Data = $util.emptyArray;\n\n        /**\n         * Creates a new TensorProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.TensorProto\n         * @static\n         * @param {onnx.ITensorProto=} [properties] Properties to set\n         * @returns {onnx.TensorProto} TensorProto instance\n         */\n        TensorProto.create = function create(properties) {\n            return new TensorProto(properties);\n        };\n\n        /**\n         * Encodes the specified TensorProto message. Does not implicitly {@link onnx.TensorProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.TensorProto\n         * @static\n         * @param {onnx.ITensorProto} message TensorProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TensorProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.dims != null && message.dims.length) {\n                writer.uint32(/* id 1, wireType 2 =*/10).fork();\n                for (var i = 0; i < message.dims.length; ++i)\n                    writer.int64(message.dims[i]);\n                writer.ldelim();\n            }\n            if (message.dataType != null && Object.hasOwnProperty.call(message, \"dataType\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.dataType);\n            if (message.segment != null && Object.hasOwnProperty.call(message, \"segment\"))\n                $root.onnx.TensorProto.Segment.encode(message.segment, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.floatData != null && message.floatData.length) {\n                writer.uint32(/* id 4, wireType 2 =*/34).fork();\n                for (var i = 0; i < message.floatData.length; ++i)\n                    writer.float(message.floatData[i]);\n                writer.ldelim();\n            }\n            if (message.int32Data != null && message.int32Data.length) {\n                writer.uint32(/* id 5, wireType 2 =*/42).fork();\n                for (var i = 0; i < message.int32Data.length; ++i)\n                    writer.int32(message.int32Data[i]);\n                writer.ldelim();\n            }\n            if (message.stringData != null && message.stringData.length)\n                for (var i = 0; i < message.stringData.length; ++i)\n                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.stringData[i]);\n            if (message.int64Data != null && message.int64Data.length) {\n                writer.uint32(/* id 7, wireType 2 =*/58).fork();\n                for (var i = 0; i < message.int64Data.length; ++i)\n                    writer.int64(message.int64Data[i]);\n                writer.ldelim();\n            }\n            if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                writer.uint32(/* id 8, wireType 2 =*/66).string(message.name);\n            if (message.rawData != null && Object.hasOwnProperty.call(message, \"rawData\"))\n                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.rawData);\n            if (message.doubleData != null && message.doubleData.length) {\n                writer.uint32(/* id 10, wireType 2 =*/82).fork();\n                for (var i = 0; i < message.doubleData.length; ++i)\n                    writer.double(message.doubleData[i]);\n                writer.ldelim();\n            }\n            if (message.uint64Data != null && message.uint64Data.length) {\n                writer.uint32(/* id 11, wireType 2 =*/90).fork();\n                for (var i = 0; i < message.uint64Data.length; ++i)\n                    writer.uint64(message.uint64Data[i]);\n                writer.ldelim();\n            }\n            if (message.docString != null && Object.hasOwnProperty.call(message, \"docString\"))\n                writer.uint32(/* id 12, wireType 2 =*/98).string(message.docString);\n            if (message.externalData != null && message.externalData.length)\n                for (var i = 0; i < message.externalData.length; ++i)\n                    $root.onnx.StringStringEntryProto.encode(message.externalData[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();\n            if (message.dataLocation != null && Object.hasOwnProperty.call(message, \"dataLocation\"))\n                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.dataLocation);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified TensorProto message, length delimited. Does not implicitly {@link onnx.TensorProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.TensorProto\n         * @static\n         * @param {onnx.ITensorProto} message TensorProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TensorProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a TensorProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.TensorProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.TensorProto} TensorProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TensorProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TensorProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1: {\n                        if (!(message.dims && message.dims.length))\n                            message.dims = [];\n                        if ((tag & 7) === 2) {\n                            var end2 = reader.uint32() + reader.pos;\n                            while (reader.pos < end2)\n                                message.dims.push(reader.int64());\n                        } else\n                            message.dims.push(reader.int64());\n                        break;\n                    }\n                case 2: {\n                        message.dataType = reader.int32();\n                        break;\n                    }\n                case 3: {\n                        message.segment = $root.onnx.TensorProto.Segment.decode(reader, reader.uint32());\n                        break;\n                    }\n                case 4: {\n                        if (!(message.floatData && message.floatData.length))\n                            message.floatData = [];\n                        if ((tag & 7) === 2) {\n                            var end2 = reader.uint32() + reader.pos;\n                            while (reader.pos < end2)\n                                message.floatData.push(reader.float());\n                        } else\n                            message.floatData.push(reader.float());\n                        break;\n                    }\n                case 5: {\n                        if (!(message.int32Data && message.int32Data.length))\n                            message.int32Data = [];\n                        if ((tag & 7) === 2) {\n                            var end2 = reader.uint32() + reader.pos;\n                            while (reader.pos < end2)\n                                message.int32Data.push(reader.int32());\n                        } else\n                            message.int32Data.push(reader.int32());\n                        break;\n                    }\n                case 6: {\n                        if (!(message.stringData && message.stringData.length))\n                            message.stringData = [];\n                        message.stringData.push(reader.bytes());\n                        break;\n                    }\n                case 7: {\n                        if (!(message.int64Data && message.int64Data.length))\n                            message.int64Data = [];\n                        if ((tag & 7) === 2) {\n                            var end2 = reader.uint32() + reader.pos;\n                            while (reader.pos < end2)\n                                message.int64Data.push(reader.int64());\n                        } else\n                            message.int64Data.push(reader.int64());\n                        break;\n                    }\n                case 8: {\n                        message.name = reader.string();\n                        break;\n                    }\n                case 12: {\n                        message.docString = reader.string();\n                        break;\n                    }\n                case 9: {\n                        message.rawData = reader.bytes();\n                        break;\n                    }\n                case 13: {\n                        if (!(message.externalData && message.externalData.length))\n                            message.externalData = [];\n                        message.externalData.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));\n                        break;\n                    }\n                case 14: {\n                        message.dataLocation = reader.int32();\n                        break;\n                    }\n                case 10: {\n                        if (!(message.doubleData && message.doubleData.length))\n                            message.doubleData = [];\n                        if ((tag & 7) === 2) {\n                            var end2 = reader.uint32() + reader.pos;\n                            while (reader.pos < end2)\n                                message.doubleData.push(reader.double());\n                        } else\n                            message.doubleData.push(reader.double());\n                        break;\n                    }\n                case 11: {\n                        if (!(message.uint64Data && message.uint64Data.length))\n                            message.uint64Data = [];\n                        if ((tag & 7) === 2) {\n                            var end2 = reader.uint32() + reader.pos;\n                            while (reader.pos < end2)\n                                message.uint64Data.push(reader.uint64());\n                        } else\n                            message.uint64Data.push(reader.uint64());\n                        break;\n                    }\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a TensorProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.TensorProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.TensorProto} TensorProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TensorProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a TensorProto message.\n         * @function verify\n         * @memberof onnx.TensorProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        TensorProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.dims != null && message.hasOwnProperty(\"dims\")) {\n                if (!Array.isArray(message.dims))\n                    return \"dims: array expected\";\n                for (var i = 0; i < message.dims.length; ++i)\n                    if (!$util.isInteger(message.dims[i]) && !(message.dims[i] && $util.isInteger(message.dims[i].low) && $util.isInteger(message.dims[i].high)))\n                        return \"dims: integer|Long[] expected\";\n            }\n            if (message.dataType != null && message.hasOwnProperty(\"dataType\"))\n                if (!$util.isInteger(message.dataType))\n                    return \"dataType: integer expected\";\n            if (message.segment != null && message.hasOwnProperty(\"segment\")) {\n                var error = $root.onnx.TensorProto.Segment.verify(message.segment);\n                if (error)\n                    return \"segment.\" + error;\n            }\n            if (message.floatData != null && message.hasOwnProperty(\"floatData\")) {\n                if (!Array.isArray(message.floatData))\n                    return \"floatData: array expected\";\n                for (var i = 0; i < message.floatData.length; ++i)\n                    if (typeof message.floatData[i] !== \"number\")\n                        return \"floatData: number[] expected\";\n            }\n            if (message.int32Data != null && message.hasOwnProperty(\"int32Data\")) {\n                if (!Array.isArray(message.int32Data))\n                    return \"int32Data: array expected\";\n                for (var i = 0; i < message.int32Data.length; ++i)\n                    if (!$util.isInteger(message.int32Data[i]))\n                        return \"int32Data: integer[] expected\";\n            }\n            if (message.stringData != null && message.hasOwnProperty(\"stringData\")) {\n                if (!Array.isArray(message.stringData))\n                    return \"stringData: array expected\";\n                for (var i = 0; i < message.stringData.length; ++i)\n                    if (!(message.stringData[i] && typeof message.stringData[i].length === \"number\" || $util.isString(message.stringData[i])))\n                        return \"stringData: buffer[] expected\";\n            }\n            if (message.int64Data != null && message.hasOwnProperty(\"int64Data\")) {\n                if (!Array.isArray(message.int64Data))\n                    return \"int64Data: array expected\";\n                for (var i = 0; i < message.int64Data.length; ++i)\n                    if (!$util.isInteger(message.int64Data[i]) && !(message.int64Data[i] && $util.isInteger(message.int64Data[i].low) && $util.isInteger(message.int64Data[i].high)))\n                        return \"int64Data: integer|Long[] expected\";\n            }\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                if (!$util.isString(message.name))\n                    return \"name: string expected\";\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                if (!$util.isString(message.docString))\n                    return \"docString: string expected\";\n            if (message.rawData != null && message.hasOwnProperty(\"rawData\"))\n                if (!(message.rawData && typeof message.rawData.length === \"number\" || $util.isString(message.rawData)))\n                    return \"rawData: buffer expected\";\n            if (message.externalData != null && message.hasOwnProperty(\"externalData\")) {\n                if (!Array.isArray(message.externalData))\n                    return \"externalData: array expected\";\n                for (var i = 0; i < message.externalData.length; ++i) {\n                    var error = $root.onnx.StringStringEntryProto.verify(message.externalData[i]);\n                    if (error)\n                        return \"externalData.\" + error;\n                }\n            }\n            if (message.dataLocation != null && message.hasOwnProperty(\"dataLocation\"))\n                switch (message.dataLocation) {\n                default:\n                    return \"dataLocation: enum value expected\";\n                case 0:\n                case 1:\n                    break;\n                }\n            if (message.doubleData != null && message.hasOwnProperty(\"doubleData\")) {\n                if (!Array.isArray(message.doubleData))\n                    return \"doubleData: array expected\";\n                for (var i = 0; i < message.doubleData.length; ++i)\n                    if (typeof message.doubleData[i] !== \"number\")\n                        return \"doubleData: number[] expected\";\n            }\n            if (message.uint64Data != null && message.hasOwnProperty(\"uint64Data\")) {\n                if (!Array.isArray(message.uint64Data))\n                    return \"uint64Data: array expected\";\n                for (var i = 0; i < message.uint64Data.length; ++i)\n                    if (!$util.isInteger(message.uint64Data[i]) && !(message.uint64Data[i] && $util.isInteger(message.uint64Data[i].low) && $util.isInteger(message.uint64Data[i].high)))\n                        return \"uint64Data: integer|Long[] expected\";\n            }\n            return null;\n        };\n\n        /**\n         * Creates a TensorProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.TensorProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.TensorProto} TensorProto\n         */\n        TensorProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.TensorProto)\n                return object;\n            var message = new $root.onnx.TensorProto();\n            if (object.dims) {\n                if (!Array.isArray(object.dims))\n                    throw TypeError(\".onnx.TensorProto.dims: array expected\");\n                message.dims = [];\n                for (var i = 0; i < object.dims.length; ++i)\n                    if ($util.Long)\n                        (message.dims[i] = $util.Long.fromValue(object.dims[i])).unsigned = false;\n                    else if (typeof object.dims[i] === \"string\")\n                        message.dims[i] = parseInt(object.dims[i], 10);\n                    else if (typeof object.dims[i] === \"number\")\n                        message.dims[i] = object.dims[i];\n                    else if (typeof object.dims[i] === \"object\")\n                        message.dims[i] = new $util.LongBits(object.dims[i].low >>> 0, object.dims[i].high >>> 0).toNumber();\n            }\n            if (object.dataType != null)\n                message.dataType = object.dataType | 0;\n            if (object.segment != null) {\n                if (typeof object.segment !== \"object\")\n                    throw TypeError(\".onnx.TensorProto.segment: object expected\");\n                message.segment = $root.onnx.TensorProto.Segment.fromObject(object.segment);\n            }\n            if (object.floatData) {\n                if (!Array.isArray(object.floatData))\n                    throw TypeError(\".onnx.TensorProto.floatData: array expected\");\n                message.floatData = [];\n                for (var i = 0; i < object.floatData.length; ++i)\n                    message.floatData[i] = Number(object.floatData[i]);\n            }\n            if (object.int32Data) {\n                if (!Array.isArray(object.int32Data))\n                    throw TypeError(\".onnx.TensorProto.int32Data: array expected\");\n                message.int32Data = [];\n                for (var i = 0; i < object.int32Data.length; ++i)\n                    message.int32Data[i] = object.int32Data[i] | 0;\n            }\n            if (object.stringData) {\n                if (!Array.isArray(object.stringData))\n                    throw TypeError(\".onnx.TensorProto.stringData: array expected\");\n                message.stringData = [];\n                for (var i = 0; i < object.stringData.length; ++i)\n                    if (typeof object.stringData[i] === \"string\")\n                        $util.base64.decode(object.stringData[i], message.stringData[i] = $util.newBuffer($util.base64.length(object.stringData[i])), 0);\n                    else if (object.stringData[i].length >= 0)\n                        message.stringData[i] = object.stringData[i];\n            }\n            if (object.int64Data) {\n                if (!Array.isArray(object.int64Data))\n                    throw TypeError(\".onnx.TensorProto.int64Data: array expected\");\n                message.int64Data = [];\n                for (var i = 0; i < object.int64Data.length; ++i)\n                    if ($util.Long)\n                        (message.int64Data[i] = $util.Long.fromValue(object.int64Data[i])).unsigned = false;\n                    else if (typeof object.int64Data[i] === \"string\")\n                        message.int64Data[i] = parseInt(object.int64Data[i], 10);\n                    else if (typeof object.int64Data[i] === \"number\")\n                        message.int64Data[i] = object.int64Data[i];\n                    else if (typeof object.int64Data[i] === \"object\")\n                        message.int64Data[i] = new $util.LongBits(object.int64Data[i].low >>> 0, object.int64Data[i].high >>> 0).toNumber();\n            }\n            if (object.name != null)\n                message.name = String(object.name);\n            if (object.docString != null)\n                message.docString = String(object.docString);\n            if (object.rawData != null)\n                if (typeof object.rawData === \"string\")\n                    $util.base64.decode(object.rawData, message.rawData = $util.newBuffer($util.base64.length(object.rawData)), 0);\n                else if (object.rawData.length >= 0)\n                    message.rawData = object.rawData;\n            if (object.externalData) {\n                if (!Array.isArray(object.externalData))\n                    throw TypeError(\".onnx.TensorProto.externalData: array expected\");\n                message.externalData = [];\n                for (var i = 0; i < object.externalData.length; ++i) {\n                    if (typeof object.externalData[i] !== \"object\")\n                        throw TypeError(\".onnx.TensorProto.externalData: object expected\");\n                    message.externalData[i] = $root.onnx.StringStringEntryProto.fromObject(object.externalData[i]);\n                }\n            }\n            switch (object.dataLocation) {\n            default:\n                if (typeof object.dataLocation === \"number\") {\n                    message.dataLocation = object.dataLocation;\n                    break;\n                }\n                break;\n            case \"DEFAULT\":\n            case 0:\n                message.dataLocation = 0;\n                break;\n            case \"EXTERNAL\":\n            case 1:\n                message.dataLocation = 1;\n                break;\n            }\n            if (object.doubleData) {\n                if (!Array.isArray(object.doubleData))\n                    throw TypeError(\".onnx.TensorProto.doubleData: array expected\");\n                message.doubleData = [];\n                for (var i = 0; i < object.doubleData.length; ++i)\n                    message.doubleData[i] = Number(object.doubleData[i]);\n            }\n            if (object.uint64Data) {\n                if (!Array.isArray(object.uint64Data))\n                    throw TypeError(\".onnx.TensorProto.uint64Data: array expected\");\n                message.uint64Data = [];\n                for (var i = 0; i < object.uint64Data.length; ++i)\n                    if ($util.Long)\n                        (message.uint64Data[i] = $util.Long.fromValue(object.uint64Data[i])).unsigned = true;\n                    else if (typeof object.uint64Data[i] === \"string\")\n                        message.uint64Data[i] = parseInt(object.uint64Data[i], 10);\n                    else if (typeof object.uint64Data[i] === \"number\")\n                        message.uint64Data[i] = object.uint64Data[i];\n                    else if (typeof object.uint64Data[i] === \"object\")\n                        message.uint64Data[i] = new $util.LongBits(object.uint64Data[i].low >>> 0, object.uint64Data[i].high >>> 0).toNumber(true);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a TensorProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.TensorProto\n         * @static\n         * @param {onnx.TensorProto} message TensorProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        TensorProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.dims = [];\n                object.floatData = [];\n                object.int32Data = [];\n                object.stringData = [];\n                object.int64Data = [];\n                object.doubleData = [];\n                object.uint64Data = [];\n                object.externalData = [];\n            }\n            if (options.defaults) {\n                object.dataType = 0;\n                object.segment = null;\n                object.name = \"\";\n                if (options.bytes === String)\n                    object.rawData = \"\";\n                else {\n                    object.rawData = [];\n                    if (options.bytes !== Array)\n                        object.rawData = $util.newBuffer(object.rawData);\n                }\n                object.docString = \"\";\n                object.dataLocation = options.enums === String ? \"DEFAULT\" : 0;\n            }\n            if (message.dims && message.dims.length) {\n                object.dims = [];\n                for (var j = 0; j < message.dims.length; ++j)\n                    if (typeof message.dims[j] === \"number\")\n                        object.dims[j] = options.longs === String ? String(message.dims[j]) : message.dims[j];\n                    else\n                        object.dims[j] = options.longs === String ? $util.Long.prototype.toString.call(message.dims[j]) : options.longs === Number ? new $util.LongBits(message.dims[j].low >>> 0, message.dims[j].high >>> 0).toNumber() : message.dims[j];\n            }\n            if (message.dataType != null && message.hasOwnProperty(\"dataType\"))\n                object.dataType = message.dataType;\n            if (message.segment != null && message.hasOwnProperty(\"segment\"))\n                object.segment = $root.onnx.TensorProto.Segment.toObject(message.segment, options);\n            if (message.floatData && message.floatData.length) {\n                object.floatData = [];\n                for (var j = 0; j < message.floatData.length; ++j)\n                    object.floatData[j] = options.json && !isFinite(message.floatData[j]) ? String(message.floatData[j]) : message.floatData[j];\n            }\n            if (message.int32Data && message.int32Data.length) {\n                object.int32Data = [];\n                for (var j = 0; j < message.int32Data.length; ++j)\n                    object.int32Data[j] = message.int32Data[j];\n            }\n            if (message.stringData && message.stringData.length) {\n                object.stringData = [];\n                for (var j = 0; j < message.stringData.length; ++j)\n                    object.stringData[j] = options.bytes === String ? $util.base64.encode(message.stringData[j], 0, message.stringData[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.stringData[j]) : message.stringData[j];\n            }\n            if (message.int64Data && message.int64Data.length) {\n                object.int64Data = [];\n                for (var j = 0; j < message.int64Data.length; ++j)\n                    if (typeof message.int64Data[j] === \"number\")\n                        object.int64Data[j] = options.longs === String ? String(message.int64Data[j]) : message.int64Data[j];\n                    else\n                        object.int64Data[j] = options.longs === String ? $util.Long.prototype.toString.call(message.int64Data[j]) : options.longs === Number ? new $util.LongBits(message.int64Data[j].low >>> 0, message.int64Data[j].high >>> 0).toNumber() : message.int64Data[j];\n            }\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                object.name = message.name;\n            if (message.rawData != null && message.hasOwnProperty(\"rawData\"))\n                object.rawData = options.bytes === String ? $util.base64.encode(message.rawData, 0, message.rawData.length) : options.bytes === Array ? Array.prototype.slice.call(message.rawData) : message.rawData;\n            if (message.doubleData && message.doubleData.length) {\n                object.doubleData = [];\n                for (var j = 0; j < message.doubleData.length; ++j)\n                    object.doubleData[j] = options.json && !isFinite(message.doubleData[j]) ? String(message.doubleData[j]) : message.doubleData[j];\n            }\n            if (message.uint64Data && message.uint64Data.length) {\n                object.uint64Data = [];\n                for (var j = 0; j < message.uint64Data.length; ++j)\n                    if (typeof message.uint64Data[j] === \"number\")\n                        object.uint64Data[j] = options.longs === String ? String(message.uint64Data[j]) : message.uint64Data[j];\n                    else\n                        object.uint64Data[j] = options.longs === String ? $util.Long.prototype.toString.call(message.uint64Data[j]) : options.longs === Number ? new $util.LongBits(message.uint64Data[j].low >>> 0, message.uint64Data[j].high >>> 0).toNumber(true) : message.uint64Data[j];\n            }\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                object.docString = message.docString;\n            if (message.externalData && message.externalData.length) {\n                object.externalData = [];\n                for (var j = 0; j < message.externalData.length; ++j)\n                    object.externalData[j] = $root.onnx.StringStringEntryProto.toObject(message.externalData[j], options);\n            }\n            if (message.dataLocation != null && message.hasOwnProperty(\"dataLocation\"))\n                object.dataLocation = options.enums === String ? $root.onnx.TensorProto.DataLocation[message.dataLocation] === undefined ? message.dataLocation : $root.onnx.TensorProto.DataLocation[message.dataLocation] : message.dataLocation;\n            return object;\n        };\n\n        /**\n         * Converts this TensorProto to JSON.\n         * @function toJSON\n         * @memberof onnx.TensorProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        TensorProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * Gets the default type url for TensorProto\n         * @function getTypeUrl\n         * @memberof onnx.TensorProto\n         * @static\n         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n         * @returns {string} The default type url\n         */\n        TensorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === undefined) {\n                typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/onnx.TensorProto\";\n        };\n\n        /**\n         * DataType enum.\n         * @name onnx.TensorProto.DataType\n         * @enum {number}\n         * @property {number} UNDEFINED=0 UNDEFINED value\n         * @property {number} FLOAT=1 FLOAT value\n         * @property {number} UINT8=2 UINT8 value\n         * @property {number} INT8=3 INT8 value\n         * @property {number} UINT16=4 UINT16 value\n         * @property {number} INT16=5 INT16 value\n         * @property {number} INT32=6 INT32 value\n         * @property {number} INT64=7 INT64 value\n         * @property {number} STRING=8 STRING value\n         * @property {number} BOOL=9 BOOL value\n         * @property {number} FLOAT16=10 FLOAT16 value\n         * @property {number} DOUBLE=11 DOUBLE value\n         * @property {number} UINT32=12 UINT32 value\n         * @property {number} UINT64=13 UINT64 value\n         * @property {number} COMPLEX64=14 COMPLEX64 value\n         * @property {number} COMPLEX128=15 COMPLEX128 value\n         * @property {number} BFLOAT16=16 BFLOAT16 value\n         * @property {number} FLOAT8E4M3FN=17 FLOAT8E4M3FN value\n         * @property {number} FLOAT8E4M3FNUZ=18 FLOAT8E4M3FNUZ value\n         * @property {number} FLOAT8E5M2=19 FLOAT8E5M2 value\n         * @property {number} FLOAT8E5M2FNUZ=20 FLOAT8E5M2FNUZ value\n         */\n        TensorProto.DataType = (function() {\n            var valuesById = {}, values = Object.create(valuesById);\n            values[valuesById[0] = \"UNDEFINED\"] = 0;\n            values[valuesById[1] = \"FLOAT\"] = 1;\n            values[valuesById[2] = \"UINT8\"] = 2;\n            values[valuesById[3] = \"INT8\"] = 3;\n            values[valuesById[4] = \"UINT16\"] = 4;\n            values[valuesById[5] = \"INT16\"] = 5;\n            values[valuesById[6] = \"INT32\"] = 6;\n            values[valuesById[7] = \"INT64\"] = 7;\n            values[valuesById[8] = \"STRING\"] = 8;\n            values[valuesById[9] = \"BOOL\"] = 9;\n            values[valuesById[10] = \"FLOAT16\"] = 10;\n            values[valuesById[11] = \"DOUBLE\"] = 11;\n            values[valuesById[12] = \"UINT32\"] = 12;\n            values[valuesById[13] = \"UINT64\"] = 13;\n            values[valuesById[14] = \"COMPLEX64\"] = 14;\n            values[valuesById[15] = \"COMPLEX128\"] = 15;\n            values[valuesById[16] = \"BFLOAT16\"] = 16;\n            values[valuesById[17] = \"FLOAT8E4M3FN\"] = 17;\n            values[valuesById[18] = \"FLOAT8E4M3FNUZ\"] = 18;\n            values[valuesById[19] = \"FLOAT8E5M2\"] = 19;\n            values[valuesById[20] = \"FLOAT8E5M2FNUZ\"] = 20;\n            return values;\n        })();\n\n        TensorProto.Segment = (function() {\n\n            /**\n             * Properties of a Segment.\n             * @memberof onnx.TensorProto\n             * @interface ISegment\n             * @property {number|Long|null} [begin] Segment begin\n             * @property {number|Long|null} [end] Segment end\n             */\n\n            /**\n             * Constructs a new Segment.\n             * @memberof onnx.TensorProto\n             * @classdesc Represents a Segment.\n             * @implements ISegment\n             * @constructor\n             * @param {onnx.TensorProto.ISegment=} [properties] Properties to set\n             */\n            function Segment(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Segment begin.\n             * @member {number|Long} begin\n             * @memberof onnx.TensorProto.Segment\n             * @instance\n             */\n            Segment.prototype.begin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Segment end.\n             * @member {number|Long} end\n             * @memberof onnx.TensorProto.Segment\n             * @instance\n             */\n            Segment.prototype.end = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Creates a new Segment instance using the specified properties.\n             * @function create\n             * @memberof onnx.TensorProto.Segment\n             * @static\n             * @param {onnx.TensorProto.ISegment=} [properties] Properties to set\n             * @returns {onnx.TensorProto.Segment} Segment instance\n             */\n            Segment.create = function create(properties) {\n                return new Segment(properties);\n            };\n\n            /**\n             * Encodes the specified Segment message. Does not implicitly {@link onnx.TensorProto.Segment.verify|verify} messages.\n             * @function encode\n             * @memberof onnx.TensorProto.Segment\n             * @static\n             * @param {onnx.TensorProto.ISegment} message Segment message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Segment.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.begin != null && Object.hasOwnProperty.call(message, \"begin\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.begin);\n                if (message.end != null && Object.hasOwnProperty.call(message, \"end\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.end);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Segment message, length delimited. Does not implicitly {@link onnx.TensorProto.Segment.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof onnx.TensorProto.Segment\n             * @static\n             * @param {onnx.TensorProto.ISegment} message Segment message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Segment.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Segment message from the specified reader or buffer.\n             * @function decode\n             * @memberof onnx.TensorProto.Segment\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {onnx.TensorProto.Segment} Segment\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Segment.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TensorProto.Segment();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1: {\n                            message.begin = reader.int64();\n                            break;\n                        }\n                    case 2: {\n                            message.end = reader.int64();\n                            break;\n                        }\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Segment message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof onnx.TensorProto.Segment\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {onnx.TensorProto.Segment} Segment\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Segment.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Segment message.\n             * @function verify\n             * @memberof onnx.TensorProto.Segment\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Segment.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.begin != null && message.hasOwnProperty(\"begin\"))\n                    if (!$util.isInteger(message.begin) && !(message.begin && $util.isInteger(message.begin.low) && $util.isInteger(message.begin.high)))\n                        return \"begin: integer|Long expected\";\n                if (message.end != null && message.hasOwnProperty(\"end\"))\n                    if (!$util.isInteger(message.end) && !(message.end && $util.isInteger(message.end.low) && $util.isInteger(message.end.high)))\n                        return \"end: integer|Long expected\";\n                return null;\n            };\n\n            /**\n             * Creates a Segment message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof onnx.TensorProto.Segment\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {onnx.TensorProto.Segment} Segment\n             */\n            Segment.fromObject = function fromObject(object) {\n                if (object instanceof $root.onnx.TensorProto.Segment)\n                    return object;\n                var message = new $root.onnx.TensorProto.Segment();\n                if (object.begin != null)\n                    if ($util.Long)\n                        (message.begin = $util.Long.fromValue(object.begin)).unsigned = false;\n                    else if (typeof object.begin === \"string\")\n                        message.begin = parseInt(object.begin, 10);\n                    else if (typeof object.begin === \"number\")\n                        message.begin = object.begin;\n                    else if (typeof object.begin === \"object\")\n                        message.begin = new $util.LongBits(object.begin.low >>> 0, object.begin.high >>> 0).toNumber();\n                if (object.end != null)\n                    if ($util.Long)\n                        (message.end = $util.Long.fromValue(object.end)).unsigned = false;\n                    else if (typeof object.end === \"string\")\n                        message.end = parseInt(object.end, 10);\n                    else if (typeof object.end === \"number\")\n                        message.end = object.end;\n                    else if (typeof object.end === \"object\")\n                        message.end = new $util.LongBits(object.end.low >>> 0, object.end.high >>> 0).toNumber();\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Segment message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof onnx.TensorProto.Segment\n             * @static\n             * @param {onnx.TensorProto.Segment} message Segment\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Segment.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.begin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.begin = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.end = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.end = options.longs === String ? \"0\" : 0;\n                }\n                if (message.begin != null && message.hasOwnProperty(\"begin\"))\n                    if (typeof message.begin === \"number\")\n                        object.begin = options.longs === String ? String(message.begin) : message.begin;\n                    else\n                        object.begin = options.longs === String ? $util.Long.prototype.toString.call(message.begin) : options.longs === Number ? new $util.LongBits(message.begin.low >>> 0, message.begin.high >>> 0).toNumber() : message.begin;\n                if (message.end != null && message.hasOwnProperty(\"end\"))\n                    if (typeof message.end === \"number\")\n                        object.end = options.longs === String ? String(message.end) : message.end;\n                    else\n                        object.end = options.longs === String ? $util.Long.prototype.toString.call(message.end) : options.longs === Number ? new $util.LongBits(message.end.low >>> 0, message.end.high >>> 0).toNumber() : message.end;\n                return object;\n            };\n\n            /**\n             * Converts this Segment to JSON.\n             * @function toJSON\n             * @memberof onnx.TensorProto.Segment\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Segment.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            /**\n             * Gets the default type url for Segment\n             * @function getTypeUrl\n             * @memberof onnx.TensorProto.Segment\n             * @static\n             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n             * @returns {string} The default type url\n             */\n            Segment.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                if (typeUrlPrefix === undefined) {\n                    typeUrlPrefix = \"type.googleapis.com\";\n                }\n                return typeUrlPrefix + \"/onnx.TensorProto.Segment\";\n            };\n\n            return Segment;\n        })();\n\n        /**\n         * DataLocation enum.\n         * @name onnx.TensorProto.DataLocation\n         * @enum {number}\n         * @property {number} DEFAULT=0 DEFAULT value\n         * @property {number} EXTERNAL=1 EXTERNAL value\n         */\n        TensorProto.DataLocation = (function() {\n            var valuesById = {}, values = Object.create(valuesById);\n            values[valuesById[0] = \"DEFAULT\"] = 0;\n            values[valuesById[1] = \"EXTERNAL\"] = 1;\n            return values;\n        })();\n\n        return TensorProto;\n    })();\n\n    onnx.SparseTensorProto = (function() {\n\n        /**\n         * Properties of a SparseTensorProto.\n         * @memberof onnx\n         * @interface ISparseTensorProto\n         * @property {onnx.ITensorProto|null} [values] SparseTensorProto values\n         * @property {onnx.ITensorProto|null} [indices] SparseTensorProto indices\n         * @property {Array.<number|Long>|null} [dims] SparseTensorProto dims\n         */\n\n        /**\n         * Constructs a new SparseTensorProto.\n         * @memberof onnx\n         * @classdesc Represents a SparseTensorProto.\n         * @implements ISparseTensorProto\n         * @constructor\n         * @param {onnx.ISparseTensorProto=} [properties] Properties to set\n         */\n        function SparseTensorProto(properties) {\n            this.dims = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * SparseTensorProto values.\n         * @member {onnx.ITensorProto|null|undefined} values\n         * @memberof onnx.SparseTensorProto\n         * @instance\n         */\n        SparseTensorProto.prototype.values = null;\n\n        /**\n         * SparseTensorProto indices.\n         * @member {onnx.ITensorProto|null|undefined} indices\n         * @memberof onnx.SparseTensorProto\n         * @instance\n         */\n        SparseTensorProto.prototype.indices = null;\n\n        /**\n         * SparseTensorProto dims.\n         * @member {Array.<number|Long>} dims\n         * @memberof onnx.SparseTensorProto\n         * @instance\n         */\n        SparseTensorProto.prototype.dims = $util.emptyArray;\n\n        /**\n         * Creates a new SparseTensorProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.SparseTensorProto\n         * @static\n         * @param {onnx.ISparseTensorProto=} [properties] Properties to set\n         * @returns {onnx.SparseTensorProto} SparseTensorProto instance\n         */\n        SparseTensorProto.create = function create(properties) {\n            return new SparseTensorProto(properties);\n        };\n\n        /**\n         * Encodes the specified SparseTensorProto message. Does not implicitly {@link onnx.SparseTensorProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.SparseTensorProto\n         * @static\n         * @param {onnx.ISparseTensorProto} message SparseTensorProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        SparseTensorProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.values != null && Object.hasOwnProperty.call(message, \"values\"))\n                $root.onnx.TensorProto.encode(message.values, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.indices != null && Object.hasOwnProperty.call(message, \"indices\"))\n                $root.onnx.TensorProto.encode(message.indices, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.dims != null && message.dims.length) {\n                writer.uint32(/* id 3, wireType 2 =*/26).fork();\n                for (var i = 0; i < message.dims.length; ++i)\n                    writer.int64(message.dims[i]);\n                writer.ldelim();\n            }\n            return writer;\n        };\n\n        /**\n         * Encodes the specified SparseTensorProto message, length delimited. Does not implicitly {@link onnx.SparseTensorProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.SparseTensorProto\n         * @static\n         * @param {onnx.ISparseTensorProto} message SparseTensorProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        SparseTensorProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a SparseTensorProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.SparseTensorProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.SparseTensorProto} SparseTensorProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SparseTensorProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.SparseTensorProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1: {\n                        message.values = $root.onnx.TensorProto.decode(reader, reader.uint32());\n                        break;\n                    }\n                case 2: {\n                        message.indices = $root.onnx.TensorProto.decode(reader, reader.uint32());\n                        break;\n                    }\n                case 3: {\n                        if (!(message.dims && message.dims.length))\n                            message.dims = [];\n                        if ((tag & 7) === 2) {\n                            var end2 = reader.uint32() + reader.pos;\n                            while (reader.pos < end2)\n                                message.dims.push(reader.int64());\n                        } else\n                            message.dims.push(reader.int64());\n                        break;\n                    }\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a SparseTensorProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.SparseTensorProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.SparseTensorProto} SparseTensorProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SparseTensorProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a SparseTensorProto message.\n         * @function verify\n         * @memberof onnx.SparseTensorProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        SparseTensorProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.values != null && message.hasOwnProperty(\"values\")) {\n                var error = $root.onnx.TensorProto.verify(message.values);\n                if (error)\n                    return \"values.\" + error;\n            }\n            if (message.indices != null && message.hasOwnProperty(\"indices\")) {\n                var error = $root.onnx.TensorProto.verify(message.indices);\n                if (error)\n                    return \"indices.\" + error;\n            }\n            if (message.dims != null && message.hasOwnProperty(\"dims\")) {\n                if (!Array.isArray(message.dims))\n                    return \"dims: array expected\";\n                for (var i = 0; i < message.dims.length; ++i)\n                    if (!$util.isInteger(message.dims[i]) && !(message.dims[i] && $util.isInteger(message.dims[i].low) && $util.isInteger(message.dims[i].high)))\n                        return \"dims: integer|Long[] expected\";\n            }\n            return null;\n        };\n\n        /**\n         * Creates a SparseTensorProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.SparseTensorProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.SparseTensorProto} SparseTensorProto\n         */\n        SparseTensorProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.SparseTensorProto)\n                return object;\n            var message = new $root.onnx.SparseTensorProto();\n            if (object.values != null) {\n                if (typeof object.values !== \"object\")\n                    throw TypeError(\".onnx.SparseTensorProto.values: object expected\");\n                message.values = $root.onnx.TensorProto.fromObject(object.values);\n            }\n            if (object.indices != null) {\n                if (typeof object.indices !== \"object\")\n                    throw TypeError(\".onnx.SparseTensorProto.indices: object expected\");\n                message.indices = $root.onnx.TensorProto.fromObject(object.indices);\n            }\n            if (object.dims) {\n                if (!Array.isArray(object.dims))\n                    throw TypeError(\".onnx.SparseTensorProto.dims: array expected\");\n                message.dims = [];\n                for (var i = 0; i < object.dims.length; ++i)\n                    if ($util.Long)\n                        (message.dims[i] = $util.Long.fromValue(object.dims[i])).unsigned = false;\n                    else if (typeof object.dims[i] === \"string\")\n                        message.dims[i] = parseInt(object.dims[i], 10);\n                    else if (typeof object.dims[i] === \"number\")\n                        message.dims[i] = object.dims[i];\n                    else if (typeof object.dims[i] === \"object\")\n                        message.dims[i] = new $util.LongBits(object.dims[i].low >>> 0, object.dims[i].high >>> 0).toNumber();\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a SparseTensorProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.SparseTensorProto\n         * @static\n         * @param {onnx.SparseTensorProto} message SparseTensorProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        SparseTensorProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.dims = [];\n            if (options.defaults) {\n                object.values = null;\n                object.indices = null;\n            }\n            if (message.values != null && message.hasOwnProperty(\"values\"))\n                object.values = $root.onnx.TensorProto.toObject(message.values, options);\n            if (message.indices != null && message.hasOwnProperty(\"indices\"))\n                object.indices = $root.onnx.TensorProto.toObject(message.indices, options);\n            if (message.dims && message.dims.length) {\n                object.dims = [];\n                for (var j = 0; j < message.dims.length; ++j)\n                    if (typeof message.dims[j] === \"number\")\n                        object.dims[j] = options.longs === String ? String(message.dims[j]) : message.dims[j];\n                    else\n                        object.dims[j] = options.longs === String ? $util.Long.prototype.toString.call(message.dims[j]) : options.longs === Number ? new $util.LongBits(message.dims[j].low >>> 0, message.dims[j].high >>> 0).toNumber() : message.dims[j];\n            }\n            return object;\n        };\n\n        /**\n         * Converts this SparseTensorProto to JSON.\n         * @function toJSON\n         * @memberof onnx.SparseTensorProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        SparseTensorProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * Gets the default type url for SparseTensorProto\n         * @function getTypeUrl\n         * @memberof onnx.SparseTensorProto\n         * @static\n         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n         * @returns {string} The default type url\n         */\n        SparseTensorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === undefined) {\n                typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/onnx.SparseTensorProto\";\n        };\n\n        return SparseTensorProto;\n    })();\n\n    onnx.TensorShapeProto = (function() {\n\n        /**\n         * Properties of a TensorShapeProto.\n         * @memberof onnx\n         * @interface ITensorShapeProto\n         * @property {Array.<onnx.TensorShapeProto.IDimension>|null} [dim] TensorShapeProto dim\n         */\n\n        /**\n         * Constructs a new TensorShapeProto.\n         * @memberof onnx\n         * @classdesc Represents a TensorShapeProto.\n         * @implements ITensorShapeProto\n         * @constructor\n         * @param {onnx.ITensorShapeProto=} [properties] Properties to set\n         */\n        function TensorShapeProto(properties) {\n            this.dim = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * TensorShapeProto dim.\n         * @member {Array.<onnx.TensorShapeProto.IDimension>} dim\n         * @memberof onnx.TensorShapeProto\n         * @instance\n         */\n        TensorShapeProto.prototype.dim = $util.emptyArray;\n\n        /**\n         * Creates a new TensorShapeProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.TensorShapeProto\n         * @static\n         * @param {onnx.ITensorShapeProto=} [properties] Properties to set\n         * @returns {onnx.TensorShapeProto} TensorShapeProto instance\n         */\n        TensorShapeProto.create = function create(properties) {\n            return new TensorShapeProto(properties);\n        };\n\n        /**\n         * Encodes the specified TensorShapeProto message. Does not implicitly {@link onnx.TensorShapeProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.TensorShapeProto\n         * @static\n         * @param {onnx.ITensorShapeProto} message TensorShapeProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TensorShapeProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.dim != null && message.dim.length)\n                for (var i = 0; i < message.dim.length; ++i)\n                    $root.onnx.TensorShapeProto.Dimension.encode(message.dim[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified TensorShapeProto message, length delimited. Does not implicitly {@link onnx.TensorShapeProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.TensorShapeProto\n         * @static\n         * @param {onnx.ITensorShapeProto} message TensorShapeProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TensorShapeProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a TensorShapeProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.TensorShapeProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.TensorShapeProto} TensorShapeProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TensorShapeProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TensorShapeProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1: {\n                        if (!(message.dim && message.dim.length))\n                            message.dim = [];\n                        message.dim.push($root.onnx.TensorShapeProto.Dimension.decode(reader, reader.uint32()));\n                        break;\n                    }\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a TensorShapeProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.TensorShapeProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.TensorShapeProto} TensorShapeProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TensorShapeProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a TensorShapeProto message.\n         * @function verify\n         * @memberof onnx.TensorShapeProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        TensorShapeProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.dim != null && message.hasOwnProperty(\"dim\")) {\n                if (!Array.isArray(message.dim))\n                    return \"dim: array expected\";\n                for (var i = 0; i < message.dim.length; ++i) {\n                    var error = $root.onnx.TensorShapeProto.Dimension.verify(message.dim[i]);\n                    if (error)\n                        return \"dim.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a TensorShapeProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.TensorShapeProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.TensorShapeProto} TensorShapeProto\n         */\n        TensorShapeProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.TensorShapeProto)\n                return object;\n            var message = new $root.onnx.TensorShapeProto();\n            if (object.dim) {\n                if (!Array.isArray(object.dim))\n                    throw TypeError(\".onnx.TensorShapeProto.dim: array expected\");\n                message.dim = [];\n                for (var i = 0; i < object.dim.length; ++i) {\n                    if (typeof object.dim[i] !== \"object\")\n                        throw TypeError(\".onnx.TensorShapeProto.dim: object expected\");\n                    message.dim[i] = $root.onnx.TensorShapeProto.Dimension.fromObject(object.dim[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a TensorShapeProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.TensorShapeProto\n         * @static\n         * @param {onnx.TensorShapeProto} message TensorShapeProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        TensorShapeProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.dim = [];\n            if (message.dim && message.dim.length) {\n                object.dim = [];\n                for (var j = 0; j < message.dim.length; ++j)\n                    object.dim[j] = $root.onnx.TensorShapeProto.Dimension.toObject(message.dim[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this TensorShapeProto to JSON.\n         * @function toJSON\n         * @memberof onnx.TensorShapeProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        TensorShapeProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * Gets the default type url for TensorShapeProto\n         * @function getTypeUrl\n         * @memberof onnx.TensorShapeProto\n         * @static\n         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n         * @returns {string} The default type url\n         */\n        TensorShapeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === undefined) {\n                typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/onnx.TensorShapeProto\";\n        };\n\n        TensorShapeProto.Dimension = (function() {\n\n            /**\n             * Properties of a Dimension.\n             * @memberof onnx.TensorShapeProto\n             * @interface IDimension\n             * @property {number|Long|null} [dimValue] Dimension dimValue\n             * @property {string|null} [dimParam] Dimension dimParam\n             * @property {string|null} [denotation] Dimension denotation\n             */\n\n            /**\n             * Constructs a new Dimension.\n             * @memberof onnx.TensorShapeProto\n             * @classdesc Represents a Dimension.\n             * @implements IDimension\n             * @constructor\n             * @param {onnx.TensorShapeProto.IDimension=} [properties] Properties to set\n             */\n            function Dimension(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Dimension dimValue.\n             * @member {number|Long|null|undefined} dimValue\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @instance\n             */\n            Dimension.prototype.dimValue = null;\n\n            /**\n             * Dimension dimParam.\n             * @member {string|null|undefined} dimParam\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @instance\n             */\n            Dimension.prototype.dimParam = null;\n\n            /**\n             * Dimension denotation.\n             * @member {string} denotation\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @instance\n             */\n            Dimension.prototype.denotation = \"\";\n\n            // OneOf field names bound to virtual getters and setters\n            var $oneOfFields;\n\n            /**\n             * Dimension value.\n             * @member {\"dimValue\"|\"dimParam\"|undefined} value\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @instance\n             */\n            Object.defineProperty(Dimension.prototype, \"value\", {\n                get: $util.oneOfGetter($oneOfFields = [\"dimValue\", \"dimParam\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Creates a new Dimension instance using the specified properties.\n             * @function create\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @static\n             * @param {onnx.TensorShapeProto.IDimension=} [properties] Properties to set\n             * @returns {onnx.TensorShapeProto.Dimension} Dimension instance\n             */\n            Dimension.create = function create(properties) {\n                return new Dimension(properties);\n            };\n\n            /**\n             * Encodes the specified Dimension message. Does not implicitly {@link onnx.TensorShapeProto.Dimension.verify|verify} messages.\n             * @function encode\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @static\n             * @param {onnx.TensorShapeProto.IDimension} message Dimension message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Dimension.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.dimValue != null && Object.hasOwnProperty.call(message, \"dimValue\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.dimValue);\n                if (message.dimParam != null && Object.hasOwnProperty.call(message, \"dimParam\"))\n                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.dimParam);\n                if (message.denotation != null && Object.hasOwnProperty.call(message, \"denotation\"))\n                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.denotation);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Dimension message, length delimited. Does not implicitly {@link onnx.TensorShapeProto.Dimension.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @static\n             * @param {onnx.TensorShapeProto.IDimension} message Dimension message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Dimension.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Dimension message from the specified reader or buffer.\n             * @function decode\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {onnx.TensorShapeProto.Dimension} Dimension\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Dimension.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TensorShapeProto.Dimension();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1: {\n                            message.dimValue = reader.int64();\n                            break;\n                        }\n                    case 2: {\n                            message.dimParam = reader.string();\n                            break;\n                        }\n                    case 3: {\n                            message.denotation = reader.string();\n                            break;\n                        }\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Dimension message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {onnx.TensorShapeProto.Dimension} Dimension\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Dimension.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Dimension message.\n             * @function verify\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Dimension.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                var properties = {};\n                if (message.dimValue != null && message.hasOwnProperty(\"dimValue\")) {\n                    properties.value = 1;\n                    if (!$util.isInteger(message.dimValue) && !(message.dimValue && $util.isInteger(message.dimValue.low) && $util.isInteger(message.dimValue.high)))\n                        return \"dimValue: integer|Long expected\";\n                }\n                if (message.dimParam != null && message.hasOwnProperty(\"dimParam\")) {\n                    if (properties.value === 1)\n                        return \"value: multiple values\";\n                    properties.value = 1;\n                    if (!$util.isString(message.dimParam))\n                        return \"dimParam: string expected\";\n                }\n                if (message.denotation != null && message.hasOwnProperty(\"denotation\"))\n                    if (!$util.isString(message.denotation))\n                        return \"denotation: string expected\";\n                return null;\n            };\n\n            /**\n             * Creates a Dimension message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {onnx.TensorShapeProto.Dimension} Dimension\n             */\n            Dimension.fromObject = function fromObject(object) {\n                if (object instanceof $root.onnx.TensorShapeProto.Dimension)\n                    return object;\n                var message = new $root.onnx.TensorShapeProto.Dimension();\n                if (object.dimValue != null)\n                    if ($util.Long)\n                        (message.dimValue = $util.Long.fromValue(object.dimValue)).unsigned = false;\n                    else if (typeof object.dimValue === \"string\")\n                        message.dimValue = parseInt(object.dimValue, 10);\n                    else if (typeof object.dimValue === \"number\")\n                        message.dimValue = object.dimValue;\n                    else if (typeof object.dimValue === \"object\")\n                        message.dimValue = new $util.LongBits(object.dimValue.low >>> 0, object.dimValue.high >>> 0).toNumber();\n                if (object.dimParam != null)\n                    message.dimParam = String(object.dimParam);\n                if (object.denotation != null)\n                    message.denotation = String(object.denotation);\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Dimension message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @static\n             * @param {onnx.TensorShapeProto.Dimension} message Dimension\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Dimension.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults)\n                    object.denotation = \"\";\n                if (message.dimValue != null && message.hasOwnProperty(\"dimValue\")) {\n                    if (typeof message.dimValue === \"number\")\n                        object.dimValue = options.longs === String ? String(message.dimValue) : message.dimValue;\n                    else\n                        object.dimValue = options.longs === String ? $util.Long.prototype.toString.call(message.dimValue) : options.longs === Number ? new $util.LongBits(message.dimValue.low >>> 0, message.dimValue.high >>> 0).toNumber() : message.dimValue;\n                    if (options.oneofs)\n                        object.value = \"dimValue\";\n                }\n                if (message.dimParam != null && message.hasOwnProperty(\"dimParam\")) {\n                    object.dimParam = message.dimParam;\n                    if (options.oneofs)\n                        object.value = \"dimParam\";\n                }\n                if (message.denotation != null && message.hasOwnProperty(\"denotation\"))\n                    object.denotation = message.denotation;\n                return object;\n            };\n\n            /**\n             * Converts this Dimension to JSON.\n             * @function toJSON\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Dimension.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            /**\n             * Gets the default type url for Dimension\n             * @function getTypeUrl\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @static\n             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n             * @returns {string} The default type url\n             */\n            Dimension.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                if (typeUrlPrefix === undefined) {\n                    typeUrlPrefix = \"type.googleapis.com\";\n                }\n                return typeUrlPrefix + \"/onnx.TensorShapeProto.Dimension\";\n            };\n\n            return Dimension;\n        })();\n\n        return TensorShapeProto;\n    })();\n\n    onnx.TypeProto = (function() {\n\n        /**\n         * Properties of a TypeProto.\n         * @memberof onnx\n         * @interface ITypeProto\n         * @property {onnx.TypeProto.ITensor|null} [tensorType] TypeProto tensorType\n         * @property {onnx.TypeProto.ISequence|null} [sequenceType] TypeProto sequenceType\n         * @property {onnx.TypeProto.IMap|null} [mapType] TypeProto mapType\n         * @property {onnx.TypeProto.IOptional|null} [optionalType] TypeProto optionalType\n         * @property {onnx.TypeProto.ISparseTensor|null} [sparseTensorType] TypeProto sparseTensorType\n         * @property {string|null} [denotation] TypeProto denotation\n         */\n\n        /**\n         * Constructs a new TypeProto.\n         * @memberof onnx\n         * @classdesc Represents a TypeProto.\n         * @implements ITypeProto\n         * @constructor\n         * @param {onnx.ITypeProto=} [properties] Properties to set\n         */\n        function TypeProto(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * TypeProto tensorType.\n         * @member {onnx.TypeProto.ITensor|null|undefined} tensorType\n         * @memberof onnx.TypeProto\n         * @instance\n         */\n        TypeProto.prototype.tensorType = null;\n\n        /**\n         * TypeProto sequenceType.\n         * @member {onnx.TypeProto.ISequence|null|undefined} sequenceType\n         * @memberof onnx.TypeProto\n         * @instance\n         */\n        TypeProto.prototype.sequenceType = null;\n\n        /**\n         * TypeProto mapType.\n         * @member {onnx.TypeProto.IMap|null|undefined} mapType\n         * @memberof onnx.TypeProto\n         * @instance\n         */\n        TypeProto.prototype.mapType = null;\n\n        /**\n         * TypeProto optionalType.\n         * @member {onnx.TypeProto.IOptional|null|undefined} optionalType\n         * @memberof onnx.TypeProto\n         * @instance\n         */\n        TypeProto.prototype.optionalType = null;\n\n        /**\n         * TypeProto sparseTensorType.\n         * @member {onnx.TypeProto.ISparseTensor|null|undefined} sparseTensorType\n         * @memberof onnx.TypeProto\n         * @instance\n         */\n        TypeProto.prototype.sparseTensorType = null;\n\n        /**\n         * TypeProto denotation.\n         * @member {string} denotation\n         * @memberof onnx.TypeProto\n         * @instance\n         */\n        TypeProto.prototype.denotation = \"\";\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * TypeProto value.\n         * @member {\"tensorType\"|\"sequenceType\"|\"mapType\"|\"optionalType\"|\"sparseTensorType\"|undefined} value\n         * @memberof onnx.TypeProto\n         * @instance\n         */\n        Object.defineProperty(TypeProto.prototype, \"value\", {\n            get: $util.oneOfGetter($oneOfFields = [\"tensorType\", \"sequenceType\", \"mapType\", \"optionalType\", \"sparseTensorType\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new TypeProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.TypeProto\n         * @static\n         * @param {onnx.ITypeProto=} [properties] Properties to set\n         * @returns {onnx.TypeProto} TypeProto instance\n         */\n        TypeProto.create = function create(properties) {\n            return new TypeProto(properties);\n        };\n\n        /**\n         * Encodes the specified TypeProto message. Does not implicitly {@link onnx.TypeProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.TypeProto\n         * @static\n         * @param {onnx.ITypeProto} message TypeProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TypeProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.tensorType != null && Object.hasOwnProperty.call(message, \"tensorType\"))\n                $root.onnx.TypeProto.Tensor.encode(message.tensorType, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.sequenceType != null && Object.hasOwnProperty.call(message, \"sequenceType\"))\n                $root.onnx.TypeProto.Sequence.encode(message.sequenceType, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            if (message.mapType != null && Object.hasOwnProperty.call(message, \"mapType\"))\n                $root.onnx.TypeProto.Map.encode(message.mapType, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n            if (message.denotation != null && Object.hasOwnProperty.call(message, \"denotation\"))\n                writer.uint32(/* id 6, wireType 2 =*/50).string(message.denotation);\n            if (message.sparseTensorType != null && Object.hasOwnProperty.call(message, \"sparseTensorType\"))\n                $root.onnx.TypeProto.SparseTensor.encode(message.sparseTensorType, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n            if (message.optionalType != null && Object.hasOwnProperty.call(message, \"optionalType\"))\n                $root.onnx.TypeProto.Optional.encode(message.optionalType, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified TypeProto message, length delimited. Does not implicitly {@link onnx.TypeProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.TypeProto\n         * @static\n         * @param {onnx.ITypeProto} message TypeProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TypeProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a TypeProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.TypeProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.TypeProto} TypeProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TypeProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1: {\n                        message.tensorType = $root.onnx.TypeProto.Tensor.decode(reader, reader.uint32());\n                        break;\n                    }\n                case 4: {\n                        message.sequenceType = $root.onnx.TypeProto.Sequence.decode(reader, reader.uint32());\n                        break;\n                    }\n                case 5: {\n                        message.mapType = $root.onnx.TypeProto.Map.decode(reader, reader.uint32());\n                        break;\n                    }\n                case 9: {\n                        message.optionalType = $root.onnx.TypeProto.Optional.decode(reader, reader.uint32());\n                        break;\n                    }\n                case 8: {\n                        message.sparseTensorType = $root.onnx.TypeProto.SparseTensor.decode(reader, reader.uint32());\n                        break;\n                    }\n                case 6: {\n                        message.denotation = reader.string();\n                        break;\n                    }\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a TypeProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.TypeProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.TypeProto} TypeProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TypeProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a TypeProto message.\n         * @function verify\n         * @memberof onnx.TypeProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        TypeProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.tensorType != null && message.hasOwnProperty(\"tensorType\")) {\n                properties.value = 1;\n                {\n                    var error = $root.onnx.TypeProto.Tensor.verify(message.tensorType);\n                    if (error)\n                        return \"tensorType.\" + error;\n                }\n            }\n            if (message.sequenceType != null && message.hasOwnProperty(\"sequenceType\")) {\n                if (properties.value === 1)\n                    return \"value: multiple values\";\n                properties.value = 1;\n                {\n                    var error = $root.onnx.TypeProto.Sequence.verify(message.sequenceType);\n                    if (error)\n                        return \"sequenceType.\" + error;\n                }\n            }\n            if (message.mapType != null && message.hasOwnProperty(\"mapType\")) {\n                if (properties.value === 1)\n                    return \"value: multiple values\";\n                properties.value = 1;\n                {\n                    var error = $root.onnx.TypeProto.Map.verify(message.mapType);\n                    if (error)\n                        return \"mapType.\" + error;\n                }\n            }\n            if (message.optionalType != null && message.hasOwnProperty(\"optionalType\")) {\n                if (properties.value === 1)\n                    return \"value: multiple values\";\n                properties.value = 1;\n                {\n                    var error = $root.onnx.TypeProto.Optional.verify(message.optionalType);\n                    if (error)\n                        return \"optionalType.\" + error;\n                }\n            }\n            if (message.sparseTensorType != null && message.hasOwnProperty(\"sparseTensorType\")) {\n                if (properties.value === 1)\n                    return \"value: multiple values\";\n                properties.value = 1;\n                {\n                    var error = $root.onnx.TypeProto.SparseTensor.verify(message.sparseTensorType);\n                    if (error)\n                        return \"sparseTensorType.\" + error;\n                }\n            }\n            if (message.denotation != null && message.hasOwnProperty(\"denotation\"))\n                if (!$util.isString(message.denotation))\n                    return \"denotation: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a TypeProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.TypeProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.TypeProto} TypeProto\n         */\n        TypeProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.TypeProto)\n                return object;\n            var message = new $root.onnx.TypeProto();\n            if (object.tensorType != null) {\n                if (typeof object.tensorType !== \"object\")\n                    throw TypeError(\".onnx.TypeProto.tensorType: object expected\");\n                message.tensorType = $root.onnx.TypeProto.Tensor.fromObject(object.tensorType);\n            }\n            if (object.sequenceType != null) {\n                if (typeof object.sequenceType !== \"object\")\n                    throw TypeError(\".onnx.TypeProto.sequenceType: object expected\");\n                message.sequenceType = $root.onnx.TypeProto.Sequence.fromObject(object.sequenceType);\n            }\n            if (object.mapType != null) {\n                if (typeof object.mapType !== \"object\")\n                    throw TypeError(\".onnx.TypeProto.mapType: object expected\");\n                message.mapType = $root.onnx.TypeProto.Map.fromObject(object.mapType);\n            }\n            if (object.optionalType != null) {\n                if (typeof object.optionalType !== \"object\")\n                    throw TypeError(\".onnx.TypeProto.optionalType: object expected\");\n                message.optionalType = $root.onnx.TypeProto.Optional.fromObject(object.optionalType);\n            }\n            if (object.sparseTensorType != null) {\n                if (typeof object.sparseTensorType !== \"object\")\n                    throw TypeError(\".onnx.TypeProto.sparseTensorType: object expected\");\n                message.sparseTensorType = $root.onnx.TypeProto.SparseTensor.fromObject(object.sparseTensorType);\n            }\n            if (object.denotation != null)\n                message.denotation = String(object.denotation);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a TypeProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.TypeProto\n         * @static\n         * @param {onnx.TypeProto} message TypeProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        TypeProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults)\n                object.denotation = \"\";\n            if (message.tensorType != null && message.hasOwnProperty(\"tensorType\")) {\n                object.tensorType = $root.onnx.TypeProto.Tensor.toObject(message.tensorType, options);\n                if (options.oneofs)\n                    object.value = \"tensorType\";\n            }\n            if (message.sequenceType != null && message.hasOwnProperty(\"sequenceType\")) {\n                object.sequenceType = $root.onnx.TypeProto.Sequence.toObject(message.sequenceType, options);\n                if (options.oneofs)\n                    object.value = \"sequenceType\";\n            }\n            if (message.mapType != null && message.hasOwnProperty(\"mapType\")) {\n                object.mapType = $root.onnx.TypeProto.Map.toObject(message.mapType, options);\n                if (options.oneofs)\n                    object.value = \"mapType\";\n            }\n            if (message.denotation != null && message.hasOwnProperty(\"denotation\"))\n                object.denotation = message.denotation;\n            if (message.sparseTensorType != null && message.hasOwnProperty(\"sparseTensorType\")) {\n                object.sparseTensorType = $root.onnx.TypeProto.SparseTensor.toObject(message.sparseTensorType, options);\n                if (options.oneofs)\n                    object.value = \"sparseTensorType\";\n            }\n            if (message.optionalType != null && message.hasOwnProperty(\"optionalType\")) {\n                object.optionalType = $root.onnx.TypeProto.Optional.toObject(message.optionalType, options);\n                if (options.oneofs)\n                    object.value = \"optionalType\";\n            }\n            return object;\n        };\n\n        /**\n         * Converts this TypeProto to JSON.\n         * @function toJSON\n         * @memberof onnx.TypeProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        TypeProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * Gets the default type url for TypeProto\n         * @function getTypeUrl\n         * @memberof onnx.TypeProto\n         * @static\n         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n         * @returns {string} The default type url\n         */\n        TypeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === undefined) {\n                typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/onnx.TypeProto\";\n        };\n\n        TypeProto.Tensor = (function() {\n\n            /**\n             * Properties of a Tensor.\n             * @memberof onnx.TypeProto\n             * @interface ITensor\n             * @property {number|null} [elemType] Tensor elemType\n             * @property {onnx.ITensorShapeProto|null} [shape] Tensor shape\n             */\n\n            /**\n             * Constructs a new Tensor.\n             * @memberof onnx.TypeProto\n             * @classdesc Represents a Tensor.\n             * @implements ITensor\n             * @constructor\n             * @param {onnx.TypeProto.ITensor=} [properties] Properties to set\n             */\n            function Tensor(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Tensor elemType.\n             * @member {number} elemType\n             * @memberof onnx.TypeProto.Tensor\n             * @instance\n             */\n            Tensor.prototype.elemType = 0;\n\n            /**\n             * Tensor shape.\n             * @member {onnx.ITensorShapeProto|null|undefined} shape\n             * @memberof onnx.TypeProto.Tensor\n             * @instance\n             */\n            Tensor.prototype.shape = null;\n\n            /**\n             * Creates a new Tensor instance using the specified properties.\n             * @function create\n             * @memberof onnx.TypeProto.Tensor\n             * @static\n             * @param {onnx.TypeProto.ITensor=} [properties] Properties to set\n             * @returns {onnx.TypeProto.Tensor} Tensor instance\n             */\n            Tensor.create = function create(properties) {\n                return new Tensor(properties);\n            };\n\n            /**\n             * Encodes the specified Tensor message. Does not implicitly {@link onnx.TypeProto.Tensor.verify|verify} messages.\n             * @function encode\n             * @memberof onnx.TypeProto.Tensor\n             * @static\n             * @param {onnx.TypeProto.ITensor} message Tensor message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Tensor.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.elemType != null && Object.hasOwnProperty.call(message, \"elemType\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.elemType);\n                if (message.shape != null && Object.hasOwnProperty.call(message, \"shape\"))\n                    $root.onnx.TensorShapeProto.encode(message.shape, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Tensor message, length delimited. Does not implicitly {@link onnx.TypeProto.Tensor.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof onnx.TypeProto.Tensor\n             * @static\n             * @param {onnx.TypeProto.ITensor} message Tensor message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Tensor.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Tensor message from the specified reader or buffer.\n             * @function decode\n             * @memberof onnx.TypeProto.Tensor\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {onnx.TypeProto.Tensor} Tensor\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Tensor.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Tensor();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1: {\n                            message.elemType = reader.int32();\n                            break;\n                        }\n                    case 2: {\n                            message.shape = $root.onnx.TensorShapeProto.decode(reader, reader.uint32());\n                            break;\n                        }\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Tensor message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof onnx.TypeProto.Tensor\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {onnx.TypeProto.Tensor} Tensor\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Tensor.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Tensor message.\n             * @function verify\n             * @memberof onnx.TypeProto.Tensor\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Tensor.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.elemType != null && message.hasOwnProperty(\"elemType\"))\n                    if (!$util.isInteger(message.elemType))\n                        return \"elemType: integer expected\";\n                if (message.shape != null && message.hasOwnProperty(\"shape\")) {\n                    var error = $root.onnx.TensorShapeProto.verify(message.shape);\n                    if (error)\n                        return \"shape.\" + error;\n                }\n                return null;\n            };\n\n            /**\n             * Creates a Tensor message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof onnx.TypeProto.Tensor\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {onnx.TypeProto.Tensor} Tensor\n             */\n            Tensor.fromObject = function fromObject(object) {\n                if (object instanceof $root.onnx.TypeProto.Tensor)\n                    return object;\n                var message = new $root.onnx.TypeProto.Tensor();\n                if (object.elemType != null)\n                    message.elemType = object.elemType | 0;\n                if (object.shape != null) {\n                    if (typeof object.shape !== \"object\")\n                        throw TypeError(\".onnx.TypeProto.Tensor.shape: object expected\");\n                    message.shape = $root.onnx.TensorShapeProto.fromObject(object.shape);\n                }\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Tensor message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof onnx.TypeProto.Tensor\n             * @static\n             * @param {onnx.TypeProto.Tensor} message Tensor\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Tensor.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.elemType = 0;\n                    object.shape = null;\n                }\n                if (message.elemType != null && message.hasOwnProperty(\"elemType\"))\n                    object.elemType = message.elemType;\n                if (message.shape != null && message.hasOwnProperty(\"shape\"))\n                    object.shape = $root.onnx.TensorShapeProto.toObject(message.shape, options);\n                return object;\n            };\n\n            /**\n             * Converts this Tensor to JSON.\n             * @function toJSON\n             * @memberof onnx.TypeProto.Tensor\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Tensor.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            /**\n             * Gets the default type url for Tensor\n             * @function getTypeUrl\n             * @memberof onnx.TypeProto.Tensor\n             * @static\n             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n             * @returns {string} The default type url\n             */\n            Tensor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                if (typeUrlPrefix === undefined) {\n                    typeUrlPrefix = \"type.googleapis.com\";\n                }\n                return typeUrlPrefix + \"/onnx.TypeProto.Tensor\";\n            };\n\n            return Tensor;\n        })();\n\n        TypeProto.Sequence = (function() {\n\n            /**\n             * Properties of a Sequence.\n             * @memberof onnx.TypeProto\n             * @interface ISequence\n             * @property {onnx.ITypeProto|null} [elemType] Sequence elemType\n             */\n\n            /**\n             * Constructs a new Sequence.\n             * @memberof onnx.TypeProto\n             * @classdesc Represents a Sequence.\n             * @implements ISequence\n             * @constructor\n             * @param {onnx.TypeProto.ISequence=} [properties] Properties to set\n             */\n            function Sequence(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Sequence elemType.\n             * @member {onnx.ITypeProto|null|undefined} elemType\n             * @memberof onnx.TypeProto.Sequence\n             * @instance\n             */\n            Sequence.prototype.elemType = null;\n\n            /**\n             * Creates a new Sequence instance using the specified properties.\n             * @function create\n             * @memberof onnx.TypeProto.Sequence\n             * @static\n             * @param {onnx.TypeProto.ISequence=} [properties] Properties to set\n             * @returns {onnx.TypeProto.Sequence} Sequence instance\n             */\n            Sequence.create = function create(properties) {\n                return new Sequence(properties);\n            };\n\n            /**\n             * Encodes the specified Sequence message. Does not implicitly {@link onnx.TypeProto.Sequence.verify|verify} messages.\n             * @function encode\n             * @memberof onnx.TypeProto.Sequence\n             * @static\n             * @param {onnx.TypeProto.ISequence} message Sequence message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Sequence.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.elemType != null && Object.hasOwnProperty.call(message, \"elemType\"))\n                    $root.onnx.TypeProto.encode(message.elemType, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Sequence message, length delimited. Does not implicitly {@link onnx.TypeProto.Sequence.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof onnx.TypeProto.Sequence\n             * @static\n             * @param {onnx.TypeProto.ISequence} message Sequence message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Sequence.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Sequence message from the specified reader or buffer.\n             * @function decode\n             * @memberof onnx.TypeProto.Sequence\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {onnx.TypeProto.Sequence} Sequence\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Sequence.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Sequence();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1: {\n                            message.elemType = $root.onnx.TypeProto.decode(reader, reader.uint32());\n                            break;\n                        }\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Sequence message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof onnx.TypeProto.Sequence\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {onnx.TypeProto.Sequence} Sequence\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Sequence.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Sequence message.\n             * @function verify\n             * @memberof onnx.TypeProto.Sequence\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Sequence.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.elemType != null && message.hasOwnProperty(\"elemType\")) {\n                    var error = $root.onnx.TypeProto.verify(message.elemType);\n                    if (error)\n                        return \"elemType.\" + error;\n                }\n                return null;\n            };\n\n            /**\n             * Creates a Sequence message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof onnx.TypeProto.Sequence\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {onnx.TypeProto.Sequence} Sequence\n             */\n            Sequence.fromObject = function fromObject(object) {\n                if (object instanceof $root.onnx.TypeProto.Sequence)\n                    return object;\n                var message = new $root.onnx.TypeProto.Sequence();\n                if (object.elemType != null) {\n                    if (typeof object.elemType !== \"object\")\n                        throw TypeError(\".onnx.TypeProto.Sequence.elemType: object expected\");\n                    message.elemType = $root.onnx.TypeProto.fromObject(object.elemType);\n                }\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Sequence message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof onnx.TypeProto.Sequence\n             * @static\n             * @param {onnx.TypeProto.Sequence} message Sequence\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Sequence.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults)\n                    object.elemType = null;\n                if (message.elemType != null && message.hasOwnProperty(\"elemType\"))\n                    object.elemType = $root.onnx.TypeProto.toObject(message.elemType, options);\n                return object;\n            };\n\n            /**\n             * Converts this Sequence to JSON.\n             * @function toJSON\n             * @memberof onnx.TypeProto.Sequence\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Sequence.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            /**\n             * Gets the default type url for Sequence\n             * @function getTypeUrl\n             * @memberof onnx.TypeProto.Sequence\n             * @static\n             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n             * @returns {string} The default type url\n             */\n            Sequence.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                if (typeUrlPrefix === undefined) {\n                    typeUrlPrefix = \"type.googleapis.com\";\n                }\n                return typeUrlPrefix + \"/onnx.TypeProto.Sequence\";\n            };\n\n            return Sequence;\n        })();\n\n        TypeProto.Map = (function() {\n\n            /**\n             * Properties of a Map.\n             * @memberof onnx.TypeProto\n             * @interface IMap\n             * @property {number|null} [keyType] Map keyType\n             * @property {onnx.ITypeProto|null} [valueType] Map valueType\n             */\n\n            /**\n             * Constructs a new Map.\n             * @memberof onnx.TypeProto\n             * @classdesc Represents a Map.\n             * @implements IMap\n             * @constructor\n             * @param {onnx.TypeProto.IMap=} [properties] Properties to set\n             */\n            function Map(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Map keyType.\n             * @member {number} keyType\n             * @memberof onnx.TypeProto.Map\n             * @instance\n             */\n            Map.prototype.keyType = 0;\n\n            /**\n             * Map valueType.\n             * @member {onnx.ITypeProto|null|undefined} valueType\n             * @memberof onnx.TypeProto.Map\n             * @instance\n             */\n            Map.prototype.valueType = null;\n\n            /**\n             * Creates a new Map instance using the specified properties.\n             * @function create\n             * @memberof onnx.TypeProto.Map\n             * @static\n             * @param {onnx.TypeProto.IMap=} [properties] Properties to set\n             * @returns {onnx.TypeProto.Map} Map instance\n             */\n            Map.create = function create(properties) {\n                return new Map(properties);\n            };\n\n            /**\n             * Encodes the specified Map message. Does not implicitly {@link onnx.TypeProto.Map.verify|verify} messages.\n             * @function encode\n             * @memberof onnx.TypeProto.Map\n             * @static\n             * @param {onnx.TypeProto.IMap} message Map message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Map.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.keyType != null && Object.hasOwnProperty.call(message, \"keyType\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.keyType);\n                if (message.valueType != null && Object.hasOwnProperty.call(message, \"valueType\"))\n                    $root.onnx.TypeProto.encode(message.valueType, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Map message, length delimited. Does not implicitly {@link onnx.TypeProto.Map.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof onnx.TypeProto.Map\n             * @static\n             * @param {onnx.TypeProto.IMap} message Map message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Map.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Map message from the specified reader or buffer.\n             * @function decode\n             * @memberof onnx.TypeProto.Map\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {onnx.TypeProto.Map} Map\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Map.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Map();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1: {\n                            message.keyType = reader.int32();\n                            break;\n                        }\n                    case 2: {\n                            message.valueType = $root.onnx.TypeProto.decode(reader, reader.uint32());\n                            break;\n                        }\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Map message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof onnx.TypeProto.Map\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {onnx.TypeProto.Map} Map\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Map.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Map message.\n             * @function verify\n             * @memberof onnx.TypeProto.Map\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Map.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.keyType != null && message.hasOwnProperty(\"keyType\"))\n                    if (!$util.isInteger(message.keyType))\n                        return \"keyType: integer expected\";\n                if (message.valueType != null && message.hasOwnProperty(\"valueType\")) {\n                    var error = $root.onnx.TypeProto.verify(message.valueType);\n                    if (error)\n                        return \"valueType.\" + error;\n                }\n                return null;\n            };\n\n            /**\n             * Creates a Map message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof onnx.TypeProto.Map\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {onnx.TypeProto.Map} Map\n             */\n            Map.fromObject = function fromObject(object) {\n                if (object instanceof $root.onnx.TypeProto.Map)\n                    return object;\n                var message = new $root.onnx.TypeProto.Map();\n                if (object.keyType != null)\n                    message.keyType = object.keyType | 0;\n                if (object.valueType != null) {\n                    if (typeof object.valueType !== \"object\")\n                        throw TypeError(\".onnx.TypeProto.Map.valueType: object expected\");\n                    message.valueType = $root.onnx.TypeProto.fromObject(object.valueType);\n                }\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Map message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof onnx.TypeProto.Map\n             * @static\n             * @param {onnx.TypeProto.Map} message Map\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Map.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.keyType = 0;\n                    object.valueType = null;\n                }\n                if (message.keyType != null && message.hasOwnProperty(\"keyType\"))\n                    object.keyType = message.keyType;\n                if (message.valueType != null && message.hasOwnProperty(\"valueType\"))\n                    object.valueType = $root.onnx.TypeProto.toObject(message.valueType, options);\n                return object;\n            };\n\n            /**\n             * Converts this Map to JSON.\n             * @function toJSON\n             * @memberof onnx.TypeProto.Map\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Map.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            /**\n             * Gets the default type url for Map\n             * @function getTypeUrl\n             * @memberof onnx.TypeProto.Map\n             * @static\n             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n             * @returns {string} The default type url\n             */\n            Map.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                if (typeUrlPrefix === undefined) {\n                    typeUrlPrefix = \"type.googleapis.com\";\n                }\n                return typeUrlPrefix + \"/onnx.TypeProto.Map\";\n            };\n\n            return Map;\n        })();\n\n        TypeProto.Optional = (function() {\n\n            /**\n             * Properties of an Optional.\n             * @memberof onnx.TypeProto\n             * @interface IOptional\n             * @property {onnx.ITypeProto|null} [elemType] Optional elemType\n             */\n\n            /**\n             * Constructs a new Optional.\n             * @memberof onnx.TypeProto\n             * @classdesc Represents an Optional.\n             * @implements IOptional\n             * @constructor\n             * @param {onnx.TypeProto.IOptional=} [properties] Properties to set\n             */\n            function Optional(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Optional elemType.\n             * @member {onnx.ITypeProto|null|undefined} elemType\n             * @memberof onnx.TypeProto.Optional\n             * @instance\n             */\n            Optional.prototype.elemType = null;\n\n            /**\n             * Creates a new Optional instance using the specified properties.\n             * @function create\n             * @memberof onnx.TypeProto.Optional\n             * @static\n             * @param {onnx.TypeProto.IOptional=} [properties] Properties to set\n             * @returns {onnx.TypeProto.Optional} Optional instance\n             */\n            Optional.create = function create(properties) {\n                return new Optional(properties);\n            };\n\n            /**\n             * Encodes the specified Optional message. Does not implicitly {@link onnx.TypeProto.Optional.verify|verify} messages.\n             * @function encode\n             * @memberof onnx.TypeProto.Optional\n             * @static\n             * @param {onnx.TypeProto.IOptional} message Optional message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Optional.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.elemType != null && Object.hasOwnProperty.call(message, \"elemType\"))\n                    $root.onnx.TypeProto.encode(message.elemType, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Optional message, length delimited. Does not implicitly {@link onnx.TypeProto.Optional.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof onnx.TypeProto.Optional\n             * @static\n             * @param {onnx.TypeProto.IOptional} message Optional message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Optional.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes an Optional message from the specified reader or buffer.\n             * @function decode\n             * @memberof onnx.TypeProto.Optional\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {onnx.TypeProto.Optional} Optional\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Optional.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Optional();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1: {\n                            message.elemType = $root.onnx.TypeProto.decode(reader, reader.uint32());\n                            break;\n                        }\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes an Optional message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof onnx.TypeProto.Optional\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {onnx.TypeProto.Optional} Optional\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Optional.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies an Optional message.\n             * @function verify\n             * @memberof onnx.TypeProto.Optional\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Optional.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.elemType != null && message.hasOwnProperty(\"elemType\")) {\n                    var error = $root.onnx.TypeProto.verify(message.elemType);\n                    if (error)\n                        return \"elemType.\" + error;\n                }\n                return null;\n            };\n\n            /**\n             * Creates an Optional message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof onnx.TypeProto.Optional\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {onnx.TypeProto.Optional} Optional\n             */\n            Optional.fromObject = function fromObject(object) {\n                if (object instanceof $root.onnx.TypeProto.Optional)\n                    return object;\n                var message = new $root.onnx.TypeProto.Optional();\n                if (object.elemType != null) {\n                    if (typeof object.elemType !== \"object\")\n                        throw TypeError(\".onnx.TypeProto.Optional.elemType: object expected\");\n                    message.elemType = $root.onnx.TypeProto.fromObject(object.elemType);\n                }\n                return message;\n            };\n\n            /**\n             * Creates a plain object from an Optional message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof onnx.TypeProto.Optional\n             * @static\n             * @param {onnx.TypeProto.Optional} message Optional\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Optional.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults)\n                    object.elemType = null;\n                if (message.elemType != null && message.hasOwnProperty(\"elemType\"))\n                    object.elemType = $root.onnx.TypeProto.toObject(message.elemType, options);\n                return object;\n            };\n\n            /**\n             * Converts this Optional to JSON.\n             * @function toJSON\n             * @memberof onnx.TypeProto.Optional\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Optional.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            /**\n             * Gets the default type url for Optional\n             * @function getTypeUrl\n             * @memberof onnx.TypeProto.Optional\n             * @static\n             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n             * @returns {string} The default type url\n             */\n            Optional.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                if (typeUrlPrefix === undefined) {\n                    typeUrlPrefix = \"type.googleapis.com\";\n                }\n                return typeUrlPrefix + \"/onnx.TypeProto.Optional\";\n            };\n\n            return Optional;\n        })();\n\n        TypeProto.SparseTensor = (function() {\n\n            /**\n             * Properties of a SparseTensor.\n             * @memberof onnx.TypeProto\n             * @interface ISparseTensor\n             * @property {number|null} [elemType] SparseTensor elemType\n             * @property {onnx.ITensorShapeProto|null} [shape] SparseTensor shape\n             */\n\n            /**\n             * Constructs a new SparseTensor.\n             * @memberof onnx.TypeProto\n             * @classdesc Represents a SparseTensor.\n             * @implements ISparseTensor\n             * @constructor\n             * @param {onnx.TypeProto.ISparseTensor=} [properties] Properties to set\n             */\n            function SparseTensor(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * SparseTensor elemType.\n             * @member {number} elemType\n             * @memberof onnx.TypeProto.SparseTensor\n             * @instance\n             */\n            SparseTensor.prototype.elemType = 0;\n\n            /**\n             * SparseTensor shape.\n             * @member {onnx.ITensorShapeProto|null|undefined} shape\n             * @memberof onnx.TypeProto.SparseTensor\n             * @instance\n             */\n            SparseTensor.prototype.shape = null;\n\n            /**\n             * Creates a new SparseTensor instance using the specified properties.\n             * @function create\n             * @memberof onnx.TypeProto.SparseTensor\n             * @static\n             * @param {onnx.TypeProto.ISparseTensor=} [properties] Properties to set\n             * @returns {onnx.TypeProto.SparseTensor} SparseTensor instance\n             */\n            SparseTensor.create = function create(properties) {\n                return new SparseTensor(properties);\n            };\n\n            /**\n             * Encodes the specified SparseTensor message. Does not implicitly {@link onnx.TypeProto.SparseTensor.verify|verify} messages.\n             * @function encode\n             * @memberof onnx.TypeProto.SparseTensor\n             * @static\n             * @param {onnx.TypeProto.ISparseTensor} message SparseTensor message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SparseTensor.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.elemType != null && Object.hasOwnProperty.call(message, \"elemType\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.elemType);\n                if (message.shape != null && Object.hasOwnProperty.call(message, \"shape\"))\n                    $root.onnx.TensorShapeProto.encode(message.shape, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                return writer;\n            };\n\n            /**\n             * Encodes the specified SparseTensor message, length delimited. Does not implicitly {@link onnx.TypeProto.SparseTensor.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof onnx.TypeProto.SparseTensor\n             * @static\n             * @param {onnx.TypeProto.ISparseTensor} message SparseTensor message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SparseTensor.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a SparseTensor message from the specified reader or buffer.\n             * @function decode\n             * @memberof onnx.TypeProto.SparseTensor\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {onnx.TypeProto.SparseTensor} SparseTensor\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SparseTensor.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.SparseTensor();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1: {\n                            message.elemType = reader.int32();\n                            break;\n                        }\n                    case 2: {\n                            message.shape = $root.onnx.TensorShapeProto.decode(reader, reader.uint32());\n                            break;\n                        }\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a SparseTensor message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof onnx.TypeProto.SparseTensor\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {onnx.TypeProto.SparseTensor} SparseTensor\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SparseTensor.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a SparseTensor message.\n             * @function verify\n             * @memberof onnx.TypeProto.SparseTensor\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            SparseTensor.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.elemType != null && message.hasOwnProperty(\"elemType\"))\n                    if (!$util.isInteger(message.elemType))\n                        return \"elemType: integer expected\";\n                if (message.shape != null && message.hasOwnProperty(\"shape\")) {\n                    var error = $root.onnx.TensorShapeProto.verify(message.shape);\n                    if (error)\n                        return \"shape.\" + error;\n                }\n                return null;\n            };\n\n            /**\n             * Creates a SparseTensor message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof onnx.TypeProto.SparseTensor\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {onnx.TypeProto.SparseTensor} SparseTensor\n             */\n            SparseTensor.fromObject = function fromObject(object) {\n                if (object instanceof $root.onnx.TypeProto.SparseTensor)\n                    return object;\n                var message = new $root.onnx.TypeProto.SparseTensor();\n                if (object.elemType != null)\n                    message.elemType = object.elemType | 0;\n                if (object.shape != null) {\n                    if (typeof object.shape !== \"object\")\n                        throw TypeError(\".onnx.TypeProto.SparseTensor.shape: object expected\");\n                    message.shape = $root.onnx.TensorShapeProto.fromObject(object.shape);\n                }\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a SparseTensor message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof onnx.TypeProto.SparseTensor\n             * @static\n             * @param {onnx.TypeProto.SparseTensor} message SparseTensor\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            SparseTensor.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.elemType = 0;\n                    object.shape = null;\n                }\n                if (message.elemType != null && message.hasOwnProperty(\"elemType\"))\n                    object.elemType = message.elemType;\n                if (message.shape != null && message.hasOwnProperty(\"shape\"))\n                    object.shape = $root.onnx.TensorShapeProto.toObject(message.shape, options);\n                return object;\n            };\n\n            /**\n             * Converts this SparseTensor to JSON.\n             * @function toJSON\n             * @memberof onnx.TypeProto.SparseTensor\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            SparseTensor.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            /**\n             * Gets the default type url for SparseTensor\n             * @function getTypeUrl\n             * @memberof onnx.TypeProto.SparseTensor\n             * @static\n             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n             * @returns {string} The default type url\n             */\n            SparseTensor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                if (typeUrlPrefix === undefined) {\n                    typeUrlPrefix = \"type.googleapis.com\";\n                }\n                return typeUrlPrefix + \"/onnx.TypeProto.SparseTensor\";\n            };\n\n            return SparseTensor;\n        })();\n\n        return TypeProto;\n    })();\n\n    onnx.OperatorSetIdProto = (function() {\n\n        /**\n         * Properties of an OperatorSetIdProto.\n         * @memberof onnx\n         * @interface IOperatorSetIdProto\n         * @property {string|null} [domain] OperatorSetIdProto domain\n         * @property {number|Long|null} [version] OperatorSetIdProto version\n         */\n\n        /**\n         * Constructs a new OperatorSetIdProto.\n         * @memberof onnx\n         * @classdesc Represents an OperatorSetIdProto.\n         * @implements IOperatorSetIdProto\n         * @constructor\n         * @param {onnx.IOperatorSetIdProto=} [properties] Properties to set\n         */\n        function OperatorSetIdProto(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * OperatorSetIdProto domain.\n         * @member {string} domain\n         * @memberof onnx.OperatorSetIdProto\n         * @instance\n         */\n        OperatorSetIdProto.prototype.domain = \"\";\n\n        /**\n         * OperatorSetIdProto version.\n         * @member {number|Long} version\n         * @memberof onnx.OperatorSetIdProto\n         * @instance\n         */\n        OperatorSetIdProto.prototype.version = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * Creates a new OperatorSetIdProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.OperatorSetIdProto\n         * @static\n         * @param {onnx.IOperatorSetIdProto=} [properties] Properties to set\n         * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto instance\n         */\n        OperatorSetIdProto.create = function create(properties) {\n            return new OperatorSetIdProto(properties);\n        };\n\n        /**\n         * Encodes the specified OperatorSetIdProto message. Does not implicitly {@link onnx.OperatorSetIdProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.OperatorSetIdProto\n         * @static\n         * @param {onnx.IOperatorSetIdProto} message OperatorSetIdProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        OperatorSetIdProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.domain != null && Object.hasOwnProperty.call(message, \"domain\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.domain);\n            if (message.version != null && Object.hasOwnProperty.call(message, \"version\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.version);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified OperatorSetIdProto message, length delimited. Does not implicitly {@link onnx.OperatorSetIdProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.OperatorSetIdProto\n         * @static\n         * @param {onnx.IOperatorSetIdProto} message OperatorSetIdProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        OperatorSetIdProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an OperatorSetIdProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.OperatorSetIdProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        OperatorSetIdProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.OperatorSetIdProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1: {\n                        message.domain = reader.string();\n                        break;\n                    }\n                case 2: {\n                        message.version = reader.int64();\n                        break;\n                    }\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an OperatorSetIdProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.OperatorSetIdProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        OperatorSetIdProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an OperatorSetIdProto message.\n         * @function verify\n         * @memberof onnx.OperatorSetIdProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        OperatorSetIdProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.domain != null && message.hasOwnProperty(\"domain\"))\n                if (!$util.isString(message.domain))\n                    return \"domain: string expected\";\n            if (message.version != null && message.hasOwnProperty(\"version\"))\n                if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))\n                    return \"version: integer|Long expected\";\n            return null;\n        };\n\n        /**\n         * Creates an OperatorSetIdProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.OperatorSetIdProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto\n         */\n        OperatorSetIdProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.OperatorSetIdProto)\n                return object;\n            var message = new $root.onnx.OperatorSetIdProto();\n            if (object.domain != null)\n                message.domain = String(object.domain);\n            if (object.version != null)\n                if ($util.Long)\n                    (message.version = $util.Long.fromValue(object.version)).unsigned = false;\n                else if (typeof object.version === \"string\")\n                    message.version = parseInt(object.version, 10);\n                else if (typeof object.version === \"number\")\n                    message.version = object.version;\n                else if (typeof object.version === \"object\")\n                    message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber();\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an OperatorSetIdProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.OperatorSetIdProto\n         * @static\n         * @param {onnx.OperatorSetIdProto} message OperatorSetIdProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        OperatorSetIdProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.domain = \"\";\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.version = options.longs === String ? \"0\" : 0;\n            }\n            if (message.domain != null && message.hasOwnProperty(\"domain\"))\n                object.domain = message.domain;\n            if (message.version != null && message.hasOwnProperty(\"version\"))\n                if (typeof message.version === \"number\")\n                    object.version = options.longs === String ? String(message.version) : message.version;\n                else\n                    object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber() : message.version;\n            return object;\n        };\n\n        /**\n         * Converts this OperatorSetIdProto to JSON.\n         * @function toJSON\n         * @memberof onnx.OperatorSetIdProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        OperatorSetIdProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * Gets the default type url for OperatorSetIdProto\n         * @function getTypeUrl\n         * @memberof onnx.OperatorSetIdProto\n         * @static\n         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n         * @returns {string} The default type url\n         */\n        OperatorSetIdProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === undefined) {\n                typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/onnx.OperatorSetIdProto\";\n        };\n\n        return OperatorSetIdProto;\n    })();\n\n    /**\n     * OperatorStatus enum.\n     * @name onnx.OperatorStatus\n     * @enum {number}\n     * @property {number} EXPERIMENTAL=0 EXPERIMENTAL value\n     * @property {number} STABLE=1 STABLE value\n     */\n    onnx.OperatorStatus = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"EXPERIMENTAL\"] = 0;\n        values[valuesById[1] = \"STABLE\"] = 1;\n        return values;\n    })();\n\n    onnx.FunctionProto = (function() {\n\n        /**\n         * Properties of a FunctionProto.\n         * @memberof onnx\n         * @interface IFunctionProto\n         * @property {string|null} [name] FunctionProto name\n         * @property {Array.<string>|null} [input] FunctionProto input\n         * @property {Array.<string>|null} [output] FunctionProto output\n         * @property {Array.<string>|null} [attribute] FunctionProto attribute\n         * @property {Array.<onnx.IAttributeProto>|null} [attributeProto] FunctionProto attributeProto\n         * @property {Array.<onnx.INodeProto>|null} [node] FunctionProto node\n         * @property {string|null} [docString] FunctionProto docString\n         * @property {Array.<onnx.IOperatorSetIdProto>|null} [opsetImport] FunctionProto opsetImport\n         * @property {string|null} [domain] FunctionProto domain\n         */\n\n        /**\n         * Constructs a new FunctionProto.\n         * @memberof onnx\n         * @classdesc Represents a FunctionProto.\n         * @implements IFunctionProto\n         * @constructor\n         * @param {onnx.IFunctionProto=} [properties] Properties to set\n         */\n        function FunctionProto(properties) {\n            this.input = [];\n            this.output = [];\n            this.attribute = [];\n            this.attributeProto = [];\n            this.node = [];\n            this.opsetImport = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * FunctionProto name.\n         * @member {string} name\n         * @memberof onnx.FunctionProto\n         * @instance\n         */\n        FunctionProto.prototype.name = \"\";\n\n        /**\n         * FunctionProto input.\n         * @member {Array.<string>} input\n         * @memberof onnx.FunctionProto\n         * @instance\n         */\n        FunctionProto.prototype.input = $util.emptyArray;\n\n        /**\n         * FunctionProto output.\n         * @member {Array.<string>} output\n         * @memberof onnx.FunctionProto\n         * @instance\n         */\n        FunctionProto.prototype.output = $util.emptyArray;\n\n        /**\n         * FunctionProto attribute.\n         * @member {Array.<string>} attribute\n         * @memberof onnx.FunctionProto\n         * @instance\n         */\n        FunctionProto.prototype.attribute = $util.emptyArray;\n\n        /**\n         * FunctionProto attributeProto.\n         * @member {Array.<onnx.IAttributeProto>} attributeProto\n         * @memberof onnx.FunctionProto\n         * @instance\n         */\n        FunctionProto.prototype.attributeProto = $util.emptyArray;\n\n        /**\n         * FunctionProto node.\n         * @member {Array.<onnx.INodeProto>} node\n         * @memberof onnx.FunctionProto\n         * @instance\n         */\n        FunctionProto.prototype.node = $util.emptyArray;\n\n        /**\n         * FunctionProto docString.\n         * @member {string} docString\n         * @memberof onnx.FunctionProto\n         * @instance\n         */\n        FunctionProto.prototype.docString = \"\";\n\n        /**\n         * FunctionProto opsetImport.\n         * @member {Array.<onnx.IOperatorSetIdProto>} opsetImport\n         * @memberof onnx.FunctionProto\n         * @instance\n         */\n        FunctionProto.prototype.opsetImport = $util.emptyArray;\n\n        /**\n         * FunctionProto domain.\n         * @member {string} domain\n         * @memberof onnx.FunctionProto\n         * @instance\n         */\n        FunctionProto.prototype.domain = \"\";\n\n        /**\n         * Creates a new FunctionProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.FunctionProto\n         * @static\n         * @param {onnx.IFunctionProto=} [properties] Properties to set\n         * @returns {onnx.FunctionProto} FunctionProto instance\n         */\n        FunctionProto.create = function create(properties) {\n            return new FunctionProto(properties);\n        };\n\n        /**\n         * Encodes the specified FunctionProto message. Does not implicitly {@link onnx.FunctionProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.FunctionProto\n         * @static\n         * @param {onnx.IFunctionProto} message FunctionProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        FunctionProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n            if (message.input != null && message.input.length)\n                for (var i = 0; i < message.input.length; ++i)\n                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.input[i]);\n            if (message.output != null && message.output.length)\n                for (var i = 0; i < message.output.length; ++i)\n                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.output[i]);\n            if (message.attribute != null && message.attribute.length)\n                for (var i = 0; i < message.attribute.length; ++i)\n                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.attribute[i]);\n            if (message.node != null && message.node.length)\n                for (var i = 0; i < message.node.length; ++i)\n                    $root.onnx.NodeProto.encode(message.node[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n            if (message.docString != null && Object.hasOwnProperty.call(message, \"docString\"))\n                writer.uint32(/* id 8, wireType 2 =*/66).string(message.docString);\n            if (message.opsetImport != null && message.opsetImport.length)\n                for (var i = 0; i < message.opsetImport.length; ++i)\n                    $root.onnx.OperatorSetIdProto.encode(message.opsetImport[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();\n            if (message.domain != null && Object.hasOwnProperty.call(message, \"domain\"))\n                writer.uint32(/* id 10, wireType 2 =*/82).string(message.domain);\n            if (message.attributeProto != null && message.attributeProto.length)\n                for (var i = 0; i < message.attributeProto.length; ++i)\n                    $root.onnx.AttributeProto.encode(message.attributeProto[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified FunctionProto message, length delimited. Does not implicitly {@link onnx.FunctionProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.FunctionProto\n         * @static\n         * @param {onnx.IFunctionProto} message FunctionProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        FunctionProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a FunctionProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.FunctionProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.FunctionProto} FunctionProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        FunctionProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.FunctionProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1: {\n                        message.name = reader.string();\n                        break;\n                    }\n                case 4: {\n                        if (!(message.input && message.input.length))\n                            message.input = [];\n                        message.input.push(reader.string());\n                        break;\n                    }\n                case 5: {\n                        if (!(message.output && message.output.length))\n                            message.output = [];\n                        message.output.push(reader.string());\n                        break;\n                    }\n                case 6: {\n                        if (!(message.attribute && message.attribute.length))\n                            message.attribute = [];\n                        message.attribute.push(reader.string());\n                        break;\n                    }\n                case 11: {\n                        if (!(message.attributeProto && message.attributeProto.length))\n                            message.attributeProto = [];\n                        message.attributeProto.push($root.onnx.AttributeProto.decode(reader, reader.uint32()));\n                        break;\n                    }\n                case 7: {\n                        if (!(message.node && message.node.length))\n                            message.node = [];\n                        message.node.push($root.onnx.NodeProto.decode(reader, reader.uint32()));\n                        break;\n                    }\n                case 8: {\n                        message.docString = reader.string();\n                        break;\n                    }\n                case 9: {\n                        if (!(message.opsetImport && message.opsetImport.length))\n                            message.opsetImport = [];\n                        message.opsetImport.push($root.onnx.OperatorSetIdProto.decode(reader, reader.uint32()));\n                        break;\n                    }\n                case 10: {\n                        message.domain = reader.string();\n                        break;\n                    }\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a FunctionProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.FunctionProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.FunctionProto} FunctionProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        FunctionProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a FunctionProto message.\n         * @function verify\n         * @memberof onnx.FunctionProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        FunctionProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                if (!$util.isString(message.name))\n                    return \"name: string expected\";\n            if (message.input != null && message.hasOwnProperty(\"input\")) {\n                if (!Array.isArray(message.input))\n                    return \"input: array expected\";\n                for (var i = 0; i < message.input.length; ++i)\n                    if (!$util.isString(message.input[i]))\n                        return \"input: string[] expected\";\n            }\n            if (message.output != null && message.hasOwnProperty(\"output\")) {\n                if (!Array.isArray(message.output))\n                    return \"output: array expected\";\n                for (var i = 0; i < message.output.length; ++i)\n                    if (!$util.isString(message.output[i]))\n                        return \"output: string[] expected\";\n            }\n            if (message.attribute != null && message.hasOwnProperty(\"attribute\")) {\n                if (!Array.isArray(message.attribute))\n                    return \"attribute: array expected\";\n                for (var i = 0; i < message.attribute.length; ++i)\n                    if (!$util.isString(message.attribute[i]))\n                        return \"attribute: string[] expected\";\n            }\n            if (message.attributeProto != null && message.hasOwnProperty(\"attributeProto\")) {\n                if (!Array.isArray(message.attributeProto))\n                    return \"attributeProto: array expected\";\n                for (var i = 0; i < message.attributeProto.length; ++i) {\n                    var error = $root.onnx.AttributeProto.verify(message.attributeProto[i]);\n                    if (error)\n                        return \"attributeProto.\" + error;\n                }\n            }\n            if (message.node != null && message.hasOwnProperty(\"node\")) {\n                if (!Array.isArray(message.node))\n                    return \"node: array expected\";\n                for (var i = 0; i < message.node.length; ++i) {\n                    var error = $root.onnx.NodeProto.verify(message.node[i]);\n                    if (error)\n                        return \"node.\" + error;\n                }\n            }\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                if (!$util.isString(message.docString))\n                    return \"docString: string expected\";\n            if (message.opsetImport != null && message.hasOwnProperty(\"opsetImport\")) {\n                if (!Array.isArray(message.opsetImport))\n                    return \"opsetImport: array expected\";\n                for (var i = 0; i < message.opsetImport.length; ++i) {\n                    var error = $root.onnx.OperatorSetIdProto.verify(message.opsetImport[i]);\n                    if (error)\n                        return \"opsetImport.\" + error;\n                }\n            }\n            if (message.domain != null && message.hasOwnProperty(\"domain\"))\n                if (!$util.isString(message.domain))\n                    return \"domain: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a FunctionProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.FunctionProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.FunctionProto} FunctionProto\n         */\n        FunctionProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.FunctionProto)\n                return object;\n            var message = new $root.onnx.FunctionProto();\n            if (object.name != null)\n                message.name = String(object.name);\n            if (object.input) {\n                if (!Array.isArray(object.input))\n                    throw TypeError(\".onnx.FunctionProto.input: array expected\");\n                message.input = [];\n                for (var i = 0; i < object.input.length; ++i)\n                    message.input[i] = String(object.input[i]);\n            }\n            if (object.output) {\n                if (!Array.isArray(object.output))\n                    throw TypeError(\".onnx.FunctionProto.output: array expected\");\n                message.output = [];\n                for (var i = 0; i < object.output.length; ++i)\n                    message.output[i] = String(object.output[i]);\n            }\n            if (object.attribute) {\n                if (!Array.isArray(object.attribute))\n                    throw TypeError(\".onnx.FunctionProto.attribute: array expected\");\n                message.attribute = [];\n                for (var i = 0; i < object.attribute.length; ++i)\n                    message.attribute[i] = String(object.attribute[i]);\n            }\n            if (object.attributeProto) {\n                if (!Array.isArray(object.attributeProto))\n                    throw TypeError(\".onnx.FunctionProto.attributeProto: array expected\");\n                message.attributeProto = [];\n                for (var i = 0; i < object.attributeProto.length; ++i) {\n                    if (typeof object.attributeProto[i] !== \"object\")\n                        throw TypeError(\".onnx.FunctionProto.attributeProto: object expected\");\n                    message.attributeProto[i] = $root.onnx.AttributeProto.fromObject(object.attributeProto[i]);\n                }\n            }\n            if (object.node) {\n                if (!Array.isArray(object.node))\n                    throw TypeError(\".onnx.FunctionProto.node: array expected\");\n                message.node = [];\n                for (var i = 0; i < object.node.length; ++i) {\n                    if (typeof object.node[i] !== \"object\")\n                        throw TypeError(\".onnx.FunctionProto.node: object expected\");\n                    message.node[i] = $root.onnx.NodeProto.fromObject(object.node[i]);\n                }\n            }\n            if (object.docString != null)\n                message.docString = String(object.docString);\n            if (object.opsetImport) {\n                if (!Array.isArray(object.opsetImport))\n                    throw TypeError(\".onnx.FunctionProto.opsetImport: array expected\");\n                message.opsetImport = [];\n                for (var i = 0; i < object.opsetImport.length; ++i) {\n                    if (typeof object.opsetImport[i] !== \"object\")\n                        throw TypeError(\".onnx.FunctionProto.opsetImport: object expected\");\n                    message.opsetImport[i] = $root.onnx.OperatorSetIdProto.fromObject(object.opsetImport[i]);\n                }\n            }\n            if (object.domain != null)\n                message.domain = String(object.domain);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a FunctionProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.FunctionProto\n         * @static\n         * @param {onnx.FunctionProto} message FunctionProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        FunctionProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.input = [];\n                object.output = [];\n                object.attribute = [];\n                object.node = [];\n                object.opsetImport = [];\n                object.attributeProto = [];\n            }\n            if (options.defaults) {\n                object.name = \"\";\n                object.docString = \"\";\n                object.domain = \"\";\n            }\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                object.name = message.name;\n            if (message.input && message.input.length) {\n                object.input = [];\n                for (var j = 0; j < message.input.length; ++j)\n                    object.input[j] = message.input[j];\n            }\n            if (message.output && message.output.length) {\n                object.output = [];\n                for (var j = 0; j < message.output.length; ++j)\n                    object.output[j] = message.output[j];\n            }\n            if (message.attribute && message.attribute.length) {\n                object.attribute = [];\n                for (var j = 0; j < message.attribute.length; ++j)\n                    object.attribute[j] = message.attribute[j];\n            }\n            if (message.node && message.node.length) {\n                object.node = [];\n                for (var j = 0; j < message.node.length; ++j)\n                    object.node[j] = $root.onnx.NodeProto.toObject(message.node[j], options);\n            }\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                object.docString = message.docString;\n            if (message.opsetImport && message.opsetImport.length) {\n                object.opsetImport = [];\n                for (var j = 0; j < message.opsetImport.length; ++j)\n                    object.opsetImport[j] = $root.onnx.OperatorSetIdProto.toObject(message.opsetImport[j], options);\n            }\n            if (message.domain != null && message.hasOwnProperty(\"domain\"))\n                object.domain = message.domain;\n            if (message.attributeProto && message.attributeProto.length) {\n                object.attributeProto = [];\n                for (var j = 0; j < message.attributeProto.length; ++j)\n                    object.attributeProto[j] = $root.onnx.AttributeProto.toObject(message.attributeProto[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this FunctionProto to JSON.\n         * @function toJSON\n         * @memberof onnx.FunctionProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        FunctionProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * Gets the default type url for FunctionProto\n         * @function getTypeUrl\n         * @memberof onnx.FunctionProto\n         * @static\n         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n         * @returns {string} The default type url\n         */\n        FunctionProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === undefined) {\n                typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/onnx.FunctionProto\";\n        };\n\n        return FunctionProto;\n    })();\n\n    return onnx;\n})();\n\nmodule.exports = $root;\n","var _scriptDir,e=(_scriptDir=\"undefined\"!=typeof document&&document.currentScript?document.currentScript.src:void 0,\"undefined\"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){function t(){return F.buffer!=k.buffer&&W(),k}function r(){return F.buffer!=k.buffer&&W(),x}function n(){return F.buffer!=k.buffer&&W(),Y}function a(){return F.buffer!=k.buffer&&W(),H}function o(){return F.buffer!=k.buffer&&W(),U}var i,u,s=e;s.ready=new Promise(((e,t)=>{i=e,u=t}));var f,c,l,d=Object.assign({},s),h=\"./this.program\",m=(e,t)=>{throw t},p=\"object\"==typeof window,g=\"function\"==typeof importScripts,b=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node,y=s.ENVIRONMENT_IS_PTHREAD||!1,v=\"\";function _(e){return s.locateFile?s.locateFile(e,v):v+e}if(b){var w=require(\"fs\"),O=require(\"path\");let e;v=g?O.dirname(v)+\"/\":__dirname+\"/\",f=(e,t)=>(e=e.startsWith(\"file://\")?new URL(e):O.normalize(e),w.readFileSync(e,t?void 0:\"utf8\")),l=e=>((e=f(e,!0)).buffer||(e=new Uint8Array(e)),e),c=(e,t,r,n=!0)=>{e=e.startsWith(\"file://\")?new URL(e):O.normalize(e),w.readFile(e,n?void 0:\"utf8\",((e,a)=>{e?r(e):t(n?a.buffer:a)}))},!s.thisProgram&&1<process.argv.length&&(h=process.argv[1].replace(/\\\\/g,\"/\")),process.argv.slice(2),m=(e,t)=>{throw process.exitCode=e,t},s.inspect=()=>\"[Emscripten Module object]\";try{e=require(\"worker_threads\")}catch(e){throw console.error('The \"worker_threads\" module is not supported in this node.js build - perhaps a newer version is needed?'),e}global.Worker=e.Worker}else(p||g)&&(g?v=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(v=document.currentScript.src),_scriptDir&&(v=_scriptDir),v=0!==v.indexOf(\"blob:\")?v.substr(0,v.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):\"\",b||(f=e=>{var t=new XMLHttpRequest;return t.open(\"GET\",e,!1),t.send(null),t.responseText},g&&(l=e=>{var t=new XMLHttpRequest;return t.open(\"GET\",e,!1),t.responseType=\"arraybuffer\",t.send(null),new Uint8Array(t.response)}),c=(e,t,r)=>{var n=new XMLHttpRequest;n.open(\"GET\",e,!0),n.responseType=\"arraybuffer\",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)}));b&&\"undefined\"==typeof performance&&(global.performance=require(\"perf_hooks\").performance);var M=console.log.bind(console),T=console.error.bind(console);b&&(M=(...e)=>w.writeSync(1,e.join(\" \")+\"\\n\"),T=(...e)=>w.writeSync(2,e.join(\" \")+\"\\n\"));var S,A=s.print||M,R=s.printErr||T;Object.assign(s,d),d=null,s.thisProgram&&(h=s.thisProgram),s.quit&&(m=s.quit),s.wasmBinary&&(S=s.wasmBinary);var E=s.noExitRuntime||!0;\"object\"!=typeof WebAssembly&&ee(\"no native wasm support detected\");var F,D,C,I,k,x,Y,H,U,P=!1;function W(){var e=F.buffer;s.HEAP8=k=new Int8Array(e),s.HEAP16=new Int16Array(e),s.HEAP32=Y=new Int32Array(e),s.HEAPU8=x=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAPU32=H=new Uint32Array(e),s.HEAPF32=new Float32Array(e),s.HEAPF64=U=new Float64Array(e)}var G=s.INITIAL_MEMORY||16777216;if(5242880<=G||ee(\"INITIAL_MEMORY should be larger than STACK_SIZE, was \"+G+\"! (STACK_SIZE=5242880)\"),y)F=s.wasmMemory;else if(s.wasmMemory)F=s.wasmMemory;else if(!((F=new WebAssembly.Memory({initial:G/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw R(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"),b&&R(\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)\"),Error(\"bad memory\");W(),G=F.buffer.byteLength;var L,N=[],j=[],B=[],z=0;function q(){return E||0<z}var J,K,V=0,X=null,$=null;function Z(){V++,s.monitorRunDependencies&&s.monitorRunDependencies(V)}function Q(){if(V--,s.monitorRunDependencies&&s.monitorRunDependencies(V),0==V&&(null!==X&&(clearInterval(X),X=null),$)){var e=$;$=null,e()}}function ee(e){throw s.onAbort&&s.onAbort(e),R(e=\"Aborted(\"+e+\")\"),P=!0,I=1,e=new WebAssembly.RuntimeError(e+\". Build with -sASSERTIONS for more info.\"),u(e),e}function te(e){return e.startsWith(\"data:application/octet-stream;base64,\")}function re(e){if(e==J&&S)return new Uint8Array(S);if(l)return l(e);throw\"both async and sync fetching of the wasm failed\"}function ne(e,t,r){return function(e){if(!S&&(p||g)){if(\"function\"==typeof fetch&&!e.startsWith(\"file://\"))return fetch(e,{credentials:\"same-origin\"}).then((t=>{if(!t.ok)throw\"failed to load wasm binary file at '\"+e+\"'\";return t.arrayBuffer()})).catch((()=>re(e)));if(c)return new Promise(((t,r)=>{c(e,(e=>t(new Uint8Array(e))),r)}))}return Promise.resolve().then((()=>re(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(r,(e=>{R(\"failed to asynchronously prepare wasm: \"+e),ee(e)}))}function ae(e){this.name=\"ExitStatus\",this.message=`Program terminated with exit(${e})`,this.status=e}function oe(e){e.terminate(),e.onmessage=()=>{}}function ie(e){(e=he.Fa[e])||ee(),he.fb(e)}function ue(e){var t=he.Za();if(!t)return 6;he.Ia.push(t),he.Fa[e.Ha]=t,t.Ha=e.Ha;var r={cmd:\"run\",start_routine:e.gb,arg:e.Ya,pthread_ptr:e.Ha};return b&&t.unref(),t.postMessage(r,e.mb),0}te(J=\"ort-wasm-threaded.wasm\")||(J=_(J));var se=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0,fe=(e,t,r)=>{var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&se)return se.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,r):e.subarray(t,r));for(n=\"\";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n},ce=(e,t)=>(e>>>=0)?fe(r(),e,t):\"\";function le(e){if(y)return qe(1,1,e);I=e,q()||(he.hb(),s.onExit&&s.onExit(e),P=!0),m(e,new ae(e))}var de=e=>{if(I=e,y)throw pe(e),\"unwind\";le(e)},he={La:[],Ia:[],Ta:[],Fa:{},Pa:function(){y?he.ab():he.$a()},$a:function(){N.unshift((()=>{Z(),he.bb((()=>Q()))}))},ab:function(){he.receiveObjectTransfer=he.eb,he.threadInitTLS=he.Sa,he.setExitStatus=he.Ra,E=!1},Ra:function(e){I=e},rb:[\"$terminateWorker\"],hb:function(){for(var e of he.Ia)oe(e);for(e of he.La)oe(e);he.La=[],he.Ia=[],he.Fa=[]},fb:function(e){var t=e.Ha;delete he.Fa[t],he.La.push(e),he.Ia.splice(he.Ia.indexOf(e),1),e.Ha=0,gt(t)},eb:function(){},Sa:function(){he.Ta.forEach((e=>e()))},cb:e=>new Promise((t=>{e.onmessage=r=>{var n=(r=r.data).cmd;if(r.targetThread&&r.targetThread!=lt()){var a=he.Fa[r.qb];a?a.postMessage(r,r.transferList):R('Internal error! Worker sent a message \"'+n+'\" to target pthread '+r.targetThread+\", but that thread no longer exists!\")}else\"checkMailbox\"===n?Pe():\"spawnThread\"===n?ue(r):\"cleanupThread\"===n?ie(r.thread):\"killThread\"===n?(r=r.thread,n=he.Fa[r],delete he.Fa[r],oe(n),gt(r),he.Ia.splice(he.Ia.indexOf(n),1),n.Ha=0):\"cancelThread\"===n?he.Fa[r.thread].postMessage({cmd:\"cancel\"}):\"loaded\"===n?(e.loaded=!0,t(e)):\"alert\"===n?alert(\"Thread \"+r.threadId+\": \"+r.text):\"setimmediate\"===r.target?e.postMessage(r):\"callHandler\"===n?s[r.handler](...r.args):n&&R(\"worker sent an unknown command \"+n)},e.onerror=e=>{throw R(\"worker sent an error! \"+e.filename+\":\"+e.lineno+\": \"+e.message),e},b&&(e.on(\"message\",(function(t){e.onmessage({data:t})})),e.on(\"error\",(function(t){e.onerror(t)})));var r,n=[];for(r of[\"onExit\",\"onAbort\",\"print\",\"printErr\"])s.hasOwnProperty(r)&&n.push(r);e.postMessage({cmd:\"load\",handlers:n,urlOrBlob:s.mainScriptUrlOrBlob||_scriptDir,wasmMemory:F,wasmModule:C})})),bb:function(e){e()},Xa:function(){var e=_(\"ort-wasm-threaded.worker.js\");e=new Worker(e),he.La.push(e)},Za:function(){return 0==he.La.length&&(he.Xa(),he.cb(he.La[0])),he.La.pop()}};s.PThread=he;var me=e=>{for(;0<e.length;)e.shift()(s)};function pe(e){if(y)return qe(2,0,e);de(e)}s.establishStackSpace=function(){var e=lt(),t=n()[e+52>>2>>>0];e=n()[e+56>>2>>>0],_t(t,t-e),Ot(t)};var ge=[];function be(e){this.Oa=e-24,this.Wa=function(e){a()[this.Oa+4>>2>>>0]=e},this.Va=function(e){a()[this.Oa+8>>2>>>0]=e},this.Pa=function(e,t){this.Ua(),this.Wa(e),this.Va(t)},this.Ua=function(){a()[this.Oa+16>>2>>>0]=0}}function ye(e,t,r,n){return y?qe(3,1,e,t,r,n):ve(e,t,r,n)}function ve(e,t,r,n){if(e>>>=0,t>>>=0,r>>>=0,n>>>=0,\"undefined\"==typeof SharedArrayBuffer)return R(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"),6;var a=[];return y&&0===a.length?ye(e,t,r,n):(e={gb:r,Ha:e,Ya:n,mb:a},y?(e.ob=\"spawnThread\",postMessage(e,a),0):ue(e))}function _e(e,t,r){return y?qe(4,1,e,t,r):0}function we(e,t){if(y)return qe(5,1,e,t)}s.invokeEntryPoint=function(e,t){var r=ge[e];r||(e>=ge.length&&(ge.length=e+1),ge[e]=r=L.get(e)),e=r(t),q()?he.Ra(e):bt(e)};var Oe=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t},Me=(e,t,r,n)=>{if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(r>=n)break;t[r++>>>0]=i}else{if(2047>=i){if(r+1>=n)break;t[r++>>>0]=192|i>>6}else{if(65535>=i){if(r+2>=n)break;t[r++>>>0]=224|i>>12}else{if(r+3>=n)break;t[r++>>>0]=240|i>>18,t[r++>>>0]=128|i>>12&63}t[r++>>>0]=128|i>>6&63}t[r++>>>0]=128|63&i}}return t[r>>>0]=0,r-a},Te=(e,t,n)=>Me(e,r(),t,n);function Se(e,t){if(y)return qe(6,1,e,t)}function Ae(e,t,r){if(y)return qe(7,1,e,t,r)}function Re(e,t,r){return y?qe(8,1,e,t,r):0}function Ee(e,t){if(y)return qe(9,1,e,t)}function Fe(e,t,r){if(y)return qe(10,1,e,t,r)}function De(e,t,r,n){if(y)return qe(11,1,e,t,r,n)}function Ce(e,t,r,n){if(y)return qe(12,1,e,t,r,n)}function Ie(e,t,r,n){if(y)return qe(13,1,e,t,r,n)}function ke(e){if(y)return qe(14,1,e)}function xe(e,t){if(y)return qe(15,1,e,t)}function Ye(e,t,r){if(y)return qe(16,1,e,t,r)}var He=e=>{if(!P)try{if(e(),!q())try{y?bt(I):de(I)}catch(e){e instanceof ae||\"unwind\"==e||m(1,e)}}catch(e){e instanceof ae||\"unwind\"==e||m(1,e)}};function Ue(e){e>>>=0,\"function\"==typeof Atomics.nb&&(Atomics.nb(n(),e>>2,e).value.then(Pe),e+=128,Atomics.store(n(),e>>2,1))}function Pe(){var e=lt();e&&(Ue(e),He((()=>yt())))}s.__emscripten_thread_mailbox_await=Ue,s.checkMailbox=Pe;var We=e=>0==e%4&&(0!=e%100||0==e%400),Ge=[0,31,60,91,121,152,182,213,244,274,305,335],Le=[0,31,59,90,120,151,181,212,243,273,304,334];function Ne(e,t,r,n,a,o,i,u){return y?qe(17,1,e,t,r,n,a,o,i,u):-52}function je(e,t,r,n,a,o,i){if(y)return qe(18,1,e,t,r,n,a,o,i)}var Be=e=>{var t=Oe(e)+1,r=dt(t);return r&&Te(e,r,t),r},ze=e=>{var t=wt();return e=e(),Ot(t),e};function qe(e,t){var r=arguments.length-2,n=arguments;return ze((()=>{for(var a=Mt(8*r),i=a>>3,u=0;u<r;u++){var s=n[2+u];o()[i+u>>>0]=s}return pt(e,r,a,t)}))}var Je,Ke=[],Ve={},Xe=()=>{if(!Je){var e,t={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:h||\"./this.program\"};for(e in Ve)void 0===Ve[e]?delete t[e]:t[e]=Ve[e];var r=[];for(e in t)r.push(`${e}=${t[e]}`);Je=r}return Je};function $e(e,r){if(y)return qe(19,1,e,r);e>>>=0,r>>>=0;var n=0;return Xe().forEach((function(o,i){var u=r+n;for(i=a()[e+4*i>>2>>>0]=u,u=0;u<o.length;++u)t()[i++>>0>>>0]=o.charCodeAt(u);t()[i>>0>>>0]=0,n+=o.length+1})),0}function Ze(e,t){if(y)return qe(20,1,e,t);e>>>=0,t>>>=0;var r=Xe();a()[e>>2>>>0]=r.length;var n=0;return r.forEach((function(e){n+=e.length+1})),a()[t>>2>>>0]=n,0}function Qe(e){return y?qe(21,1,e):52}function et(e,t,r,n){return y?qe(22,1,e,t,r,n):52}function tt(e,t,r,n,a){return y?qe(23,1,e,t,r,n,a):70}var rt=[null,[],[]];function nt(e,t,n,o){if(y)return qe(24,1,e,t,n,o);t>>>=0,n>>>=0,o>>>=0;for(var i=0,u=0;u<n;u++){var s=a()[t>>2>>>0],f=a()[t+4>>2>>>0];t+=8;for(var c=0;c<f;c++){var l=r()[s+c>>>0],d=rt[e];0===l||10===l?((1===e?A:R)(fe(d,0)),d.length=0):d.push(l)}i+=f}return a()[o>>2>>>0]=i,0}var at=e=>(at=(()=>{if(\"object\"==typeof crypto&&\"function\"==typeof crypto.getRandomValues)return e=>(e.set(crypto.getRandomValues(new Uint8Array(e.byteLength))),e);if(b)try{var e=require(\"crypto\");if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}ee(\"initRandomDevice\")})())(e),ot=[31,29,31,30,31,30,31,31,30,31,30,31],it=[31,28,31,30,31,30,31,31,30,31,30,31],ut=(e,r)=>{t().set(e,r>>>0)};function st(e,t,r,a){function o(e,t,r){for(e=\"number\"==typeof e?e.toString():e||\"\";e.length<t;)e=r[0]+e;return e}function i(e,t){return o(e,t,\"0\")}function u(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function f(e){var t=e.Ja;for(e=new Date(new Date(e.Ka+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(We(e.getFullYear())?ot:it)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),r=s(r),0>=u(t,e)?0>=u(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,r>>>=0,a>>>=0;var c=n()[a+40>>2>>>0];for(var l in a={kb:n()[a>>2>>>0],jb:n()[a+4>>2>>>0],Ma:n()[a+8>>2>>>0],Qa:n()[a+12>>2>>>0],Na:n()[a+16>>2>>>0],Ka:n()[a+20>>2>>>0],Ga:n()[a+24>>2>>>0],Ja:n()[a+28>>2>>>0],sb:n()[a+32>>2>>>0],ib:n()[a+36>>2>>>0],lb:c?ce(c):\"\"},r=ce(r),c={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})r=r.replace(new RegExp(l,\"g\"),c[l]);var d=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),h=\"January February March April May June July August September October November December\".split(\" \");for(l in c={\"%a\":e=>d[e.Ga].substring(0,3),\"%A\":e=>d[e.Ga],\"%b\":e=>h[e.Na].substring(0,3),\"%B\":e=>h[e.Na],\"%C\":e=>i((e.Ka+1900)/100|0,2),\"%d\":e=>i(e.Qa,2),\"%e\":e=>o(e.Qa,2,\" \"),\"%g\":e=>f(e).toString().substring(2),\"%G\":e=>f(e),\"%H\":e=>i(e.Ma,2),\"%I\":e=>(0==(e=e.Ma)?e=12:12<e&&(e-=12),i(e,2)),\"%j\":e=>{for(var t=0,r=0;r<=e.Na-1;t+=(We(e.Ka+1900)?ot:it)[r++]);return i(e.Qa+t,3)},\"%m\":e=>i(e.Na+1,2),\"%M\":e=>i(e.jb,2),\"%n\":()=>\"\\n\",\"%p\":e=>0<=e.Ma&&12>e.Ma?\"AM\":\"PM\",\"%S\":e=>i(e.kb,2),\"%t\":()=>\"\\t\",\"%u\":e=>e.Ga||7,\"%U\":e=>i(Math.floor((e.Ja+7-e.Ga)/7),2),\"%V\":e=>{var t=Math.floor((e.Ja+7-(e.Ga+6)%7)/7);if(2>=(e.Ga+371-e.Ja-2)%7&&t++,t)53==t&&(4==(r=(e.Ga+371-e.Ja)%7)||3==r&&We(e.Ka)||(t=1));else{t=52;var r=(e.Ga+7-e.Ja-1)%7;(4==r||5==r&&We(e.Ka%400-1))&&t++}return i(t,2)},\"%w\":e=>e.Ga,\"%W\":e=>i(Math.floor((e.Ja+7-(e.Ga+6)%7)/7),2),\"%y\":e=>(e.Ka+1900).toString().substring(2),\"%Y\":e=>e.Ka+1900,\"%z\":e=>{var t=0<=(e=e.ib);return e=Math.abs(e)/60,(t?\"+\":\"-\")+String(\"0000\"+(e/60*100+e%60)).slice(-4)},\"%Z\":e=>e.lb,\"%%\":()=>\"%\"},r=r.replace(/%%/g,\"\\0\\0\"),c)r.includes(l)&&(r=r.replace(new RegExp(l,\"g\"),c[l](a)));return l=function(e){var t=Array(Oe(e)+1);return Me(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,\"%\")),l.length>t?0:(ut(l,e),l.length-1)}he.Pa();var ft=[null,le,pe,ye,_e,we,Se,Ae,Re,Ee,Fe,De,Ce,Ie,ke,xe,Ye,Ne,je,$e,Ze,Qe,et,tt,nt],ct={b:function(e,t,r){throw new be(e>>>=0).Pa(t>>>0,r>>>0),e},N:function(e){ht(e>>>0,!g,1,!p,131072,!1),he.Sa()},k:function(e){e>>>=0,y?postMessage({cmd:\"cleanupThread\",thread:e}):ie(e)},I:ve,h:_e,T:we,E:Se,G:Ae,U:Re,R:Ee,J:Fe,Q:De,o:Ce,F:Ie,C:ke,S:xe,D:Ye,q:()=>!0,A:function(e,t){(e>>>=0)==t>>>0?setTimeout((()=>Pe())):y?postMessage({targetThread:e,cmd:\"checkMailbox\"}):(e=he.Fa[e])&&e.postMessage({cmd:\"checkMailbox\"})},L:function(){return-1},M:Ue,p:function(e){b&&he.Fa[e>>>0].ref()},t:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),n()[r>>2>>>0]=e.getUTCSeconds(),n()[r+4>>2>>>0]=e.getUTCMinutes(),n()[r+8>>2>>>0]=e.getUTCHours(),n()[r+12>>2>>>0]=e.getUTCDate(),n()[r+16>>2>>>0]=e.getUTCMonth(),n()[r+20>>2>>>0]=e.getUTCFullYear()-1900,n()[r+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,n()[r+28>>2>>>0]=e},u:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),n()[r>>2>>>0]=e.getSeconds(),n()[r+4>>2>>>0]=e.getMinutes(),n()[r+8>>2>>>0]=e.getHours(),n()[r+12>>2>>>0]=e.getDate(),n()[r+16>>2>>>0]=e.getMonth(),n()[r+20>>2>>>0]=e.getFullYear()-1900,n()[r+24>>2>>>0]=e.getDay(),t=(We(e.getFullYear())?Ge:Le)[e.getMonth()]+e.getDate()-1|0,n()[r+28>>2>>>0]=t,n()[r+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var a=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(t!=a&&e.getTimezoneOffset()==Math.min(a,t)),n()[r+32>>2>>>0]=e},v:function(e){e>>>=0;var t=new Date(n()[e+20>>2>>>0]+1900,n()[e+16>>2>>>0],n()[e+12>>2>>>0],n()[e+8>>2>>>0],n()[e+4>>2>>>0],n()[e>>2>>>0],0),r=n()[e+32>>2>>>0],a=t.getTimezoneOffset(),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=new Date(t.getFullYear(),0,1).getTimezoneOffset(),u=Math.min(i,o);return 0>r?n()[e+32>>2>>>0]=Number(o!=i&&u==a):0<r!=(u==a)&&(o=Math.max(i,o),t.setTime(t.getTime()+6e4*((0<r?u:o)-a))),n()[e+24>>2>>>0]=t.getDay(),r=(We(t.getFullYear())?Ge:Le)[t.getMonth()]+t.getDate()-1|0,n()[e+28>>2>>>0]=r,n()[e>>2>>>0]=t.getSeconds(),n()[e+4>>2>>>0]=t.getMinutes(),n()[e+8>>2>>>0]=t.getHours(),n()[e+12>>2>>>0]=t.getDate(),n()[e+16>>2>>>0]=t.getMonth(),n()[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,vt((K=e,1<=+Math.abs(K)?0<K?+Math.floor(K/4294967296)>>>0:~~+Math.ceil((K-+(~~K>>>0))/4294967296)>>>0:0)),e>>>0},r:Ne,s:je,z:function(e,t,r){function o(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:\"GMT\"}e>>>=0,t>>>=0,r>>>=0;var i=(new Date).getFullYear(),u=new Date(i,0,1),s=new Date(i,6,1);i=u.getTimezoneOffset();var f=s.getTimezoneOffset(),c=Math.max(i,f);a()[e>>2>>>0]=60*c,n()[t>>2>>>0]=Number(i!=f),e=o(u),t=o(s),e=Be(e),t=Be(t),f<i?(a()[r>>2>>>0]=e,a()[r+4>>2>>>0]=t):(a()[r>>2>>>0]=t,a()[r+4>>2>>>0]=e)},c:()=>{ee(\"\")},l:function(){},i:function(){return Date.now()},V:()=>{throw z+=1,\"unwind\"},B:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:function(){return b?require(\"os\").cpus().length:navigator.hardwareConcurrency},K:function(e,t,r,n){for(he.pb=t>>>0,Ke.length=r,t=n>>>0>>3,n=0;n<r;n++)Ke[n]=o()[t+n>>>0];return ft[e].apply(null,Ke)},y:function(e){e>>>=0;var t=r().length;if(e<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var a=t*(1+.2/n);a=Math.min(a,e+100663296);var o=Math;a=Math.max(e,a);e:{o=o.min.call(o,4294901760,a+(65536-a%65536)%65536)-F.buffer.byteLength+65535>>>16;try{F.grow(o),W();var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},O:$e,P:Ze,j:de,g:Qe,n:et,w:tt,m:nt,x:function(e,t){return e>>>=0,t>>>=0,at(r().subarray(e>>>0,e+t>>>0)),0},a:F||s.wasmMemory,H:st,d:function(e,t,r,n){return st(e>>>0,t>>>0,r>>>0,n>>>0)}};!function(){function e(e,t){return e=e.exports,D=e=function(e){var t=e=>()=>e()>>>0,r=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.pthread_self=t(e.pthread_self),e.malloc=r(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=r(e.stackAlloc),e}(e),he.Ta.push(D.sa),L=D.ta,j.unshift(D.W),C=t,Q(),e}var t={a:ct};if(Z(),s.instantiateWasm)try{return s.instantiateWasm(t,e)}catch(e){R(\"Module.instantiateWasm callback failed with error: \"+e),u(e)}(function(e,t){var r=J;return S||\"function\"!=typeof WebAssembly.instantiateStreaming||te(r)||r.startsWith(\"file://\")||b||\"function\"!=typeof fetch?ne(r,e,t):fetch(r,{credentials:\"same-origin\"}).then((n=>WebAssembly.instantiateStreaming(n,e).then(t,(function(n){return R(\"wasm streaming compile failed: \"+n),R(\"falling back to ArrayBuffer instantiation\"),ne(r,e,t)}))))})(t,(function(t){e(t.instance,t.module)})).catch(u)}(),s._OrtInit=(e,t)=>(s._OrtInit=D.X)(e,t),s._OrtGetLastError=(e,t)=>(s._OrtGetLastError=D.Y)(e,t),s._OrtCreateSessionOptions=(e,t,r,n,a,o,i,u,f,c)=>(s._OrtCreateSessionOptions=D.Z)(e,t,r,n,a,o,i,u,f,c),s._OrtAppendExecutionProvider=(e,t)=>(s._OrtAppendExecutionProvider=D._)(e,t),s._OrtAddSessionConfigEntry=(e,t,r)=>(s._OrtAddSessionConfigEntry=D.$)(e,t,r),s._OrtReleaseSessionOptions=e=>(s._OrtReleaseSessionOptions=D.aa)(e),s._OrtCreateSession=(e,t,r)=>(s._OrtCreateSession=D.ba)(e,t,r),s._OrtReleaseSession=e=>(s._OrtReleaseSession=D.ca)(e),s._OrtGetInputOutputCount=(e,t,r)=>(s._OrtGetInputOutputCount=D.da)(e,t,r),s._OrtGetInputName=(e,t)=>(s._OrtGetInputName=D.ea)(e,t),s._OrtGetOutputName=(e,t)=>(s._OrtGetOutputName=D.fa)(e,t),s._OrtFree=e=>(s._OrtFree=D.ga)(e),s._OrtCreateTensor=(e,t,r,n,a)=>(s._OrtCreateTensor=D.ha)(e,t,r,n,a),s._OrtGetTensorData=(e,t,r,n,a)=>(s._OrtGetTensorData=D.ia)(e,t,r,n,a),s._OrtReleaseTensor=e=>(s._OrtReleaseTensor=D.ja)(e),s._OrtCreateRunOptions=(e,t,r,n)=>(s._OrtCreateRunOptions=D.ka)(e,t,r,n),s._OrtAddRunConfigEntry=(e,t,r)=>(s._OrtAddRunConfigEntry=D.la)(e,t,r),s._OrtReleaseRunOptions=e=>(s._OrtReleaseRunOptions=D.ma)(e),s._OrtRun=(e,t,r,n,a,o,i,u)=>(s._OrtRun=D.na)(e,t,r,n,a,o,i,u),s._OrtEndProfiling=e=>(s._OrtEndProfiling=D.oa)(e);var lt=s._pthread_self=()=>(lt=s._pthread_self=D.pa)(),dt=s._malloc=e=>(dt=s._malloc=D.qa)(e);s._free=e=>(s._free=D.ra)(e),s.__emscripten_tls_init=()=>(s.__emscripten_tls_init=D.sa)();var ht=s.__emscripten_thread_init=(e,t,r,n,a,o)=>(ht=s.__emscripten_thread_init=D.ua)(e,t,r,n,a,o);s.__emscripten_thread_crashed=()=>(s.__emscripten_thread_crashed=D.va)();var mt,pt=(e,t,r,n)=>(pt=D.wa)(e,t,r,n),gt=e=>(gt=D.xa)(e),bt=s.__emscripten_thread_exit=e=>(bt=s.__emscripten_thread_exit=D.ya)(e),yt=s.__emscripten_check_mailbox=()=>(yt=s.__emscripten_check_mailbox=D.za)(),vt=e=>(vt=D.Aa)(e),_t=(e,t)=>(_t=D.Ba)(e,t),wt=()=>(wt=D.Ca)(),Ot=e=>(Ot=D.Da)(e),Mt=e=>(Mt=D.Ea)(e);function Tt(){function e(){if(!mt&&(mt=!0,s.calledRun=!0,!P)&&(y||me(j),i(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),!y)){if(s.postRun)for(\"function\"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;){var e=s.postRun.shift();B.unshift(e)}me(B)}}if(!(0<V))if(y)i(s),y||me(j),startWorker(s);else{if(s.preRun)for(\"function\"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)N.unshift(s.preRun.shift());me(N),0<V||(s.setStatus?(s.setStatus(\"Running...\"),setTimeout((function(){setTimeout((function(){s.setStatus(\"\")}),1),e()}),1)):e())}}if(s.keepRuntimeAlive=q,s.wasmMemory=F,s.stackAlloc=Mt,s.stackSave=wt,s.stackRestore=Ot,s.UTF8ToString=ce,s.stringToUTF8=Te,s.lengthBytesUTF8=Oe,s.ExitStatus=ae,s.PThread=he,$=function e(){mt||Tt(),mt||($=e)},s.preInit)for(\"function\"==typeof s.preInit&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();return Tt(),e.ready});\"object\"==typeof exports&&\"object\"==typeof module?module.exports=e:\"function\"==typeof define&&define.amd&&define([],(()=>e));\n","\r\nvar ortWasm = (() => {\r\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\r\n  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename;\r\n  return (\r\nfunction(moduleArg = {}) {\r\n\r\nvar e=moduleArg,aa,h;e.ready=new Promise((a,b)=>{aa=a;h=b});var ba=Object.assign({},e),m=\"./this.program\",q=(a,b)=>{throw b;},ca=\"object\"==typeof window,v=\"function\"==typeof importScripts,x=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node,y=\"\",A,B,C;\r\nif(x){var fs=require(\"fs\"),D=require(\"path\");y=v?D.dirname(y)+\"/\":__dirname+\"/\";A=(a,b)=>{a=a.startsWith(\"file://\")?new URL(a):D.normalize(a);return fs.readFileSync(a,b?void 0:\"utf8\")};C=a=>{a=A(a,!0);a.buffer||(a=new Uint8Array(a));return a};B=(a,b,c,f=!0)=>{a=a.startsWith(\"file://\")?new URL(a):D.normalize(a);fs.readFile(a,f?void 0:\"utf8\",(g,k)=>{g?c(g):b(f?k.buffer:k)})};!e.thisProgram&&1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,\"/\"));process.argv.slice(2);q=(a,b)=>{process.exitCode=\r\na;throw b;};e.inspect=()=>\"[Emscripten Module object]\"}else if(ca||v)v?y=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(y=document.currentScript.src),_scriptDir&&(y=_scriptDir),0!==y.indexOf(\"blob:\")?y=y.substr(0,y.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):y=\"\",A=a=>{var b=new XMLHttpRequest;b.open(\"GET\",a,!1);b.send(null);return b.responseText},v&&(C=a=>{var b=new XMLHttpRequest;b.open(\"GET\",a,!1);b.responseType=\"arraybuffer\";b.send(null);return new Uint8Array(b.response)}),\r\nB=(a,b,c)=>{var f=new XMLHttpRequest;f.open(\"GET\",a,!0);f.responseType=\"arraybuffer\";f.onload=()=>{200==f.status||0==f.status&&f.response?b(f.response):c()};f.onerror=c;f.send(null)};var da=e.print||console.log.bind(console),E=e.printErr||console.error.bind(console);Object.assign(e,ba);ba=null;e.thisProgram&&(m=e.thisProgram);e.quit&&(q=e.quit);var F;e.wasmBinary&&(F=e.wasmBinary);var noExitRuntime=e.noExitRuntime||!0;\"object\"!=typeof WebAssembly&&G(\"no native wasm support detected\");\r\nvar H,I,J=!1,K,L,M,N;function ea(){var a=H.buffer;e.HEAP8=K=new Int8Array(a);e.HEAP16=new Int16Array(a);e.HEAP32=M=new Int32Array(a);e.HEAPU8=L=new Uint8Array(a);e.HEAPU16=new Uint16Array(a);e.HEAPU32=N=new Uint32Array(a);e.HEAPF32=new Float32Array(a);e.HEAPF64=new Float64Array(a)}var fa=[],ha=[],ia=[];function ja(){var a=e.preRun.shift();fa.unshift(a)}var O=0,P=null,Q=null;\r\nfunction G(a){if(e.onAbort)e.onAbort(a);a=\"Aborted(\"+a+\")\";E(a);J=!0;a=new WebAssembly.RuntimeError(a+\". Build with -sASSERTIONS for more info.\");h(a);throw a;}function ka(a){return a.startsWith(\"data:application/octet-stream;base64,\")}var R;R=\"ort-wasm.wasm\";if(!ka(R)){var la=R;R=e.locateFile?e.locateFile(la,y):y+la}function ma(a){if(a==R&&F)return new Uint8Array(F);if(C)return C(a);throw\"both async and sync fetching of the wasm failed\";}\r\nfunction na(a){if(!F&&(ca||v)){if(\"function\"==typeof fetch&&!a.startsWith(\"file://\"))return fetch(a,{credentials:\"same-origin\"}).then(b=>{if(!b.ok)throw\"failed to load wasm binary file at '\"+a+\"'\";return b.arrayBuffer()}).catch(()=>ma(a));if(B)return new Promise((b,c)=>{B(a,f=>b(new Uint8Array(f)),c)})}return Promise.resolve().then(()=>ma(a))}function oa(a,b,c){return na(a).then(f=>WebAssembly.instantiate(f,b)).then(f=>f).then(c,f=>{E(\"failed to asynchronously prepare wasm: \"+f);G(f)})}\r\nfunction pa(a,b){var c=R;return F||\"function\"!=typeof WebAssembly.instantiateStreaming||ka(c)||c.startsWith(\"file://\")||x||\"function\"!=typeof fetch?oa(c,a,b):fetch(c,{credentials:\"same-origin\"}).then(f=>WebAssembly.instantiateStreaming(f,a).then(b,function(g){E(\"wasm streaming compile failed: \"+g);E(\"falling back to ArrayBuffer instantiation\");return oa(c,a,b)}))}var S;function qa(a){this.name=\"ExitStatus\";this.message=`Program terminated with exit(${a})`;this.status=a}var T=a=>{for(;0<a.length;)a.shift()(e)};\r\nfunction ra(a){this.qa=a-24;this.va=function(b){N[this.qa+4>>2>>>0]=b};this.ua=function(b){N[this.qa+8>>2>>>0]=b};this.sa=function(b,c){this.ta();this.va(b);this.ua(c)};this.ta=function(){N[this.qa+16>>2>>>0]=0}}\r\nvar sa=0,ta=0,ua=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0,va=(a,b,c)=>{b>>>=0;var f=b+c;for(c=b;a[c]&&!(c>=f);)++c;if(16<c-b&&a.buffer&&ua)return ua.decode(a.subarray(b,c));for(f=\"\";b<c;){var g=a[b++];if(g&128){var k=a[b++]&63;if(192==(g&224))f+=String.fromCharCode((g&31)<<6|k);else{var l=a[b++]&63;g=224==(g&240)?(g&15)<<12|k<<6|l:(g&7)<<18|k<<12|l<<6|a[b++]&63;65536>g?f+=String.fromCharCode(g):(g-=65536,f+=String.fromCharCode(55296|g>>10,56320|g&1023))}}else f+=String.fromCharCode(g)}return f},\r\nU=(a,b)=>(a>>>=0)?va(L,a,b):\"\",V=a=>{for(var b=0,c=0;c<a.length;++c){var f=a.charCodeAt(c);127>=f?b++:2047>=f?b+=2:55296<=f&&57343>=f?(b+=4,++c):b+=3}return b},W=(a,b,c,f)=>{c>>>=0;if(!(0<f))return 0;var g=c;f=c+f-1;for(var k=0;k<a.length;++k){var l=a.charCodeAt(k);if(55296<=l&&57343>=l){var r=a.charCodeAt(++k);l=65536+((l&1023)<<10)|r&1023}if(127>=l){if(c>=f)break;b[c++>>>0]=l}else{if(2047>=l){if(c+1>=f)break;b[c++>>>0]=192|l>>6}else{if(65535>=l){if(c+2>=f)break;b[c++>>>0]=224|l>>12}else{if(c+3>=\r\nf)break;b[c++>>>0]=240|l>>18;b[c++>>>0]=128|l>>12&63}b[c++>>>0]=128|l>>6&63}b[c++>>>0]=128|l&63}}b[c>>>0]=0;return c-g},X=a=>0===a%4&&(0!==a%100||0===a%400),wa=[0,31,60,91,121,152,182,213,244,274,305,335],xa=[0,31,59,90,120,151,181,212,243,273,304,334],Ca=a=>{var b=V(a)+1,c=ya(b);c&&W(a,L,c,b);return c},Y={},Ea=()=>{if(!Da){var a={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\r\n\"_\")+\".UTF-8\",_:m||\"./this.program\"},b;for(b in Y)void 0===Y[b]?delete a[b]:a[b]=Y[b];var c=[];for(b in a)c.push(`${b}=${a[b]}`);Da=c}return Da},Da,Fa=[null,[],[]],Ga=()=>{if(\"object\"==typeof crypto&&\"function\"==typeof crypto.getRandomValues)return c=>crypto.getRandomValues(c);if(x)try{var a=require(\"crypto\");if(a.randomFillSync)return c=>a.randomFillSync(c);var b=a.randomBytes;return c=>(c.set(b(c.byteLength)),c)}catch(c){}G(\"initRandomDevice\")},Ha=a=>(Ha=Ga())(a),Ia=[31,29,31,30,31,30,31,31,30,\r\n31,30,31],Ja=[31,28,31,30,31,30,31,31,30,31,30,31];function Ka(a){var b=Array(V(a)+1);W(a,b,0,b.length);return b}\r\nfunction La(a,b,c,f){function g(d,n,p){for(d=\"number\"==typeof d?d.toString():d||\"\";d.length<n;)d=p[0]+d;return d}function k(d,n){return g(d,n,\"0\")}function l(d,n){function p(za){return 0>za?-1:0<za?1:0}var z;0===(z=p(d.getFullYear()-n.getFullYear()))&&0===(z=p(d.getMonth()-n.getMonth()))&&(z=p(d.getDate()-n.getDate()));return z}function r(d){switch(d.getDay()){case 0:return new Date(d.getFullYear()-1,11,29);case 1:return d;case 2:return new Date(d.getFullYear(),0,3);case 3:return new Date(d.getFullYear(),\r\n0,2);case 4:return new Date(d.getFullYear(),0,1);case 5:return new Date(d.getFullYear()-1,11,31);case 6:return new Date(d.getFullYear()-1,11,30)}}function w(d){var n=d.ma;for(d=new Date((new Date(d.na+1900,0,1)).getTime());0<n;){var p=d.getMonth(),z=(X(d.getFullYear())?Ia:Ja)[p];if(n>z-d.getDate())n-=z-d.getDate()+1,d.setDate(1),11>p?d.setMonth(p+1):(d.setMonth(0),d.setFullYear(d.getFullYear()+1));else{d.setDate(d.getDate()+n);break}}p=new Date(d.getFullYear()+1,0,4);n=r(new Date(d.getFullYear(),\r\n0,4));p=r(p);return 0>=l(n,d)?0>=l(p,d)?d.getFullYear()+1:d.getFullYear():d.getFullYear()-1}a>>>=0;b>>>=0;c>>>=0;f>>>=0;var t=M[f+40>>2>>>0];f={ya:M[f>>2>>>0],xa:M[f+4>>2>>>0],oa:M[f+8>>2>>>0],ra:M[f+12>>2>>>0],pa:M[f+16>>2>>>0],na:M[f+20>>2>>>0],ha:M[f+24>>2>>>0],ma:M[f+28>>2>>>0],Aa:M[f+32>>2>>>0],wa:M[f+36>>2>>>0],za:t?U(t):\"\"};c=U(c);t={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\r\n\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"};for(var u in t)c=c.replace(new RegExp(u,\"g\"),t[u]);var Aa=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),Ba=\"January February March April May June July August September October November December\".split(\" \");t={\"%a\":d=>Aa[d.ha].substring(0,3),\"%A\":d=>Aa[d.ha],\"%b\":d=>\r\nBa[d.pa].substring(0,3),\"%B\":d=>Ba[d.pa],\"%C\":d=>k((d.na+1900)/100|0,2),\"%d\":d=>k(d.ra,2),\"%e\":d=>g(d.ra,2,\" \"),\"%g\":d=>w(d).toString().substring(2),\"%G\":d=>w(d),\"%H\":d=>k(d.oa,2),\"%I\":d=>{d=d.oa;0==d?d=12:12<d&&(d-=12);return k(d,2)},\"%j\":d=>{for(var n=0,p=0;p<=d.pa-1;n+=(X(d.na+1900)?Ia:Ja)[p++]);return k(d.ra+n,3)},\"%m\":d=>k(d.pa+1,2),\"%M\":d=>k(d.xa,2),\"%n\":()=>\"\\n\",\"%p\":d=>0<=d.oa&&12>d.oa?\"AM\":\"PM\",\"%S\":d=>k(d.ya,2),\"%t\":()=>\"\\t\",\"%u\":d=>d.ha||7,\"%U\":d=>k(Math.floor((d.ma+7-d.ha)/7),2),\"%V\":d=>\r\n{var n=Math.floor((d.ma+7-(d.ha+6)%7)/7);2>=(d.ha+371-d.ma-2)%7&&n++;if(n)53==n&&(p=(d.ha+371-d.ma)%7,4==p||3==p&&X(d.na)||(n=1));else{n=52;var p=(d.ha+7-d.ma-1)%7;(4==p||5==p&&X(d.na%400-1))&&n++}return k(n,2)},\"%w\":d=>d.ha,\"%W\":d=>k(Math.floor((d.ma+7-(d.ha+6)%7)/7),2),\"%y\":d=>(d.na+1900).toString().substring(2),\"%Y\":d=>d.na+1900,\"%z\":d=>{d=d.wa;var n=0<=d;d=Math.abs(d)/60;return(n?\"+\":\"-\")+String(\"0000\"+(d/60*100+d%60)).slice(-4)},\"%Z\":d=>d.za,\"%%\":()=>\"%\"};c=c.replace(/%%/g,\"\\x00\\x00\");for(u in t)c.includes(u)&&\r\n(c=c.replace(new RegExp(u,\"g\"),t[u](f)));c=c.replace(/\\0\\0/g,\"%\");u=Ka(c);if(u.length>b)return 0;K.set(u,a>>>0);return u.length-1}\r\nvar Na={a:function(a,b,c){a>>>=0;(new ra(a)).sa(b>>>0,c>>>0);sa=a;ta++;throw sa;},e:function(){return 0},I:function(){},y:function(){},A:function(){},K:function(){return 0},G:function(){},B:function(){},F:function(){},g:function(){},z:function(){},w:function(){},H:function(){},x:function(){},k:()=>!0,n:function(a,b,c){a=b+2097152>>>0<4194305-!!a?(a>>>0)+4294967296*b:NaN;c>>>=0;a=new Date(1E3*a);M[c>>2>>>0]=a.getUTCSeconds();M[c+4>>2>>>0]=a.getUTCMinutes();M[c+8>>2>>>0]=a.getUTCHours();M[c+12>>2>>>\r\n0]=a.getUTCDate();M[c+16>>2>>>0]=a.getUTCMonth();M[c+20>>2>>>0]=a.getUTCFullYear()-1900;M[c+24>>2>>>0]=a.getUTCDay();M[c+28>>2>>>0]=(a.getTime()-Date.UTC(a.getUTCFullYear(),0,1,0,0,0,0))/864E5|0},o:function(a,b,c){a=b+2097152>>>0<4194305-!!a?(a>>>0)+4294967296*b:NaN;c>>>=0;a=new Date(1E3*a);M[c>>2>>>0]=a.getSeconds();M[c+4>>2>>>0]=a.getMinutes();M[c+8>>2>>>0]=a.getHours();M[c+12>>2>>>0]=a.getDate();M[c+16>>2>>>0]=a.getMonth();M[c+20>>2>>>0]=a.getFullYear()-1900;M[c+24>>2>>>0]=a.getDay();M[c+28>>2>>>\r\n0]=(X(a.getFullYear())?wa:xa)[a.getMonth()]+a.getDate()-1|0;M[c+36>>2>>>0]=-(60*a.getTimezoneOffset());b=(new Date(a.getFullYear(),6,1)).getTimezoneOffset();var f=(new Date(a.getFullYear(),0,1)).getTimezoneOffset();M[c+32>>2>>>0]=(b!=f&&a.getTimezoneOffset()==Math.min(f,b))|0},p:function(a){a>>>=0;var b=new Date(M[a+20>>2>>>0]+1900,M[a+16>>2>>>0],M[a+12>>2>>>0],M[a+8>>2>>>0],M[a+4>>2>>>0],M[a>>2>>>0],0),c=M[a+32>>2>>>0],f=b.getTimezoneOffset(),g=(new Date(b.getFullYear(),6,1)).getTimezoneOffset(),\r\nk=(new Date(b.getFullYear(),0,1)).getTimezoneOffset(),l=Math.min(k,g);0>c?M[a+32>>2>>>0]=Number(g!=k&&l==f):0<c!=(l==f)&&(g=Math.max(k,g),b.setTime(b.getTime()+6E4*((0<c?l:g)-f)));M[a+24>>2>>>0]=b.getDay();M[a+28>>2>>>0]=(X(b.getFullYear())?wa:xa)[b.getMonth()]+b.getDate()-1|0;M[a>>2>>>0]=b.getSeconds();M[a+4>>2>>>0]=b.getMinutes();M[a+8>>2>>>0]=b.getHours();M[a+12>>2>>>0]=b.getDate();M[a+16>>2>>>0]=b.getMonth();M[a+20>>2>>>0]=b.getYear();a=b.getTime()/1E3;return Ma((S=a,1<=+Math.abs(S)?0<S?+Math.floor(S/\r\n4294967296)>>>0:~~+Math.ceil((S-+(~~S>>>0))/4294967296)>>>0:0)),a>>>0},l:function(){return-52},m:function(){},u:function(a,b,c){function f(w){return(w=w.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?w[1]:\"GMT\"}c>>>=0;var g=(new Date).getFullYear(),k=new Date(g,0,1),l=new Date(g,6,1);g=k.getTimezoneOffset();var r=l.getTimezoneOffset();N[a>>>0>>2>>>0]=60*Math.max(g,r);M[b>>>0>>2>>>0]=Number(g!=r);a=f(k);b=f(l);a=Ca(a);b=Ca(b);r<g?(N[c>>2>>>0]=a,N[c+4>>2>>>0]=b):(N[c>>2>>>0]=b,N[c+4>>2>>>0]=a)},d:()=>{G(\"\")},\r\nh:function(){return Date.now()},v:function(){return 4294901760},b:()=>performance.now(),J:function(a,b,c){b>>>=0;return L.copyWithin(a>>>0>>>0,b>>>0,b+(c>>>0)>>>0)},t:function(a){a>>>=0;var b=L.length;if(4294901760<a)return!1;for(var c=1;4>=c;c*=2){var f=b*(1+.2/c);f=Math.min(f,a+100663296);var g=Math;f=Math.max(a,f);a:{g=g.min.call(g,4294901760,f+(65536-f%65536)%65536)-H.buffer.byteLength+65535>>>16;try{H.grow(g);ea();var k=1;break a}catch(l){}k=void 0}if(k)return!0}return!1},D:function(a,b){a>>>=\r\n0;b>>>=0;var c=0;Ea().forEach(function(f,g){var k=b+c;g=N[a+4*g>>2>>>0]=k;for(k=0;k<f.length;++k)K[g++>>0>>>0]=f.charCodeAt(k);K[g>>0>>>0]=0;c+=f.length+1});return 0},E:function(a,b){a>>>=0;b>>>=0;var c=Ea();N[a>>2>>>0]=c.length;var f=0;c.forEach(function(g){f+=g.length+1});N[b>>2>>>0]=f;return 0},s:a=>{if(!noExitRuntime){if(e.onExit)e.onExit(a);J=!0}q(a,new qa(a))},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(a,b,c,f){b>>>=0;c>>>=0;f>>>=0;for(var g=0,k=0;k<c;k++){var l=N[b>>\r\n2>>>0],r=N[b+4>>2>>>0];b+=8;for(var w=0;w<r;w++){var t=L[l+w>>>0],u=Fa[a];0===t||10===t?((1===a?da:E)(va(u,0)),u.length=0):u.push(t)}g+=r}N[f>>2>>>0]=g;return 0},r:function(a,b){a>>>=0;Ha(L.subarray(a>>>0,a+(b>>>0)>>>0));return 0},C:La,c:function(a,b,c,f){return La(a>>>0,b>>>0,c>>>0,f>>>0)}};\r\n(function(){function a(c){c=c.exports;I=c=Oa(c);H=I.L;ea();ha.unshift(I.M);O--;e.monitorRunDependencies&&e.monitorRunDependencies(O);if(0==O&&(null!==P&&(clearInterval(P),P=null),Q)){var f=Q;Q=null;f()}return c}var b={a:Na};O++;e.monitorRunDependencies&&e.monitorRunDependencies(O);if(e.instantiateWasm)try{return e.instantiateWasm(b,a)}catch(c){E(\"Module.instantiateWasm callback failed with error: \"+c),h(c)}pa(b,function(c){a(c.instance)}).catch(h);return{}})();\r\ne._OrtInit=(a,b)=>(e._OrtInit=I.N)(a,b);e._OrtGetLastError=(a,b)=>(e._OrtGetLastError=I.O)(a,b);e._OrtCreateSessionOptions=(a,b,c,f,g,k,l,r,w,t)=>(e._OrtCreateSessionOptions=I.P)(a,b,c,f,g,k,l,r,w,t);e._OrtAppendExecutionProvider=(a,b)=>(e._OrtAppendExecutionProvider=I.Q)(a,b);e._OrtAddSessionConfigEntry=(a,b,c)=>(e._OrtAddSessionConfigEntry=I.R)(a,b,c);e._OrtReleaseSessionOptions=a=>(e._OrtReleaseSessionOptions=I.S)(a);e._OrtCreateSession=(a,b,c)=>(e._OrtCreateSession=I.T)(a,b,c);\r\ne._OrtReleaseSession=a=>(e._OrtReleaseSession=I.U)(a);e._OrtGetInputOutputCount=(a,b,c)=>(e._OrtGetInputOutputCount=I.V)(a,b,c);e._OrtGetInputName=(a,b)=>(e._OrtGetInputName=I.W)(a,b);e._OrtGetOutputName=(a,b)=>(e._OrtGetOutputName=I.X)(a,b);e._OrtFree=a=>(e._OrtFree=I.Y)(a);e._OrtCreateTensor=(a,b,c,f,g)=>(e._OrtCreateTensor=I.Z)(a,b,c,f,g);e._OrtGetTensorData=(a,b,c,f,g)=>(e._OrtGetTensorData=I._)(a,b,c,f,g);e._OrtReleaseTensor=a=>(e._OrtReleaseTensor=I.$)(a);\r\ne._OrtCreateRunOptions=(a,b,c,f)=>(e._OrtCreateRunOptions=I.aa)(a,b,c,f);e._OrtAddRunConfigEntry=(a,b,c)=>(e._OrtAddRunConfigEntry=I.ba)(a,b,c);e._OrtReleaseRunOptions=a=>(e._OrtReleaseRunOptions=I.ca)(a);e._OrtRun=(a,b,c,f,g,k,l,r)=>(e._OrtRun=I.da)(a,b,c,f,g,k,l,r);e._OrtEndProfiling=a=>(e._OrtEndProfiling=I.ea)(a);var ya=e._malloc=a=>(ya=e._malloc=I.fa)(a);e._free=a=>(e._free=I.ga)(a);var Ma=a=>(Ma=I.ia)(a),Pa=()=>(Pa=I.ja)(),Qa=a=>(Qa=I.ka)(a),Ra=a=>(Ra=I.la)(a);\r\nfunction Oa(a){a=Object.assign({},a);var b=f=>()=>f()>>>0,c=f=>g=>f(g)>>>0;a.__errno_location=b(a.__errno_location);a.malloc=c(a.malloc);a.stackSave=b(a.stackSave);a.stackAlloc=c(a.stackAlloc);return a}e.stackAlloc=Ra;e.stackSave=Pa;e.stackRestore=Qa;e.UTF8ToString=U;e.stringToUTF8=(a,b,c)=>W(a,L,b,c);e.lengthBytesUTF8=V;var Z;Q=function Sa(){Z||Ta();Z||(Q=Sa)};\r\nfunction Ta(){function a(){if(!Z&&(Z=!0,e.calledRun=!0,!J)){T(ha);aa(e);if(e.onRuntimeInitialized)e.onRuntimeInitialized();if(e.postRun)for(\"function\"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var b=e.postRun.shift();ia.unshift(b)}T(ia)}}if(!(0<O)){if(e.preRun)for(\"function\"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)ja();T(fa);0<O||(e.setStatus?(e.setStatus(\"Running...\"),setTimeout(function(){setTimeout(function(){e.setStatus(\"\")},1);a()},1)):a())}}\r\nif(e.preInit)for(\"function\"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();Ta();\r\n\r\n\r\n  return moduleArg.ready\r\n}\r\n\r\n);\r\n})();\r\nif (typeof exports === 'object' && typeof module === 'object')\r\n  module.exports = ortWasm;\r\nelse if (typeof define === 'function' && define['amd'])\r\n  define([], () => ortWasm);\r\n","\"use strict\";\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n","\"use strict\";\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n","\"use strict\";\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n","\"use strict\";\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n","\"use strict\";\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n","\"use strict\";\r\nexports.__esModule = true;\r\nvar Guid = /** @class */ (function () {\r\n    function Guid(guid) {\r\n        if (!guid) {\r\n            throw new TypeError(\"Invalid argument; `value` has no value.\");\r\n        }\r\n        this.value = Guid.EMPTY;\r\n        if (guid && Guid.isGuid(guid)) {\r\n            this.value = guid;\r\n        }\r\n    }\r\n    Guid.isGuid = function (guid) {\r\n        var value = guid.toString();\r\n        return guid && (guid instanceof Guid || Guid.validator.test(value));\r\n    };\r\n    Guid.create = function () {\r\n        return new Guid([Guid.gen(2), Guid.gen(1), Guid.gen(1), Guid.gen(1), Guid.gen(3)].join(\"-\"));\r\n    };\r\n    Guid.createEmpty = function () {\r\n        return new Guid(\"emptyguid\");\r\n    };\r\n    Guid.parse = function (guid) {\r\n        return new Guid(guid);\r\n    };\r\n    Guid.raw = function () {\r\n        return [Guid.gen(2), Guid.gen(1), Guid.gen(1), Guid.gen(1), Guid.gen(3)].join(\"-\");\r\n    };\r\n    Guid.gen = function (count) {\r\n        var out = \"\";\r\n        for (var i = 0; i < count; i++) {\r\n            // tslint:disable-next-line:no-bitwise\r\n            out += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\r\n        }\r\n        return out;\r\n    };\r\n    Guid.prototype.equals = function (other) {\r\n        // Comparing string `value` against provided `guid` will auto-call\r\n        // toString on `guid` for comparison\r\n        return Guid.isGuid(other) && this.value === other.toString();\r\n    };\r\n    Guid.prototype.isEmpty = function () {\r\n        return this.value === Guid.EMPTY;\r\n    };\r\n    Guid.prototype.toString = function () {\r\n        return this.value;\r\n    };\r\n    Guid.prototype.toJSON = function () {\r\n        return {\r\n            value: this.value\r\n        };\r\n    };\r\n    Guid.validator = new RegExp(\"^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$\", \"i\");\r\n    Guid.EMPTY = \"00000000-0000-0000-0000-000000000000\";\r\n    return Guid;\r\n}());\r\nexports.Guid = Guid;\r\n","// minimal library entry point.\n\n\"use strict\";\nmodule.exports = require(\"./src/index-minimal\");\n","\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = require(\"./writer\");\nprotobuf.BufferWriter = require(\"./writer_buffer\");\nprotobuf.Reader       = require(\"./reader\");\nprotobuf.BufferReader = require(\"./reader_buffer\");\n\n// Utility\nprotobuf.util         = require(\"./util/minimal\");\nprotobuf.rpc          = require(\"./rpc\");\nprotobuf.roots        = require(\"./roots\");\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n","\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n        ? new this.buf.constructor(0)\n        : this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n","\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(\"./reader\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n","\"use strict\";\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available across modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n","\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(\"./rpc/service\");\n","\"use strict\";\nmodule.exports = Service;\n\nvar util = require(\"../util/minimal\");\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n","\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(\"../util/minimal\");\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n","\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(\"@protobufjs/aspromise\");\n\n// converts to / from base64 encoded strings\nutil.base64 = require(\"@protobufjs/base64\");\n\n// base class of rpc.Service\nutil.EventEmitter = require(\"@protobufjs/eventemitter\");\n\n// float handling accross browsers\nutil.float = require(\"@protobufjs/float\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(\"@protobufjs/inquire\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(\"@protobufjs/utf8\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(\"@protobufjs/pool\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(\"./longbits\");\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n            value: CustomError,\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n        name: {\n            get: function get() { return name; },\n            set: undefined,\n            enumerable: false,\n            // configurable: false would accurately preserve the behavior of\n            // the original, but I'm guessing that was not intentional.\n            // For an actual error subclass, this property would\n            // be configurable.\n            configurable: true,\n        },\n        toString: {\n            value: function value() { return this.name + \": \" + this.message; },\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n    });\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n","\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n","\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(\"./writer\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveBackend = exports.registerBackend = void 0;\nconst backends = {};\nconst backendsSortedByPriority = [];\n/**\n * Register a backend.\n *\n * @param name - the name as a key to lookup as an execution provider.\n * @param backend - the backend object.\n * @param priority - an integer indicating the priority of the backend. Higher number means higher priority. if priority\n * < 0, it will be considered as a 'beta' version and will not be used as a fallback backend by default.\n *\n * @internal\n */\nconst registerBackend = (name, backend, priority) => {\n    if (backend && typeof backend.init === 'function' && typeof backend.createSessionHandler === 'function') {\n        const currentBackend = backends[name];\n        if (currentBackend === undefined) {\n            backends[name] = { backend, priority };\n        }\n        else if (currentBackend.priority > priority) {\n            // same name is already registered with a higher priority. skip registeration.\n            return;\n        }\n        else if (currentBackend.priority === priority) {\n            if (currentBackend.backend !== backend) {\n                throw new Error(`cannot register backend \"${name}\" using priority ${priority}`);\n            }\n        }\n        if (priority >= 0) {\n            const i = backendsSortedByPriority.indexOf(name);\n            if (i !== -1) {\n                backendsSortedByPriority.splice(i, 1);\n            }\n            for (let i = 0; i < backendsSortedByPriority.length; i++) {\n                if (backends[backendsSortedByPriority[i]].priority <= priority) {\n                    backendsSortedByPriority.splice(i, 0, name);\n                    return;\n                }\n            }\n            backendsSortedByPriority.push(name);\n        }\n        return;\n    }\n    throw new TypeError('not a valid backend');\n};\nexports.registerBackend = registerBackend;\n/**\n * Resolve backend by specified hints.\n *\n * @param backendHints - a list of execution provider names to lookup. If omitted use registered backends as list.\n * @returns a promise that resolves to the backend.\n *\n * @internal\n */\nconst resolveBackend = async (backendHints) => {\n    const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;\n    const errors = [];\n    for (const backendName of backendNames) {\n        const backendInfo = backends[backendName];\n        if (backendInfo) {\n            if (backendInfo.initialized) {\n                return backendInfo.backend;\n            }\n            else if (backendInfo.aborted) {\n                continue; // current backend is unavailable; try next\n            }\n            const isInitializing = !!backendInfo.initPromise;\n            try {\n                if (!isInitializing) {\n                    backendInfo.initPromise = backendInfo.backend.init();\n                }\n                await backendInfo.initPromise;\n                backendInfo.initialized = true;\n                return backendInfo.backend;\n            }\n            catch (e) {\n                if (!isInitializing) {\n                    errors.push({ name: backendName, err: e });\n                }\n                backendInfo.aborted = true;\n            }\n            finally {\n                delete backendInfo.initPromise;\n            }\n        }\n    }\n    throw new Error(`no available backend found. ERR: ${errors.map(e => `[${e.name}] ${e.err}`).join(', ')}`);\n};\nexports.resolveBackend = resolveBackend;\n//# sourceMappingURL=backend-impl.js.map","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.registerBackend = void 0;\nvar backend_impl_js_1 = require(\"./backend-impl.js\");\nObject.defineProperty(exports, \"registerBackend\", { enumerable: true, get: function () { return backend_impl_js_1.registerBackend; } });\n//# sourceMappingURL=backend.js.map","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.env = void 0;\nconst version_js_1 = require(\"./version.js\");\nlet logLevelValue = 'warning';\nexports.env = {\n    wasm: {},\n    webgl: {},\n    webgpu: {},\n    versions: { common: version_js_1.version },\n    set logLevel(value) {\n        if (value === undefined) {\n            return;\n        }\n        if (typeof value !== 'string' || ['verbose', 'info', 'warning', 'error', 'fatal'].indexOf(value) === -1) {\n            throw new Error(`Unsupported logging level: ${value}`);\n        }\n        logLevelValue = value;\n    },\n    get logLevel() {\n        return logLevelValue;\n    },\n};\n// set property 'logLevel' so that they can be correctly transferred to worker by `postMessage()`.\nObject.defineProperty(exports.env, 'logLevel', { enumerable: true });\n//# sourceMappingURL=env-impl.js.map","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.env = void 0;\nconst env_impl_js_1 = require(\"./env-impl.js\");\n/**\n * Represent a set of flags as a global singleton.\n */\nexports.env = env_impl_js_1.env;\n//# sourceMappingURL=env.js.map","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * # ONNX Runtime JavaScript API\n *\n * ONNX Runtime JavaScript API is a unified API for all JavaScript usages, including the following NPM packages:\n *\n * - [onnxruntime-node](https://www.npmjs.com/package/onnxruntime-node)\n * - [onnxruntime-web](https://www.npmjs.com/package/onnxruntime-web)\n * - [onnxruntime-react-native](https://www.npmjs.com/package/onnxruntime-react-native)\n *\n * See also:\n * - [Get Started](https://onnxruntime.ai/docs/get-started/with-javascript.html)\n * - [Inference examples](https://github.com/microsoft/onnxruntime-inference-examples/tree/main/js)\n *\n * @packageDocumentation\n */\n__exportStar(require(\"./backend.js\"), exports);\n__exportStar(require(\"./env.js\"), exports);\n__exportStar(require(\"./inference-session.js\"), exports);\n__exportStar(require(\"./tensor.js\"), exports);\n__exportStar(require(\"./onnx-value.js\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InferenceSession = void 0;\nconst backend_impl_js_1 = require(\"./backend-impl.js\");\nconst tensor_js_1 = require(\"./tensor.js\");\nclass InferenceSession {\n    constructor(handler) {\n        this.handler = handler;\n    }\n    async run(feeds, arg1, arg2) {\n        const fetches = {};\n        let options = {};\n        // check inputs\n        if (typeof feeds !== 'object' || feeds === null || feeds instanceof tensor_js_1.Tensor || Array.isArray(feeds)) {\n            throw new TypeError('\\'feeds\\' must be an object that use input names as keys and OnnxValue as corresponding values.');\n        }\n        let isFetchesEmpty = true;\n        // determine which override is being used\n        if (typeof arg1 === 'object') {\n            if (arg1 === null) {\n                throw new TypeError('Unexpected argument[1]: cannot be null.');\n            }\n            if (arg1 instanceof tensor_js_1.Tensor) {\n                throw new TypeError('\\'fetches\\' cannot be a Tensor');\n            }\n            if (Array.isArray(arg1)) {\n                if (arg1.length === 0) {\n                    throw new TypeError('\\'fetches\\' cannot be an empty array.');\n                }\n                isFetchesEmpty = false;\n                // output names\n                for (const name of arg1) {\n                    if (typeof name !== 'string') {\n                        throw new TypeError('\\'fetches\\' must be a string array or an object.');\n                    }\n                    if (this.outputNames.indexOf(name) === -1) {\n                        throw new RangeError(`'fetches' contains invalid output name: ${name}.`);\n                    }\n                    fetches[name] = null;\n                }\n                if (typeof arg2 === 'object' && arg2 !== null) {\n                    options = arg2;\n                }\n                else if (typeof arg2 !== 'undefined') {\n                    throw new TypeError('\\'options\\' must be an object.');\n                }\n            }\n            else {\n                // decide whether arg1 is fetches or options\n                // if any output name is present and its value is valid OnnxValue, we consider it fetches\n                let isFetches = false;\n                const arg1Keys = Object.getOwnPropertyNames(arg1);\n                for (const name of this.outputNames) {\n                    if (arg1Keys.indexOf(name) !== -1) {\n                        const v = arg1[name];\n                        if (v === null || v instanceof tensor_js_1.Tensor) {\n                            isFetches = true;\n                            isFetchesEmpty = false;\n                            fetches[name] = v;\n                        }\n                    }\n                }\n                if (isFetches) {\n                    if (typeof arg2 === 'object' && arg2 !== null) {\n                        options = arg2;\n                    }\n                    else if (typeof arg2 !== 'undefined') {\n                        throw new TypeError('\\'options\\' must be an object.');\n                    }\n                }\n                else {\n                    options = arg1;\n                }\n            }\n        }\n        else if (typeof arg1 !== 'undefined') {\n            throw new TypeError('Unexpected argument[1]: must be \\'fetches\\' or \\'options\\'.');\n        }\n        // check if all inputs are in feed\n        for (const name of this.inputNames) {\n            if (typeof feeds[name] === 'undefined') {\n                throw new Error(`input '${name}' is missing in 'feeds'.`);\n            }\n        }\n        // if no fetches is specified, we use the full output names list\n        if (isFetchesEmpty) {\n            for (const name of this.outputNames) {\n                fetches[name] = null;\n            }\n        }\n        // feeds, fetches and options are prepared\n        const results = await this.handler.run(feeds, fetches, options);\n        const returnValue = {};\n        for (const key in results) {\n            if (Object.hasOwnProperty.call(results, key)) {\n                returnValue[key] = new tensor_js_1.Tensor(results[key].type, results[key].data, results[key].dims);\n            }\n        }\n        return returnValue;\n    }\n    async release() {\n        return this.handler.dispose();\n    }\n    static async create(arg0, arg1, arg2, arg3) {\n        // either load from a file or buffer\n        let filePathOrUint8Array;\n        let options = {};\n        if (typeof arg0 === 'string') {\n            filePathOrUint8Array = arg0;\n            if (typeof arg1 === 'object' && arg1 !== null) {\n                options = arg1;\n            }\n            else if (typeof arg1 !== 'undefined') {\n                throw new TypeError('\\'options\\' must be an object.');\n            }\n        }\n        else if (arg0 instanceof Uint8Array) {\n            filePathOrUint8Array = arg0;\n            if (typeof arg1 === 'object' && arg1 !== null) {\n                options = arg1;\n            }\n            else if (typeof arg1 !== 'undefined') {\n                throw new TypeError('\\'options\\' must be an object.');\n            }\n        }\n        else if (arg0 instanceof ArrayBuffer ||\n            (typeof SharedArrayBuffer !== 'undefined' && arg0 instanceof SharedArrayBuffer)) {\n            const buffer = arg0;\n            let byteOffset = 0;\n            let byteLength = arg0.byteLength;\n            if (typeof arg1 === 'object' && arg1 !== null) {\n                options = arg1;\n            }\n            else if (typeof arg1 === 'number') {\n                byteOffset = arg1;\n                if (!Number.isSafeInteger(byteOffset)) {\n                    throw new RangeError('\\'byteOffset\\' must be an integer.');\n                }\n                if (byteOffset < 0 || byteOffset >= buffer.byteLength) {\n                    throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);\n                }\n                byteLength = arg0.byteLength - byteOffset;\n                if (typeof arg2 === 'number') {\n                    byteLength = arg2;\n                    if (!Number.isSafeInteger(byteLength)) {\n                        throw new RangeError('\\'byteLength\\' must be an integer.');\n                    }\n                    if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {\n                        throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);\n                    }\n                    if (typeof arg3 === 'object' && arg3 !== null) {\n                        options = arg3;\n                    }\n                    else if (typeof arg3 !== 'undefined') {\n                        throw new TypeError('\\'options\\' must be an object.');\n                    }\n                }\n                else if (typeof arg2 !== 'undefined') {\n                    throw new TypeError('\\'byteLength\\' must be a number.');\n                }\n            }\n            else if (typeof arg1 !== 'undefined') {\n                throw new TypeError('\\'options\\' must be an object.');\n            }\n            filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);\n        }\n        else {\n            throw new TypeError('Unexpected argument[0]: must be \\'path\\' or \\'buffer\\'.');\n        }\n        // get backend hints\n        const eps = options.executionProviders || [];\n        const backendHints = eps.map(i => typeof i === 'string' ? i : i.name);\n        const backend = await (0, backend_impl_js_1.resolveBackend)(backendHints);\n        const handler = await backend.createSessionHandler(filePathOrUint8Array, options);\n        return new InferenceSession(handler);\n    }\n    startProfiling() {\n        this.handler.startProfiling();\n    }\n    endProfiling() {\n        this.handler.endProfiling();\n    }\n    get inputNames() {\n        return this.handler.inputNames;\n    }\n    get outputNames() {\n        return this.handler.outputNames;\n    }\n}\nexports.InferenceSession = InferenceSession;\n//# sourceMappingURL=inference-session-impl.js.map","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InferenceSession = void 0;\nconst inference_session_impl_js_1 = require(\"./inference-session-impl.js\");\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexports.InferenceSession = inference_session_impl_js_1.InferenceSession;\n//# sourceMappingURL=inference-session.js.map","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=onnx-value.js.map","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.tensorToImageData = exports.tensorToDataURL = void 0;\n/**\n * implementation of Tensor.toDataURL()\n */\nconst tensorToDataURL = (tensor, options) => {\n    const canvas = document.createElement('canvas');\n    canvas.width = tensor.dims[3];\n    canvas.height = tensor.dims[2];\n    const pixels2DContext = canvas.getContext('2d');\n    if (pixels2DContext != null) {\n        // Default values for height and width & format\n        let width;\n        let height;\n        if (options?.tensorLayout !== undefined && options.tensorLayout === 'NHWC') {\n            width = tensor.dims[2];\n            height = tensor.dims[3];\n        }\n        else { // Default layout is NCWH\n            width = tensor.dims[3];\n            height = tensor.dims[2];\n        }\n        const inputformat = options?.format !== undefined ? options.format : 'RGB';\n        const norm = options?.norm;\n        let normMean;\n        let normBias;\n        if (norm === undefined || norm.mean === undefined) {\n            normMean = [255, 255, 255, 255];\n        }\n        else {\n            if (typeof (norm.mean) === 'number') {\n                normMean = [norm.mean, norm.mean, norm.mean, norm.mean];\n            }\n            else {\n                normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 0];\n                if (norm.mean[3] !== undefined) {\n                    normMean[3] = norm.mean[3];\n                }\n            }\n        }\n        if (norm === undefined || norm.bias === undefined) {\n            normBias = [0, 0, 0, 0];\n        }\n        else {\n            if (typeof (norm.bias) === 'number') {\n                normBias = [norm.bias, norm.bias, norm.bias, norm.bias];\n            }\n            else {\n                normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];\n                if (norm.bias[3] !== undefined) {\n                    normBias[3] = norm.bias[3];\n                }\n            }\n        }\n        const stride = height * width;\n        // Default pointer assignments\n        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;\n        // Updating the pointer assignments based on the input image format\n        if (inputformat === 'RGBA') {\n            rTensorPointer = 0;\n            gTensorPointer = stride;\n            bTensorPointer = stride * 2;\n            aTensorPointer = stride * 3;\n        }\n        else if (inputformat === 'RGB') {\n            rTensorPointer = 0;\n            gTensorPointer = stride;\n            bTensorPointer = stride * 2;\n        }\n        else if (inputformat === 'RBG') {\n            rTensorPointer = 0;\n            bTensorPointer = stride;\n            gTensorPointer = stride * 2;\n        }\n        for (let i = 0; i < height; i++) {\n            for (let j = 0; j < width; j++) {\n                const R = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0]; // R value\n                const G = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1]; // G value\n                const B = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2]; // B value\n                const A = aTensorPointer === -1 ?\n                    255 :\n                    (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3]; // A value\n                // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n                pixels2DContext.fillStyle = 'rgba(' + R + ',' + G + ',' + B + ',' + A + ')';\n                pixels2DContext.fillRect(j, i, 1, 1);\n            }\n        }\n        return canvas.toDataURL();\n    }\n    else {\n        throw new Error('Can not access image data');\n    }\n};\nexports.tensorToDataURL = tensorToDataURL;\n/**\n * implementation of Tensor.toImageData()\n */\nconst tensorToImageData = (tensor, options) => {\n    const pixels2DContext = document.createElement('canvas').getContext('2d');\n    let image;\n    if (pixels2DContext != null) {\n        // Default values for height and width & format\n        let width;\n        let height;\n        let channels;\n        if (options?.tensorLayout !== undefined && options.tensorLayout === 'NHWC') {\n            width = tensor.dims[2];\n            height = tensor.dims[1];\n            channels = tensor.dims[3];\n        }\n        else { // Default layout is NCWH\n            width = tensor.dims[3];\n            height = tensor.dims[2];\n            channels = tensor.dims[1];\n        }\n        const inputformat = options !== undefined ? (options.format !== undefined ? options.format : 'RGB') : 'RGB';\n        const norm = options?.norm;\n        let normMean;\n        let normBias;\n        if (norm === undefined || norm.mean === undefined) {\n            normMean = [255, 255, 255, 255];\n        }\n        else {\n            if (typeof (norm.mean) === 'number') {\n                normMean = [norm.mean, norm.mean, norm.mean, norm.mean];\n            }\n            else {\n                normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 255];\n                if (norm.mean[3] !== undefined) {\n                    normMean[3] = norm.mean[3];\n                }\n            }\n        }\n        if (norm === undefined || norm.bias === undefined) {\n            normBias = [0, 0, 0, 0];\n        }\n        else {\n            if (typeof (norm.bias) === 'number') {\n                normBias = [norm.bias, norm.bias, norm.bias, norm.bias];\n            }\n            else {\n                normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];\n                if (norm.bias[3] !== undefined) {\n                    normBias[3] = norm.bias[3];\n                }\n            }\n        }\n        const stride = height * width;\n        if (options !== undefined) {\n            if (options.format !== undefined && (channels === 4 && options.format !== 'RGBA') ||\n                (channels === 3 && (options.format !== 'RGB' && options.format !== 'BGR'))) {\n                throw new Error('Tensor format doesn\\'t match input tensor dims');\n            }\n        }\n        // Default pointer assignments\n        const step = 4;\n        let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;\n        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;\n        // Updating the pointer assignments based on the input image format\n        if (inputformat === 'RGBA') {\n            rTensorPointer = 0;\n            gTensorPointer = stride;\n            bTensorPointer = stride * 2;\n            aTensorPointer = stride * 3;\n        }\n        else if (inputformat === 'RGB') {\n            rTensorPointer = 0;\n            gTensorPointer = stride;\n            bTensorPointer = stride * 2;\n        }\n        else if (inputformat === 'RBG') {\n            rTensorPointer = 0;\n            bTensorPointer = stride;\n            gTensorPointer = stride * 2;\n        }\n        image = pixels2DContext.createImageData(width, height);\n        for (let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {\n            image.data[rImagePointer] = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0]; // R value\n            image.data[gImagePointer] = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1]; // G value\n            image.data[bImagePointer] = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2]; // B value\n            image.data[aImagePointer] = aTensorPointer === -1 ?\n                255 :\n                (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3]; // A value\n        }\n    }\n    else {\n        throw new Error('Can not access image data');\n    }\n    return image;\n};\nexports.tensorToImageData = tensorToImageData;\n//# sourceMappingURL=tensor-conversion-impl.js.map","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.tensorFromImage = exports.bufferToTensor = void 0;\nconst tensor_js_1 = require(\"./tensor.js\");\n/**\n * Create a new tensor object from image object\n *\n * @param buffer - Extracted image buffer data - assuming RGBA format\n * @param imageFormat - input image configuration - required configurations height, width, format\n * @param tensorFormat - output tensor configuration - Default is RGB format\n */\nconst bufferToTensor = (buffer, options) => {\n    if (buffer === undefined) {\n        throw new Error('Image buffer must be defined');\n    }\n    if (options.height === undefined || options.width === undefined) {\n        throw new Error('Image height and width must be defined');\n    }\n    if (options.tensorLayout === 'NHWC') {\n        throw new Error('NHWC Tensor layout is not supported yet');\n    }\n    const { height, width } = options;\n    const norm = options.norm ?? { mean: 255, bias: 0 };\n    let normMean;\n    let normBias;\n    if (typeof (norm.mean) === 'number') {\n        normMean = [norm.mean, norm.mean, norm.mean, norm.mean];\n    }\n    else {\n        normMean = [norm.mean[0], norm.mean[1], norm.mean[2], norm.mean[3] ?? 255];\n    }\n    if (typeof (norm.bias) === 'number') {\n        normBias = [norm.bias, norm.bias, norm.bias, norm.bias];\n    }\n    else {\n        normBias = [norm.bias[0], norm.bias[1], norm.bias[2], norm.bias[3] ?? 0];\n    }\n    const inputformat = options.format !== undefined ? options.format : 'RGBA';\n    // default value is RGBA since imagedata and HTMLImageElement uses it\n    const outputformat = options.tensorFormat !== undefined ?\n        (options.tensorFormat !== undefined ? options.tensorFormat : 'RGB') :\n        'RGB';\n    const stride = height * width;\n    const float32Data = outputformat === 'RGBA' ? new Float32Array(stride * 4) : new Float32Array(stride * 3);\n    // Default pointer assignments\n    let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;\n    let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;\n    // Updating the pointer assignments based on the input image format\n    if (inputformat === 'RGB') {\n        step = 3;\n        rImagePointer = 0;\n        gImagePointer = 1;\n        bImagePointer = 2;\n        aImagePointer = -1;\n    }\n    // Updating the pointer assignments based on the output tensor format\n    if (outputformat === 'RGBA') {\n        aTensorPointer = stride * 3;\n    }\n    else if (outputformat === 'RBG') {\n        rTensorPointer = 0;\n        bTensorPointer = stride;\n        gTensorPointer = stride * 2;\n    }\n    else if (outputformat === 'BGR') {\n        bTensorPointer = 0;\n        gTensorPointer = stride;\n        rTensorPointer = stride * 2;\n    }\n    for (let i = 0; i < stride; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {\n        float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias[0]) / normMean[0];\n        float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias[1]) / normMean[1];\n        float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias[2]) / normMean[2];\n        if (aTensorPointer !== -1 && aImagePointer !== -1) {\n            float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias[3]) / normMean[3];\n        }\n    }\n    // Float32Array -> ort.Tensor\n    const outputTensor = outputformat === 'RGBA' ? new tensor_js_1.Tensor('float32', float32Data, [1, 4, height, width]) :\n        new tensor_js_1.Tensor('float32', float32Data, [1, 3, height, width]);\n    return outputTensor;\n};\nexports.bufferToTensor = bufferToTensor;\n/**\n * implementation of Tensor.fromImage().\n */\nconst tensorFromImage = async (image, options) => {\n    // checking the type of image object\n    const isHTMLImageEle = typeof (HTMLImageElement) !== 'undefined' && image instanceof HTMLImageElement;\n    const isImageDataEle = typeof (ImageData) !== 'undefined' && image instanceof ImageData;\n    const isImageBitmap = typeof (ImageBitmap) !== 'undefined' && image instanceof ImageBitmap;\n    const isString = typeof image === 'string';\n    let data;\n    let bufferToTensorOptions = options ?? {};\n    // filling and checking image configuration options\n    if (isHTMLImageEle) {\n        // HTMLImageElement - image object - format is RGBA by default\n        const canvas = document.createElement('canvas');\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const pixels2DContext = canvas.getContext('2d');\n        if (pixels2DContext != null) {\n            let height = image.height;\n            let width = image.width;\n            if (options !== undefined && options.resizedHeight !== undefined && options.resizedWidth !== undefined) {\n                height = options.resizedHeight;\n                width = options.resizedWidth;\n            }\n            if (options !== undefined) {\n                bufferToTensorOptions = options;\n                if (options.tensorFormat !== undefined) {\n                    throw new Error('Image input config format must be RGBA for HTMLImageElement');\n                }\n                else {\n                    bufferToTensorOptions.tensorFormat = 'RGBA';\n                }\n                bufferToTensorOptions.height = height;\n                bufferToTensorOptions.width = width;\n            }\n            else {\n                bufferToTensorOptions.tensorFormat = 'RGBA';\n                bufferToTensorOptions.height = height;\n                bufferToTensorOptions.width = width;\n            }\n            pixels2DContext.drawImage(image, 0, 0);\n            data = pixels2DContext.getImageData(0, 0, width, height).data;\n        }\n        else {\n            throw new Error('Can not access image data');\n        }\n    }\n    else if (isImageDataEle) {\n        let height;\n        let width;\n        if (options !== undefined && options.resizedWidth !== undefined && options.resizedHeight !== undefined) {\n            height = options.resizedHeight;\n            width = options.resizedWidth;\n        }\n        else {\n            height = image.height;\n            width = image.width;\n        }\n        if (options !== undefined) {\n            bufferToTensorOptions = options;\n        }\n        bufferToTensorOptions.format = 'RGBA';\n        bufferToTensorOptions.height = height;\n        bufferToTensorOptions.width = width;\n        if (options !== undefined) {\n            const tempCanvas = document.createElement('canvas');\n            tempCanvas.width = width;\n            tempCanvas.height = height;\n            const pixels2DContext = tempCanvas.getContext('2d');\n            if (pixels2DContext != null) {\n                pixels2DContext.putImageData(image, 0, 0);\n                data = pixels2DContext.getImageData(0, 0, width, height).data;\n            }\n            else {\n                throw new Error('Can not access image data');\n            }\n        }\n        else {\n            data = image.data;\n        }\n    }\n    else if (isImageBitmap) {\n        // ImageBitmap - image object - format must be provided by user\n        if (options === undefined) {\n            throw new Error('Please provide image config with format for Imagebitmap');\n        }\n        const canvas = document.createElement('canvas');\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const pixels2DContext = canvas.getContext('2d');\n        if (pixels2DContext != null) {\n            const height = image.height;\n            const width = image.width;\n            pixels2DContext.drawImage(image, 0, 0, width, height);\n            data = pixels2DContext.getImageData(0, 0, width, height).data;\n            bufferToTensorOptions.height = height;\n            bufferToTensorOptions.width = width;\n            return (0, exports.bufferToTensor)(data, bufferToTensorOptions);\n        }\n        else {\n            throw new Error('Can not access image data');\n        }\n    }\n    else if (isString) {\n        return new Promise((resolve, reject) => {\n            const canvas = document.createElement('canvas');\n            const context = canvas.getContext('2d');\n            if (!image || !context) {\n                return reject();\n            }\n            const newImage = new Image();\n            newImage.crossOrigin = 'Anonymous';\n            newImage.src = image;\n            newImage.onload = () => {\n                canvas.width = newImage.width;\n                canvas.height = newImage.height;\n                context.drawImage(newImage, 0, 0, canvas.width, canvas.height);\n                const img = context.getImageData(0, 0, canvas.width, canvas.height);\n                bufferToTensorOptions.height = canvas.height;\n                bufferToTensorOptions.width = canvas.width;\n                resolve((0, exports.bufferToTensor)(img.data, bufferToTensorOptions));\n            };\n        });\n    }\n    else {\n        throw new Error('Input data provided is not supported - aborted tensor creation');\n    }\n    if (data !== undefined) {\n        return (0, exports.bufferToTensor)(data, bufferToTensorOptions);\n    }\n    else {\n        throw new Error('Input data provided is not supported - aborted tensor creation');\n    }\n};\nexports.tensorFromImage = tensorFromImage;\n//# sourceMappingURL=tensor-factory-impl.js.map","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Tensor = void 0;\nconst tensor_conversion_impl_js_1 = require(\"./tensor-conversion-impl.js\");\nconst tensor_factory_impl_js_1 = require(\"./tensor-factory-impl.js\");\nconst tensor_utils_impl_js_1 = require(\"./tensor-utils-impl.js\");\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\nconst NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map([\n    ['float32', Float32Array],\n    ['uint8', Uint8Array],\n    ['int8', Int8Array],\n    ['uint16', Uint16Array],\n    ['float16', Uint16Array],\n    ['int16', Int16Array],\n    ['int32', Int32Array],\n    ['bool', Uint8Array],\n    ['float64', Float64Array],\n    ['uint32', Uint32Array],\n]);\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\nconst NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map([\n    [Float32Array, 'float32'],\n    [Uint8Array, 'uint8'],\n    [Int8Array, 'int8'],\n    [Uint16Array, 'uint16'],\n    [Int16Array, 'int16'],\n    [Int32Array, 'int32'],\n    [Float64Array, 'float64'],\n    [Uint32Array, 'uint32'],\n]);\n// the following code allows delaying execution of BigInt checking. This allows lazy initialization for\n// NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP and NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP, which allows BigInt polyfill\n// if available.\nlet isBigIntChecked = false;\nconst checkBigInt = () => {\n    if (!isBigIntChecked) {\n        isBigIntChecked = true;\n        const isBigInt64ArrayAvailable = typeof BigInt64Array !== 'undefined' && typeof BigInt64Array.from === 'function';\n        const isBigUint64ArrayAvailable = typeof BigUint64Array !== 'undefined' && typeof BigUint64Array.from === 'function';\n        if (isBigInt64ArrayAvailable) {\n            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('int64', BigInt64Array);\n            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, 'int64');\n        }\n        if (isBigUint64ArrayAvailable) {\n            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('uint64', BigUint64Array);\n            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, 'uint64');\n        }\n    }\n};\nclass Tensor {\n    constructor(arg0, arg1, arg2) {\n        checkBigInt();\n        let type;\n        let data;\n        let dims;\n        // check whether arg0 is type or data\n        if (typeof arg0 === 'string') {\n            //\n            // Override: constructor(type, data, ...)\n            //\n            type = arg0;\n            dims = arg2;\n            if (arg0 === 'string') {\n                // string tensor\n                if (!Array.isArray(arg1)) {\n                    throw new TypeError('A string tensor\\'s data must be a string array.');\n                }\n                // we don't check whether every element in the array is string; this is too slow. we assume it's correct and\n                // error will be populated at inference\n                data = arg1;\n            }\n            else {\n                // numeric tensor\n                const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);\n                if (typedArrayConstructor === undefined) {\n                    throw new TypeError(`Unsupported tensor type: ${arg0}.`);\n                }\n                if (Array.isArray(arg1)) {\n                    if (arg0 === 'float16') {\n                        // Throw error here because when user try to use number array as data,\n                        // e.g. new Tensor('float16', [1, 2, 3, 4], dims)), it will actually call\n                        // Uint16Array.from(arg1) which generates wrong data.\n                        throw new TypeError('Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.');\n                    }\n                    else if (arg0 === 'uint64' || arg0 === 'int64') {\n                        // use 'as any' here because:\n                        // 1. TypeScript's check on type of 'Array.isArray()' does not work with readonly arrays.\n                        // see https://github.com/microsoft/TypeScript/issues/17002\n                        // 2. TypeScript's check on union type of '(BigInt64ArrayConstructor|BigUint64ArrayConstructor).from()' does\n                        // not accept parameter mapFn.\n                        // 3. parameters of 'SupportedTypedArrayConstructors.from()' does not match the requirement of the union\n                        // type.\n                        // assume 'arg1' is of type \"readonly number[]|readonly bigint[]\" here.\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        data = typedArrayConstructor.from(arg1, BigInt);\n                    }\n                    else {\n                        // assume 'arg1' is of type \"readonly number[]\" here.\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        data = typedArrayConstructor.from(arg1);\n                    }\n                }\n                else if (arg1 instanceof typedArrayConstructor) {\n                    data = arg1;\n                }\n                else {\n                    throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);\n                }\n            }\n        }\n        else {\n            //\n            // Override: constructor(data, ...)\n            //\n            dims = arg1;\n            if (Array.isArray(arg0)) {\n                // only boolean[] and string[] is supported\n                if (arg0.length === 0) {\n                    throw new TypeError('Tensor type cannot be inferred from an empty array.');\n                }\n                const firstElementType = typeof arg0[0];\n                if (firstElementType === 'string') {\n                    type = 'string';\n                    data = arg0;\n                }\n                else if (firstElementType === 'boolean') {\n                    type = 'bool';\n                    // 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is\n                    // wrong type. We use 'as any' to make it happy.\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    data = Uint8Array.from(arg0);\n                }\n                else {\n                    throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);\n                }\n            }\n            else {\n                // get tensor type from TypedArray\n                const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);\n                if (mappedType === undefined) {\n                    throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);\n                }\n                type = mappedType;\n                data = arg0;\n            }\n        }\n        // type and data is processed, now processing dims\n        if (dims === undefined) {\n            // assume 1-D tensor if dims omitted\n            dims = [data.length];\n        }\n        else if (!Array.isArray(dims)) {\n            throw new TypeError('A tensor\\'s dims must be a number array');\n        }\n        // perform check\n        const size = (0, tensor_utils_impl_js_1.calculateSize)(dims);\n        if (size !== data.length) {\n            throw new Error(`Tensor's size(${size}) does not match data length(${data.length}).`);\n        }\n        this.dims = dims;\n        this.type = type;\n        this.data = data;\n        this.size = size;\n    }\n    static async fromImage(image, options) {\n        return (0, tensor_factory_impl_js_1.tensorFromImage)(image, options);\n    }\n    // #endregion\n    // #region conversions\n    toDataURL(options) {\n        return (0, tensor_conversion_impl_js_1.tensorToDataURL)(this, options);\n    }\n    toImageData(options) {\n        return (0, tensor_conversion_impl_js_1.tensorToImageData)(this, options);\n    }\n    // #endregion\n    // #region tensor utilities\n    reshape(dims) {\n        return (0, tensor_utils_impl_js_1.tensorReshape)(this, dims);\n    }\n}\nexports.Tensor = Tensor;\n//# sourceMappingURL=tensor-impl.js.map","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.tensorReshape = exports.calculateSize = void 0;\nconst tensor_js_1 = require(\"./tensor.js\");\n/**\n * calculate size from dims.\n *\n * @param dims the dims array. May be an illegal input.\n */\nconst calculateSize = (dims) => {\n    let size = 1;\n    for (let i = 0; i < dims.length; i++) {\n        const dim = dims[i];\n        if (typeof dim !== 'number' || !Number.isSafeInteger(dim)) {\n            throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);\n        }\n        if (dim < 0) {\n            throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);\n        }\n        size *= dim;\n    }\n    return size;\n};\nexports.calculateSize = calculateSize;\n/**\n * implementation of Tensor.reshape()\n */\nconst tensorReshape = (tensor, dims) => new tensor_js_1.Tensor(tensor.type, tensor.data, dims);\nexports.tensorReshape = tensorReshape;\n//# sourceMappingURL=tensor-utils-impl.js.map","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Tensor = void 0;\nconst tensor_impl_js_1 = require(\"./tensor-impl.js\");\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexports.Tensor = tensor_impl_js_1.Tensor;\n//# sourceMappingURL=tensor.js.map","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.version = void 0;\n// This file is generated by /js/scripts/update-version.ts\n// Do not modify file content manually.\nexports.version = '1.16.3';\n//# sourceMappingURL=version.js.map","// GENERATED FILE. DO NOT EDIT.\nvar Long = (function(exports) {\n  \"use strict\";\n  \n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.default = void 0;\n  \n  /**\n   * @license\n   * Copyright 2009 The Closure Library Authors\n   * Copyright 2020 Daniel Wirtz / The long.js Authors.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *\n   * SPDX-License-Identifier: Apache-2.0\n   */\n  // WebAssembly optimizations to do native i64 multiplication and divide\n  var wasm = null;\n  \n  try {\n    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;\n  } catch (e) {// no wasm support :(\n  }\n  /**\n   * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n   *  See the from* functions below for more convenient ways of constructing Longs.\n   * @exports Long\n   * @class A Long class for representing a 64 bit two's-complement integer value.\n   * @param {number} low The low (signed) 32 bits of the long\n   * @param {number} high The high (signed) 32 bits of the long\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @constructor\n   */\n  \n  \n  function Long(low, high, unsigned) {\n    /**\n     * The low 32 bits as a signed value.\n     * @type {number}\n     */\n    this.low = low | 0;\n    /**\n     * The high 32 bits as a signed value.\n     * @type {number}\n     */\n  \n    this.high = high | 0;\n    /**\n     * Whether unsigned or not.\n     * @type {boolean}\n     */\n  \n    this.unsigned = !!unsigned;\n  } // The internal representation of a long is the two given signed, 32-bit values.\n  // We use 32-bit pieces because these are the size of integers on which\n  // Javascript performs bit-operations.  For operations like addition and\n  // multiplication, we split each number into 16 bit pieces, which can easily be\n  // multiplied within Javascript's floating-point representation without overflow\n  // or change in sign.\n  //\n  // In the algorithms below, we frequently reduce the negative case to the\n  // positive case by negating the input(s) and then post-processing the result.\n  // Note that we must ALWAYS check specially whether those values are MIN_VALUE\n  // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n  // a positive number, it overflows back into a negative).  Not handling this\n  // case would often result in infinite recursion.\n  //\n  // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n  // methods on which they depend.\n  \n  /**\n   * An indicator used to reliably determine if an object is a Long or not.\n   * @type {boolean}\n   * @const\n   * @private\n   */\n  \n  \n  Long.prototype.__isLong__;\n  Object.defineProperty(Long.prototype, \"__isLong__\", {\n    value: true\n  });\n  /**\n   * @function\n   * @param {*} obj Object\n   * @returns {boolean}\n   * @inner\n   */\n  \n  function isLong(obj) {\n    return (obj && obj[\"__isLong__\"]) === true;\n  }\n  /**\n   * @function\n   * @param {*} value number\n   * @returns {number}\n   * @inner\n   */\n  \n  \n  function ctz32(value) {\n    var c = Math.clz32(value & -value);\n    return value ? 31 - c : c;\n  }\n  /**\n   * Tests if the specified object is a Long.\n   * @function\n   * @param {*} obj Object\n   * @returns {boolean}\n   */\n  \n  \n  Long.isLong = isLong;\n  /**\n   * A cache of the Long representations of small integer values.\n   * @type {!Object}\n   * @inner\n   */\n  \n  var INT_CACHE = {};\n  /**\n   * A cache of the Long representations of small unsigned integer values.\n   * @type {!Object}\n   * @inner\n   */\n  \n  var UINT_CACHE = {};\n  /**\n   * @param {number} value\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */\n  \n  function fromInt(value, unsigned) {\n    var obj, cachedObj, cache;\n  \n    if (unsigned) {\n      value >>>= 0;\n  \n      if (cache = 0 <= value && value < 256) {\n        cachedObj = UINT_CACHE[value];\n        if (cachedObj) return cachedObj;\n      }\n  \n      obj = fromBits(value, 0, true);\n      if (cache) UINT_CACHE[value] = obj;\n      return obj;\n    } else {\n      value |= 0;\n  \n      if (cache = -128 <= value && value < 128) {\n        cachedObj = INT_CACHE[value];\n        if (cachedObj) return cachedObj;\n      }\n  \n      obj = fromBits(value, value < 0 ? -1 : 0, false);\n      if (cache) INT_CACHE[value] = obj;\n      return obj;\n    }\n  }\n  /**\n   * Returns a Long representing the given 32 bit integer value.\n   * @function\n   * @param {number} value The 32 bit integer in question\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */\n  \n  \n  Long.fromInt = fromInt;\n  /**\n   * @param {number} value\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */\n  \n  function fromNumber(value, unsigned) {\n    if (isNaN(value)) return unsigned ? UZERO : ZERO;\n  \n    if (unsigned) {\n      if (value < 0) return UZERO;\n      if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;\n    } else {\n      if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;\n      if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;\n    }\n  \n    if (value < 0) return fromNumber(-value, unsigned).neg();\n    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n  }\n  /**\n   * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n   * @function\n   * @param {number} value The number in question\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */\n  \n  \n  Long.fromNumber = fromNumber;\n  /**\n   * @param {number} lowBits\n   * @param {number} highBits\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */\n  \n  function fromBits(lowBits, highBits, unsigned) {\n    return new Long(lowBits, highBits, unsigned);\n  }\n  /**\n   * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n   *  assumed to use 32 bits.\n   * @function\n   * @param {number} lowBits The low 32 bits\n   * @param {number} highBits The high 32 bits\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */\n  \n  \n  Long.fromBits = fromBits;\n  /**\n   * @function\n   * @param {number} base\n   * @param {number} exponent\n   * @returns {number}\n   * @inner\n   */\n  \n  var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\n  \n  /**\n   * @param {string} str\n   * @param {(boolean|number)=} unsigned\n   * @param {number=} radix\n   * @returns {!Long}\n   * @inner\n   */\n  \n  function fromString(str, unsigned, radix) {\n    if (str.length === 0) throw Error('empty string');\n  \n    if (typeof unsigned === 'number') {\n      // For goog.math.long compatibility\n      radix = unsigned;\n      unsigned = false;\n    } else {\n      unsigned = !!unsigned;\n    }\n  \n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\") return unsigned ? UZERO : ZERO;\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix) throw RangeError('radix');\n    var p;\n    if ((p = str.indexOf('-')) > 0) throw Error('interior hyphen');else if (p === 0) {\n      return fromString(str.substring(1), unsigned, radix).neg();\n    } // Do several (8) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n  \n    var radixToPower = fromNumber(pow_dbl(radix, 8));\n    var result = ZERO;\n  \n    for (var i = 0; i < str.length; i += 8) {\n      var size = Math.min(8, str.length - i),\n          value = parseInt(str.substring(i, i + size), radix);\n  \n      if (size < 8) {\n        var power = fromNumber(pow_dbl(radix, size));\n        result = result.mul(power).add(fromNumber(value));\n      } else {\n        result = result.mul(radixToPower);\n        result = result.add(fromNumber(value));\n      }\n    }\n  \n    result.unsigned = unsigned;\n    return result;\n  }\n  /**\n   * Returns a Long representation of the given string, written using the specified radix.\n   * @function\n   * @param {string} str The textual representation of the Long\n   * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\n   * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n   * @returns {!Long} The corresponding Long value\n   */\n  \n  \n  Long.fromString = fromString;\n  /**\n   * @function\n   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */\n  \n  function fromValue(val, unsigned) {\n    if (typeof val === 'number') return fromNumber(val, unsigned);\n    if (typeof val === 'string') return fromString(val, unsigned); // Throws for non-objects, converts non-instanceof Long:\n  \n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\n  }\n  /**\n   * Converts the specified value to a Long using the appropriate from* function for its type.\n   * @function\n   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long}\n   */\n  \n  \n  Long.fromValue = fromValue; // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n  // no runtime penalty for these.\n  \n  /**\n   * @type {number}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_16_DBL = 1 << 16;\n  /**\n   * @type {number}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_24_DBL = 1 << 24;\n  /**\n   * @type {number}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n  /**\n   * @type {number}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n  /**\n   * @type {number}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n  /**\n   * @type {!Long}\n   * @const\n   * @inner\n   */\n  \n  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var ZERO = fromInt(0);\n  /**\n   * Signed zero.\n   * @type {!Long}\n   */\n  \n  Long.ZERO = ZERO;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var UZERO = fromInt(0, true);\n  /**\n   * Unsigned zero.\n   * @type {!Long}\n   */\n  \n  Long.UZERO = UZERO;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var ONE = fromInt(1);\n  /**\n   * Signed one.\n   * @type {!Long}\n   */\n  \n  Long.ONE = ONE;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var UONE = fromInt(1, true);\n  /**\n   * Unsigned one.\n   * @type {!Long}\n   */\n  \n  Long.UONE = UONE;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var NEG_ONE = fromInt(-1);\n  /**\n   * Signed negative one.\n   * @type {!Long}\n   */\n  \n  Long.NEG_ONE = NEG_ONE;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);\n  /**\n   * Maximum signed value.\n   * @type {!Long}\n   */\n  \n  Long.MAX_VALUE = MAX_VALUE;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);\n  /**\n   * Maximum unsigned value.\n   * @type {!Long}\n   */\n  \n  Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n  /**\n   * @type {!Long}\n   * @inner\n   */\n  \n  var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);\n  /**\n   * Minimum signed value.\n   * @type {!Long}\n   */\n  \n  Long.MIN_VALUE = MIN_VALUE;\n  /**\n   * @alias Long.prototype\n   * @inner\n   */\n  \n  var LongPrototype = Long.prototype;\n  /**\n   * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n   * @this {!Long}\n   * @returns {number}\n   */\n  \n  LongPrototype.toInt = function toInt() {\n    return this.unsigned ? this.low >>> 0 : this.low;\n  };\n  /**\n   * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n   * @this {!Long}\n   * @returns {number}\n   */\n  \n  \n  LongPrototype.toNumber = function toNumber() {\n    if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n  };\n  /**\n   * Converts the Long to a string written in the specified radix.\n   * @this {!Long}\n   * @param {number=} radix Radix (2-36), defaults to 10\n   * @returns {string}\n   * @override\n   * @throws {RangeError} If `radix` is out of range\n   */\n  \n  \n  LongPrototype.toString = function toString(radix) {\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix) throw RangeError('radix');\n    if (this.isZero()) return '0';\n  \n    if (this.isNegative()) {\n      // Unsigned Longs are never negative\n      if (this.eq(MIN_VALUE)) {\n        // We need to change the Long value before it can be negated, so we remove\n        // the bottom-most digit in this base and then recurse to do the rest.\n        var radixLong = fromNumber(radix),\n            div = this.div(radixLong),\n            rem1 = div.mul(radixLong).sub(this);\n        return div.toString(radix) + rem1.toInt().toString(radix);\n      } else return '-' + this.neg().toString(radix);\n    } // Do several (6) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n  \n  \n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\n        rem = this;\n    var result = '';\n  \n    while (true) {\n      var remDiv = rem.div(radixToPower),\n          intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\n          digits = intval.toString(radix);\n      rem = remDiv;\n      if (rem.isZero()) return digits + result;else {\n        while (digits.length < 6) digits = '0' + digits;\n  \n        result = '' + digits + result;\n      }\n    }\n  };\n  /**\n   * Gets the high 32 bits as a signed integer.\n   * @this {!Long}\n   * @returns {number} Signed high bits\n   */\n  \n  \n  LongPrototype.getHighBits = function getHighBits() {\n    return this.high;\n  };\n  /**\n   * Gets the high 32 bits as an unsigned integer.\n   * @this {!Long}\n   * @returns {number} Unsigned high bits\n   */\n  \n  \n  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n    return this.high >>> 0;\n  };\n  /**\n   * Gets the low 32 bits as a signed integer.\n   * @this {!Long}\n   * @returns {number} Signed low bits\n   */\n  \n  \n  LongPrototype.getLowBits = function getLowBits() {\n    return this.low;\n  };\n  /**\n   * Gets the low 32 bits as an unsigned integer.\n   * @this {!Long}\n   * @returns {number} Unsigned low bits\n   */\n  \n  \n  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n    return this.low >>> 0;\n  };\n  /**\n   * Gets the number of bits needed to represent the absolute value of this Long.\n   * @this {!Long}\n   * @returns {number}\n   */\n  \n  \n  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n    if (this.isNegative()) // Unsigned Longs are never negative\n      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n    var val = this.high != 0 ? this.high : this.low;\n  \n    for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;\n  \n    return this.high != 0 ? bit + 33 : bit + 1;\n  };\n  /**\n   * Tests if this Long's value equals zero.\n   * @this {!Long}\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.isZero = function isZero() {\n    return this.high === 0 && this.low === 0;\n  };\n  /**\n   * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.eqz = LongPrototype.isZero;\n  /**\n   * Tests if this Long's value is negative.\n   * @this {!Long}\n   * @returns {boolean}\n   */\n  \n  LongPrototype.isNegative = function isNegative() {\n    return !this.unsigned && this.high < 0;\n  };\n  /**\n   * Tests if this Long's value is positive or zero.\n   * @this {!Long}\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.isPositive = function isPositive() {\n    return this.unsigned || this.high >= 0;\n  };\n  /**\n   * Tests if this Long's value is odd.\n   * @this {!Long}\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.isOdd = function isOdd() {\n    return (this.low & 1) === 1;\n  };\n  /**\n   * Tests if this Long's value is even.\n   * @this {!Long}\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.isEven = function isEven() {\n    return (this.low & 1) === 0;\n  };\n  /**\n   * Tests if this Long's value equals the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.equals = function equals(other) {\n    if (!isLong(other)) other = fromValue(other);\n    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;\n    return this.high === other.high && this.low === other.low;\n  };\n  /**\n   * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.eq = LongPrototype.equals;\n  /**\n   * Tests if this Long's value differs from the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.notEquals = function notEquals(other) {\n    return !this.eq(\n    /* validates */\n    other);\n  };\n  /**\n   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.neq = LongPrototype.notEquals;\n  /**\n   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.ne = LongPrototype.notEquals;\n  /**\n   * Tests if this Long's value is less than the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.lessThan = function lessThan(other) {\n    return this.comp(\n    /* validates */\n    other) < 0;\n  };\n  /**\n   * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.lt = LongPrototype.lessThan;\n  /**\n   * Tests if this Long's value is less than or equal the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n    return this.comp(\n    /* validates */\n    other) <= 0;\n  };\n  /**\n   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.lte = LongPrototype.lessThanOrEqual;\n  /**\n   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.le = LongPrototype.lessThanOrEqual;\n  /**\n   * Tests if this Long's value is greater than the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.greaterThan = function greaterThan(other) {\n    return this.comp(\n    /* validates */\n    other) > 0;\n  };\n  /**\n   * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.gt = LongPrototype.greaterThan;\n  /**\n   * Tests if this Long's value is greater than or equal the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n    return this.comp(\n    /* validates */\n    other) >= 0;\n  };\n  /**\n   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  \n  LongPrototype.gte = LongPrototype.greaterThanOrEqual;\n  /**\n   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */\n  \n  LongPrototype.ge = LongPrototype.greaterThanOrEqual;\n  /**\n   * Compares this Long's value with the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n   *  if the given one is greater\n   */\n  \n  LongPrototype.compare = function compare(other) {\n    if (!isLong(other)) other = fromValue(other);\n    if (this.eq(other)) return 0;\n    var thisNeg = this.isNegative(),\n        otherNeg = other.isNegative();\n    if (thisNeg && !otherNeg) return -1;\n    if (!thisNeg && otherNeg) return 1; // At this point the sign bits are the same\n  \n    if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1; // Both are positive if at least one is unsigned\n  \n    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n  };\n  /**\n   * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n   *  if the given one is greater\n   */\n  \n  \n  LongPrototype.comp = LongPrototype.compare;\n  /**\n   * Negates this Long's value.\n   * @this {!Long}\n   * @returns {!Long} Negated Long\n   */\n  \n  LongPrototype.negate = function negate() {\n    if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;\n    return this.not().add(ONE);\n  };\n  /**\n   * Negates this Long's value. This is an alias of {@link Long#negate}.\n   * @function\n   * @returns {!Long} Negated Long\n   */\n  \n  \n  LongPrototype.neg = LongPrototype.negate;\n  /**\n   * Returns the sum of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|string} addend Addend\n   * @returns {!Long} Sum\n   */\n  \n  LongPrototype.add = function add(addend) {\n    if (!isLong(addend)) addend = fromValue(addend); // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n  \n    var a48 = this.high >>> 16;\n    var a32 = this.high & 0xFFFF;\n    var a16 = this.low >>> 16;\n    var a00 = this.low & 0xFFFF;\n    var b48 = addend.high >>> 16;\n    var b32 = addend.high & 0xFFFF;\n    var b16 = addend.low >>> 16;\n    var b00 = addend.low & 0xFFFF;\n    var c48 = 0,\n        c32 = 0,\n        c16 = 0,\n        c00 = 0;\n    c00 += a00 + b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 + b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 + b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 + b48;\n    c48 &= 0xFFFF;\n    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n  };\n  /**\n   * Returns the difference of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|string} subtrahend Subtrahend\n   * @returns {!Long} Difference\n   */\n  \n  \n  LongPrototype.subtract = function subtract(subtrahend) {\n    if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);\n    return this.add(subtrahend.neg());\n  };\n  /**\n   * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\n   * @function\n   * @param {!Long|number|string} subtrahend Subtrahend\n   * @returns {!Long} Difference\n   */\n  \n  \n  LongPrototype.sub = LongPrototype.subtract;\n  /**\n   * Returns the product of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|string} multiplier Multiplier\n   * @returns {!Long} Product\n   */\n  \n  LongPrototype.multiply = function multiply(multiplier) {\n    if (this.isZero()) return this;\n    if (!isLong(multiplier)) multiplier = fromValue(multiplier); // use wasm support if present\n  \n    if (wasm) {\n      var low = wasm[\"mul\"](this.low, this.high, multiplier.low, multiplier.high);\n      return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n    }\n  \n    if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;\n    if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;\n    if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;\n  \n    if (this.isNegative()) {\n      if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg();\n    } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg(); // If both longs are small, use float multiplication\n  \n  \n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n    // We can skip products that would overflow.\n  \n    var a48 = this.high >>> 16;\n    var a32 = this.high & 0xFFFF;\n    var a16 = this.low >>> 16;\n    var a00 = this.low & 0xFFFF;\n    var b48 = multiplier.high >>> 16;\n    var b32 = multiplier.high & 0xFFFF;\n    var b16 = multiplier.low >>> 16;\n    var b00 = multiplier.low & 0xFFFF;\n    var c48 = 0,\n        c32 = 0,\n        c16 = 0,\n        c00 = 0;\n    c00 += a00 * b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 * b00;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c16 += a00 * b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 * b00;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a16 * b16;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a00 * b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n    c48 &= 0xFFFF;\n    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n  };\n  /**\n   * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\n   * @function\n   * @param {!Long|number|string} multiplier Multiplier\n   * @returns {!Long} Product\n   */\n  \n  \n  LongPrototype.mul = LongPrototype.multiply;\n  /**\n   * Returns this Long divided by the specified. The result is signed if this Long is signed or\n   *  unsigned if this Long is unsigned.\n   * @this {!Long}\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Quotient\n   */\n  \n  LongPrototype.divide = function divide(divisor) {\n    if (!isLong(divisor)) divisor = fromValue(divisor);\n    if (divisor.isZero()) throw Error('division by zero'); // use wasm support if present\n  \n    if (wasm) {\n      // guard against signed division overflow: the largest\n      // negative number / -1 would be 1 larger than the largest\n      // positive number, due to two's complement.\n      if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {\n        // be consistent with non-wasm code path\n        return this;\n      }\n  \n      var low = (this.unsigned ? wasm[\"div_u\"] : wasm[\"div_s\"])(this.low, this.high, divisor.low, divisor.high);\n      return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n    }\n  \n    if (this.isZero()) return this.unsigned ? UZERO : ZERO;\n    var approx, rem, res;\n  \n    if (!this.unsigned) {\n      // This section is only relevant for signed longs and is derived from the\n      // closure library as a whole.\n      if (this.eq(MIN_VALUE)) {\n        if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE\n        else if (divisor.eq(MIN_VALUE)) return ONE;else {\n          // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n          var halfThis = this.shr(1);\n          approx = halfThis.div(divisor).shl(1);\n  \n          if (approx.eq(ZERO)) {\n            return divisor.isNegative() ? ONE : NEG_ONE;\n          } else {\n            rem = this.sub(divisor.mul(approx));\n            res = approx.add(rem.div(divisor));\n            return res;\n          }\n        }\n      } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;\n  \n      if (this.isNegative()) {\n        if (divisor.isNegative()) return this.neg().div(divisor.neg());\n        return this.neg().div(divisor).neg();\n      } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();\n  \n      res = ZERO;\n    } else {\n      // The algorithm below has not been made for unsigned longs. It's therefore\n      // required to take special care of the MSB prior to running it.\n      if (!divisor.unsigned) divisor = divisor.toUnsigned();\n      if (divisor.gt(this)) return UZERO;\n      if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\n        return UONE;\n      res = UZERO;\n    } // Repeat the following until the remainder is less than other:  find a\n    // floating-point that approximates remainder / other *from below*, add this\n    // into the result, and subtract it from the remainder.  It is critical that\n    // the approximate value is less than or equal to the real value so that the\n    // remainder never becomes negative.\n  \n  \n    rem = this;\n  \n    while (rem.gte(divisor)) {\n      // Approximate the result of division. This may be a little greater or\n      // smaller than the actual value.\n      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or\n      // the smallest non-fractional digit, whichever is larger.\n  \n      var log2 = Math.ceil(Math.log(approx) / Math.LN2),\n          delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),\n          // Decrease the approximation until it is smaller than the remainder.  Note\n      // that if it is too large, the product overflows and is negative.\n      approxRes = fromNumber(approx),\n          approxRem = approxRes.mul(divisor);\n  \n      while (approxRem.isNegative() || approxRem.gt(rem)) {\n        approx -= delta;\n        approxRes = fromNumber(approx, this.unsigned);\n        approxRem = approxRes.mul(divisor);\n      } // We know the answer can't be zero... and actually, zero would cause\n      // infinite recursion since we would make no progress.\n  \n  \n      if (approxRes.isZero()) approxRes = ONE;\n      res = res.add(approxRes);\n      rem = rem.sub(approxRem);\n    }\n  \n    return res;\n  };\n  /**\n   * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\n   * @function\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Quotient\n   */\n  \n  \n  LongPrototype.div = LongPrototype.divide;\n  /**\n   * Returns this Long modulo the specified.\n   * @this {!Long}\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */\n  \n  LongPrototype.modulo = function modulo(divisor) {\n    if (!isLong(divisor)) divisor = fromValue(divisor); // use wasm support if present\n  \n    if (wasm) {\n      var low = (this.unsigned ? wasm[\"rem_u\"] : wasm[\"rem_s\"])(this.low, this.high, divisor.low, divisor.high);\n      return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n    }\n  \n    return this.sub(this.div(divisor).mul(divisor));\n  };\n  /**\n   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n   * @function\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */\n  \n  \n  LongPrototype.mod = LongPrototype.modulo;\n  /**\n   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n   * @function\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */\n  \n  LongPrototype.rem = LongPrototype.modulo;\n  /**\n   * Returns the bitwise NOT of this Long.\n   * @this {!Long}\n   * @returns {!Long}\n   */\n  \n  LongPrototype.not = function not() {\n    return fromBits(~this.low, ~this.high, this.unsigned);\n  };\n  /**\n   * Returns count leading zeros of this Long.\n   * @this {!Long}\n   * @returns {!number}\n   */\n  \n  \n  LongPrototype.countLeadingZeros = function countLeadingZeros() {\n    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n  };\n  /**\n   * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.\n   * @function\n   * @param {!Long}\n   * @returns {!number}\n   */\n  \n  \n  LongPrototype.clz = LongPrototype.countLeadingZeros;\n  /**\n   * Returns count trailing zeros of this Long.\n   * @this {!Long}\n   * @returns {!number}\n   */\n  \n  LongPrototype.countTrailingZeros = function countTrailingZeros() {\n    return this.low ? ctz32(this.low) : ctz32(this.high) + 32;\n  };\n  /**\n   * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.\n   * @function\n   * @param {!Long}\n   * @returns {!number}\n   */\n  \n  \n  LongPrototype.ctz = LongPrototype.countTrailingZeros;\n  /**\n   * Returns the bitwise AND of this Long and the specified.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other Long\n   * @returns {!Long}\n   */\n  \n  LongPrototype.and = function and(other) {\n    if (!isLong(other)) other = fromValue(other);\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n  };\n  /**\n   * Returns the bitwise OR of this Long and the specified.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other Long\n   * @returns {!Long}\n   */\n  \n  \n  LongPrototype.or = function or(other) {\n    if (!isLong(other)) other = fromValue(other);\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n  };\n  /**\n   * Returns the bitwise XOR of this Long and the given one.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other Long\n   * @returns {!Long}\n   */\n  \n  \n  LongPrototype.xor = function xor(other) {\n    if (!isLong(other)) other = fromValue(other);\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits shifted to the left by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  \n  LongPrototype.shiftLeft = function shiftLeft(numBits) {\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);else return fromBits(0, this.low << numBits - 32, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  \n  LongPrototype.shl = LongPrototype.shiftLeft;\n  /**\n   * Returns this Long with bits arithmetically shifted to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  LongPrototype.shiftRight = function shiftRight(numBits) {\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  \n  LongPrototype.shr = LongPrototype.shiftRight;\n  /**\n   * Returns this Long with bits logically shifted to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;\n    if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);\n    if (numBits === 32) return fromBits(this.high, 0, this.unsigned);\n    return fromBits(this.high >>> numBits - 32, 0, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  \n  LongPrototype.shru = LongPrototype.shiftRightUnsigned;\n  /**\n   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */\n  \n  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n  /**\n   * Returns this Long with bits rotated to the left by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */\n  \n  LongPrototype.rotateLeft = function rotateLeft(numBits) {\n    var b;\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;\n    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n  \n    if (numBits < 32) {\n      b = 32 - numBits;\n      return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);\n    }\n  \n    numBits -= 32;\n    b = 32 - numBits;\n    return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */\n  \n  \n  LongPrototype.rotl = LongPrototype.rotateLeft;\n  /**\n   * Returns this Long with bits rotated to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */\n  \n  LongPrototype.rotateRight = function rotateRight(numBits) {\n    var b;\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;\n    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n  \n    if (numBits < 32) {\n      b = 32 - numBits;\n      return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);\n    }\n  \n    numBits -= 32;\n    b = 32 - numBits;\n    return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);\n  };\n  /**\n   * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */\n  \n  \n  LongPrototype.rotr = LongPrototype.rotateRight;\n  /**\n   * Converts this Long to signed.\n   * @this {!Long}\n   * @returns {!Long} Signed long\n   */\n  \n  LongPrototype.toSigned = function toSigned() {\n    if (!this.unsigned) return this;\n    return fromBits(this.low, this.high, false);\n  };\n  /**\n   * Converts this Long to unsigned.\n   * @this {!Long}\n   * @returns {!Long} Unsigned long\n   */\n  \n  \n  LongPrototype.toUnsigned = function toUnsigned() {\n    if (this.unsigned) return this;\n    return fromBits(this.low, this.high, true);\n  };\n  /**\n   * Converts this Long to its byte representation.\n   * @param {boolean=} le Whether little or big endian, defaults to big endian\n   * @this {!Long}\n   * @returns {!Array.<number>} Byte representation\n   */\n  \n  \n  LongPrototype.toBytes = function toBytes(le) {\n    return le ? this.toBytesLE() : this.toBytesBE();\n  };\n  /**\n   * Converts this Long to its little endian byte representation.\n   * @this {!Long}\n   * @returns {!Array.<number>} Little endian byte representation\n   */\n  \n  \n  LongPrototype.toBytesLE = function toBytesLE() {\n    var hi = this.high,\n        lo = this.low;\n    return [lo & 0xff, lo >>> 8 & 0xff, lo >>> 16 & 0xff, lo >>> 24, hi & 0xff, hi >>> 8 & 0xff, hi >>> 16 & 0xff, hi >>> 24];\n  };\n  /**\n   * Converts this Long to its big endian byte representation.\n   * @this {!Long}\n   * @returns {!Array.<number>} Big endian byte representation\n   */\n  \n  \n  LongPrototype.toBytesBE = function toBytesBE() {\n    var hi = this.high,\n        lo = this.low;\n    return [hi >>> 24, hi >>> 16 & 0xff, hi >>> 8 & 0xff, hi & 0xff, lo >>> 24, lo >>> 16 & 0xff, lo >>> 8 & 0xff, lo & 0xff];\n  };\n  /**\n   * Creates a Long from its byte representation.\n   * @param {!Array.<number>} bytes Byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @param {boolean=} le Whether little or big endian, defaults to big endian\n   * @returns {Long} The corresponding Long value\n   */\n  \n  \n  Long.fromBytes = function fromBytes(bytes, unsigned, le) {\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n  };\n  /**\n   * Creates a Long from its little endian byte representation.\n   * @param {!Array.<number>} bytes Little endian byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {Long} The corresponding Long value\n   */\n  \n  \n  Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n    return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);\n  };\n  /**\n   * Creates a Long from its big endian byte representation.\n   * @param {!Array.<number>} bytes Big endian byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {Long} The corresponding Long value\n   */\n  \n  \n  Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n    return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);\n  };\n  \n  var _default = Long;\n  exports.default = _default;\n  return \"default\" in exports ? exports.default : exports;\n})({});\nif (typeof define === 'function' && define.amd) define([], function() { return Long; });\nelse if (typeof module === 'object' && typeof exports === 'object') module.exports = Long;\n","/// @file\n/// @addtogroup flatbuffers_javascript_api\n/// @{\n/// @cond FLATBUFFERS_INTERNAL\n\n/**\n * @fileoverview\n *\n * Need to suppress 'global this' error so the Node.js export line doesn't cause\n * closure compile to error out.\n * @suppress {globalThis}\n */\n\n/**\n * @const\n * @namespace\n */\nvar flatbuffers = {};\n\n/**\n * @typedef {number}\n */\nflatbuffers.Offset;\n\n/**\n * @typedef {{\n *   bb: flatbuffers.ByteBuffer,\n *   bb_pos: number\n * }}\n */\nflatbuffers.Table;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZEOF_SHORT = 2;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZEOF_INT = 4;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.FILE_IDENTIFIER_LENGTH = 4;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZE_PREFIX_LENGTH = 4;\n\n/**\n * @enum {number}\n */\nflatbuffers.Encoding = {\n  UTF8_BYTES: 1,\n  UTF16_STRING: 2\n};\n\n/**\n * @type {Int32Array}\n * @const\n */\nflatbuffers.int32 = new Int32Array(2);\n\n/**\n * @type {Float32Array}\n * @const\n */\nflatbuffers.float32 = new Float32Array(flatbuffers.int32.buffer);\n\n/**\n * @type {Float64Array}\n * @const\n */\nflatbuffers.float64 = new Float64Array(flatbuffers.int32.buffer);\n\n/**\n * @type {boolean}\n * @const\n */\nflatbuffers.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @constructor\n * @param {number} low\n * @param {number} high\n */\nflatbuffers.Long = function(low, high) {\n  /**\n   * @type {number}\n   * @const\n   */\n  this.low = low | 0;\n\n  /**\n   * @type {number}\n   * @const\n   */\n  this.high = high | 0;\n};\n\n/**\n * @param {number} low\n * @param {number} high\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.Long.create = function(low, high) {\n  // Special-case zero to avoid GC overhead for default values\n  return low == 0 && high == 0 ? flatbuffers.Long.ZERO : new flatbuffers.Long(low, high);\n};\n\n/**\n * @returns {number}\n */\nflatbuffers.Long.prototype.toFloat64 = function() {\n  return (this.low >>> 0) + this.high * 0x100000000;\n};\n\n/**\n * @param {flatbuffers.Long} other\n * @returns {boolean}\n */\nflatbuffers.Long.prototype.equals = function(other) {\n  return this.low == other.low && this.high == other.high;\n};\n\n/**\n * @type {!flatbuffers.Long}\n * @const\n */\nflatbuffers.Long.ZERO = new flatbuffers.Long(0, 0);\n\n/// @endcond\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a FlatBufferBuilder.\n *\n * @constructor\n * @param {number=} opt_initial_size\n */\nflatbuffers.Builder = function(opt_initial_size) {\n  if (!opt_initial_size) {\n    var initial_size = 1024;\n  } else {\n    var initial_size = opt_initial_size;\n  }\n\n  /**\n   * @type {flatbuffers.ByteBuffer}\n   * @private\n   */\n  this.bb = flatbuffers.ByteBuffer.allocate(initial_size);\n\n  /**\n   * Remaining space in the ByteBuffer.\n   *\n   * @type {number}\n   * @private\n   */\n  this.space = initial_size;\n\n  /**\n   * Minimum alignment encountered so far.\n   *\n   * @type {number}\n   * @private\n   */\n  this.minalign = 1;\n\n  /**\n   * The vtable for the current table.\n   *\n   * @type {Array.<number>}\n   * @private\n   */\n  this.vtable = null;\n\n  /**\n   * The amount of fields we're actually using.\n   *\n   * @type {number}\n   * @private\n   */\n  this.vtable_in_use = 0;\n\n  /**\n   * Whether we are currently serializing a table.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.isNested = false;\n\n  /**\n   * Starting offset of the current struct/table.\n   *\n   * @type {number}\n   * @private\n   */\n  this.object_start = 0;\n\n  /**\n   * List of offsets of all vtables.\n   *\n   * @type {Array.<number>}\n   * @private\n   */\n  this.vtables = [];\n\n  /**\n   * For the current vector being built.\n   *\n   * @type {number}\n   * @private\n   */\n  this.vector_num_elems = 0;\n\n  /**\n   * False omits default values from the serialized data\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.force_defaults = false;\n};\n\nflatbuffers.Builder.prototype.clear = function() {\n  this.bb.clear();\n  this.space = this.bb.capacity();\n  this.minalign = 1;\n  this.vtable = null;\n  this.vtable_in_use = 0;\n  this.isNested = false;\n  this.object_start = 0;\n  this.vtables = [];\n  this.vector_num_elems = 0;\n  this.force_defaults = false;\n};\n\n/**\n * In order to save space, fields that are set to their default value\n * don't get serialized into the buffer. Forcing defaults provides a\n * way to manually disable this optimization.\n *\n * @param {boolean} forceDefaults true always serializes default values\n */\nflatbuffers.Builder.prototype.forceDefaults = function(forceDefaults) {\n  this.force_defaults = forceDefaults;\n};\n\n/**\n * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n * called finish(). The actual data starts at the ByteBuffer's current position,\n * not necessarily at 0.\n *\n * @returns {flatbuffers.ByteBuffer}\n */\nflatbuffers.Builder.prototype.dataBuffer = function() {\n  return this.bb;\n};\n\n/**\n * Get the bytes representing the FlatBuffer. Only call this after you've\n * called finish().\n *\n * @returns {!Uint8Array}\n */\nflatbuffers.Builder.prototype.asUint8Array = function() {\n  return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Prepare to write an element of `size` after `additional_bytes` have been\n * written, e.g. if you write a string, you need to align such the int length\n * field is aligned to 4 bytes, and the string data follows it directly. If all\n * you need to do is alignment, `additional_bytes` will be 0.\n *\n * @param {number} size This is the of the new element to write\n * @param {number} additional_bytes The padding size\n */\nflatbuffers.Builder.prototype.prep = function(size, additional_bytes) {\n  // Track the biggest thing we've ever aligned to.\n  if (size > this.minalign) {\n    this.minalign = size;\n  }\n\n  // Find the amount of alignment needed such that `size` is properly\n  // aligned after `additional_bytes`\n  var align_size = ((~(this.bb.capacity() - this.space + additional_bytes)) + 1) & (size - 1);\n\n  // Reallocate the buffer if needed.\n  while (this.space < align_size + size + additional_bytes) {\n    var old_buf_size = this.bb.capacity();\n    this.bb = flatbuffers.Builder.growByteBuffer(this.bb);\n    this.space += this.bb.capacity() - old_buf_size;\n  }\n\n  this.pad(align_size);\n};\n\n/**\n * @param {number} byte_size\n */\nflatbuffers.Builder.prototype.pad = function(byte_size) {\n  for (var i = 0; i < byte_size; i++) {\n    this.bb.writeInt8(--this.space, 0);\n  }\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt8 = function(value) {\n  this.bb.writeInt8(this.space -= 1, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt16 = function(value) {\n  this.bb.writeInt16(this.space -= 2, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt32 = function(value) {\n  this.bb.writeInt32(this.space -= 4, value);\n};\n\n/**\n * @param {flatbuffers.Long} value\n */\nflatbuffers.Builder.prototype.writeInt64 = function(value) {\n  this.bb.writeInt64(this.space -= 8, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeFloat32 = function(value) {\n  this.bb.writeFloat32(this.space -= 4, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeFloat64 = function(value) {\n  this.bb.writeFloat64(this.space -= 8, value);\n};\n/// @endcond\n\n/**\n * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int8` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt8 = function(value) {\n  this.prep(1, 0);\n  this.writeInt8(value);\n};\n\n/**\n * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int16` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt16 = function(value) {\n  this.prep(2, 0);\n  this.writeInt16(value);\n};\n\n/**\n * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int32` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt32 = function(value) {\n  this.prep(4, 0);\n  this.writeInt32(value);\n};\n\n/**\n * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {flatbuffers.Long} value The `int64` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt64 = function(value) {\n  this.prep(8, 0);\n  this.writeInt64(value);\n};\n\n/**\n * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `float32` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addFloat32 = function(value) {\n  this.prep(4, 0);\n  this.writeFloat32(value);\n};\n\n/**\n * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `float64` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addFloat64 = function(value) {\n  this.prep(8, 0);\n  this.writeFloat64(value);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt8 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt8(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt16 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt16(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt32 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt32(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {flatbuffers.Long} value\n * @param {flatbuffers.Long} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt64 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || !value.equals(defaultValue)) {\n    this.addInt64(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldFloat32 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addFloat32(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldFloat64 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addFloat64(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {flatbuffers.Offset} value\n * @param {flatbuffers.Offset} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldOffset = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addOffset(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * Structs are stored inline, so nothing additional is being added. `d` is always 0.\n *\n * @param {number} voffset\n * @param {flatbuffers.Offset} value\n * @param {flatbuffers.Offset} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldStruct = function(voffset, value, defaultValue) {\n  if (value != defaultValue) {\n    this.nested(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * Structures are always stored inline, they need to be created right\n * where they're used.  You'll get this assertion failure if you\n * created it elsewhere.\n *\n * @param {flatbuffers.Offset} obj The offset of the created object\n */\nflatbuffers.Builder.prototype.nested = function(obj) {\n  if (obj != this.offset()) {\n    throw new Error('FlatBuffers: struct must be serialized inline.');\n  }\n};\n\n/**\n * Should not be creating any other object, string or vector\n * while an object is being constructed\n */\nflatbuffers.Builder.prototype.notNested = function() {\n  if (this.isNested) {\n    throw new Error('FlatBuffers: object serialization must not be nested.');\n  }\n};\n\n/**\n * Set the current vtable at `voffset` to the current location in the buffer.\n *\n * @param {number} voffset\n */\nflatbuffers.Builder.prototype.slot = function(voffset) {\n  this.vtable[voffset] = this.offset();\n};\n\n/**\n * @returns {flatbuffers.Offset} Offset relative to the end of the buffer.\n */\nflatbuffers.Builder.prototype.offset = function() {\n  return this.bb.capacity() - this.space;\n};\n\n/**\n * Doubles the size of the backing ByteBuffer and copies the old data towards\n * the end of the new buffer (since we build the buffer backwards).\n *\n * @param {flatbuffers.ByteBuffer} bb The current buffer with the existing data\n * @returns {!flatbuffers.ByteBuffer} A new byte buffer with the old data copied\n * to it. The data is located at the end of the buffer.\n *\n * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass\n * it a uint8Array we need to suppress the type check:\n * @suppress {checkTypes}\n */\nflatbuffers.Builder.growByteBuffer = function(bb) {\n  var old_buf_size = bb.capacity();\n\n  // Ensure we don't grow beyond what fits in an int.\n  if (old_buf_size & 0xC0000000) {\n    throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');\n  }\n\n  var new_buf_size = old_buf_size << 1;\n  var nbb = flatbuffers.ByteBuffer.allocate(new_buf_size);\n  nbb.setPosition(new_buf_size - old_buf_size);\n  nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);\n  return nbb;\n};\n/// @endcond\n\n/**\n * Adds on offset, relative to where it will be written.\n *\n * @param {flatbuffers.Offset} offset The offset to add.\n */\nflatbuffers.Builder.prototype.addOffset = function(offset) {\n  this.prep(flatbuffers.SIZEOF_INT, 0); // Ensure alignment is already done.\n  this.writeInt32(this.offset() - offset + flatbuffers.SIZEOF_INT);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Start encoding a new object in the buffer.  Users will not usually need to\n * call this directly. The FlatBuffers compiler will generate helper methods\n * that call this method internally.\n *\n * @param {number} numfields\n */\nflatbuffers.Builder.prototype.startObject = function(numfields) {\n  this.notNested();\n  if (this.vtable == null) {\n    this.vtable = [];\n  }\n  this.vtable_in_use = numfields;\n  for (var i = 0; i < numfields; i++) {\n    this.vtable[i] = 0; // This will push additional elements as needed\n  }\n  this.isNested = true;\n  this.object_start = this.offset();\n};\n\n/**\n * Finish off writing the object that is under construction.\n *\n * @returns {flatbuffers.Offset} The offset to the object inside `dataBuffer`\n */\nflatbuffers.Builder.prototype.endObject = function() {\n  if (this.vtable == null || !this.isNested) {\n    throw new Error('FlatBuffers: endObject called without startObject');\n  }\n\n  this.addInt32(0);\n  var vtableloc = this.offset();\n\n  // Trim trailing zeroes.\n  var i = this.vtable_in_use - 1;\n  for (; i >= 0 && this.vtable[i] == 0; i--) {}\n  var trimmed_size = i + 1;\n\n  // Write out the current vtable.\n  for (; i >= 0; i--) {\n    // Offset relative to the start of the table.\n    this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);\n  }\n\n  var standard_fields = 2; // The fields below:\n  this.addInt16(vtableloc - this.object_start);\n  var len = (trimmed_size + standard_fields) * flatbuffers.SIZEOF_SHORT;\n  this.addInt16(len);\n\n  // Search for an existing vtable that matches the current one.\n  var existing_vtable = 0;\n  var vt1 = this.space;\nouter_loop:\n  for (i = 0; i < this.vtables.length; i++) {\n    var vt2 = this.bb.capacity() - this.vtables[i];\n    if (len == this.bb.readInt16(vt2)) {\n      for (var j = flatbuffers.SIZEOF_SHORT; j < len; j += flatbuffers.SIZEOF_SHORT) {\n        if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {\n          continue outer_loop;\n        }\n      }\n      existing_vtable = this.vtables[i];\n      break;\n    }\n  }\n\n  if (existing_vtable) {\n    // Found a match:\n    // Remove the current vtable.\n    this.space = this.bb.capacity() - vtableloc;\n\n    // Point table to existing vtable.\n    this.bb.writeInt32(this.space, existing_vtable - vtableloc);\n  } else {\n    // No match:\n    // Add the location of the current vtable to the list of vtables.\n    this.vtables.push(this.offset());\n\n    // Point table to current vtable.\n    this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);\n  }\n\n  this.isNested = false;\n  return vtableloc;\n};\n/// @endcond\n\n/**\n * Finalize a buffer, poiting to the given `root_table`.\n *\n * @param {flatbuffers.Offset} root_table\n * @param {string=} opt_file_identifier\n * @param {boolean=} opt_size_prefix\n */\nflatbuffers.Builder.prototype.finish = function(root_table, opt_file_identifier, opt_size_prefix) {\n  var size_prefix = opt_size_prefix ? flatbuffers.SIZE_PREFIX_LENGTH : 0;\n  if (opt_file_identifier) {\n    var file_identifier = opt_file_identifier;\n    this.prep(this.minalign, flatbuffers.SIZEOF_INT +\n      flatbuffers.FILE_IDENTIFIER_LENGTH + size_prefix);\n    if (file_identifier.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {\n      throw new Error('FlatBuffers: file identifier must be length ' +\n        flatbuffers.FILE_IDENTIFIER_LENGTH);\n    }\n    for (var i = flatbuffers.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {\n      this.writeInt8(file_identifier.charCodeAt(i));\n    }\n  }\n  this.prep(this.minalign, flatbuffers.SIZEOF_INT + size_prefix);\n  this.addOffset(root_table);\n  if (size_prefix) {\n    this.addInt32(this.bb.capacity() - this.space);\n  }\n  this.bb.setPosition(this.space);\n};\n\n/**\n * Finalize a size prefixed buffer, pointing to the given `root_table`.\n *\n * @param {flatbuffers.Offset} root_table\n * @param {string=} opt_file_identifier\n */\nflatbuffers.Builder.prototype.finishSizePrefixed = function (root_table, opt_file_identifier) {\n  this.finish(root_table, opt_file_identifier, true);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * This checks a required field has been set in a given table that has\n * just been constructed.\n *\n * @param {flatbuffers.Offset} table\n * @param {number} field\n */\nflatbuffers.Builder.prototype.requiredField = function(table, field) {\n  var table_start = this.bb.capacity() - table;\n  var vtable_start = table_start - this.bb.readInt32(table_start);\n  var ok = this.bb.readInt16(vtable_start + field) != 0;\n\n  // If this fails, the caller will show what field needs to be set.\n  if (!ok) {\n    throw new Error('FlatBuffers: field ' + field + ' must be set');\n  }\n};\n\n/**\n * Start a new array/vector of objects.  Users usually will not call\n * this directly. The FlatBuffers compiler will create a start/end\n * method for vector types in generated code.\n *\n * @param {number} elem_size The size of each element in the array\n * @param {number} num_elems The number of elements in the array\n * @param {number} alignment The alignment of the array\n */\nflatbuffers.Builder.prototype.startVector = function(elem_size, num_elems, alignment) {\n  this.notNested();\n  this.vector_num_elems = num_elems;\n  this.prep(flatbuffers.SIZEOF_INT, elem_size * num_elems);\n  this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.\n};\n\n/**\n * Finish off the creation of an array and all its elements. The array must be\n * created with `startVector`.\n *\n * @returns {flatbuffers.Offset} The offset at which the newly created array\n * starts.\n */\nflatbuffers.Builder.prototype.endVector = function() {\n  this.writeInt32(this.vector_num_elems);\n  return this.offset();\n};\n/// @endcond\n\n/**\n * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\n * instead of a string, it is assumed to contain valid UTF-8 encoded data.\n *\n * @param {string|Uint8Array} s The string to encode\n * @return {flatbuffers.Offset} The offset in the buffer where the encoded string starts\n */\nflatbuffers.Builder.prototype.createString = function(s) {\n  if (s instanceof Uint8Array) {\n    var utf8 = s;\n  } else {\n    var utf8 = [];\n    var i = 0;\n\n    while (i < s.length) {\n      var codePoint;\n\n      // Decode UTF-16\n      var a = s.charCodeAt(i++);\n      if (a < 0xD800 || a >= 0xDC00) {\n        codePoint = a;\n      } else {\n        var b = s.charCodeAt(i++);\n        codePoint = (a << 10) + b + (0x10000 - (0xD800 << 10) - 0xDC00);\n      }\n\n      // Encode UTF-8\n      if (codePoint < 0x80) {\n        utf8.push(codePoint);\n      } else {\n        if (codePoint < 0x800) {\n          utf8.push(((codePoint >> 6) & 0x1F) | 0xC0);\n        } else {\n          if (codePoint < 0x10000) {\n            utf8.push(((codePoint >> 12) & 0x0F) | 0xE0);\n          } else {\n            utf8.push(\n              ((codePoint >> 18) & 0x07) | 0xF0,\n              ((codePoint >> 12) & 0x3F) | 0x80);\n          }\n          utf8.push(((codePoint >> 6) & 0x3F) | 0x80);\n        }\n        utf8.push((codePoint & 0x3F) | 0x80);\n      }\n    }\n  }\n\n  this.addInt8(0);\n  this.startVector(1, utf8.length, 1);\n  this.bb.setPosition(this.space -= utf8.length);\n  for (var i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {\n    bytes[offset++] = utf8[i];\n  }\n  return this.endVector();\n};\n\n/**\n * A helper function to avoid generated code depending on this file directly.\n *\n * @param {number} low\n * @param {number} high\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.Builder.prototype.createLong = function(low, high) {\n  return flatbuffers.Long.create(low, high);\n};\n////////////////////////////////////////////////////////////////////////////////\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Create a new ByteBuffer with a given array of bytes (`Uint8Array`).\n *\n * @constructor\n * @param {Uint8Array} bytes\n */\nflatbuffers.ByteBuffer = function(bytes) {\n  /**\n   * @type {Uint8Array}\n   * @private\n   */\n  this.bytes_ = bytes;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n/**\n * Create and allocate a new ByteBuffer with a given size.\n *\n * @param {number} byte_size\n * @returns {!flatbuffers.ByteBuffer}\n */\nflatbuffers.ByteBuffer.allocate = function(byte_size) {\n  return new flatbuffers.ByteBuffer(new Uint8Array(byte_size));\n};\n\nflatbuffers.ByteBuffer.prototype.clear = function() {\n  this.position_ = 0;\n};\n\n/**\n * Get the underlying `Uint8Array`.\n *\n * @returns {Uint8Array}\n */\nflatbuffers.ByteBuffer.prototype.bytes = function() {\n  return this.bytes_;\n};\n\n/**\n * Get the buffer's position.\n *\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.position = function() {\n  return this.position_;\n};\n\n/**\n * Set the buffer's position.\n *\n * @param {number} position\n */\nflatbuffers.ByteBuffer.prototype.setPosition = function(position) {\n  this.position_ = position;\n};\n\n/**\n * Get the buffer's capacity.\n *\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.capacity = function() {\n  return this.bytes_.length;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt8 = function(offset) {\n  return this.readUint8(offset) << 24 >> 24;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint8 = function(offset) {\n  return this.bytes_[offset];\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt16 = function(offset) {\n  return this.readUint16(offset) << 16 >> 16;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint16 = function(offset) {\n  return this.bytes_[offset] | this.bytes_[offset + 1] << 8;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt32 = function(offset) {\n  return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint32 = function(offset) {\n  return this.readInt32(offset) >>> 0;\n};\n\n/**\n * @param {number} offset\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.readInt64 = function(offset) {\n  return new flatbuffers.Long(this.readInt32(offset), this.readInt32(offset + 4));\n};\n\n/**\n * @param {number} offset\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.readUint64 = function(offset) {\n  return new flatbuffers.Long(this.readUint32(offset), this.readUint32(offset + 4));\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readFloat32 = function(offset) {\n  flatbuffers.int32[0] = this.readInt32(offset);\n  return flatbuffers.float32[0];\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readFloat64 = function(offset) {\n  flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1] = this.readInt32(offset);\n  flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);\n  return flatbuffers.float64[0];\n};\n\n/**\n * @param {number} offset\n * @param {number|boolean} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt8 = function(offset, value) {\n  this.bytes_[offset] = /** @type {number} */(value);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint8 = function(offset, value) {\n  this.bytes_[offset] = value;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt16 = function(offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint16 = function(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt32 = function(offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n  this.bytes_[offset + 2] = value >> 16;\n  this.bytes_[offset + 3] = value >> 24;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint32 = function(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n    this.bytes_[offset + 2] = value >> 16;\n    this.bytes_[offset + 3] = value >> 24;\n};\n\n/**\n * @param {number} offset\n * @param {flatbuffers.Long} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt64 = function(offset, value) {\n  this.writeInt32(offset, value.low);\n  this.writeInt32(offset + 4, value.high);\n};\n\n/**\n * @param {number} offset\n * @param {flatbuffers.Long} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint64 = function(offset, value) {\n    this.writeUint32(offset, value.low);\n    this.writeUint32(offset + 4, value.high);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeFloat32 = function(offset, value) {\n  flatbuffers.float32[0] = value;\n  this.writeInt32(offset, flatbuffers.int32[0]);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeFloat64 = function(offset, value) {\n  flatbuffers.float64[0] = value;\n  this.writeInt32(offset, flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1]);\n  this.writeInt32(offset + 4, flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0]);\n};\n\n/**\n * Return the file identifier.   Behavior is undefined for FlatBuffers whose\n * schema does not include a file_identifier (likely points at padding or the\n * start of a the root vtable).\n * @returns {string}\n */\nflatbuffers.ByteBuffer.prototype.getBufferIdentifier = function() {\n  if (this.bytes_.length < this.position_ + flatbuffers.SIZEOF_INT +\n      flatbuffers.FILE_IDENTIFIER_LENGTH) {\n    throw new Error(\n        'FlatBuffers: ByteBuffer is too short to contain an identifier.');\n  }\n  var result = \"\";\n  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {\n    result += String.fromCharCode(\n        this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i));\n  }\n  return result;\n};\n\n/**\n * Look up a field in the vtable, return an offset into the object, or 0 if the\n * field is not present.\n *\n * @param {number} bb_pos\n * @param {number} vtable_offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__offset = function(bb_pos, vtable_offset) {\n  var vtable = bb_pos - this.readInt32(bb_pos);\n  return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;\n};\n\n/**\n * Initialize any Table-derived type to point to the union at the given offset.\n *\n * @param {flatbuffers.Table} t\n * @param {number} offset\n * @returns {flatbuffers.Table}\n */\nflatbuffers.ByteBuffer.prototype.__union = function(t, offset) {\n  t.bb_pos = offset + this.readInt32(offset);\n  t.bb = this;\n  return t;\n};\n\n/**\n * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n * This allocates a new string and converts to wide chars upon each access.\n *\n * To avoid the conversion to UTF-16, pass flatbuffers.Encoding.UTF8_BYTES as\n * the \"optionalEncoding\" argument. This is useful for avoiding conversion to\n * and from UTF-16 when the data will just be packaged back up in another\n * FlatBuffer later on.\n *\n * @param {number} offset\n * @param {flatbuffers.Encoding=} opt_encoding Defaults to UTF16_STRING\n * @returns {string|!Uint8Array}\n */\nflatbuffers.ByteBuffer.prototype.__string = function(offset, opt_encoding) {\n  offset += this.readInt32(offset);\n\n  var length = this.readInt32(offset);\n  var result = '';\n  var i = 0;\n\n  offset += flatbuffers.SIZEOF_INT;\n\n  if (opt_encoding === flatbuffers.Encoding.UTF8_BYTES) {\n    return this.bytes_.subarray(offset, offset + length);\n  }\n\n  while (i < length) {\n    var codePoint;\n\n    // Decode UTF-8\n    var a = this.readUint8(offset + i++);\n    if (a < 0xC0) {\n      codePoint = a;\n    } else {\n      var b = this.readUint8(offset + i++);\n      if (a < 0xE0) {\n        codePoint =\n          ((a & 0x1F) << 6) |\n          (b & 0x3F);\n      } else {\n        var c = this.readUint8(offset + i++);\n        if (a < 0xF0) {\n          codePoint =\n            ((a & 0x0F) << 12) |\n            ((b & 0x3F) << 6) |\n            (c & 0x3F);\n        } else {\n          var d = this.readUint8(offset + i++);\n          codePoint =\n            ((a & 0x07) << 18) |\n            ((b & 0x3F) << 12) |\n            ((c & 0x3F) << 6) |\n            (d & 0x3F);\n        }\n      }\n    }\n\n    // Encode UTF-16\n    if (codePoint < 0x10000) {\n      result += String.fromCharCode(codePoint);\n    } else {\n      codePoint -= 0x10000;\n      result += String.fromCharCode(\n        (codePoint >> 10) + 0xD800,\n        (codePoint & ((1 << 10) - 1)) + 0xDC00);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Retrieve the relative offset stored at \"offset\"\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__indirect = function(offset) {\n  return offset + this.readInt32(offset);\n};\n\n/**\n * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\n *\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__vector = function(offset) {\n  return offset + this.readInt32(offset) + flatbuffers.SIZEOF_INT; // data starts after the length\n};\n\n/**\n * Get the length of a vector whose offset is stored at \"offset\" in this object.\n *\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__vector_len = function(offset) {\n  return this.readInt32(offset + this.readInt32(offset));\n};\n\n/**\n * @param {string} ident\n * @returns {boolean}\n */\nflatbuffers.ByteBuffer.prototype.__has_identifier = function(ident) {\n  if (ident.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {\n    throw new Error('FlatBuffers: file identifier must be length ' +\n                    flatbuffers.FILE_IDENTIFIER_LENGTH);\n  }\n  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {\n    if (ident.charCodeAt(i) != this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * A helper function to avoid generated code depending on this file directly.\n *\n * @param {number} low\n * @param {number} high\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.createLong = function(low, high) {\n  return flatbuffers.Long.create(low, high);\n};\n\n// Exports for Node.js and RequireJS\nexport { flatbuffers };\n\n/// @endcond\n/// @}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(1057);\n"],"mappings":";;;;;CAAA,UAA2CA,CAAA,EAAMC,CAAA;EAC1B,mBAAZC,OAAA,IAA0C,mBAAXC,MAAA,GACxCA,MAAA,CAAOD,OAAA,GAAUD,CAAA,KACQ,qBAAXG,MAAA,IAAyBA,MAAA,CAAOC,GAAA,GAC9CD,MAAA,CAAO,IAAIH,CAAA,IACe,mBAAZC,OAAA,GACdA,OAAA,CAAaI,GAAA,GAAIL,CAAA,KAEjBD,CAAA,CAAUM,GAAA,GAAIL,CAAA,EACf;AAAA,CATD,CASGM,IAAA,EAAM,M;;;;;;QCHT,MAAAC,CAAA,GAAAC,CAAA;UACAC,CAAA,GAAAD,CAAA;QAyBaR,CAAA,CAAAU,CAAA,GAAgB,IAvB7B;UAEE,MAAAC,KAAA,GAA6B;UAE7B,MAAAC,qBAA2Bb,CAAA,EAAiCC,CAAA;YAM1D,MAAMQ,CAAA,GAAU,IAAID,CAAA,CAAAM,OAAA,CAAQb,CAAA;YAS5B,aALQQ,CAAA,CAAQM,SAAA,CAAUf,CAAA,GAKnB,IAAIU,CAAA,CAAAM,oBAAA,CAAqBP,CAAA,CAClC;UAAA;QAAA,C,CAAA,C;;;;;;QC1BF,MAAAD,CAAA,GAAAC,CAAA;UACAC,CAAA,GAAAD,CAAA;UAEAQ,CAAA,GAAAR,CAAA;UACAS,CAAA,GAAAT,CAAA;QAQaR,CAAA,CAAAkB,EAAA,GAAkB;UAa7B,KAZoC,mBAAzBX,CAAA,CAAAY,GAAA,CAAIC,IAAA,CAAKC,WAAA,IAA4Bd,CAAA,CAAAY,GAAA,CAAIC,IAAA,CAAKC,WAAA,GAAc,OACrEd,CAAA,CAAAY,GAAA,CAAIC,IAAA,CAAKC,WAAA,GAAc,IAGI,oBAAlBd,CAAA,CAAAY,GAAA,CAAIC,IAAA,CAAKE,IAAA,KAClBf,CAAA,CAAAY,GAAA,CAAIC,IAAA,CAAKE,IAAA,IAAO,IAGY,oBAAnBf,CAAA,CAAAY,GAAA,CAAIC,IAAA,CAAKG,KAAA,KAClBhB,CAAA,CAAAY,GAAA,CAAIC,IAAA,CAAKG,KAAA,IAAQ,IAGgB,mBAAxBhB,CAAA,CAAAY,GAAA,CAAIC,IAAA,CAAKI,UAAA,KAA4BC,MAAA,CAAOC,SAAA,CAAUnB,CAAA,CAAAY,GAAA,CAAIC,IAAA,CAAKI,UAAA,KAAejB,CAAA,CAAAY,GAAA,CAAIC,IAAA,CAAKI,UAAA,IAAc,GAAG;YACjH,MAAMzB,CAAA,GAA0C,sBAAd4B,SAAA,IAA4B,GAAAlB,CAAA,CAAAmB,IAAA,IAAOC,MAAA,GAASF,SAAA,CAAUG,mBAAA;YACxFvB,CAAA,CAAAY,GAAA,CAAIC,IAAA,CAAKI,UAAA,GAAaO,IAAA,CAAKC,GAAA,CAAI,GAAGD,IAAA,CAAKE,IAAA,EAAMlC,CAAA,IAAsB,KAAK,G;;WAsB/DC,CAAA,CAAAkC,EAAA,GAAc,IAlB3B;UACE,MAAAvB,KAAA;YAAA,CAEE,GAAAX,CAAA,CAAAkB,EAAA,YAGM,GAAAF,CAAA,CAAAmB,6BAAA,GACR;UAAA;UAGA,MAAAvB,qBAA2Bb,CAAA,EAAiCC,CAAA;YAE1D,MAAMQ,CAAA,GAAU,IAAIS,CAAA,CAAAmB,oCAAA;YAEpB,aADM5B,CAAA,CAAQM,SAAA,CAAUf,CAAA,EAAcC,CAAA,GAC/BqC,OAAA,CAAQC,OAAA,CAAQ9B,CAAA,CACzB;UAAA;QAAA,C,CAAA,C;;;;;;;;;;;;;;;;;;;;;;YCzCFC,CAAA,CAAAD,CAAA,QAAAR,CAAA;QACA,MAAAgB,CAAA,GAAAR,CAAA;UACAS,CAAA,GAAAT,CAAA;QAE+B;UAC7B,MAAMT,CAAA,GAAgBS,CAAA,OAAAE,CAAA;UAAA,CACtB,GAAAM,CAAA,CAAAuB,eAAA,EAAgB,SAASxC,CAAA,GAAgB,G;;QAGb;UAC5B,MAAMA,CAAA,GAAcS,CAAA,OAAA0B,EAAA;UAAA,CAIpB,GAAAlB,CAAA,CAAAuB,eAAA,EAAgB,OAAOxC,CAAA,EAAa,MACpC,GAAAiB,CAAA,CAAAuB,eAAA,EAAgB,QAAQxC,CAAA,EAAa,MACrC,GAAAiB,CAAA,CAAAuB,eAAA,EAAgB,WAAWxC,CAAA,EAAa,KACxC,GAAAiB,CAAA,CAAAuB,eAAA,EAAgB,SAASxC,CAAA,EAAa,E;;QAGxCiB,CAAA,CAAAG,GAAA,CAAIqB,QAAA,CAASC,GAAA,GAAMxB,CAAA,CAAAyB,O;;;;;;;;QCzBnB,MAAMlC,CAAA;UACJmC,YAAY5C,CAAA;YACV6C,MAAA,CAAOC,MAAA,CAAO,MAAM9C,CAAA,CACtB;UAAA;UAGW,IAAA+C,SAAA;YAKT,OAJK,KAAKC,SAAA,KACR,KAAKA,SAAA,GACDH,MAAA,CAAOI,mBAAA,CAAoB,MAAMC,IAAA,GAAOC,GAAA,CAAInD,CAAA,IAAQ,GAAI,KAAiCA,CAAA,KAASoD,IAAA,CAAK,OAEtG,KAAKJ,SACd;UAAA;QAAA;QAOW/C,CAAA,CAAAoD,2BAAA,GAAkErD,CAAA,IAC3E,IAAIS,CAAA,CAA0BT,CAAA,C;;;;;;;;QClBlC,MAAAQ,CAAA,GAAAC,CAAA;UACAC,CAAA,GAAAD,CAAA;UACAQ,CAAA,GAAAR,CAAA;UACAS,CAAA,GAAAT,CAAA;QAEA,IAAO6C,CAAA,GAAS9C,CAAA,CAAA+C,WAAA,CAAYC,YAAA,CAAaC,GAAA;QAqBzC,MAAaC,CAAA;UACXd,YAAY5C,CAAA;YAEV,IADA,KAAK2D,WAAA,GAAc,IAAIC,GAAA,IACnB,QAAA5D,CAAA,EAAiD;cACnD,KAAK,MAAMC,CAAA,IAAQD,CAAA,EACbC,CAAA,YAAgBS,CAAA,CAAAmD,IAAA,CAAKC,cAAA,GACvB,KAAKH,WAAA,CAAYI,GAAA,CAAI9D,CAAA,CAAK+D,IAAA,EAAM,CAACN,CAAA,CAAUO,QAAA,CAAShE,CAAA,GAAOyD,CAAA,CAAUQ,OAAA,CAAQjE,CAAA,MACpEA,CAAA,YAAgBqD,CAAA,CAAOa,SAAA,IAChC,KAAKR,WAAA,CAAYI,GAAA,CAAI9D,CAAA,CAAK+D,IAAA,IAAS,CAACN,CAAA,CAAUO,QAAA,CAAShE,CAAA,GAAOyD,CAAA,CAAUQ,OAAA,CAAQjE,CAAA;cAGpF,IAAI,KAAK0D,WAAA,CAAYS,IAAA,GAAOpE,CAAA,CAAW8B,MAAA,EACrC,MAAM,IAAIuC,KAAA,CAAM,6B;;UAGtB;UAEAN,IAAI/D,CAAA,EAAaC,CAAA,EAA0BQ,CAAA;YACzC,KAAKkD,WAAA,CAAYI,GAAA,CAAI/D,CAAA,EAAK,CAACS,CAAA,EAAOR,CAAA,EACpC;UAAA;UACAqE,OAAOtE,CAAA;YACL,KAAK2D,WAAA,CAAYW,MAAA,CAAOtE,CAAA,CAC1B;UAAA;UACAuE,SAASvE,CAAA,EAAaC,CAAA;YACpB,OAAO,KAAKuE,GAAA,CAAIxE,CAAA,EAAK,SAASC,CAAA,CAChC;UAAA;UAEAwE,OAAOzE,CAAA,EAAaC,CAAA;YAClB,OAAO,KAAKuE,GAAA,CAAIxE,CAAA,EAAK,OAAOC,CAAA,CAC9B;UAAA;UAEAyE,UAAU1E,CAAA,EAAaC,CAAA;YACrB,OAAO,KAAKuE,GAAA,CAAIxE,CAAA,EAAK,UAAUC,CAAA,CACjC;UAAA;UAEA0E,UAAU3E,CAAA,EAAaC,CAAA;YACrB,OAAO,KAAKuE,GAAA,CAAIxE,CAAA,EAAK,UAAUC,CAAA,CACjC;UAAA;UAEA2E,UAAU5E,CAAA,EAAaC,CAAA;YACrB,OAAO,KAAKuE,GAAA,CAAIxE,CAAA,EAAK,UAAUC,CAAA,CACjC;UAAA;UAEA4E,QAAQ7E,CAAA,EAAaC,CAAA;YACnB,OAAO,KAAKuE,GAAA,CAAIxE,CAAA,EAAK,QAAQC,CAAA,CAC/B;UAAA;UAEA6E,WAAW9E,CAAA,EAAaC,CAAA;YACtB,OAAO,KAAKuE,GAAA,CAAIxE,CAAA,EAAK,WAAWC,CAAA,CAClC;UAAA;UAEA8E,WAAW/E,CAAA,EAAaC,CAAA;YACtB,OAAO,KAAKuE,GAAA,CAAIxE,CAAA,EAAK,WAAWC,CAAA,CAClC;UAAA;UAEQuE,IACJxE,CAAA,EAAaC,CAAA,EAA0BQ,CAAA;YACzC,MAAMD,CAAA,GAAe,KAAKmD,WAAA,CAAYa,GAAA,CAAIxE,CAAA;YAC1C,SAAqB,MAAjBQ,CAAA,EAA4B;cAC9B,SAAqB,MAAjBC,CAAA,EACF,OAAOA,CAAA;cAET,MAAM,IAAI4D,KAAA,CAAM,iCAAiCrE,CAAA,G;;YAEnD,IAAIQ,CAAA,CAAa,OAAOP,CAAA,EACtB,MAAM,IAAIoE,KAAA,CAAM,2BAA2BpE,CAAA,YAAgBO,CAAA,CAAa;YAE1E,OAAOA,CAAA,CAAa,EACtB;UAAA;UAEQ,OAAA0D,QAAelE,CAAA;YACrB,MAAMC,CAAA,GAAOD,CAAA,YAAgBU,CAAA,CAAAmD,IAAA,CAAKC,cAAA,GAAiB9D,CAAA,CAAOgF,IAAA,GAAQhF,CAAA,CAA0BgF,IAAA;YAC5F,QAAQ/E,CAAA;cACN,KAAKS,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcC,KAAA;gBACrC,OAAO;cACT,KAAKxE,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcE,GAAA;gBACrC,OAAO;cACT,KAAKzE,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcG,MAAA;gBACrC,OAAO;cACT,KAAK1E,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcI,MAAA;gBACrC,OAAO;cACT,KAAK3E,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcK,MAAA;gBACrC,OAAO;cACT,KAAK5E,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcM,IAAA;gBACrC,OAAO;cACT,KAAK7E,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcO,OAAA;gBACrC,OAAO;cACT,KAAK9E,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcQ,OAAA;gBACrC,OAAO;cACT;gBACE,MAAM,IAAIpB,KAAA,CAAM,wCAAwC3D,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAchF,CAAA;YAAA;UAEhG;UAEQ,OAAAgE,SAAgBjE,CAAA;YACtB,MAAMC,CAAA,GAAWD,CAAA,YAAgBU,CAAA,CAAAmD,IAAA,CAAKC,cAAA,GAAiB9D,CAAA,CAAKgF,IAAA,GAAQhF,CAAA,CAA0BgF,IAAA;YAC9F,IAAI/E,CAAA,KAAaS,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcS,KAAA,IAASzF,CAAA,KAAaS,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcU,MAAA,EACzG,MAAM,IAAItB,KAAA,CAAM;YAGlB,MAAM5D,CAAA,GAAQ,KAAKmF,eAAA,CAAgB5F,CAAA;YAGnC,IAAIC,CAAA,KAAaS,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcE,GAAA,IAAOjE,CAAA,CAAA2E,QAAA,CAASC,MAAA,CAAOrF,CAAA,GACxE,OAAOS,CAAA,CAAA2E,QAAA,CAASE,YAAA,CAAatF,CAAA;YAI/B,IAAIR,CAAA,KAAaS,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcM,IAAA,EAAM;cACvD,MAAMvF,CAAA,GAAOS,CAAA;gBACPR,CAAA,GAAwB,IAAI+F,KAAA,CAAchG,CAAA,CAAI8B,MAAA;cAEpD,KAAK,IAAIrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAI8B,MAAA,EAAQrB,CAAA,IAAK;gBACnC,MAAMD,CAAA,GAAYR,CAAA,CAAIS,CAAA;gBACtBR,CAAA,CAAYQ,CAAA,IAAKS,CAAA,CAAA2E,QAAA,CAASE,YAAA,CAAavF,CAAA,C;;cAGzC,OAAOP,C;;YAIT,IAAIA,CAAA,KAAaS,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcI,MAAA,EACjD,OAAOrF,CAAA,YAAgBU,CAAA,CAAAmD,IAAA,CAAKC,cAAA,GAAiB7C,CAAA,CAAAgF,MAAA,CAAOC,SAAA,CAAUzF,CAAA,IACjBQ,CAAA,CAAAgF,MAAA,CAAOE,aAAA,CAAc1F,CAAA;YAIpE,IAAIR,CAAA,KAAaS,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcQ,OAAA,EAAS;cAC1D,IAAIzF,CAAA,YAAgBU,CAAA,CAAAmD,IAAA,CAAKC,cAAA,EAEvB,OADqBrD,CAAA,CACD0C,GAAA,CAAInD,CAAA,IAASiB,CAAA,CAAAgF,MAAA,CAAOC,SAAA,CAAUlG,CAAA;cAC7C,IAAIA,CAAA,YAAgBsD,CAAA,CAAOa,SAAA,EAEhC,OADqB1D,CAAA,CACD0C,GAAA,CAAInD,CAAA,IAASiB,CAAA,CAAAgF,MAAA,CAAOE,aAAA,CAAcnG,CAAA,E;;YAK1D,IAAIC,CAAA,KAAaS,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcG,MAAA,IAG7CpF,CAAA,YAAgBU,CAAA,CAAAmD,IAAA,CAAKC,cAAA,EAAgB;cACvC,MAAM9D,CAAA,GAAaS,CAAA;cACnB,QAAO,GAAAS,CAAA,CAAAkF,gBAAA,EAAiBpG,CAAA,C;;YAK5B,OAAIC,CAAA,KAAaS,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcO,OAAA,IAG7CxF,CAAA,YAAgBU,CAAA,CAAAmD,IAAA,CAAKC,cAAA,GACHrD,CAAA,CACD0C,GAAA,CAAIjC,CAAA,CAAAkF,gBAAA,IAIpB3F,CACT;UAAA;UAEQ,OAAAmF,gBAAuB5F,CAAA;YAC7B,OAAOA,CAAA,YAAiBU,CAAA,CAAAmD,IAAA,CAAmBC,cAAA,GAAI,KAAKuC,6BAAA,CAA8BrG,CAAA,IACnC,KAAKsG,4BAAA,CAA6BtG,CAAA,CACnF;UAAA;UAEQ,OAAAqG,8BAAqCrG,CAAA;YAC3C,QAAQA,CAAA,CAAKgF,IAAA;cACX,KAAKtE,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcC,KAAA;gBACrC,OAAOlF,CAAA,CAAKuG,CAAA;cACd,KAAK7F,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcE,GAAA;gBACrC,OAAOnF,CAAA,CAAKiB,CAAA;cACd,KAAKP,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcG,MAAA;gBACrC,OAAOpF,CAAA,CAAKsD,CAAA;cACd,KAAK5C,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcI,MAAA;gBACrC,OAAOrF,CAAA,CAAKC,CAAA;cACd,KAAKS,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcS,KAAA;gBACrC,OAAO1F,CAAA,CAAKwG,CAAA;cACd,KAAK9F,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcK,MAAA;gBACrC,OAAOtF,CAAA,CAAKyG,MAAA;cACd,KAAK/F,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcM,IAAA;gBACrC,OAAOvF,CAAA,CAAK0G,IAAA;cACd,KAAKhG,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcO,OAAA;gBACrC,OAAOxF,CAAA,CAAK2G,OAAA;cACd,KAAKjG,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcQ,OAAA;gBACrC,OAAOzF,CAAA,CAAK4G,OAAA;cACd,KAAKlG,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcU,MAAA;gBACrC,OAAO3F,CAAA,CAAK6G,MAAA;cACd;gBACE,MAAM,IAAIxC,KAAA,CAAM,+BAA+B3D,CAAA,CAAAmD,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcjF,CAAA,CAAKgF,IAAA;YAAA;UAE5F;UAEQ,OAAAsB,6BAAoCtG,CAAA;YAC1C,QAAQA,CAAA,CAAKgF,IAAA;cACX,KAAK1B,CAAA,CAAO2B,aAAA,CAAcC,KAAA;gBACxB,OAAOlF,CAAA,CAAKuG,CAAA;cACd,KAAKjD,CAAA,CAAO2B,aAAA,CAAcE,GAAA;gBACxB,OAAOnF,CAAA,CAAKiB,CAAA;cACd,KAAKqC,CAAA,CAAO2B,aAAA,CAAcG,MAAA;gBACxB,OAAOpF,CAAA,CAAKsD,CAAA;cACd,KAAKA,CAAA,CAAO2B,aAAA,CAAcI,MAAA;gBACxB,OAAOrF,CAAA,CAAKC,CAAA;cACd,KAAKqD,CAAA,CAAO2B,aAAA,CAAcS,KAAA;gBACxB,OAAO1F,CAAA,CAAKwG,CAAA;cACd,KAAKlD,CAAA,CAAO2B,aAAA,CAAcK,MAAA;gBACxB,OAAOtF,CAAA,CAAK8G,WAAA;cACd,KAAKxD,CAAA,CAAO2B,aAAA,CAAcM,IAAA;gBAAM;kBAC9B,MAAMtF,CAAA,GAAO;kBACb,KAAK,IAAIQ,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAK+G,UAAA,IAActG,CAAA,IACrCR,CAAA,CAAK+G,IAAA,CAAKhH,CAAA,CAAK0G,IAAA,CAAKjG,CAAA;kBAEtB,OAAOR,C;;cAET,KAAKqD,CAAA,CAAO2B,aAAA,CAAcO,OAAA;gBAAS;kBACjC,MAAMvF,CAAA,GAAU;kBAChB,KAAK,IAAIQ,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAKiH,aAAA,IAAiBxG,CAAA,IACxCR,CAAA,CAAQ+G,IAAA,CAAKhH,CAAA,CAAK2G,OAAA,CAAQlG,CAAA;kBAE5B,OAAOR,C;;cAET,KAAKqD,CAAA,CAAO2B,aAAA,CAAcQ,OAAA;gBAAS;kBACjC,MAAMxF,CAAA,GAAU;kBAChB,KAAK,IAAIQ,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAKkH,aAAA,IAAiBzG,CAAA,IACxCR,CAAA,CAAQ+G,IAAA,CAAKhH,CAAA,CAAK4G,OAAA,CAAQnG,CAAA;kBAE5B,OAAOR,C;;cAST;gBACE,MAAM,IAAIoE,KAAA,CAAM,+BAA+Bf,CAAA,CAAO2B,aAAA,CAAcjF,CAAA,CAAKgF,IAAA;YAAA;UAE/E;QAAA;QA7OF/E,CAAA,CAAAkE,SAAA,GAAAT,C;;;;;;;;QC5BA,MAAAlD,CAAA,GAAAC,CAAA;UA0EMC,CAAA,GAAsC,IAAIkD,GAAA;QAgChD,eAAe3C,EAAejB,CAAA;UAC5B,MAAMS,CAAA,GAAaR,CAAA,CAAAkH,OAAA;UAEnB,SAAuC,MAA5B1G,CAAA,CAAWT,CAAA,KAexB,UAAmBA,CAAA;YAEjB,MAAMC,CAAA,GAAID,CAAA;YAGV,OACI,gBAAgBC,CAAA,IAA6B,qBAAjBA,CAAA,CAAEmH,UAAA,IAC9B,0BAA0BnH,CAAA,IAAuC,qBAA3BA,CAAA,CAAEY,oBAAA,IACxC,aAAaZ,CAAA,IAA0B,qBAAdA,CAAA,CAAEoH,OAMjC;UAAA,CA7BwD,CAAU5G,CAAA,CAAWT,CAAA,IAAe;YACxF,MAAMC,CAAA,GAAUQ,CAAA,CAAWT,CAAA;YAC3B,IAAIQ,CAAA,GAAOP,CAAA,CAAQmH,UAAA;YAInB,IAHoB,mBAAT5G,CAAA,IAAqB,UAAUA,CAAA,KACxCA,CAAA,SAAaA,CAAA,GAEXA,CAAA,EAEF,OADAE,CAAA,CAAcqD,GAAA,CAAI/D,CAAA,EAAaC,CAAA,GACxBA,C;;QAKb;QA9CaA,CAAA,CAAAkH,OAAA,GAAqC;UAChDG,KAAA,EAAO,IAAI9G,CAAA,CAAA+G,YAAA;QAAA,GAObtH,CAAA,CAAAuH,cAAA,GAAO,eAAexH,EAAeC,CAAA;UACnC,KAAKA,CAAA,EACH,OAAOD,CAAA,CAAe,CAAC;UAClB;YACL,MAAMA,CAAA,GAAwB,mBAATC,CAAA,GAAoB,CAACA,CAAA,IAAQA,CAAA;YAElD,KAAK,MAAMA,CAAA,IAAeD,CAAA,EAAO;cAC/B,MAAMA,CAAA,GAAQU,CAAA,CAAc8D,GAAA,CAAIvE,CAAA;cAChC,IAAID,CAAA,EACF,OAAOA,CAAA;cAGT,MAAMS,CAAA,SAAgBQ,CAAA,CAAehB,CAAA;cACrC,IAAIQ,CAAA,EACF,OAAOA,C;;;UAKb,MAAM,IAAI4D,KAAA,CAAM,8BAClB;QAAA,C;;;;;;;;QCxGA,MAAA7D,CAAA,GAAAC,CAAA;UAGAC,CAAA,GAAAD,CAAA;UAGAQ,CAAA,GAAAR,CAAA;UAEAS,CAAA,GAAAT,CAAA;QAOAR,CAAA,CAAAsH,YAAA;UAGM,IAAAE,UAAA;YACF,OAAOjH,CAAA,CAAAY,GAAA,CAAIkG,KAAA,CAAMG,SACnB;UAAA;UACI,IAAAA,UAAUzH,CAAA;YACZQ,CAAA,CAAAY,GAAA,CAAIkG,KAAA,CAAMG,SAAA,GAAYzH,CACxB;UAAA;UAEI,IAAA0H,mBAAA;YACF,OAAOlH,CAAA,CAAAY,GAAA,CAAIkG,KAAA,CAAMI,kBACnB;UAAA;UACI,IAAAA,mBAAmB1H,CAAA;YACrBQ,CAAA,CAAAY,GAAA,CAAIkG,KAAA,CAAMI,kBAAA,GAAqB1H,CACjC;UAAA;UAEI,IAAA2H,iBAAA;YACF,OAAOnH,CAAA,CAAAY,GAAA,CAAIkG,KAAA,CAAMK,gBACnB;UAAA;UACI,IAAAA,iBAAiB3H,CAAA;YACnBQ,CAAA,CAAAY,GAAA,CAAIkG,KAAA,CAAMK,gBAAA,GAAmB3H,CAC/B;UAAA;UAEI,IAAA4H,KAAA;YACF,OAAOpH,CAAA,CAAAY,GAAA,CAAIkG,KAAA,CAAMM,IACnB;UAAA;UACI,IAAAA,KAAK5H,CAAA;YACPQ,CAAA,CAAAY,GAAA,CAAIkG,KAAA,CAAMM,IAAA,GAAO5H,CACnB;UAAA;UAEI,IAAA6H,MAAA;YACF,OAAOrH,CAAA,CAAAY,GAAA,CAAIkG,KAAA,CAAMO,KACnB;UAAA;UACI,IAAAA,MAAM7H,CAAA;YACRQ,CAAA,CAAAY,GAAA,CAAIkG,KAAA,CAAMO,KAAA,GAAQ7H,CACpB;UAAA;UAEAoH,WAAA;YACE;cAsBE,OArBA,KAAKU,SAAA,IAAY,GAAA5G,CAAA,CAAA6G,kBAAA,EAAmB,KAAKN,SAAA,GACF,mBAA5B,KAAKC,kBAAA,KACd,KAAKA,kBAAA,GAAqB,KAES,mBAA1B,KAAKC,gBAAA,KACd,KAAKA,gBAAA,GAAmB,SAED,oBAAd,KAAKC,IAAA,KACd,KAAKA,IAAA,IAAO,IAEY,oBAAf,KAAKC,KAAA,KACd,KAAKA,KAAA,IAAQ,IAGfnH,CAAA,CAAAsH,MAAA,CAAOC,UAAA,CAAWzH,CAAA,CAAAY,GAAA,GAElBV,CAAA,CAAAsH,MAAA,CAAOE,OAAA,CACH,gBACA,gCAAgC,KAAKJ,SAAA,6BACjC,KAAKJ,kBAAA,uBAAyC,KAAKC,gBAAA,WAA2B,KAAKC,IAAA,YACnF,KAAKC,KAAA,OACN,C;aACP,QAAO7H,CAAA;cAEP,OADAU,CAAA,CAAAsH,MAAA,CAAOG,OAAA,CAAQ,gBAAgB,sCAAsCnI,CAAA,MAC9D,C;;UAEX;UACAa,qBAAqBb,CAAA;YACnB,OAAO,IAAIiB,CAAA,CAAAmH,mBAAA,CAAoB,MAAMpI,CAAA,CACvC;UAAA;UACAqH,QAAA;YACE,KAAKS,SAAA,CAAUT,OAAA,EACjB;UAAA;QAAA,C;;;;;;;;QCvFF,MAAA7G,CAAA,GAAAC,CAAA;UAEAC,CAAA,GAAAD,CAAA;UACAQ,CAAA,GAAAR,CAAA;UACAS,CAAA,GAAAT,CAAA;UAEA6C,CAAA,GAAA7C,CAAA;QAMA,MAAaiD,CAAA,SAAsBhD,CAAA,CAAA2H,OAAA;UAGjCzF,YAAY5C,CAAA;YACV,MAAMA,CAAA,CACR;UAAA;UACAsI,aAAA;YACE,OAAOzF,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK,KAAKyF,cAAA,KACL,KAAKC,cAAA,KACL,KAAKC,KAAA,KACL,KAAKC,SAAA,KAEL,KAAKC,kBAAA,KACL,KAAKC,yBAAA,KACL,KAAKC,wBAAA,GAEZ;UAAA;UACAC,eAAA;YACE,OAAO,CAAC,CACV;UAAA;UAKUP,eAAA;YAER,OAAO;cACLA,cAAA,EAAgB,IAAI7H,CAAA,CAAAqI,cAAA,CAAe;YAAA,CASvC;UAAA;UAMUP,eAAA;YAER,OAAO;cACLA,cAAA,EAAgB,IAAI9H,CAAA,CAAAqI,cAAA,CAAe;YAAA,CASvC;UAAA;UAMUF,yBAAA;YACR,MAAM7I,CAAA,GAAe,KAAKgJ,OAAA,CAAQC,mBAAA;YAClC,OAAIjJ,CAAA,CAAakJ,QAAA,GACR,KAAKC,8BAAA,CAA+BnJ,CAAA,IAEpC,KAAKoJ,gCAAA,CAAiCpJ,CAAA,CAEjD;UAAA;UAKUmJ,+BAA+BnJ,CAAA;YACvC,MAAMC,CAAA,GAAWD,CAAA,CAAaqJ,aAAA;cACxB5I,CAAA,GAAc,CAACT,CAAA,CAAasJ,KAAA,EAAOtJ,CAAA,CAAauJ,MAAA;cAChD/I,CAAA,GAA2C,CAAC;cAC5CU,CAAA,GAAW;YACjB,QAAQjB,CAAA,CAAS6B,MAAA;cACf,KAAK;gBACHtB,CAAA,CAAOU,CAAA,IAAY,KAAKsI,qBAAA;gBACxB;cACF,KAAK;gBACHhJ,CAAA,CAAOU,CAAA,IAAY,KAAKuI,uBAAA,CAAwBxJ,CAAA,EAAsBQ,CAAA;gBACtE;cACF,KAAK;gBACHD,CAAA,CAAOU,CAAA,IAAY,KAAKwI,uBAAA,CAAwBzJ,CAAA,EAA8BQ,CAAA;gBAC9E;cACF,KAAK;gBACHD,CAAA,CAAOU,CAAA,IACH,KAAKyI,uBAAA,CAAwB1J,CAAA,EAAsCQ,CAAA;gBACvE;cACF;gBACED,CAAA,CAAOU,CAAA,IAAY,KAAK0I,uBAAA,CAAwB3J,CAAA,EAAUQ,CAAA;YAAA;YAE9D,MAGM6C,CAAA,GAA4B,gDAHrB,GAAArC,CAAA,CAAA4I,OAAA,EAAQ,KAAKb,OAAA,CAAQlB,SAAA,CAAUnF,OAAA,EAKjCmH,MAAA;YAKX,OADAtJ,CAAA,CAAkCuJ,mBAAA,GAAI,IAAIrJ,CAAA,CAAAqI,cAAA,CAAezF,CAAA,GAClD9C,CACT;UAAA;UAKU4I,iCAAiCpJ,CAAA;YACzC,MAAMC,CAAA,GAAWD,CAAA,CAAaqJ,aAAA;cACxB5I,CAAA,GAAc,CAACT,CAAA,CAAasJ,KAAA,EAAOtJ,CAAA,CAAauJ,MAAA;cAChD/I,CAAA,GAA2C,CAAC;cAC5CU,CAAA,GAAW;YACjB,QAAQjB,CAAA,CAAS6B,MAAA;cACf,KAAK;gBACHtB,CAAA,CAAOU,CAAA,IAAY,KAAKsI,qBAAA;gBACxB;cACF,KAAK;gBACHhJ,CAAA,CAAOU,CAAA,IAAY,KAAK8I,yBAAA,CAA0B/J,CAAA,EAAsBQ,CAAA;gBACxE;cACF,KAAK;gBACHD,CAAA,CAAOU,CAAA,IACH,KAAK+I,yBAAA,CAA0BhK,CAAA,EAA8BQ,CAAA;gBACjE;cACF,KAAK;gBACHD,CAAA,CAAOU,CAAA,IACH,KAAKgJ,yBAAA,CAA0BjK,CAAA,EAAsCQ,CAAA;gBACzE;cACF,KAAK;gBACHD,CAAA,CAAOU,CAAA,IAAY,KAAKiJ,yBAAA,CACpBlK,CAAA,EAA8CQ,CAAA;gBAClD;cACF,KAAK;gBACHD,CAAA,CAAOU,CAAA,IAAY,KAAKkJ,yBAAA,CACpBnK,CAAA,EAAsDQ,CAAA;gBAC1D;cACF,KAAK;gBACHD,CAAA,CAAOU,CAAA,IAAY,KAAKmJ,yBAAA,CACpBpK,CAAA,EAA8DQ,CAAA;gBAClE;cACF;gBACE,MAAM,IAAI4D,KAAA,CAAM,sCAAsCpE,CAAA,CAAS6B,MAAA;YAAA;YAEnE,MAGMwB,CAAA,GAAyB,qDAHlB,GAAArC,CAAA,CAAA4I,OAAA,EAAQ,KAAKb,OAAA,CAAQlB,SAAA,CAAUnF,OAAA,EAK/BmH,MAAA;YAKb,OADAtJ,CAAA,CAA+B8J,gBAAA,GAAI,IAAI5J,CAAA,CAAAqI,cAAA,CAAezF,CAAA,GAC/C9C,CACT;UAAA;UAKUgJ,sBAAA;YACR,OAAO,IAAI9I,CAAA,CAAAqI,cAAA,CAAe,oEAK5B;UAAA;UAKUU,wBAAwBzJ,CAAA,EAAiBC,CAAA;YACjD,MAAMQ,CAAA,GAAiBR,CAAA;YACvB,IAAIO,CAAA,GAAS;YACb,OAA0B,MAAtBC,CAAA,CAAe,MACjBD,CAAA,GAAS,iFAE4BC,CAAA,CAAe,iCAG7C,IAAIC,CAAA,CAAAqI,cAAA,CAAevI,CAAA,KAGF,MAAtBC,CAAA,CAAe,MACjBD,CAAA,GAAS,iFAE4BC,CAAA,CAAe,iCAG7C,IAAIC,CAAA,CAAAqI,cAAA,CAAevI,CAAA,MAG5BA,CAAA,GAAS,6HAG2BC,CAAA,CAAe,OAAOA,CAAA,CAAe,6CACxCA,CAAA,CAAe,wCAGzC,IAAIC,CAAA,CAAAqI,cAAA,CAAevI,CAAA,EAC5B;UAAA;UAKUkJ,wBAAwB1J,CAAA,EAAyBC,CAAA;YACzD,IAAIQ,CAAA,GAAS;YACb,IAAID,CAAA,CAAA+J,SAAA,CAAUC,WAAA,CAAYxK,CAAA,EAAOC,CAAA,GAM/B,OALAQ,CAAA,GAAS,uFAEkCR,CAAA,CAAS,OAAOA,CAAA,CAAS,4BAG7D,IAAIS,CAAA,CAAAqI,cAAA,CAAetI,CAAA;YAG5B,MAAMQ,CAAA,GAAiBhB,CAAA;cAEjBiB,CAAA,GAAqBc,IAAA,CAAKE,IAAA,CAAKlC,CAAA,CAAM,KAAK;YAyBhD,OAdAS,CAAA,GAAS,8HAG0BQ,CAAA,CAAe,OAAOA,CAAA,CAAe,+CAEvCA,CAAA,CAAe,4GAGpBC,CAAA,0CACCA,CAAA,0DAKtB,IAAIR,CAAA,CAAAqI,cAAA,CAAetI,CAAA,CAC5B;UAAA;UAKUkJ,wBAAwB3J,CAAA,EAAiCC,CAAA;YACjE,MAAMQ,CAAA,GAAiB,CAACR,CAAA,CAAS,IAAIA,CAAA,CAAS;cACxCO,CAAA,GAAqBwB,IAAA,CAAKE,IAAA,CAAKlC,CAAA,CAAM,KAAK;cAC1CiB,CAAA,GAAgBT,CAAA,GAAqBwB,IAAA,CAAKE,IAAA,CAAKlC,CAAA,CAAM,KAAK;cAC1DkB,CAAA,GAAS,8HAGoBT,CAAA,CAAe,OAAOA,CAAA,CAAe,6CACvCA,CAAA,CAAe,iDAExBQ,CAAA,6BACHA,CAAA,6FAGOT,CAAA,0CACCA,CAAA;YAK7B,OAAO,IAAIE,CAAA,CAAAqI,cAAA,CAAe7H,CAAA,CAC5B;UAAA;UAKU0I,wBAAwB5J,CAAA,EAA0BC,CAAA;YAC1D,MAAMQ,CAAA,GAAiB,CAACR,CAAA,CAAS,IAAIA,CAAA,CAAS;cAExCO,CAAA,GAAqBwB,IAAA,CAAKE,IAAA,CAAKlC,CAAA,CAAMA,CAAA,CAAM8B,MAAA,GAAS,KAAK;cACzDb,CAAA,GAAgBT,CAAA,GAAqBwB,IAAA,CAAKE,IAAA,CAAKlC,CAAA,CAAMA,CAAA,CAAM8B,MAAA,GAAS,KAAK;YAC/E,IAAIZ,CAAA,GAAiBD,CAAA;cACjBqC,CAAA,GAAU;cACVI,CAAA,GAAS;YAEb,KAAK,IAAIzD,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAM8B,MAAA,GAAS,GAAG7B,CAAA,IACpCiB,CAAA,IAAkBlB,CAAA,CAAMA,CAAA,CAAM8B,MAAA,GAAS7B,CAAA,GAAI,IAC3CqD,CAAA,GAAU,gBACHrD,CAAA,cAAeiB,CAAA,sBACVjB,CAAA,MAAOiB,CAAA,YACjBoC,CAAA,EACFI,CAAA,GAAS,IAAIzD,CAAA,OAAQyD,CAAA;YAEvB,MAAM+G,CAAA,GAAS,eACPzK,CAAA,CAAM8B,MAAA,2GAEmBrB,CAAA,CAAe,OAAOA,CAAA,CAAe,2CACvCA,CAAA,CAAe,+BAExC6C,CAAA,+BAEgBrC,CAAA,2BACHA,CAAA,yFAGOT,CAAA,wCACCA,CAAA,4BAEVR,CAAA,CAAM8B,MAAA,IAAU4B,CAAA;YAGjC,OAAO,IAAIhD,CAAA,CAAAqI,cAAA,CAAe0B,CAAA,CAC5B;UAAA;UAKUT,0BAA0BhK,CAAA,EAAiBC,CAAA;YACnD,MAAMQ,CAAA,GAAS,4HAGoBR,CAAA,CAAS,OAAOA,CAAA,CAAS,wCAChCA,CAAA,CAAS;YAGrC,OAAO,IAAIS,CAAA,CAAAqI,cAAA,CAAetI,CAAA,CAC5B;UAAA;UAKUwJ,0BAA0BjK,CAAA,EAAyBC,CAAA;YAC3D,MAAMQ,CAAA,GAAS,8HAGoBR,CAAA,CAAS,OAAOA,CAAA,CAAS,6CAC3BA,CAAA,CAAS,+CAClBD,CAAA,CAAM,sCACFA,CAAA,CAAM;YAIlC,OAAO,IAAIU,CAAA,CAAAqI,cAAA,CAAetI,CAAA,CAC5B;UAAA;UAKUyJ,0BAA0BlK,CAAA,EAAiCC,CAAA;YACnE,IAAIQ,CAAA,GAAS;YACb,MAAMD,CAAA,GAAOR,CAAA,CAAM8B,MAAA;YAEnB,IAAIb,CAAA,GAAU;YACVT,CAAA,GAAO,MACTS,CAAA,GAAU,KAGZA,CAAA,GAAU,IAAI+E,KAAA,CAAMxF,CAAA,GAAO,IAC3BS,CAAA,CAAQT,CAAA,GAAO,KAAKR,CAAA,CAAMQ,CAAA,GAAO;YACjC,KAAK,IAAIP,CAAA,GAAIO,CAAA,GAAO,GAAGP,CAAA,IAAK,KAAKA,CAAA,EAC/BgB,CAAA,CAAQhB,CAAA,IAAKgB,CAAA,CAAQhB,CAAA,GAAI,KAAKD,CAAA,CAAMC,CAAA,GAAI;YAE1C,MAAMiB,CAAA,GAAkB,CAAC,KAAK,KAAK;cAC7BoC,CAAA,GACFrC,CAAA,CACKkC,GAAA,CAAI,CAACnD,CAAA,EAAQC,CAAA,KAKL,OAJciB,CAAA,CAAgBjB,CAAA,eAAgBD,CAAA,KACvCC,CAAA,KAAMgB,CAAA,CAAQa,MAAA,GAAS,IACjC,OAAOZ,CAAA,CAAgBjB,CAAA,GAAI,gBAAgBiB,CAAA,CAAgBjB,CAAA,OAAQD,CAAA,KACnE,YAAYkB,CAAA,CAAgBjB,CAAA,OAAQD,CAAA,OAGzCoD,IAAA,CAAK;YAWd,OATA3C,CAAA,GAAS,8HAG0BR,CAAA,CAAS,OAAOA,CAAA,CAAS,6CAC3BA,CAAA,CAAS,+BAClCqD,CAAA,yDAID,IAAI5C,CAAA,CAAAqI,cAAA,CAAetI,CAAA,CAC5B;UAAA;UAKU0J,0BAA0BnK,CAAA,EAAyCC,CAAA;YAE3E,IAAIQ,CAAA,GAAS;YACb,MAAMD,CAAA,GAAOR,CAAA,CAAM8B,MAAA;YAEnB,IAAIb,CAAA,GAAU;YACVT,CAAA,GAAO,MACTS,CAAA,GAAU,KAGZA,CAAA,GAAU,IAAI+E,KAAA,CAAMxF,CAAA,GAAO,IAC3BS,CAAA,CAAQT,CAAA,GAAO,KAAKR,CAAA,CAAMQ,CAAA,GAAO;YACjC,KAAK,IAAIP,CAAA,GAAIO,CAAA,GAAO,GAAGP,CAAA,IAAK,KAAKA,CAAA,EAC/BgB,CAAA,CAAQhB,CAAA,IAAKgB,CAAA,CAAQhB,CAAA,GAAI,KAAKD,CAAA,CAAMC,CAAA,GAAI;YAE1C,MAAMiB,CAAA,GAAkB,CAAC,KAAK,KAAK,KAAK;cAClCoC,CAAA,GACFrC,CAAA,CACKkC,GAAA,CAAI,CAACnD,CAAA,EAAQC,CAAA,KAKL,OAJciB,CAAA,CAAgBjB,CAAA,eAAgBD,CAAA,KACvCC,CAAA,KAAMgB,CAAA,CAAQa,MAAA,GAAS,IACjC,OAAOZ,CAAA,CAAgBjB,CAAA,GAAI,gBAAgBiB,CAAA,CAAgBjB,CAAA,OAAQD,CAAA,KACnE,YAAYkB,CAAA,CAAgBjB,CAAA,OAAQD,CAAA,OAGzCoD,IAAA,CAAK;YAWd,OATA3C,CAAA,GAAS,4HAG0BR,CAAA,CAAS,OAAOA,CAAA,CAAS,6CAC3BA,CAAA,CAAS,+BAClCqD,CAAA,6DAID,IAAI5C,CAAA,CAAAqI,cAAA,CAAetI,CAAA,CAC5B;UAAA;UAKU2J,0BAA0BpK,CAAA,EAAiDC,CAAA;YAEnF,IAAIQ,CAAA,GAAS;YACb,MAAMD,CAAA,GAAOR,CAAA,CAAM8B,MAAA;YAEnB,IAAIb,CAAA,GAAU;YACVT,CAAA,GAAO,MACTS,CAAA,GAAU,KAGZA,CAAA,GAAU,IAAI+E,KAAA,CAAMxF,CAAA,GAAO,IAC3BS,CAAA,CAAQT,CAAA,GAAO,KAAKR,CAAA,CAAMQ,CAAA,GAAO;YACjC,KAAK,IAAIP,CAAA,GAAIO,CAAA,GAAO,GAAGP,CAAA,IAAK,KAAKA,CAAA,EAC/BgB,CAAA,CAAQhB,CAAA,IAAKgB,CAAA,CAAQhB,CAAA,GAAI,KAAKD,CAAA,CAAMC,CAAA,GAAI;YAE1C,MAAMiB,CAAA,GAAkB,CAAC,KAAK,KAAK,KAAK,MAAM;cACxCoC,CAAA,GACFrC,CAAA,CACKkC,GAAA,CAAI,CAACnD,CAAA,EAAQC,CAAA,KAKL,OAJciB,CAAA,CAAgBjB,CAAA,eAAgBD,CAAA,KACvCC,CAAA,KAAMgB,CAAA,CAAQa,MAAA,GAAS,IACjC,OAAOZ,CAAA,CAAgBjB,CAAA,GAAI,gBAAgBiB,CAAA,CAAgBjB,CAAA,OAAQD,CAAA,KACnE,YAAYkB,CAAA,CAAgBjB,CAAA,OAAQD,CAAA,OAGzCoD,IAAA,CAAK;YAWd,OATA3C,CAAA,GAAS,4HAG0BR,CAAA,CAAS,OAAOA,CAAA,CAAS,6CAC3BA,CAAA,CAAS,+BAClCqD,CAAA,iEAID,IAAI5C,CAAA,CAAAqI,cAAA,CAAetI,CAAA,CAC5B;UAAA;UAKU4J,0BAA0BrK,CAAA,EAAyDC,CAAA;YAG3F,IAAIQ,CAAA,GAAS;YACb,MAAMD,CAAA,GAAOR,CAAA,CAAM8B,MAAA;YAEnB,IAAIb,CAAA,GAAU;YACVT,CAAA,GAAO,MACTS,CAAA,GAAU,KAGZA,CAAA,GAAU,IAAI+E,KAAA,CAAMxF,CAAA,GAAO,IAC3BS,CAAA,CAAQT,CAAA,GAAO,KAAKR,CAAA,CAAMQ,CAAA,GAAO;YACjC,KAAK,IAAIP,CAAA,GAAIO,CAAA,GAAO,GAAGP,CAAA,IAAK,KAAKA,CAAA,EAC/BgB,CAAA,CAAQhB,CAAA,IAAKgB,CAAA,CAAQhB,CAAA,GAAI,KAAKD,CAAA,CAAMC,CAAA,GAAI;YAE1C,MAAMiB,CAAA,GAAkB,CAAC,KAAK,KAAK,KAAK,MAAM,MAAM;cAC9CoC,CAAA,GACFrC,CAAA,CACKkC,GAAA,CAAI,CAACnD,CAAA,EAAQC,CAAA,KAKL,OAJciB,CAAA,CAAgBjB,CAAA,eAAgBD,CAAA,KACvCC,CAAA,KAAMgB,CAAA,CAAQa,MAAA,GAAS,IACjC,OAAOZ,CAAA,CAAgBjB,CAAA,GAAI,gBAAgBiB,CAAA,CAAgBjB,CAAA,OAAQD,CAAA,KACnE,YAAYkB,CAAA,CAAgBjB,CAAA,OAAQD,CAAA,OAGzCoD,IAAA,CAAK;YAWd,OATA3C,CAAA,GAAS,yHAGyBR,CAAA,CAAS,OAAOA,CAAA,CAAS,4CAC3BA,CAAA,CAAS,8BAClCqD,CAAA,kEAIA,IAAI5C,CAAA,CAAAqI,cAAA,CAAetI,CAAA,CAC5B;UAAA;UAKUkI,mBAAA;YACR,MAAM3I,CAAA,GAA2C,CAAC;YAClD,IAAIC,CAAA,GAAW;YACfD,CAAA,CAAOC,CAAA,IAAY,IAAIS,CAAA,CAAAqI,cAAA,CAAe,0WAStC9I,CAAA,GAAW,kBACXD,CAAA,CAAOC,CAAA,IAAY,IAAIS,CAAA,CAAAqI,cAAA,CAAe,8RAQtC9I,CAAA,GAAW,kBACXD,CAAA,CAAOC,CAAA,IAAY,IAAIS,CAAA,CAAAqI,cAAA,CAAe,8VAQtC9I,CAAA,GAAW,kBACXD,CAAA,CAAOC,CAAA,IAAY,IAAIS,CAAA,CAAAqI,cAAA,CAAe,mZAUtC9I,CAAA,GAAW;YACX,MAAMQ,CAAA,IAAO,GAAAQ,CAAA,CAAA4I,OAAA,EAAQ,KAAKb,OAAA,CAAQlB,SAAA,CAAUnF,OAAA;YAK5C,OAJA3C,CAAA,CAAOC,CAAA,IAAY,IAAIS,CAAA,CAAAqI,cAAA,CAAe,0FAErBtI,CAAA,CAAKiK,SAAA,uCAEf1K,CACT;UAAA;UAKU4I,0BAAA;YACR,MAAM5I,CAAA,GAA2C,CAAC;cAC5CC,CAAA,GAAe,KAAK+I,OAAA,CAAQC,mBAAA;YAsBlC,OArBA,KAAKD,OAAA,CAAQ2B,WAAA,CAAYC,UAAA,CAAWC,OAAA,CAAQ,CAACpK,CAAA,EAAaD,CAAA;cACxD,MAAME,CAAA,GAAc,KAAKsI,OAAA,CAAQ8B,mBAAA,CAAoBtK,CAAA;gBAC/CS,CAAA,IAAW,GAAAqC,CAAA,CAAAyH,0CAAA,EAA2CtK,CAAA;cACxDC,CAAA,CAAYwI,QAAA,GACdlJ,CAAA,CAAOiB,CAAA,IAAY,KAAK+J,yBAAA,CAA0B/J,CAAA,EAAUR,CAAA,EAAaC,CAAA,IAEzEV,CAAA,CAAOiB,CAAA,IAAY,KAAKgK,2BAAA,CAA4BhK,CAAA,EAAUR,CAAA,EAAaC,CAAA;cAG7E,MAAMQ,CAAA,IAAmB,GAAAoC,CAAA,CAAA4H,qDAAA,EAAsDzK,CAAA;cAC3EC,CAAA,CAAY2I,aAAA,CAAcvH,MAAA,IAAU7B,CAAA,CAAaoJ,aAAA,CAAcvH,MAAA,KAC7DpB,CAAA,CAAYwI,QAAA,GACdlJ,CAAA,CAAOkB,CAAA,IACH,KAAKiK,8BAAA,CAA+BjK,CAAA,EAAkBR,CAAA,EAAaT,CAAA,EAAcQ,CAAA,IAErFT,CAAA,CAAOkB,CAAA,IACH,KAAKkK,gCAAA,CAAiClK,CAAA,EAAkBR,CAAA,EAAaT,CAAA,EAAcQ,CAAA,E;gBAKtFT,CACT;UAAA;UAKUmL,+BACNnL,CAAA,EAAkBC,CAAA,EAA4BQ,CAAA,EAA6BQ,CAAA;YAC7E,MAAMC,CAAA,GAAUjB,CAAA,CAAYoJ,aAAA;cACtB3F,CAAA,GAAWjD,CAAA,CAAa4I,aAAA;cACxBoB,CAAA,GAAUxJ,CAAA;cACVoK,CAAA,IAAiB,GAAA/H,CAAA,CAAAyH,0CAAA,EAA2CN,CAAA;cAE5Da,CAAA,GAASpK,CAAA,CAAQY,MAAA;cACjByJ,CAAA,GAAU7H,CAAA,CAAS5B,MAAA;cAEnByE,CAAA,GAAgB/F,CAAA,CAAAgL,aAAA,CAAcC,gBAAA,CAAiBvK,CAAA,EAASwC,CAAA;cAExDgI,CAAA,IAAO,GAAApI,CAAA,CAAAqI,iBAAA,EAAkBJ,CAAA;cACzB/E,CAAA,GAAW+E,CAAA,GAAUD,CAAA;YAC3B,IAAIM,CAAA;YACJ,MAAMC,CAAA,IAAS,GAAAvI,CAAA,CAAAwI,aAAA;YAGbF,CAAA,GADa,MAAXN,CAAA,GACc,KACPC,CAAA,GAAU,KAAKhF,CAAA,CAAczE,MAAA,IAAU,IAChC,gBAEAyE,CAAA,CAAcpD,GAAA,CAAInD,CAAA,IAAK,UAAU6L,CAAA,CAAO7L,CAAA,GAAIwG,CAAA,UAAkBpD,IAAA,CAAK;YAErF,IAAI2I,CAAA,GAAwB;YAE1BA,CAAA,GADER,CAAA,GAAU,KAAKD,CAAA,GAAS,IACF,WAEApK,CAAA,CAAQiC,GAAA,CAAI,CAACnD,CAAA,EAAGC,CAAA,KAAM,UAAU4L,CAAA,CAAO5L,CAAA,GAAIuG,CAAA,KAAapD,IAAA,CAAK;YAGvF,IAAI4I,CAAA,GAAS;YACb,MACMC,CAAA,GAA2B,MADlBzL,CAAA,CAAA0L,SAAA,CAAU9H,IAAA,CAAKlD,CAAA;cAGxBiL,CAAA,GAA6B,MADnB3L,CAAA,CAAA0L,SAAA,CAAU9H,IAAA,CAAKV,CAAA;YAG/B,IAAe,MAAX4H,CAAA,IAAiBW,CAAA,IAAkBE,CAAA;cAIhC,IAAIF,CAAA,KAAkBE,CAAA,EAEzBH,CAAA,GADc,MAAZT,CAAA,GACO,6EAIA,yDAIN,IAAIhF,CAAA,CAAczE,MAAA,EAAQ;gBAC/B,MAAM9B,CAAA,GAAOsL,CAAA,GAAS;kBAChBrL,CAAA,GAAOqL,CAAA,GAAS;gBAElB/E,CAAA,CAAc6F,OAAA,CAAQpM,CAAA,KAAS,KAAKuG,CAAA,CAAc6F,OAAA,CAAQnM,CAAA,KAAS,IACrE+L,CAAA,GAAS,gCACAzF,CAAA,CAAc6F,OAAA,CAAQpM,CAAA,KAAS,IACxCgM,CAAA,GAAS,6EAEAzF,CAAA,CAAc6F,OAAA,CAAQnM,CAAA,KAAS,MACxC+L,CAAA,GAAS,+C;;mBAvBXA,CAAA,GAAS;YA2BX,MAKMK,CAAA,GAAS,gBACNrM,CAAA,iBACH0L,CAAA,wEANqBG,CAAA,CAAON,CAAA,GAAU,uBAC/BM,CAAA,CAAON,CAAA,GAAU,eAAeM,CAAA,CAAON,CAAA,GAAU,uBACjDM,CAAA,CAAON,CAAA,GAAU,kCAMxBK,CAAA,gCACmBP,CAAA,IAAkBU,CAAA,eACrCC,CAAA;YAGN,OAAO,IAAItL,CAAA,CAAAqI,cAAA,CAAesD,CAAA,EAAQ,CAAC,+BACrC;UAAA;UAKUjB,iCACNpL,CAAA,EAAkBC,CAAA,EAA4BQ,CAAA,EAA6BQ,CAAA;YAC7E,MAAMC,CAAA,GAAc,CAACT,CAAA,CAAa6I,KAAA,EAAO7I,CAAA,CAAa8I,MAAA;cAChD7F,CAAA,GAAa,CAACzD,CAAA,CAAYqJ,KAAA,EAAOrJ,CAAA,CAAYsJ,MAAA;cAC7CkB,CAAA,GAASxK,CAAA,CAAYoJ,aAAA,CAAcvH,MAAA;cACnCuJ,CAAA,GAAU5K,CAAA,CAAa4I,aAAA,CAAcvH,MAAA;cACrCwJ,CAAA,GAAUrL,CAAA,CAAYoJ,aAAA;cACtBkC,CAAA,GAAW9K,CAAA,CAAa4I,aAAA;cACxB9C,CAAA,IAAiB,GAAAjD,CAAA,CAAAyH,0CAAA,EAA2C9J,CAAA;YAElE,IAAIwJ,CAAA,KAAWY,CAAA,IAAW7K,CAAA,CAAA+J,SAAA,CAAUC,WAAA,CAAY9G,CAAA,EAAYxC,CAAA,GAAc;cACxE,MAAMjB,CAAA,GAAS,qBACHD,CAAA,0CACiBiB,CAAA;cAG7B,OAAO,IAAIP,CAAA,CAAAqI,cAAA,CAAe9I,CAAA,EAAQ,CAAC,6B;;YAGrC,MAAMyL,CAAA,IAAO,GAAApI,CAAA,CAAAqI,iBAAA,EAAkBN,CAAA;cACzB7E,CAAA,GAAgBhG,CAAA,CAAAgL,aAAA,CAAcC,gBAAA,CAAiBH,CAAA,EAASC,CAAA;cACxDK,CAAA,GAAWP,CAAA,GAAUZ,CAAA;YAC3B,IAAIoB,CAAA;YACJ,MAAME,CAAA,IAAS,GAAAzI,CAAA,CAAAwI,aAAA;YAGbD,CAAA,GADa,MAAXpB,CAAA,GACc,KACPY,CAAA,GAAU,KAAK7E,CAAA,CAAc1E,MAAA,IAAU,IAChC,gBAEA0E,CAAA,CAAcrD,GAAA,CAAInD,CAAA,IAAK,UAAU+L,CAAA,CAAO/L,CAAA,GAAI4L,CAAA,UAAkBxI,IAAA,CAAK;YAErF,IAAI4I,CAAA,GAAwB;YAE1BA,CAAA,GADEX,CAAA,GAAU,KAAKZ,CAAA,GAAS,IACF,WAEAxK,CAAA,CAAYoJ,aAAA,CAAclG,GAAA,CAAI,CAACnD,CAAA,EAAGC,CAAA,KAAM,UAAU8L,CAAA,CAAO9L,CAAA,GAAI2L,CAAA,KAAaxI,IAAA,CAAK;YAEzG,MAAM6I,CAAA,GAAS,mBACHjM,CAAA,mBACJ0L,CAAA,2CACAG,CAAA,sBACOtF,CAAA,IAAkByF,CAAA;YAGjC,OAAO,IAAItL,CAAA,CAAAqI,cAAA,CAAekD,CAAA,EAAQ,CAAC,+BACrC;UAAA;UAKUjB,0BAA0BhL,CAAA,EAAkBC,CAAA,EAAcQ,CAAA;YAClE,QAAQA,CAAA,CAAY4I,aAAA,CAAcvH,MAAA;cAChC,KAAK;gBACH,OAAO,KAAKwK,sBAAA,CAAuBtM,CAAA,EAAUC,CAAA;cAC/C,KAAK;gBACH,OAAO,KAAKsM,kBAAA,CAAmBvM,CAAA,EAAUC,CAAA,EAAMQ,CAAA;cACjD,KAAK;gBACH,OAAO,KAAK+L,kBAAA,CAAmBxM,CAAA,EAAUC,CAAA,EAAMQ,CAAA;cACjD,KAAK;gBACH,OAAO,KAAKgM,kBAAA,CAAmBzM,CAAA,EAAUC,CAAA,EAAMQ,CAAA;cACjD;gBACE,OAAO,KAAKiM,kBAAA,CAAmB1M,CAAA,EAAUC,CAAA,EAAMQ,CAAA;YAAA;UAErD;UAKUwK,4BAA4BjL,CAAA,EAAkBC,CAAA,EAAcQ,CAAA;YACpE,MAAMD,CAAA,GAAQC,CAAA,CAAY4I,aAAA;YAC1B,QAAQ7I,CAAA,CAAMsB,MAAA;cACZ,KAAK;gBACH,OAAO,KAAK6K,wBAAA,CAAyB3M,CAAA,EAAUC,CAAA,EAAMQ,CAAA;cACvD,KAAK;gBACH,OAAO,KAAKmM,oBAAA,CAAqB5M,CAAA,EAAUC,CAAA,EAAMQ,CAAA;cACnD,KAAK;gBACH,OAAO,KAAKoM,oBAAA,CAAqB7M,CAAA,EAAUC,CAAA,EAAMQ,CAAA;cACnD,KAAK;gBACH,OAAO,KAAKqM,oBAAA,CAAqB9M,CAAA,EAAUC,CAAA,EAAMQ,CAAA;cACnD,KAAK;gBACH,OAAO,KAAKsM,oBAAA,CAAqB/M,CAAA,EAAUC,CAAA,EAAMQ,CAAA;cACnD,KAAK;gBACH,OAAO,KAAKuM,oBAAA,CAAqBhN,CAAA,EAAUC,CAAA,EAAMQ,CAAA;cACnD,KAAK;gBACH,OAAO,KAAKwM,oBAAA,CAAqBjN,CAAA,EAAUC,CAAA,EAAMQ,CAAA;cACnD;gBAEE,MAAM,IAAI4D,KAAA,CAAM,yBAAyB7D,CAAA,CAAMsB,MAAA;YAAA;UAErD;UAKUwK,uBAAuBtM,CAAA,EAAkBC,CAAA;YACjD,MACMQ,CAAA,GAAS,oBACFT,CAAA,6BAFA,GAAAiB,CAAA,CAAA4I,OAAA,EAAQ,KAAKb,OAAA,CAAQlB,SAAA,CAAUnF,OAAA,EAGtB+H,SAAA,IAAazK,CAAA;YAGnC,OAAO,IAAIS,CAAA,CAAAqI,cAAA,CAAetI,CAAA,CAC5B;UAAA;UAKU8L,mBAAmBvM,CAAA,EAAkBC,CAAA,EAAcQ,CAAA;YAC3D,MAAMD,CAAA,GAAW,CAACC,CAAA,CAAY6I,KAAA,EAAO7I,CAAA,CAAY8I,MAAA;cAC3CrI,CAAA,GAAiB,CAACV,CAAA,CAAS,IAAIA,CAAA,CAAS;cACxC8C,CAAA,IAAO,GAAArC,CAAA,CAAA4I,OAAA,EAAQ,KAAKb,OAAA,CAAQlB,SAAA,CAAUnF,OAAA;cAOtCe,CAAA,GALgB,QAAQ1D,CAAA,yDAE1BkB,CAAA,CAAe,OAAOA,CAAA,CAAe,6BAC9BoC,CAAA,CAAKoH,SAAA,IAAazK,CAAA;YAG7B,OAAO,IAAIS,CAAA,CAAAqI,cAAA,CAAerF,CAAA,EAAQ,CAAC,8BACrC;UAAA;UAKU8I,mBAAmBxM,CAAA,EAAkBC,CAAA,EAAcQ,CAAA;YAC3D,MAAMS,CAAA,GAAQT,CAAA,CAAY4I,aAAA;cACpB/F,CAAA,GAAW,CAAC7C,CAAA,CAAY6I,KAAA,EAAO7I,CAAA,CAAY8I,MAAA;cAC3C7F,CAAA,IAAO,GAAAzC,CAAA,CAAA4I,OAAA,EAAQ,KAAKb,OAAA,CAAQlB,SAAA,CAAUnF,OAAA;cACtC8H,CAAA,GAAUnH,CAAA,CAAS;cACnB+H,CAAA,GAAU/H,CAAA,CAAS;YAEzB,IAAgB,QAAZA,CAAA,IAAoB9C,CAAA,CAAA+J,SAAA,CAAUC,WAAA,CAAYtJ,CAAA,EAAOoC,CAAA,GAAW;cAC9D,MAAM7C,CAAA,GAAgB,QAAQT,CAAA,4EACiBqL,CAAA,OAAcZ,CAAA,wBAClD/G,CAAA,CAAKgH,SAAA,IAAazK,CAAA;cAG7B,OAAO,IAAIS,CAAA,CAAAqI,cAAA,CAAetI,CAAA,C;;YAE5B,MAAM6K,CAAA,GAAiBhI,CAAA;cACjBiI,CAAA,GAAevJ,IAAA,CAAKE,IAAA,CAAKhB,CAAA,CAAM,KAAK;cAKpCqF,CAAA,GAJgB,QAAQvG,CAAA,wDACDsL,CAAA,CAAe,OAAOA,CAAA,CAAe,OAAOC,CAAA,8BAC9D7H,CAAA,CAAKgH,SAAA,IAAazK,CAAA;YAG7B,OAAO,IAAIS,CAAA,CAAAqI,cAAA,CAAexC,CAAA,EAAQ,CAAC,8BACrC;UAAA;UAKUkG,mBAAmBzM,CAAA,EAAkBC,CAAA,EAAcQ,CAAA;YAC3D,MAAMD,CAAA,GAAQC,CAAA,CAAY4I,aAAA;cACpBnI,CAAA,GAAW,CAACT,CAAA,CAAY6I,KAAA,EAAO7I,CAAA,CAAY8I,MAAA;cAC3C7F,CAAA,GAAiB,CAACxC,CAAA,CAAS,IAAIA,CAAA,CAAS;cACxCuJ,CAAA,IAAO,GAAAxJ,CAAA,CAAA4I,OAAA,EAAQ,KAAKb,OAAA,CAAQlB,SAAA,CAAUnF,OAAA;YAE5C,IAAiB,MAAbnC,CAAA,CAAM,IAAU;cAClB,MAAMS,CAAA,GAAgBT,CAAA,CAAM0M,KAAA,CAAM;gBAC5BhM,CAAA,GAAW,CAAC,GAAG;gBACfwC,CAAA,IAAgB,GAAAJ,CAAA,CAAA6J,iBAAA,EAAkB3M,CAAA,EAAOS,CAAA;gBACzCwJ,CAAA,GAAS,CAAC,KAAK,OAAO;gBAEtBY,CAAA,GAAgC+B,IAAA,CAAKC,KAAA,CAAMD,IAAA,CAAKE,SAAA,CAAU7M,CAAA;cAChE4K,CAAA,CAAehC,aAAA,GAAgB3F,CAAA;cAC/B,MAAM4H,CAAA,GAAiB,KAAKN,yBAAA,CAA0BhL,CAAA,EAAUC,CAAA,EAAMoL,CAAA;gBAKhEE,CAAA,GAJgB,GAAGD,CAAA,CAAeiC,WAAA,gBACjCvN,CAAA,+CACIA,CAAA,KAAY,GAAAsD,CAAA,CAAAkK,iBAAA,EAAkB/C,CAAA,EAAQvJ,CAAA;cAGjD,OAAO,IAAIR,CAAA,CAAAqI,cAAA,CAAewC,CAAA,EAAQD,CAAA,CAAemC,YAAA,C;;YAEnD,MAAMpC,CAAA,GAAU3H,CAAA,CAAe;cACzB4H,CAAA,GAAU5H,CAAA,CAAe;cAEzB6H,CAAA,GAAevJ,IAAA,CAAKE,IAAA,CAAK1B,CAAA,CAAM,KAAK;cAOpC+F,CAAA,GAJgB,QAAQvG,CAAA,yEAExBsL,CAAA,KAAYD,CAAA,KAJIE,CAAA,GAAevJ,IAAA,CAAKE,IAAA,CAAK1B,CAAA,CAAM,KAAK,OAIV+K,CAAA,iCACrCd,CAAA,CAAKC,SAAA,IAAazK,CAAA;YAE7B,OAAO,IAAIS,CAAA,CAAAqI,cAAA,CAAexC,CAAA,EAAQ,CAAC,8BACrC;UAAA;UAIUmG,mBAAmB1M,CAAA,EAAkBC,CAAA,EAAcQ,CAAA;YAC3D,MAAMD,CAAA,GAAQC,CAAA,CAAY4I,aAAA;cACpBnI,CAAA,GAAOV,CAAA,CAAMsB,MAAA;cACbwB,CAAA,GAAW,CAAC7C,CAAA,CAAY6I,KAAA,EAAO7I,CAAA,CAAY8I,MAAA;cAC3C7F,CAAA,IAAO,GAAAzC,CAAA,CAAA4I,OAAA,EAAQ,KAAKb,OAAA,CAAQlB,SAAA,CAAUnF,OAAA;cAEtC8H,CAAA,GAAiB,CAACnH,CAAA,CAAS,IAAIA,CAAA,CAAS;cACxC+H,CAAA,GAAUZ,CAAA,CAAe;cACzBa,CAAA,GAAUb,CAAA,CAAe;cACzBc,CAAA,GAAevJ,IAAA,CAAKE,IAAA,CAAK1B,CAAA,CAAMU,CAAA,GAAO,KAAK;YACjD,IAAIqF,CAAA,GAAgBgF,CAAA,GAAevJ,IAAA,CAAKE,IAAA,CAAK1B,CAAA,CAAMU,CAAA,GAAO,KAAK;cAC3DwK,CAAA,GAAS;cACTlF,CAAA,GAAQ,OAAOD,CAAA,kBAA+BgF,CAAA;YAClD,KAAK,IAAIvL,CAAA,GAAI,GAAGA,CAAA,GAAIkB,CAAA,GAAO,GAAGlB,CAAA,IAC5B0L,CAAA,GAAS,QAAQ1L,CAAA,OAAQ0L,CAAA,EACzBnF,CAAA,IAAiB/F,CAAA,CAAMU,CAAA,GAAOlB,CAAA,GAAI,IAClCwG,CAAA,GAAQ,IAAIxG,CAAA,MAAOuG,CAAA,QAAqBC,CAAA;YAE1C,MAOMoF,CAAA,GAPgB,QAAQ5L,CAAA,IAAY0L,CAAA,0BAC1BlF,CAAA,+BACO8E,CAAA,sCACOA,CAAA,yDACmBA,CAAA,KAAYD,CAAA,oBAClD3H,CAAA,CAAKgH,SAAA,IAAazK,CAAA;YAG7B,OAAO,IAAIS,CAAA,CAAAqI,cAAA,CAAe6C,CAAA,CAC5B;UAAA;UAKUe,yBAAyB3M,CAAA,EAAkBC,CAAA,EAAcQ,CAAA;YACjE,OAAOD,CAAA,EAASS,CAAA,IAAW,CAACR,CAAA,CAAY6I,KAAA,EAAO7I,CAAA,CAAY8I,MAAA;YAC3D,IAAgB,MAAZ/I,CAAA,IAA6B,MAAZS,CAAA,EAAe;cAClC,MAAMR,CAAA,GAAS,qBACHT,CAAA,0CACiBC,CAAA;cAG7B,OAAO,IAAIS,CAAA,CAAAqI,cAAA,CAAetI,CAAA,EAAQ,CAAC,6B;;YAGrC,MAAMS,CAAA,GAAS,mBACHlB,CAAA,8BACOC,CAAA,gCAAoCO,CAAA,KAAYS,CAAA,sCACtCT,CAAA,KAAYS,CAAA,YAAmBhB,CAAA,sCAC/BA,CAAA;YAG7B,OAAO,IAAIS,CAAA,CAAAqI,cAAA,CACP7H,CAAA,EAAQ,CAAC,0BAA0B,6BAA6B,8BACtE;UAAA;UAKU0L,qBAAqB5M,CAAA,EAAkBC,CAAA,EAAcQ,CAAA;YAC7D,MAAMD,CAAA,GAAQC,CAAA,CAAY6I,KAAA;cACpBrI,CAAA,GAAQR,CAAA,CAAY8I,MAAA;YAE1B,IAAc,MAAVtI,CAAA,IAAyB,MAAVT,CAAA,EAAa;cAC9B,MAAMC,CAAA,GAAS,mBACLT,CAAA,iDACiBC,CAAA;cAG3B,OAAO,IAAIS,CAAA,CAAAqI,cAAA,CAAetI,CAAA,EAAQ,CAAC,6B;;YAGrC,IAAc,MAAVQ,CAAA,EAAa;cACf,MAAMR,CAAA,GAAS,qBACHT,CAAA,oEACkCQ,CAAA,+CACjBP,CAAA;cAG7B,OAAO,IAAIS,CAAA,CAAAqI,cAAA,CAAetI,CAAA,EAAQ,CAAC,6B;;YAErC,IAAc,MAAVD,CAAA,EAAa;cACf,MAAMC,CAAA,GAAS,qBACHT,CAAA,yEACuCiB,CAAA,0CACtBhB,CAAA;cAG7B,OAAO,IAAIS,CAAA,CAAAqI,cAAA,CAAetI,CAAA,EAAQ,CAAC,6B;;YAErC,MAAMS,CAAA,GAAS,mBACHlB,CAAA,iDACiBQ,CAAA,KAAUS,CAAA,6CACVhB,CAAA;YAG7B,OAAO,IAAIS,CAAA,CAAAqI,cAAA,CAAe7H,CAAA,EAAQ,CAAC,0BAA0B,6BAC/D;UAAA;UAMU2L,qBAAqB7M,CAAA,EAAkBC,CAAA,EAAcQ,CAAA;YAC7D,MAAMQ,CAAA,GAAQR,CAAA,CAAY4I,aAAA;cAGpB3F,CAAA,GAAW,CAACjD,CAAA,CAAY8I,MAAA,EAAQ9I,CAAA,CAAY6I,KAAA;YAElD,IAAgB,QAAZ5F,CAAA,IAAoBlD,CAAA,CAAA+J,SAAA,CAAUC,WAAA,CAAYvJ,CAAA,EAAOyC,CAAA,GAAW;cAC9D,MAEMjD,CAAA,GAAS,qBACHT,CAAA,gFAHI0D,CAAA,CAAS,SACTA,CAAA,CAAS,4CAIIzD,CAAA;cAG7B,OAAO,IAAIS,CAAA,CAAAqI,cAAA,CAAetI,CAAA,EAAQ,CAAC,6B;;YAGrC;gBAAMiN,QAAA,EAACjD,CAAA;gBAAQkD,QAAA,EAAEtC;cAAA,KAAY,GAAAnK,CAAA,CAAA0M,YAAA,EAAa3M,CAAA;cACpCqK,CAAA,GAAgBb,CAAA;YACtB,IAAIa,CAAA,CAAcxJ,MAAA,GAASb,CAAA,CAAMa,MAAA,EAAQ;cACvC,MAAMtB,CAAA,IAAgB,GAAA8C,CAAA,CAAA6J,iBAAA,EAAkBlM,CAAA,EAAOqK,CAAA;gBAEzCpK,CAAA,GAAgCkM,IAAA,CAAKC,KAAA,CAAMD,IAAA,CAAKE,SAAA,CAAU7M,CAAA;cAChES,CAAA,CAAemI,aAAA,GAAgB7I,CAAA;cAE/B,MAAMkD,CAAA,GAAS,CAAC,OAAO;gBACjB+G,CAAA,GAAS,eACT,KAAKQ,2BAAA,CAA4BjL,CAAA,EAAUC,CAAA,EAAMiB,CAAA,EAAgBqM,WAAA,qBAC3DvN,CAAA,4CACGA,CAAA,KAAY,GAAAsD,CAAA,CAAAkK,iBAAA,EAAkB9J,CAAA,EAAQ2H,CAAA;cAGrD,OAAO,IAAI3K,CAAA,CAAAqI,cAAA,CAAe0B,CAAA,EAAQ,CAAC,6B;;YAGrC,MAAMc,CAAA,GAAU7H,CAAA,CAAS;cACnB6C,CAAA,GAAU7C,CAAA,CAAS;YACzB,IAAgB,MAAZ6C,CAAA,EAAe;cACjB,MAAM9F,CAAA,GAAS,qBACHT,CAAA,gDACOC,CAAA,gCAAoCsL,CAAA,KAAYhF,CAAA,2DACnBtG,CAAA,WAAegB,CAAA,CAAM,gEACzBsK,CAAA,0CACftL,CAAA;cAG7B,OAAO,IAAIS,CAAA,CAAAqI,cAAA,CAAetI,CAAA,EAAQ,CAAC,6BAA6B,8B;;YAGlE,IAAgB,MAAZ8K,CAAA,EAAe;cACjB,MAAM9K,CAAA,GAAS,qBACHT,CAAA,gDACOC,CAAA,gCAAoCsL,CAAA,KAAYhF,CAAA,2DACnBtG,CAAA,WAAegB,CAAA,CAAM,2DAC9BsF,CAAA,+CACVtG,CAAA;cAG7B,OAAO,IAAIS,CAAA,CAAAqI,cAAA,CAAetI,CAAA,EAAQ,CAAC,6BAA6B,8B;;YAGlE,MAAMiL,CAAA,GAAS,mBACH1L,CAAA,qDACciB,CAAA,CAAM,6CACHsK,CAAA,KAAYhF,CAAA,6CACZtG,CAAA;YAG7B,OAAO,IAAIS,CAAA,CAAAqI,cAAA,CACP2C,CAAA,EAAQ,CAAC,0BAA0B,6BAA6B,8BACtE;UAAA;UAMUoB,qBAAqB9M,CAAA,EAAkBC,CAAA,EAAcQ,CAAA;YAC7D,MAAMD,CAAA,GAAQC,CAAA,CAAY4I,aAAA;cACpBpI,CAAA,GAAUT,CAAA,CAAM,KAAKA,CAAA,CAAM;cAC3BkD,CAAA,GAAUlD,CAAA,CAAM;cAAA;gBAEhBkN,QAAA,EAACjD,CAAA;gBAAQkD,QAAA,EAAEtC;cAAA,KAAY,GAAAnK,CAAA,CAAA0M,YAAA,EAAapN,CAAA;cACpC8K,CAAA,GAAgBb,CAAA;YACtB,IAAIa,CAAA,CAAcxJ,MAAA,GAAStB,CAAA,CAAMsB,MAAA,EAAQ;cACvC,MAAMb,CAAA,IAAgB,GAAAqC,CAAA,CAAA6J,iBAAA,EAAkB3M,CAAA,EAAO8K,CAAA;gBACzCpK,CAAA,GAAS,CAAC,SAAS,OAAO;gBAE1BwC,CAAA,GAAgC0J,IAAA,CAAKC,KAAA,CAAMD,IAAA,CAAKE,SAAA,CAAU7M,CAAA;cAChEiD,CAAA,CAAe2F,aAAA,GAAgBpI,CAAA;cAC/B,MAAMwJ,CAAA,GAAU,KAAKQ,2BAAA,CAA4BjL,CAAA,EAAUC,CAAA,EAAMyD,CAAA;gBAE3D6H,CAAA,GAAUF,CAAA,CAASwC,OAAA;gBACnBtH,CAAA,GAAS,eACTkE,CAAA,CAAQ8C,WAAA,qBACFvN,CAAA,uDACGA,CAAA,KAAY,GAAAsD,CAAA,CAAAkK,iBAAA,EAAkBtM,CAAA,EAAQqK,CAAA;cAGrD,OAAO,IAAI7K,CAAA,CAAAqI,cAAA,CAAexC,CAAA,EAAQkE,CAAA,CAAQgD,YAAA,C;;YAG5C,MAEMlC,CAAA,GAAS,qBACDvL,CAAA,qJAEgBiB,CAAA,YAAmByC,CAAA,6CALjCjD,CAAA,CAAY6I,KAAA,KACZ7I,CAAA,CAAY8I,MAAA,+CAMGtJ,CAAA;YAG/B,OAAO,IAAIS,CAAA,CAAAqI,cAAA,CACPwC,CAAA,EAAQ,CAAC,0BAA0B,6BAA6B,8BACtE;UAAA;UAMUwB,qBAAqB/M,CAAA,EAAkBC,CAAA,EAAcQ,CAAA;YAC7D,MAAMD,CAAA,GAAQC,CAAA,CAAY4I,aAAA;cACpBpI,CAAA,GAAUT,CAAA,CAAM;cAChBU,CAAA,GAAUV,CAAA,CAAM,KAAKS,CAAA;cAyBrBqC,CAAA,GAAS,mBACHtD,CAAA,4EAzBIQ,CAAA,CAAM,KAAKU,CAAA,YA0BkBA,CAAA,8BACxBD,CAAA,6CALLR,CAAA,CAAY6I,KAAA,KACZ7I,CAAA,CAAY8I,MAAA,6CAMCtJ,CAAA;YAG7B,OAAO,IAAIS,CAAA,CAAAqI,cAAA,CAAezF,CAAA,EAAQ,CAAC,0BAA0B,6BAC/D;UAAA;UAKU0J,qBAAqBhN,CAAA,EAAkBC,CAAA,EAAcQ,CAAA;YAC7D,MAAMD,CAAA,GAAQC,CAAA,CAAY4I,aAAA;cACpBpI,CAAA,GAAUT,CAAA,CAAM;cAChBkD,CAAA,GAAUlD,CAAA,CAAM,KAAKS,CAAA;cACrBwJ,CAAA,GAAUjK,CAAA,CAAM,KAAKkD,CAAA;cACrB2H,CAAA,GAAU7K,CAAA,CAAM,KAAKiK,CAAA;cAAA;gBAErBiD,QAAA,EAACpC,CAAA;gBAAQqC,QAAA,EAAEpC;cAAA,KAAY,GAAArK,CAAA,CAAA0M,YAAA,EAAapN,CAAA;YAC1C,IAAI8K,CAAA,CAASxJ,MAAA,GAAStB,CAAA,CAAMsB,MAAA,EAAQ;cAClC,MAAMb,CAAA,IAAgB,GAAAqC,CAAA,CAAA6J,iBAAA,EAAkB3M,CAAA,EAAO8K,CAAA;gBACzCpK,CAAA,GAAS,CAAC,OAAO,OAAO,SAAS,UAAU;gBAE3CwC,CAAA,GAAgC0J,IAAA,CAAKC,KAAA,CAAMD,IAAA,CAAKE,SAAA,CAAU7M,CAAA;cAChEiD,CAAA,CAAe2F,aAAA,GAAgBpI,CAAA;cAE/B,MAAMwJ,CAAA,GAAS,eACT,KAAKQ,2BAAA,CAA4BjL,CAAA,EAAUC,CAAA,EAAMyD,CAAA,EAAgB6J,WAAA,qBAC3DvN,CAAA,+EACGA,CAAA,KAAY,GAAAsD,CAAA,CAAAkK,iBAAA,EAAkBtM,CAAA,EAAQqK,CAAA;cAGrD,OAAO,IAAI7K,CAAA,CAAAqI,cAAA,CAAe0B,CAAA,EAAQ,CAAC,6BAA6B,0B;;YAGlE,MAEMlE,CAAA,GAAS,mBACHvG,CAAA,wFACcqL,CAAA,YAAmBZ,CAAA,cAAqB/G,CAAA,0BACjDzC,CAAA,8CALDR,CAAA,CAAY6I,KAAA,KACZ7I,CAAA,CAAY8I,MAAA,6CAMCtJ,CAAA;YAG7B,OAAO,IAAIS,CAAA,CAAAqI,cAAA,CAAexC,CAAA,EAAQ,CAAC,6BAA6B,0BAClE;UAAA;UAKU0G,qBAAqBjN,CAAA,EAAkBC,CAAA,EAAcQ,CAAA;YAC7D,MAAMD,CAAA,GAAQC,CAAA,CAAY4I,aAAA;cACpBpI,CAAA,GAAUT,CAAA,CAAM;cAChBkD,CAAA,GAAUlD,CAAA,CAAM,KAAKS,CAAA;cACrBwJ,CAAA,GAAUjK,CAAA,CAAM,KAAKkD,CAAA;cACrB2H,CAAA,GAAU7K,CAAA,CAAM,KAAKiK,CAAA;cACrBa,CAAA,GAAU9K,CAAA,CAAM,KAAK6K,CAAA;cAAA;gBAErBqC,QAAA,EAACnC,CAAA;gBAAQoC,QAAA,EAAEpH;cAAA,KAAY,GAAArF,CAAA,CAAA0M,YAAA,EAAapN,CAAA;YAC1C,IAAI+K,CAAA,CAASzJ,MAAA,GAAStB,CAAA,CAAMsB,MAAA,EAAQ;cAClC,MAAMb,CAAA,IAAgB,GAAAqC,CAAA,CAAA6J,iBAAA,EAAkB3M,CAAA,EAAO+K,CAAA;gBACzCrK,CAAA,GAAS,CAAC,OAAO,OAAO,SAAS,UAAU,UAAU;gBAErDwC,CAAA,GAAgC0J,IAAA,CAAKC,KAAA,CAAMD,IAAA,CAAKE,SAAA,CAAU7M,CAAA;cAChEiD,CAAA,CAAe2F,aAAA,GAAgBpI,CAAA;cAE/B,MAAMwJ,CAAA,GAAS,iBACP,KAAKQ,2BAAA,CAA4BjL,CAAA,EAAUC,CAAA,EAAMyD,CAAA,EAAgB6J,WAAA,uBAC3DvN,CAAA,4GAEGA,CAAA,KAAY,GAAAsD,CAAA,CAAAkK,iBAAA,EAAkBtM,CAAA,EAAQqF,CAAA;cAGvD,OAAO,IAAI7F,CAAA,CAAAqI,cAAA,CAAe0B,CAAA,EAAQ,CAAC,6BAA6B,0B;;YAGlE,MAEMiB,CAAA,GAAS,qBACD1L,CAAA,mHAEcsL,CAAA,YAAmBD,CAAA,cAAqBZ,CAAA,4BACjD/G,CAAA,eAAsBzC,CAAA,gDANzBR,CAAA,CAAY6I,KAAA,KACZ7I,CAAA,CAAY8I,MAAA,+CAOGtJ,CAAA;YAG/B,OAAO,IAAIS,CAAA,CAAAqI,cAAA,CACP2C,CAAA,EAAQ,CAAC,0BAA0B,6BAA6B,8BACtE;UAAA;UAQUjD,MAAA;YACR,MAAMzI,CAAA,GAAS,KAAKgJ,OAAA,CAAQC,mBAAA;cACtBhJ,CAAA,GAAOD,CAAA,CAAO8N,KAAA,CAAMhM,MAAA;cACpBrB,CAAA,GAAUT,CAAA,CAAO+N,OAAA;cACjBvN,CAAA,GAASR,CAAA,CAAOsJ,KAAA;cAChBrI,CAAA,GAASjB,CAAA,CAAOuJ,MAAA;cAEhBrI,CAAA,GAAe;YACrB,KAAK,IAAIlB,CAAA,GAAI,GAAGA,CAAA,GAAIC,CAAA,GAAO,KAAKD,CAAA,EAC9BkB,CAAA,CAAa8F,IAAA,CAAK,eACZhH,CAAA,gBAAiBS,CAAA,CAAQT,CAAA,OAC/BkB,CAAA,CAAa8F,IAAA,CAAK,yBACFhH,CAAA,OAAQS,CAAA,CAAQT,CAAA;YAElCkB,CAAA,CAAa8F,IAAA,CAAK,eACV/G,CAAA,GAAO;YACf,MAAMqD,CAAA,GAAO,gDAC4BrD,CAAA,wDACIO,CAAA,KAAWS,CAAA,eAClDC,CAAA,CAAakC,IAAA,CAAK,wDAEanD,CAAA,iBAC/BiB,CAAA,CAAakC,IAAA,CAAK;YAGxB,OAAO;cAACqF,KAAA,EAAO,IAAI/H,CAAA,CAAAqI,cAAA,CAAezF,CAAA,EAAM,CAAC;YAAA,CAC3C;UAAA;UAOUoF,UAAA;YACR,MAAM1I,CAAA,GAA2C,CAAC;YAclD,OAbA,KAAKgJ,OAAA,CAAQ2B,WAAA,CAAYC,UAAA,CAAWC,OAAA,CAAQ,CAAC5K,CAAA,EAAMQ,CAAA;cACjD,MAAMD,CAAA,GAAS,KAAKwI,OAAA,CAAQ8B,mBAAA,CAAoBrK,CAAA;gBAE1CQ,CAAA,IADQT,CAAA,CAAO6I,aAAA,CAAcvH,MAAA,GAAS,IAAItB,CAAA,CAAO6I,aAAA,GAAgB7I,CAAA,CAAOsN,KAAA,EAC3DhM,MAAA;cACnB,IAAIZ,CAAA,GAAW,IAAIjB,CAAA;cACnBD,CAAA,CAAOkB,CAAA,IAAY,IAAIR,CAAA,CAAAqI,cAAA,CACnB,KAAKiF,kBAAA,CAAmB/N,CAAA,EAAMgB,CAAA,EAAMT,CAAA,CAAO8I,KAAA,EAAO9I,CAAA,CAAO+I,MAAA,GAAQ,IACjE,CAAC,6BAA6BrI,CAAA,IAAY,8BAA8B,+BAC5EA,CAAA,IAAsB,MACtBlB,CAAA,CAAOkB,CAAA,IAAY,IAAIR,CAAA,CAAAqI,cAAA,CACnB,KAAKiF,kBAAA,CAAmB/N,CAAA,EAAMgB,CAAA,EAAMT,CAAA,CAAO8I,KAAA,EAAO9I,CAAA,CAAO+I,MAAA,GAAQ,IACjE,CAAC,6BAA6BrI,CAAA,IAAY,8BAA8B,6BAA6B;YAAA,IAEpGlB,CACT;UAAA;UAQUgO,mBAAmBhO,CAAA,EAAiBC,CAAA,EAAcQ,CAAA,EAAeD,CAAA,EAAgBE,CAAA;YAEzF,IAAIQ,CAAA,GAAO,IAAIlB,CAAA;YAKf,OAJIU,CAAA,KACFQ,CAAA,IAAc,OAGT,mBACKA,CAAA,UAAcjB,CAAA,+CACUiB,CAAA,wDACST,CAAA,KAAUD,CAAA,gDAJ1C,GAAAS,CAAA,CAAA4I,OAAA,EAAQ,KAAKb,OAAA,CAAQlB,SAAA,CAAUnF,OAAA,EAKD+H,SAAA,IAAa1K,CAAA,2DAI1D;UAAA;UASUiO,mBAAmBjO,CAAA,EAAiBC,CAAA,EAAcQ,CAAA,EAAeD,CAAA,EAAgBE,CAAA;YAEzF,IAAIQ,CAAA,GAAO,IAAIlB,CAAA;YAKf,OAJIU,CAAA,KACFQ,CAAA,IAAc,OAGT,kBACIA,CAAA,UAAcjB,CAAA,gDACYD,CAAA,wDACQS,CAAA,KAAUD,CAAA,yBAJ1C,GAAAS,CAAA,CAAA4I,OAAA,EAAQ,KAAKb,OAAA,CAAQlB,SAAA,CAAUnF,OAAA,EAKxB+H,SAAA,IAAa1K,CAAA,iCAGnC;UAAA;QAAA;QAzyCFC,CAAA,CAAAiO,aAAA,GAAAxK,C;;;;;QCRA,IAAYjD,CAAA;;;4IAAAA,CAAA,GAAAR,CAAA,CAAAkO,YAAA,KAAAlO,CAAA,CAAAkO,YAAA,GAAY,KACtB1N,CAAA,CAAA2N,UAAA,sBACA3N,CAAA,CAAAA,CAAA,CAAA4N,UAAA,sBAaFpO,CAAA,CAAAqO,WAAA;UACE1L,YACW5C,CAAA,EAAgCC,CAAA,EAAiCQ,CAAA,EACjED,CAAA;YADA,KAAAsH,SAAA,GAAA9H,CAAA,EAAgC,KAAA2K,WAAA,GAAA1K,CAAA,EAAiC,KAAA6K,mBAAA,GAAArK,CAAA,EACjE,KAAAwI,mBAAA,GAAAzI,CAAqC;UAAA;QAAA,GAElDP,CAAA,CAAAoI,OAAA;UACEzF,YAAmB5C,CAAA;YAAA,KAAAgJ,OAAA,GAAAhJ,CAAuB;UAAA;QAAA,GAM5CC,CAAA,CAAA8I,cAAA;UACEnG,YAAmB5C,CAAA,EAA4BC,CAAA;YAA5B,KAAAsN,WAAA,GAAAvN,CAAA,EAA4B,KAAAyN,YAAA,GAAAxN,CAA0B;UAAA;QAAA,GAK3EA,CAAA,CAAAsO,kBAAA;UAGE3L,YAAmB5C,CAAA,EAAcC,CAAA,EAAsBQ,CAAA;YAApC,KAAAuD,IAAA,GAAAhE,CAAA,EAEf,KAAKyN,YAAA,GADHhN,CAAA,IAGkB,IAGlBR,CAAA,KACF,KAAKsN,WAAA,GAActN,CAAA,CAEvB;UAAA;UACAuO,cAAcxO,CAAA;YACRA,CAAA,IACF,KAAKyN,YAAA,CAAazG,IAAA,CAAKhH,CAAA,CAE3B;UAAA;QAAA,GAIFC,CAAA,CAAAwO,2BAAA;UACE,OAAAC,mBAA0B1O,CAAA;YACxB,KAAKA,CAAA,IAA0B,MAAjBA,CAAA,CAAM8B,MAAA,EAClB,OAAO;YAGT,IAAqB,MAAjB9B,CAAA,CAAM8B,MAAA,EACR,OAAO9B,CAAA;YAGT,MAAMC,CAAA,GAAa,IAAI0O,GAAA;cACjBlO,CAAA,GAAmB,IAAIkO,GAAA;cACvBnO,CAAA,GAAS,IAAIwF,KAAA;YAGnB,OADA,KAAK4I,kBAAA,CAAmB5O,CAAA,EAAOC,CAAA,EAAYQ,CAAA,EAAkBD,CAAA,GACtDA,CACT;UAAA;UAEQ,OAAAoO,mBACJ5O,CAAA,EAAkCC,CAAA,EAAyBQ,CAAA,EAC3DD,CAAA;YACF,KAAK,IAAIE,CAAA,GAAI,GAAGA,CAAA,GAAIV,CAAA,CAAW8B,MAAA,IAAUpB,CAAA,EACvC,KAAKmO,WAAA,CAAY7O,CAAA,CAAWU,CAAA,GAAIT,CAAA,EAAYQ,CAAA,EAAkBD,CAAA,CAElE;UAAA;UAEQ,OAAAqO,YACJ7O,CAAA,EAA0BC,CAAA,EAAyBQ,CAAA,EAA+BD,CAAA;YAEpF,KAAKR,CAAA,IAAQS,CAAA,CAAiBqO,GAAA,CAAI9O,CAAA,CAAKgE,IAAA,GACrC;YAIF,IAAI/D,CAAA,CAAW6O,GAAA,CAAI9O,CAAA,CAAKgE,IAAA,GACtB,MAAM,IAAIK,KAAA,CAAM;YAIlBpE,CAAA,CAAW8O,GAAA,CAAI/O,CAAA,CAAKgE,IAAA;YAGpB,MAAMtD,CAAA,GAAeV,CAAA,CAAKyN,YAAA;YAC1B,IAAI/M,CAAA,IAAgBA,CAAA,CAAaoB,MAAA,GAAS,GACxC,KAAK,IAAI9B,CAAA,GAAI,GAAGA,CAAA,GAAIU,CAAA,CAAaoB,MAAA,IAAU9B,CAAA,EACzC,KAAK6O,WAAA,CAAYnO,CAAA,CAAaV,CAAA,GAAIC,CAAA,EAAYQ,CAAA,EAAkBD,CAAA;YAKpEA,CAAA,CAAOwG,IAAA,CAAKhH,CAAA,GAGZS,CAAA,CAAiBsO,GAAA,CAAI/O,CAAA,CAAKgE,IAAA,GAG1B/D,CAAA,CAAWqE,MAAA,CAAOtE,CAAA,CAAKgE,IAAA,CACzB;UAAA;QAAA,C;;;;;;;;QCpHF,MAAAxD,CAAA,GAAAC,CAAA;QAMA,MAAaC,CAAA,SAAwBF,CAAA,CAAA6H,OAAA;UACnCzF,YAAY5C,CAAA;YACV,MAAMA,CAAA,CACR;UAAA;UACAsI,aAAA;YACE,OAAOzF,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAW,KAAKkM,aAAA,KAAoB,KAAKC,aAAA,GAC3C;UAAA;UACAnG,eAAA;YACE,OAAO,CAAC,CACV;UAAA;UACUkG,cAAA;YACR,OAAO;cACLE,MAAA,EAAQ,IAAI1O,CAAA,CAAAuI,cAAA,CAAe;YAAA,CAK/B;UAAA;UACUkG,cAAA;YACR,OAAO;cACLE,MAAA,EAAQ,IAAI3O,CAAA,CAAAuI,cAAA,CAAe;YAAA,CAK/B;UAAA;UAKUqG,YAAA;YACR,MAAMpP,CAAA,GAAaU,CAAA,CAAgB2O,cAAA,KAAmB,yBAAyB;YAC/E,OAAO;cACLH,MAAA,EAAQ,IAAI1O,CAAA,CAAAuI,cAAA,CAAe,kmBAYvB/I,CAAA;YAAA,CAMR;UAAA;UAKUsP,YAAA;YACR,MAAMtP,CAAA,GAAaU,CAAA,CAAgB2O,cAAA,KAAmB,yBAAyB;YAC/E,OAAO;cACLF,MAAA,EAAQ,IAAI3O,CAAA,CAAAuI,cAAA,CAAe,uJAGrB/I,CAAA;YAAA,CASV;UAAA;UAKA,OAAAqP,eAAA;YACE,MAAMrP,CAAA,GAAI,IAAIuP,WAAA,CAAY;cACpBtP,CAAA,GAAI,IAAIuP,WAAA,CAAYxP,CAAA;cACpBS,CAAA,GAAI,IAAIgP,UAAA,CAAWzP,CAAA;YAEzB,IADAC,CAAA,CAAE,KAAK,YACM,QAATQ,CAAA,CAAE,IACJ,QAAO;YAET,IAAa,QAATA,CAAA,CAAE,IACJ,QAAO;YAET,MAAM,IAAI4D,KAAA,CAAM,qBAClB;UAAA;QAAA;QAxFFpE,CAAA,CAAAyP,eAAA,GAAAhP,C;;;;;;;;QCNA,MAAAF,CAAA,GAAAC,CAAA;UACAC,CAAA,GAAAD,CAAA;QAOA,MAAaQ,CAAA,SAAyBT,CAAA,CAAA6H,OAAA;UACpCzF,YAAY5C,CAAA;YACV,MAAMA,CAAA,CACR;UAAA;UACAsI,aAAA;YACE,OAAOzF,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAW,KAAK6M,YAAA,KAAmB,KAAKC,eAAA,GAC1C;UAAA;UACA9G,eAAA;YACE,OAAO,CAAC,CACV;UAAA;UACU6G,aAAA;YACR,MAAM3P,CAAA,IAAO,GAAAU,CAAA,CAAAmJ,OAAA,EAAQ,KAAKb,OAAA,CAAQlB,SAAA,CAAUnF,OAAA;YAC5C,OAAO;cACLgN,YAAA,EAAc,IAAInP,CAAA,CAAAuI,cAAA,CACd,2DAEI/I,CAAA,CAAK8J,MAAA,0CAGT,CAAC;YAAA,CAET;UAAA;UACU8F,gBAAA;YACR,OAAO;cACLA,eAAA,EAAiB,IAAIpP,CAAA,CAAAuI,cAAA,CACjB,yGAKA,CAAC;YAAA,CAET;UAAA;QAAA;QAhCF9I,CAAA,CAAA4P,gBAAA,GAAA5O,C;;;;;;;;QCRA,MAAMR,CAAA,GAAwB;QAK9BR,CAAA,CAAA6P,cAAA,aAA+B9P,CAAA;UAC7B,MAAMC,CAAA,GAAiG,CAAC;UACxG,IAAIO,CAAA;UACJ,OAAwD,UAAhDA,CAAA,GAAQC,CAAA,CAAsBsP,IAAA,CAAK/P,CAAA,KAAmB;YAC5D,MAAMA,CAAA,GAASQ,CAAA,CAAM,GACDwP,KAAA,CAAM,KACN7M,GAAA,CAAInD,CAAA;cACH,MAAMC,CAAA,GAASD,CAAA,CAAEiQ,IAAA,GAAOD,KAAA,CAAM;cAC9B,OAAI/P,CAAA,IAA4B,MAAlBA,CAAA,CAAO6B,MAAA,GACZ;gBAACkD,IAAA,EAAM/E,CAAA,CAAO;gBAAI+D,IAAA,EAAM/D,CAAA,CAAO;cAAA,IAEjC,IAAI;YAAA,GAEZiQ,MAAA,CAAOlQ,CAAA,IAAW,SAANA,CAAA;YAChCC,CAAA,CAAWO,CAAA,CAAM,MAAM;cAAC2P,MAAA,EAAAnQ,CAAA;cAAQoQ,IAAA,EAAM5P,CAAA,CAAM;YAAA,C;;UAE9C,KAAK,MAAMC,CAAA,IAAQR,CAAA,EAAY;YAC7B,MAAMS,CAAA,GArBc,6DAqBgB2P,OAAA,CAAQ,YAAY5P,CAAA;cAClDQ,CAAA,GAAQ,IAAIqP,MAAA,CAAO5P,CAAA,EAAa;YACtC,OAAwC,UAAhCF,CAAA,GAAQS,CAAA,CAAM8O,IAAA,CAAK/P,CAAA,KAAmB;cAC5C,MAAMU,CAAA,GAAOF,CAAA,CAAM;gBACbS,CAAA,GAAWT,CAAA,CAAM;gBACjBU,CAAA,GAASV,CAAA,CAAM,GAAGwP,KAAA,CAAM;gBACxB1M,CAAA,GAAW5C,CAAA,GAAS,GAAGA,CAAA,IAAQO,CAAA,MAAc;cACnD,IAAIyC,CAAA,GAAkBzD,CAAA,CAAWQ,CAAA,EAAM2P,IAAA;gBACnC3F,CAAA,GAAiB;cACrBxK,CAAA,CAAWQ,CAAA,EAAM0P,MAAA,CAAOtF,OAAA,CAAQ,CAAC7K,CAAA,EAAGC,CAAA;gBAC9BD,CAAA,KACFyK,CAAA,IAAkB,GAAGzK,CAAA,CAAEgF,IAAA,IAAQhF,CAAA,CAAEgE,IAAA,MAAU9C,CAAA,CAAOjB,CAAA,O;kBAGtDyD,CAAA,GAAU,GAAG+G,CAAA,MAAoB/G,CAAA,IACjCA,CAAA,GAAUA,CAAA,CAAQ2M,OAAA,CAAQ,UAAU,GAAGpP,CAAA;cACvC,MAAMoK,CAAA,GAAc,WAClB/H,CAAA,sBAEEI,CAAA;cAGJ1D,CAAA,GAASA,CAAA,CAAOqQ,OAAA,CAAQ7P,CAAA,CAAM,IAAI6K,CAAA,C;;;UAItC,OADSrL,CAAA,CAAOqQ,OAAA,CAAQ5P,CAAA,EAAuB,GAEjD;QAAA,C;;;;;;;;QCjDA,MAAAD,CAAA,GAAAC,CAAA;UACAC,CAAA,GAAAD,CAAA;UACAQ,CAAA,GAAAR,CAAA;UACAS,CAAA,GAAAT,CAAA;QAYAR,CAAA,CAAAsQ,gBAAA;UAKE3N,YACI5C,CAAA,EAAyBC,CAAA,EAA0BQ,CAAA,EACnDC,CAAA;YALK,KAAA8P,IAAA,GAAkC,CAAC,GACnC,KAAAC,6BAAA,GAA6E,CAAC,GAKrF,KAAKzH,OAAA,GAAU,IAAIxI,CAAA,CAAA8N,WAAA,CAAYtO,CAAA,EAAWC,CAAA,EAAaQ,CAAA,EAAqBC,CAAA,GAG5EmC,MAAA,CAAO6N,IAAA,CAAKzP,CAAA,CAAA0P,YAAA,EAAc9F,OAAA,CAAS7K,CAAA;cACjC,MAAMC,CAAA,GAAM,IAAIgB,CAAA,CAAA0P,YAAA,CAAa3Q,CAAA,EAAM,KAAKgJ,OAAA;cACxC,KAAKwH,IAAA,CAAKxQ,CAAA,IAAQC,CAAG;YAAA;YAIvB,MAAMiB,CAAA,GAAM,KAAKuP,6BAAA;YACjB,KAAK,MAAMzQ,CAAA,IAAW,KAAKwQ,IAAA,EAAM;cAC/B,MACMvQ,CAAA,GADM,KAAKuQ,IAAA,CAAKxQ,CAAA,EACIsI,YAAA;cAC1B,KAAK,MAAM7H,CAAA,IAAWR,CAAA,EAAe;gBACnC,MAAMS,CAAA,GAAMV,CAAA,GAAU,MAAMS,CAAA;gBAC5B,IAAIQ,CAAA;gBACAC,CAAA,CAAIR,CAAA,KACNO,CAAA,GAAcC,CAAA,CAAIR,CAAA,GAClBO,CAAA,CAAYsM,WAAA,GAActN,CAAA,CAAcQ,CAAA,EAAS8M,WAAA,KAEjDtM,CAAA,GAAc,IAAIT,CAAA,CAAA+N,kBAAA,CAAmB7N,CAAA,EAAKT,CAAA,CAAcQ,CAAA,EAAS8M,WAAA,GACjErM,CAAA,CAAIR,CAAA,IAAOO,CAAA;gBAEb,MAAMqC,CAAA,GAAerD,CAAA,CAAcQ,CAAA,EAASgN,YAAA;gBAC5C,IAAInK,CAAA,EACF,KAAK,IAAItD,CAAA,GAAI,GAAGA,CAAA,GAAIsD,CAAA,CAAaxB,MAAA,IAAU9B,CAAA,EACzC,IAAKkB,CAAA,CAAIoC,CAAA,CAAatD,CAAA,IAKpBiB,CAAA,CAAYuN,aAAA,CAActN,CAAA,CAAIoC,CAAA,CAAatD,CAAA,SALlB;kBACzB,MAAMC,CAAA,GAAO,IAAIO,CAAA,CAAA+N,kBAAA,CAAmBjL,CAAA,CAAatD,CAAA;kBACjDkB,CAAA,CAAIoC,CAAA,CAAatD,CAAA,KAAMC,CAAA,EACvBgB,CAAA,CAAYuN,aAAA,CAAcvO,CAAA,C;;;;UAQtC;UAEA2Q,WAAA;YACE,MAAM5Q,CAAA,GAAc,KAAKgJ,OAAA,CAAQ2B,WAAA;YACjC,IAAI1K,CAAA,GAASD,CAAA,CAAY6Q,YAAA;YAWzB,OARK,KAAK7H,OAAA,CAAQ2B,WAAA,CAAYmG,OAAA,KAC5B7Q,CAAA,GAAS,GAAGA,CAAA,YACV,GAAAiB,CAAA,CAAA6P,wBAAA,EAAyB,KAAK/H,OAAA,CAAQlB,SAAA,CAAUnF,OAAA,EAAS,KAAKqG,OAAA,CAAQC,mBAAA,CAAoB6E,KAAA,CAAMhM,MAAA,MAGpG7B,CAAA,IAAS,GAAAS,CAAA,CAAAoP,cAAA,EAAe7P,CAAA,GAGjB,IAAG,GAAAiB,CAAA,CAAA8P,qBAAA,EAAsB,KAAKhI,OAAA,CAAQlB,SAAA,CAAUnF,OAAA,UACrD,KAAKsO,WAAA,CAAYjR,CAAA,CAAY4K,UAAA,EAAY5K,CAAA,CAAYkR,SAAA,UACrD,KAAKC,UAAA,CAAWlR,CAAA,UAChBA,CAAA,EACJ;UAAA;UAEUkR,WAAWnR,CAAA;YACnB,MAAMC,CAAA,GAAmB,KAAKmR,iCAAA,CAAkCpR,CAAA;YAEhE,IAAgC,MAA5BC,CAAA,CAAiB6B,MAAA,EACnB,OAAO;YAGT,IAAIrB,CAAA,GAAW;YACf,KAAK,IAAIT,CAAA,GAAI,GAAGA,CAAA,GAAIC,CAAA,CAAiB6B,MAAA,IAAU9B,CAAA,EAAG;cAChD,KAAIC,CAAA,CAAiBD,CAAA,EAAGuN,WAAA,EAGtB,MAAM,IAAIlJ,KAAA,CAAM,8CAA8CpE,CAAA,CAAiBD,CAAA,EAAGgE,IAAA;cAFlFvD,CAAA,IAAYR,CAAA,CAAiBD,CAAA,EAAGuN,WAAA,GAAc,I;;YAMlD,OAAO9M,CACT;UAAA;UACQ2Q,kCAAkCpR,CAAA;YACxC,MAAMC,CAAA,GAA8B;YASpC,OAPA4C,MAAA,CAAO6N,IAAA,CAAK,KAAKD,6BAAA,EAA+B5F,OAAA,CAAQpK,CAAA;cACtD,MAAMD,CAAA,GAAUC,CAAA,CAAgBuP,KAAA,CAAM,KAAK;cAAA,CACV,MAA7BhQ,CAAA,CAAOoM,OAAA,CAAQ5L,CAAA,KACjBP,CAAA,CAAM+G,IAAA,CAAK,KAAKyJ,6BAAA,CAA8BhQ,CAAA,E;gBAI3CD,CAAA,CAAAiO,2BAAA,CAA4BC,kBAAA,CAAmBzO,CAAA,CACxD;UAAA;UAEUgR,YAAYjR,CAAA,EAAqBC,CAAA;YACzC,MAAMQ,CAAA,GAAyB;YAC/B,IAAIT,CAAA,EACF,KAAK,MAAMC,CAAA,IAAWD,CAAA,EACpBS,CAAA,CAAauG,IAAA,CAAK,qBAAqB/G,CAAA;YAG3C,IAAIA,CAAA,EACF,KAAK,MAAMD,CAAA,IAAYC,CAAA,EACrBQ,CAAA,CAAauG,IAAA,CACT,WAAWhH,CAAA,CAASgF,IAAA,IAAQhF,CAAA,CAASgE,IAAA,GAAOhE,CAAA,CAASqR,WAAA,GAAc,IAAIrR,CAAA,CAASqR,WAAA,MAAiB;YAGzG,OAAO5Q,CAAA,CAAa2C,IAAA,CAAK,KAC3B;UAAA;QAAA,C;;;;;;;;QC9HF,MAAA5C,CAAA,GAAAC,CAAA;UAEAC,CAAA,GAAAD,CAAA;UACAQ,CAAA,GAAAR,CAAA;UACAS,CAAA,GAAAT,CAAA;UACA6C,CAAA,GAAA7C,CAAA;QAEaR,CAAA,CAAA0Q,YAAA,GAAwE;UACnFW,QAAA,EAAY5Q,CAAA,CAAAgP,eAAA;UACZ6B,SAAA,EAAatQ,CAAA,CAAA4O,gBAAA;UACb2B,GAAA,EAAOlO,CAAA,CAAAmO,UAAA;UACPC,UAAA,EAAcxQ,CAAA,CAAAyQ,iBAAA;UACdC,WAAA,EAAepR,CAAA,CAAA0N;QAAA,C;;;;;;;;QCZjB,MAAA1N,CAAA,GAAAC,CAAA;QAMA,MAAaC,CAAA,SAA0BF,CAAA,CAAA6H,OAAA;UACrCzF,YAAY5C,CAAA;YACV,MAAMA,CAAA,CACR;UAAA;UACAsI,aAAA;YACE,OAAOzF,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK,KAAK+O,UAAA,KACL,KAAKC,gBAAA,KACL,KAAKC,eAAA,KACL,KAAKC,eAAA,KACL,KAAKC,gBAAA,GAEZ;UAAA;UACAnJ,eAAA;YACE,OAAO,CAAC,CACV;UAAA;UACU+I,WAAA;YACR,MAAM7R,CAAA,GAAa,KAAKgJ,OAAA,CAAQC,mBAAA,CAAoB6E,KAAA,CAAMhM,MAAA;cACpD7B,CAAA,GAA2C,CAAC;YAqBlD,OApBA,KAAK+I,OAAA,CAAQ2B,WAAA,CAAYC,UAAA,CAAWC,OAAA,CAAQ,CAACpK,CAAA,EAAMC,CAAA;cACjD,MAAMO,CAAA,GAAQ,KAAK+H,OAAA,CAAQ8B,mBAAA,CAAoBpK,CAAA,EAAG2I,aAAA;cAClD,IAAIpI,CAAA,CAAMa,MAAA,IAAU9B,CAAA,EAAY;gBAC9B,MAAMU,CAAA,GAAOO,CAAA,CAAMa,MAAA;kBACbZ,CAAA,GAAYlB,CAAA,GAAaU,CAAA;kBACzB4C,CAAA,GAAW,gBAAgB7C,CAAA;gBACjC,IAAIiD,CAAA,GAAQ;gBACZ,KAAK,IAAI1D,CAAA,GAAI,GAAGA,CAAA,GAAIU,CAAA,IAAQV,CAAA,EAC1B0D,CAAA,IAAS,2BACK1D,CAAA,qCAAsCkB,CAAA,GAAYlB,CAAA,OAAQiB,CAAA,CAAMjB,CAAA;gBAGhF,MAAMyK,CAAA,GAAO,kBACNnH,CAAA,wBAAgCtD,CAAA,0BAAoCU,CAAA,mBACvEgD,CAAA;gBAGJzD,CAAA,CAAOqD,CAAA,IAAY,IAAI9C,CAAA,CAAAuI,cAAA,CAAe0B,CAAA,C;;gBAGnCxK,CACT;UAAA;UACU6R,iBAAA;YACR,MAAM9R,CAAA,GAAa,KAAKgJ,OAAA,CAAQC,mBAAA,CAAoB6E,KAAA,CAAMhM,MAAA;cACpD7B,CAAA,GAA2C,CAAC;YAuBlD,OAtBA,KAAK+I,OAAA,CAAQ2B,WAAA,CAAYC,UAAA,CAAWC,OAAA,CAAQ,CAACpK,CAAA,EAAMC,CAAA;cACjD,MAAMO,CAAA,GAAQ,KAAK+H,OAAA,CAAQ8B,mBAAA,CAAoBpK,CAAA,EAAGoN,KAAA;cAClD,MAAM7M,CAAA,CAAMa,MAAA,GAAS,KAAKb,CAAA,CAAMa,MAAA,GAAS9B,CAAA,GAAa;gBACpD,MAAMU,CAAA,GAAOO,CAAA,CAAMa,MAAA;kBACbZ,CAAA,GAAYlB,CAAA,GAAaU,CAAA;kBACzB4C,CAAA,GAAW,sBAAsB7C,CAAA;gBACvC,IAAIiD,CAAA,GAAQ;gBACZ,KAAK,IAAI1D,CAAA,GAAI,GAAGA,CAAA,GAAIU,CAAA,GAAO,KAAKV,CAAA,EAC9B0D,CAAA,IAAS,2BACK1D,CAAA,qCAAsCkB,CAAA,GAAYlB,CAAA,OAAQiB,CAAA,CAAMjB,CAAA;gBAGhF,MAAMyK,CAAA,GAAO,kBACNnH,CAAA,uBAA+BtD,CAAA,0BAAoCU,CAAA,mBACtEgD,CAAA,2BACYhD,CAAA,GAAO,uBAAuBV,CAAA,GAAa,8BAC3CU,CAAA,GAAO,uBAAuBV,CAAA,GAAa;gBAG3DC,CAAA,CAAOqD,CAAA,IAAY,IAAI9C,CAAA,CAAAuI,cAAA,CAAe0B,CAAA,C;;gBAGnCxK,CACT;UAAA;UACU+R,gBAAA;YACR,MAAMhS,CAAA,GAA2C,CAAC;YAWlD,OAVA,KAAKgJ,OAAA,CAAQ2B,WAAA,CAAYC,UAAA,CAAWC,OAAA,CAAQ,CAAC5K,CAAA,EAAMQ,CAAA;cACjD,MAAMQ,CAAA,GAAQ,KAAK+H,OAAA,CAAQ8B,mBAAA,CAAoBrK,CAAA,EAAGqN,KAAA;gBAC5C5M,CAAA,GAAU,KAAK8H,OAAA,CAAQ8B,mBAAA,CAAoBrK,CAAA,EAAGsN,OAAA;gBAC9CzK,CAAA,GAAOrC,CAAA,CAAMa,MAAA;cACnB,IAAI4B,CAAA,GAAW,mBAAmBzD,CAAA;cAClCD,CAAA,CAAO0D,CAAA,IAAY,IAAIlD,CAAA,CAAAuI,cAAA,CAAerI,CAAA,CAAkBwR,mBAAA,CAAoBxO,CAAA,EAAUJ,CAAA,EAAMpC,CAAA,IAC5FwC,CAAA,GAAW,mBAAmBzD,CAAA,MAC9BD,CAAA,CAAO0D,CAAA,IACH,IAAIlD,CAAA,CAAAuI,cAAA,CAAerI,CAAA,CAAkBwR,mBAAA,CAAoBxO,CAAA,EAAUJ,CAAA,EAAMpC,CAAA,CAAQgM,KAAA,GAAQW,OAAA,IAAW;YAAA,IAEnG7N,CACT;UAAA;UACA,OAAAkS,oBAA2BlS,CAAA,EAAcC,CAAA,EAAcQ,CAAA;YACrD,IAAID,CAAA,GAAQ;YACZ,KAAK,IAAIR,CAAA,GAAIC,CAAA,GAAO,GAAGD,CAAA,IAAK,KAAKA,CAAA,EAC/BQ,CAAA,IAAS,+BACaR,CAAA,OAAQS,CAAA,CAAQT,CAAA;YAGxC,OAAO,eACCA,CAAA,gBAAoBC,CAAA,0CAEtBO,CAAA,2CAIR;UAAA;UACUuR,gBAAA;YACR,MAAM/R,CAAA,GAA2C,CAAC;YAWlD,OAVA,KAAKgJ,OAAA,CAAQ2B,WAAA,CAAYC,UAAA,CAAWC,OAAA,CAAQ,CAAC5K,CAAA,EAAMQ,CAAA;cACjD,MAAMQ,CAAA,GAAQ,KAAK+H,OAAA,CAAQ8B,mBAAA,CAAoBrK,CAAA,EAAGqN,KAAA;gBAC5C5M,CAAA,GAAU,KAAK8H,OAAA,CAAQ8B,mBAAA,CAAoBrK,CAAA,EAAGsN,OAAA;gBAC9CzK,CAAA,GAAOrC,CAAA,CAAMa,MAAA;cACnB,IAAI4B,CAAA,GAAW,mBAAmBzD,CAAA;cAClCD,CAAA,CAAO0D,CAAA,IAAY,IAAIlD,CAAA,CAAAuI,cAAA,CAAerI,CAAA,CAAkByR,qBAAA,CAAsBzO,CAAA,EAAUJ,CAAA,EAAMpC,CAAA,IAC9FwC,CAAA,GAAW,mBAAmBzD,CAAA,MAC9BD,CAAA,CAAO0D,CAAA,IACH,IAAIlD,CAAA,CAAAuI,cAAA,CAAerI,CAAA,CAAkByR,qBAAA,CAAsBzO,CAAA,EAAUJ,CAAA,EAAMpC,CAAA,CAAQgM,KAAA,GAAQW,OAAA,IAAW;YAAA,IAErG7N,CACT;UAAA;UACA,OAAAmS,sBAA6BnS,CAAA,EAAcC,CAAA,EAAcQ,CAAA;YACvD,MAAMD,CAAA,GAAe;YACrB,KAAK,IAAIR,CAAA,GAAI,GAAGA,CAAA,GAAIC,CAAA,GAAO,KAAKD,CAAA,EAC9BQ,CAAA,CAAawG,IAAA,CAAK,mBACRhH,CAAA,gBAAiBS,CAAA,CAAQT,CAAA,OACnCQ,CAAA,CAAawG,IAAA,CAAK,+BACIhH,CAAA,OAAQS,CAAA,CAAQT,CAAA;YAIxC,OAFAQ,CAAA,CAAawG,IAAA,CAAK,mBACN/G,CAAA,GAAO,iBACZ,gBACED,CAAA,gCAAoCC,CAAA,iBACvCO,CAAA,CAAa4C,IAAA,CAAK,sBAG1B;UAAA;UACU6O,iBAAA;YACR,MAAMjS,CAAA,GAA2C,CAAC;YA0BlD,OAzBA,KAAKgJ,OAAA,CAAQ2B,WAAA,CAAYC,UAAA,CAAWC,OAAA,CAAQ,CAAC5K,CAAA,EAAMQ,CAAA;cACjD,MAAMC,CAAA,GAAQ,KAAKsI,OAAA,CAAQ8B,mBAAA,CAAoBrK,CAAA,EAAGqN,KAAA;gBAC5C7M,CAAA,GAAOP,CAAA,CAAMoB,MAAA;gBACbZ,CAAA,GAAW,oBAAoBjB,CAAA;cACrC,IAAIqD,CAAA,GAAY;cAChB,KAAK,IAAItD,CAAA,GAAI,GAAGA,CAAA,GAAIiB,CAAA,IAAQjB,CAAA,EAC1BsD,CAAA,IAAa,mBACLtD,CAAA,OAAQU,CAAA,CAAMV,CAAA;cAExB,MAAM0D,CAAA,GAAO,kBACJxC,CAAA,8BAAsCD,CAAA,6BAC/BA,CAAA,iBACVqC,CAAA,4BACYrC,CAAA;cAUlBjB,CAAA,CAAOkB,CAAA,IAAY,IAAIV,CAAA,CAAAuI,cAAA,CAAerF,CAAA,CAAK;YAAA,IAEtC1D,CACT;UAAA;QAAA;QA3JFC,CAAA,CAAA0R,iBAAA,GAAAjR,C;;;;;;;;QCOA,MAAMD,CAAA,GAAoB;YACxBkC,OAAA,EAAS;YACTyP,SAAA,EAAW;YACXC,aAAA,EAAe;YACfC,WAAA,EAAa;YACb5H,SAAA,EAAW;YACXZ,MAAA,EAAQ;YACRyI,iBAAA,EAAmB;UAAA;UAEf/R,CAAA,GAAoB;YACxBmC,OAAA,EAAS;YACTyP,SAAA,EAAW;YACXC,aAAA,EAAe;YACfC,WAAA,EAAa;YACb5H,SAAA,EAAW;YACXZ,MAAA,EAAQ;YACRyI,iBAAA,EAAmB;UAAA;QAGrB,SAAgB7R,EAAQV,CAAA;UACtB,OAAmB,MAAZA,CAAA,GAAgBS,CAAA,GAAcD,CACvC;QAAA;QAFAP,CAAA,CAAA4J,OAAA,GAAAnJ,CAAA,EAIAT,CAAA,CAAAuS,qBAAA,aAAsCxS,CAAA;UACpC,MAAMC,CAAA,GAAOS,CAAA,CAAQV,CAAA;UACrB,OAAO,GAAGC,CAAA,CAAK0C,OAAA,yCAET1C,CAAA,CAAKmS,SAAA,0BACLnS,CAAA,CAAKmS,SAAA,gCAELnS,CAAA,CAAKoS,aAAA,4IAOb;QAAA,GAEApS,CAAA,CAAA+Q,qBAAA,aAAsChR,CAAA;UACpC,MAAMC,CAAA,GAAOS,CAAA,CAAQV,CAAA;UACrB,OAAO,GAAGC,CAAA,CAAK0C,OAAA,+FAIX1C,CAAA,CAAKqS,WAAA,yBACLrS,CAAA,CAAKsS,iBAAA,oZA4BX;QAAA,GAEAtS,CAAA,CAAA8Q,wBAAA,aAAyC/Q,CAAA,EAAcC,CAAA;UAErD,OAAO,sCAESA,CAAA,sFAHHS,CAAA,CAAQV,CAAA,EAMZ8J,MAAA,qBAGX;QAAA,C;;;;;;;;QCnGA,MAAAtJ,CAAA,GAAAC,CAAA;QAOA,MAAaC,CAAA,SAAmBF,CAAA,CAAA6H,OAAA;UAC9BzF,YAAY5C,CAAA;YACV,MAAMA,CAAA,CACR;UAAA;UACA8I,eAAA;YACE,OAAO,CAAC,CACV;UAAA;UACAR,aAAA;YACE,OAAOzF,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAW,KAAK2P,kBAAA,KAAyB,KAAKC,OAAA,KAAc,KAAKC,UAAA,KAAiB,KAAKC,UAAA,GACzF;UAAA;UACUH,mBAAA;YACR,MACMzS,CAAA,GADe,KAAKgJ,OAAA,CAAQC,mBAAA,CACR6E,KAAA,CAAMhM,MAAA;cAC1B7B,CAAA,GAAmC;gBAAC8O,GAAA,EAAK;gBAAM8D,GAAA,EAAK;gBAAMC,GAAA,EAAK;gBAAMC,GAAA,EAAK;cAAA;cAC1EtS,CAAA,GAA2C,CAAC;YAClD,KAAK,MAAMC,CAAA,IAAQT,CAAA,EAAQ;cACzB,MAAMgB,CAAA,GAAQ,GAAGP,CAAA;cACjB,IAAIQ,CAAA,GAAkB;cACtB,KAAK,IAAIT,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,IAAQS,CAAA,EAC1BS,CAAA,IAAmB,oBACVT,CAAA,KAAMR,CAAA,CAAOS,CAAA,SAAaD,CAAA;cAGrC,MAAM6C,CAAA,GAAO,kBACJrC,CAAA,YAAiBjB,CAAA,mBAAuBA,CAAA,mBAC3CkB,CAAA;cAGNT,CAAA,CAAOQ,CAAA,IAAS,IAAIT,CAAA,CAAAuI,cAAA,CAAezF,CAAA,C;;YAGrC,OAAO7C,CACT;UAAA;UACUiS,QAAA;YACR,MACM1S,CAAA,GADe,KAAKgJ,OAAA,CAAQC,mBAAA,CACR6E,KAAA,CAAMhM,MAAA;YAChC,IAAI7B,CAAA,GAAkB;YACtB,KAAK,IAAIQ,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,IAAQS,CAAA,EAC1BR,CAAA,IAAmB,kBACVQ,CAAA,WAAYA,CAAA;YAGvB,MAAMA,CAAA,GAAO,gCACYT,CAAA,mBAAuBA,CAAA,iBAC1CC,CAAA;YAGN,OAAO;cAACyS,OAAA,EAAS,IAAIlS,CAAA,CAAAuI,cAAA,CAAetI,CAAA;YAAA,CACtC;UAAA;UAEUkS,WAAA;YACR,MACM3S,CAAA,GADe,KAAKgJ,OAAA,CAAQC,mBAAA,CACR6E,KAAA,CAAMhM,MAAA;YAChC,IAAI7B,CAAA,GAAQ,+CAEKD,CAAA;YAIjB,KAAK,IAAIS,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,GAAO,KAAKS,CAAA,EAC9BR,CAAA,IAAS,+BACaQ,CAAA,oBACZA,CAAA;YAGZR,CAAA,IAAS,iCAEGD,CAAA,GAAO;YAEnB,MAAMS,CAAA,GAAO,qCACiBT,CAAA,uCACxBC,CAAA;YAGN,OAAO;cAAC0S,UAAA,EAAY,IAAInS,CAAA,CAAAuI,cAAA,CAAetI,CAAA;YAAA,CACzC;UAAA;UACUmS,WAAA;YACR,MACM5S,CAAA,GADe,KAAKgJ,OAAA,CAAQC,mBAAA,CACR6E,KAAA,CAAMhM,MAAA;YAChC,IAAI7B,CAAA,GAAQ,gDAEMD,CAAA;YAIlB,KAAK,IAAIS,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,GAAO,KAAKS,CAAA,EAC9BR,CAAA,IAAS,+BACaQ,CAAA,2BACLA,CAAA;YAGnBR,CAAA,IAAS,wCAEUD,CAAA,GAAO;YAE1B,MAAMS,CAAA,GAAO,gCACYT,CAAA,4BACnBC,CAAA;YAGN,OAAO;cAAC2S,UAAA,EAAY,IAAIpS,CAAA,CAAAuI,cAAA,CAAetI,CAAA;YAAA,CACzC;UAAA;QAAA;QArGFR,CAAA,CAAAwR,UAAA,GAAA/Q,C;;;;;;;;QCNA,MAAAF,CAAA,GAAAC,CAAA;UACAC,CAAA,GAAAD,CAAA;UACAQ,CAAA,GAAAR,CAAA;UAEAS,CAAA,GAAAT,CAAA;UACA6C,CAAA,GAAA7C,CAAA;UACAiD,CAAA,GAAAjD,CAAA;UACAgK,CAAA,GAAAhK,CAAA;UAGA4K,CAAA,GAAA5K,CAAA;UACA6K,CAAA,GAAA7K,CAAA;QAeAR,CAAA,CAAA+S,qBAAA;UAGEpQ,YAAmB5C,CAAA;YAAA,KAAAiT,OAAA,GAAAjT,CAAA,EACjB,KAAKkT,sBAAA,GAAyB,IAAItP,GAAA,IAClC,KAAKuP,wBAAA,GAA2B,IAAIvP,GACtC,CADsC,CACtC;UAAA;UAKAwP,+BAA+BpT,CAAA,EAA0BC,CAAA;YACvD,QAAO,GAAAoL,CAAA,CAAA+H,8BAAA,EAA+B,KAAKH,OAAA,CAAQI,cAAA,EAAgBrT,CAAA,EAAOC,CAAA,CAC5E;UAAA;UAEAqT,eAAetT,CAAA,EAAwCC,CAAA;YACrD,IAAIA,CAAA,CAAO6B,MAAA,GAAS9B,CAAA,CAAQ4K,UAAA,CAAW9I,MAAA,EACrC,MAAM,IAAIuC,KAAA,CAAM,mCAAmCrE,CAAA,CAAQ4K,UAAA,CAAW9I,MAAA;YAExE,IAAI9B,CAAA,CAAQ4K,UAAA,CAAW9I,MAAA,KAAW9B,CAAA,CAAQuT,UAAA,CAAWzR,MAAA,EACnD,MAAM,IAAIuC,KAAA,CAAM;YAIlB,MAAM5D,CAAA,GAAmC;YACzC,KAAK,IAAID,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQ4K,UAAA,CAAW9I,MAAA,IAAUtB,CAAA,EAC/CC,CAAA,CAAkBD,CAAA,IAAK,KAAKgT,sBAAA,CAAuBvT,CAAA,CAAOO,CAAA,GAAIR,CAAA,CAAQuT,UAAA,CAAW/S,CAAA;YAGnF,MAAMA,CAAA,GAzCN,EAACR,CAAA,EAA4CC,CAAA;cAC3C,MAAMQ,CAAA,GACFR,CAAA,CAAkBkD,GAAA,CAAInD,CAAA,IAAW,GAAGA,CAAA,CAAQqJ,aAAA,CAAcjG,IAAA,CAAK,QAAQpD,CAAA,CAAQsJ,KAAA,IAAStJ,CAAA,CAAQuJ,MAAA,IAC3FnG,IAAA,CAAK;cACd,IAAI5C,CAAA,GAAMR,CAAA,CAAYgE,IAAA;cAKtB,OAJIhE,CAAA,CAAYyT,SAAA,KACdjT,CAAA,IAAO,MAAMR,CAAA,CAAYyT,SAAA,GAAY,MAEvCjT,CAAA,IAAO,MAAMC,CAAA,EACND,CAAG;YAAA,GAgCwBR,CAAA,EAASS,CAAA;YAC7C,IAAIC,CAAA,GAAW,KAAKuS,OAAA,CAAQS,cAAA,CAAeC,WAAA,CAAYnT,CAAA;YACvD,MAAMS,CAAA,GAAcP,CAAA,GAChBA,CAAA,CAASiK,WAAA,GACsC,qBAAtC3K,CAAA,CAA8BwE,GAAA,GAAsBxE,CAAA,CAA8BwE,GAAA,KAC9BxE,CAAA;cAG3DkB,CAAA,IAAsB,GAAAmK,CAAA,CAAAuI,kCAAA,EACxB,KAAKX,OAAA,CAAQI,cAAA,EAAgBpS,CAAA,CAAY6I,MAAA,CAAO+J,IAAA,EAAM5S,CAAA,CAAY6I,MAAA,CAAOgK,WAAA;cACvExQ,CAAA,GAAoB,KAAKyQ,iBAAA,CAAkB7S,CAAA,EAAqBD,CAAA,CAAY6I,MAAA,CAAO9E,IAAA;YAQzF,OANKtE,CAAA,KACHA,CAAA,GAAW,KAAKuS,OAAA,CAAQS,cAAA,CAAeM,KAAA,CAAM/S,CAAA,EAAaR,CAAA,EAAmB6C,CAAA,GAC7E,KAAK2P,OAAA,CAAQS,cAAA,CAAeO,WAAA,CAAYzT,CAAA,EAAKE,CAAA,IAG/C,KAAKwT,UAAA,CAAWxT,CAAA,EAAUD,CAAA,EAAmB6C,CAAA,GACtCA,CACT;UAAA;UAEA6Q,IAAInU,CAAA,EAA4BC,CAAA;YAE9B,OAD0B,KAAKqT,cAAA,CAAetT,CAAA,EAASC,CAAA,EAC9BmU,MAC3B;UAAA;UAEQF,WAAWlU,CAAA,EAAoBC,CAAA,EAAuBQ,CAAA;YAE5D,KAAK,IAAIA,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAO6B,MAAA,IAAUrB,CAAA,EACnC,MAAMR,CAAA,CAAOQ,CAAA,EAAGyI,QAAA,KAAclJ,CAAA,CAAS2K,WAAA,CAAY4I,UAAA,CAAW9S,CAAA,MAAO6K,CAAA,CAAA+I,WAAA,CAAYC,MAAA,GAC/E,MAAM,IAAIjQ,KAAA,CAAM,SAAS5D,CAAA;YAK7B,MAAMA,CAAA,CAAOyI,QAAA,KAAclJ,CAAA,CAAS2K,WAAA,CAAYb,MAAA,CAAOgK,WAAA,KAAgBxI,CAAA,CAAA+I,WAAA,CAAYC,MAAA,GACjF,MAAM,IAAIjQ,KAAA,CAAM;YAGlB,KAAK4O,OAAA,CAAQS,cAAA,CAAeS,GAAA,CAAInU,CAAA,EAAUC,CAAA,EAAQQ,CAAA,CACpD;UAAA;UAaQ+S,uBAAuBxT,CAAA,EAAgBC,CAAA;YAC7C,IAAIQ,CAAA,GAAK,KAAK8T,cAAA,CAAevU,CAAA,CAAOwU,MAAA,EAAQvU,CAAA,KAAgBqL,CAAA,CAAA+I,WAAA,CAAYC,MAAA;YAExE,KAAK7T,CAAA,KAEHA,CAAA,GAAK,KAAK8T,cAAA,CAAevU,CAAA,CAAOwU,MAAA,EAAQvU,CAAA,KAAgBqL,CAAA,CAAA+I,WAAA,CAAYC,MAAA,GAChE7T,CAAA,GACF,OAAIR,CAAA,KAAgBqL,CAAA,CAAA+I,WAAA,CAAYC,MAAA,GACvB,KAAK1M,IAAA,CAAKnH,CAAA,IAEV,KAAKgU,MAAA,CAAOhU,CAAA;YAKzB,KAAKA,CAAA,EAAI;cACP,MAAMD,CAAA,IAAS,GAAA6K,CAAA,CAAAuI,kCAAA,EAAmC,KAAKX,OAAA,CAAQI,cAAA,EAAgBrT,CAAA,CAAO6T,IAAA,EAAM5T,CAAA;cAE5F,IAAIA,CAAA,KAAgBqL,CAAA,CAAA+I,WAAA,CAAYK,mBAAA,EAAqB;gBACnD,MAAMjU,CAAA,GAAQ;kBACRD,CAAA,GAAW;kBACXE,CAAA,GAAQV,CAAA,CAAO6T,IAAA;gBACrB,IAAqB,MAAjBnT,CAAA,CAAMoB,MAAA,EAAc;kBAQtB,MAAMb,CAAA,GAAsB,CAACP,CAAA,CAAM,IAAIsB,IAAA,CAAKE,IAAA,CAAMxB,CAAA,CAAM,KAAKA,CAAA,CAAM,KAAKA,CAAA,CAAM,KAAMF,CAAA;oBAC9EU,CAAA,IACF,GAAAmK,CAAA,CAAAuI,kCAAA,EAAmC,KAAKX,OAAA,CAAQI,cAAA,EAAgBpS,CAAA,EAAqBhB,CAAA;kBACzF,IAAIqD,CAAA,GAAStD,CAAA,CAAO2U,UAAA;kBACpB,IAAIjU,CAAA,CAAM,KAAKA,CAAA,CAAM,KAAKA,CAAA,CAAM,KAAKF,CAAA,IAAa,GAAG;oBACnD,MAAMP,CAAA,GAAiBS,CAAA,CAAM;sBACvBO,CAAA,GAAaP,CAAA,CAAM,KAAKA,CAAA,CAAM,KAAKA,CAAA,CAAM;sBACzCQ,CAAA,GAAac,IAAA,CAAKE,IAAA,CAAKjB,CAAA,GAAaR,CAAA,GAAQD,CAAA,IAAYA,CAAA;oBAE9D8C,CAAA,GAAS,IAAIsR,YAAA,CADG3U,CAAA,GAAiBiB,CAAA;oBAEjC,KAAK,IAAIV,CAAA,GAAI,GAAGA,CAAA,GAAIP,CAAA,IAAkBO,CAAA,EAAG;sBACvC,MAAMP,CAAA,GAAYO,CAAA,GAAIS,CAAA;wBAChBP,CAAA,GAAYF,CAAA,GAAIU,CAAA,GAAaV,CAAA,GAAIC,CAAA,GAAQQ,CAAA;sBAC/CqC,CAAA,CAAOS,GAAA,CAAI/D,CAAA,CAAO2U,UAAA,CAAWE,QAAA,CAAS5U,CAAA,EAAWA,CAAA,GAAYgB,CAAA,GAAaP,CAAA,C;;;kBAG9E,OAAO,KAAKqT,iBAAA,CAAkB7S,CAAA,EAAgBlB,CAAA,CAAOgF,IAAA,EAAM1B,CAAA,EAAQtD,CAAA,EAAQ,E;;;cAI/E,IAAIC,CAAA,KAAgBqL,CAAA,CAAA+I,WAAA,CAAYC,MAAA,EAAQ;gBACtC,MAAMrU,CAAA,IACF,GAAAoL,CAAA,CAAAyJ,4BAAA,EAA6B,KAAK7B,OAAA,CAAQI,cAAA,EAAgBrT,CAAA,CAAO6T,IAAA,EAAM,GAAG,IAAI;oBAACkB,SAAA,GAAW;kBAAA;kBACxFvU,CAAA,GAAsB,KAAKuT,iBAAA,CAC7B9T,CAAA,EAAuBD,CAAA,CAAOgF,IAAA,EAAMhF,CAAA,CAAO2U,UAAA,EAAY3U,CAAA,EAAQ;gBACnES,CAAA,GAAK,KAAKmH,IAAA,CAAKpH,CAAA,C;qBAEfC,CAAA,GAAK,KAAKsT,iBAAA,CAAkBvT,CAAA,EAAQR,CAAA,CAAOgF,IAAA,EAAMhF,CAAA,CAAO2U,UAAA,EAAY3U,CAAA,EAAQ,E;;YAGhF,OAAOS,CACT;UAAA;UAWAuU,sCACIhV,CAAA,EAAuBC,CAAA,EAA2BQ,CAAA,EAAyBD,CAAA;YAC7E,OAAO,KAAKuT,iBAAA,CAAkB/T,CAAA,EAAQC,CAAA,EAAUQ,CAAA,EAAMD,CAAA,EAAQ,EAChE;UAAA;UAEQuT,kBACJ/T,CAAA,EAAuBC,CAAA,EAA2BQ,CAAA,EAA0BC,CAAA,EAC5EO,CAAA;YACFT,CAAA,CAAAwH,MAAA,CAAOE,OAAA,CAAQ,oBAAoB,iCAAiCkF,IAAA,CAAKE,SAAA,CAAUtN,CAAA;YACnF,MAAMkB,CAAA,GAAU,KAAK+R,OAAA,CAAQgC,cAAA,CAAeC,uBAAA,CAAwBjV,CAAA,EAAUD,CAAA,EAAQS,CAAA,EAAMQ,CAAA;YAC5F,OAAO,KAAKkU,4BAAA,CAA6BnV,CAAA,EAAQC,CAAA,EAAUiB,CAAA,EAASR,CAAA,CACtE;UAAA;UAEA0U,gBAAgBpV,CAAA,EAAeC,CAAA;YAC7B,MAAMQ,CAAA,GAAU,KAAK+S,sBAAA,CAAuBxT,CAAA,EAAOsL,CAAA,CAAA+I,WAAA,CAAYgB,QAAA;cACzD7U,CAAA,GAAkC;gBACtC8U,QAAA,EAAU7U,CAAA,CAAQ6U,QAAA;gBAClB/L,MAAA,EAAQ9I,CAAA,CAAQ8I,MAAA;gBAChBD,KAAA,EAAO7I,CAAA,CAAQ6I,KAAA;gBAEfwE,KAAA,EAA+B,MAAxB7N,CAAA,CAAa6B,MAAA,GAAe7B,CAAA,GAAe,CAAC;gBACnD8N,OAAA,EAAS9M,CAAA,CAAAiL,SAAA,CAAUqJ,cAAA,CAAetV,CAAA;gBAClCoJ,aAAA,EAAepJ;cAAA;YAGjB,OADuB,KAAKkV,4BAAA,CAA6B3U,CAAA,EAAkBR,CAAA,CAAMgF,IAAA,EAAMvE,CAAA,CAAQ+U,OAAA,EACzEpB,MACxB;UAAA;UAEAqB,cAAczV,CAAA,EAAeC,CAAA;YAC3B,MAAMQ,CAAA,GAAU,KAAK+S,sBAAA,CAAuBxT,CAAA,EAAOsL,CAAA,CAAA+I,WAAA,CAAYC,MAAA;YAG/D,KAAI,GAAAhR,CAAA,CAAAoS,cAAA,EAAe1V,CAAA,CAAM6T,IAAA,EAAM5T,CAAA,GAAe;cAC5C,MAAMO,CAAA,GAAkC;gBACtC8U,QAAA,EAAU7U,CAAA,CAAQ6U,QAAA;gBAClB/L,MAAA,EAAQ9I,CAAA,CAAQ8I,MAAA;gBAChBD,KAAA,EAAO7I,CAAA,CAAQ6I,KAAA;gBAEfwE,KAAA,EAA+B,MAAxB7N,CAAA,CAAa6B,MAAA,GAAe7B,CAAA,GAAe,CAAC;gBACnD8N,OAAA,EAAS9M,CAAA,CAAAiL,SAAA,CAAUqJ,cAAA,CAAetV,CAAA;gBAClCoJ,aAAA,EAAepJ,CAAA;gBACfiJ,QAAA,GAAU;cAAA;cAGZ,OADuB,KAAKiM,4BAAA,CAA6B3U,CAAA,EAAkBR,CAAA,CAAMgF,IAAA,EAAMvE,CAAA,CAAQ+U,OAAA,EACzEpB,M;;YAGxB,MAAM5T,CAAA,IAAqB,GAAA8C,CAAA,CAAAqS,aAAA,EAAc3V,CAAA,CAAM6T,IAAA;cACzCnT,CAAA,IAAsB,GAAA4C,CAAA,CAAAqS,aAAA,EAAc1V,CAAA;cAEpCiB,CAAA,GAAsB,KAAKuU,aAAA,CAAczV,CAAA,EAAOQ,CAAA;cAChDkD,CAAA,GAAuB,KAAKyQ,GAAA,EAC9B,GAAA7Q,CAAA,CAAAsS,sCAAA,EAAuC,MAAM1U,CAAA,EAAqBR,CAAA,GAAsB,CAACQ,CAAA;YAE7F,OADqB,KAAKuU,aAAA,CAAc/R,CAAA,EAAsBzD,CAAA,CAEhE;UAAA;UAEA4V,KAAK7V,CAAA,EAAeC,CAAA;YAClB,MAAMQ,CAAA,GAAU,KAAK+S,sBAAA,CAAuBxT,CAAA,EAAOsL,CAAA,CAAA+I,WAAA,CAAYgB,QAAA;YAE/D,OADuB,KAAKF,4BAAA,CAA6B1U,CAAA,EAA0BR,CAAA,EAAMQ,CAAA,CAAQ+U,OAAA,EAC3EpB,MACxB;UAAA;UAEQe,6BACJnV,CAAA,EAAuBC,CAAA,EAA2BQ,CAAA,EAAuBD,CAAA,EAAiBS,CAAA;YAC5F,MAAMC,CAAA,GAAW2B,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACZ9C,CAAA,GAAM;cACToU,MAAA,EAAQ5T,CAAA,IACJ,IAAIE,CAAA,CAAAuF,MAAA,CACIjG,CAAA,CAAOqJ,aAAA,EAAepJ,CAAA,EAAWD,CAAA,IAAmB,KAAK8V,WAAA,CAAY5U,CAAA,GACrE,MAAOlB,CAAA,IAAmB,KAAK+V,gBAAA,CAAiB7U,CAAA,QAAc,GAAWD,CAAA;cACrFuU,OAAA,EAAA/U;YAAA;YAGF,OADA,KAAKuV,cAAA,CAAe9U,CAAA,CAAYkT,MAAA,CAAOI,MAAA,EAAQtT,CAAA,EAAalB,CAAA,CAAOkJ,QAAA,GAC5DhI,CACT;UAAA;UAEQqT,eAAevU,CAAA,EAAqBC,CAAA,IAAW;YACrD,OAAO,KAAKgT,OAAA,CAAQgD,aAAA,CAAcjW,CAAA,IAAY,KAAKiT,OAAA,CAAQsB,cAAA,CAAevU,CAAA,EAAUC,CAAA,IAChFA,CAAA,GAA0C,KAAKiT,sBAAA,CAAuB1O,GAAA,CAAIxE,CAAA,IAChC,KAAKmT,wBAAA,CAAyB3O,GAAA,CAAIxE,CAAA,CAClF;UAAA;UACAgW,eAAehW,CAAA,EAAqBC,CAAA,EAAiBQ,CAAA,IAAW;YAC1D,KAAKwS,OAAA,CAAQgD,aAAA,CAAcjW,CAAA,IAC7B,KAAKiT,OAAA,CAAQ+C,cAAA,CAAehW,CAAA,EAAUC,CAAA,EAAIQ,CAAA,KAEzCA,CAAA,GAAW,KAAKyS,sBAAA,GAAyB,KAAKC,wBAAA,EAA0BpP,GAAA,CAAI/D,CAAA,EAAUC,CAAA,CAE3F;UAAA;UACAiW,sBAAsBlW,CAAA,EAAgBC,CAAA,IAAW;YAC/C,SAAS,KAAKsU,cAAA,CAAevU,CAAA,CAAOwU,MAAA,EAAQvU,CAAA,CAC9C;UAAA;UAEAoH,QAAA;YACE,KAAK4L,OAAA,CAAQgC,cAAA,CAAekB,mBAAA,IAC5B,KAAKjD,sBAAA,CAAuBrI,OAAA,CAAQ7K,CAAA,IAAM,KAAKiT,OAAA,CAAQgC,cAAA,CAAemB,cAAA,CAAepW,CAAA,IACrF,KAAKkT,sBAAA,GAAyB,IAAItP,GAAA,IAClC,KAAKuP,wBAAA,CAAyBtI,OAAA,CAAQ7K,CAAA,IAAM,KAAKiT,OAAA,CAAQgC,cAAA,CAAemB,cAAA,CAAepW,CAAA,IACvF,KAAKmT,wBAAA,GAA2B,IAAIvP,GACtC,CADsC,CACtC;UAAA;UAEAkS,YAAY9V,CAAA;YACV,OAAIA,CAAA,CAAYkJ,QAAA,GACP,KAAK4M,WAAA,CAAY,KAAKrB,MAAA,CAAOzU,CAAA,KAEjC,KAAKiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUuO,0BAAA,GAG7B,KAAKpD,OAAA,CAAQgC,cAAA,CAAea,WAAA,CAAY9V,CAAA,EAAaA,CAAA,CAAYoU,MAAA,CAAOpP,IAAA,EAAMhF,CAAA,CAAYsV,QAAA,IAFxF,KAAKrC,OAAA,CAAQgC,cAAA,CAAeqB,uBAAA,EAAwB,GAAA5S,CAAA,CAAA6S,aAAA,EAAc,MAAMvW,CAAA,EAGnF;UAAA;UAEA,MAAA+V,iBAAuB/V,CAAA;YACrB,OAAIA,CAAA,CAAYkJ,QAAA,GACP,KAAK6M,gBAAA,CAAiB,KAAKtB,MAAA,CAAOzU,CAAA,KAEtC,KAAKiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUuO,0BAAA,GAG7B,KAAKpD,OAAA,CAAQgC,cAAA,CAAec,gBAAA,CAAiB/V,CAAA,EAAaA,CAAA,CAAYoU,MAAA,CAAOpP,IAAA,EAAMhF,CAAA,CAAYsV,QAAA,IAF7F,KAAKrC,OAAA,CAAQgC,cAAA,CAAeqB,uBAAA,EAAwB,GAAA5S,CAAA,CAAA6S,aAAA,EAAc,MAAMvW,CAAA,EAGnF;UAAA;UAEA4H,KAAK5H,CAAA;YAEH,OAD0B,KAAKsT,cAAA,EAAe,GAAApS,CAAA,CAAAsV,2BAAA,EAA4B,MAAMxW,CAAA,CAAMoU,MAAA,GAAS,CAACpU,CAAA,CAAMoU,MAAA,EAExG;UAAA;UAEAK,OAAOzU,CAAA;YAEL,OAD0B,KAAKsT,cAAA,EAAe,GAAA7I,CAAA,CAAAgM,6BAAA,EAA8B,MAAMzW,CAAA,CAAMoU,MAAA,GAAS,CAACpU,CAAA,CAAMoU,MAAA,EAE1G;UAAA;QAAA,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QCpTF,MAAAlT,CAAA,GAAAT,CAAA;UACA6C,CAAA,GAAArC,CAAA,CAAAR,CAAA;UACAiD,CAAA,GAAAjD,CAAA;UACAgK,CAAA,GAAAhK,CAAA;UACA4K,CAAA,GAAA5K,CAAA;UACA6K,CAAA,GAAA7K,CAAA;UACA8K,CAAA,GAAA9K,CAAA;UACA8F,CAAA,GAAA9F,CAAA;UACAiL,CAAA,GAAAjL,CAAA;UACA+F,CAAA,GAAA/F,CAAA;UACAmL,CAAA,GAAAnL,CAAA;UACAoL,CAAA,GAAApL,CAAA;UACAsL,CAAA,GAAAtL,CAAA;UACAuL,CAAA,GAAAvL,CAAA;UACAwL,CAAA,GAAAxL,CAAA;UACA0L,CAAA,GAAA1L,CAAA;UACA4L,CAAA,GAAA5L,CAAA;UACAiW,CAAA,GAAAjW,CAAA;UACAkW,CAAA,GAAAlW,CAAA;UACAmW,CAAA,GAAAnW,CAAA;UACAoW,CAAA,GAAApW,CAAA;UACAqW,CAAA,GAAArW,CAAA;UACAsW,CAAA,GAAAtW,CAAA;UACAuW,CAAA,GAAAvW,CAAA;UACAwW,CAAA,GAAAxW,CAAA;UACAyW,CAAA,GAAAzW,CAAA;UACA0W,CAAA,GAAA1W,CAAA;UACA2W,CAAA,GAAAnW,CAAA,CAAAR,CAAA;UACA4W,CAAA,GAAA5W,CAAA;UACAE,CAAA,GAAAF,CAAA;QAEaR,CAAA,CAAAqX,sBAAA,GAAuD,CAClE,CAAC,OAAO,IAAI,MAAMF,CAAA,CAASG,GAAA,GAC3B,CAAC,QAAQ,IAAI,MAAMH,CAAA,CAASI,IAAA,GAC5B,CAAC,OAAO,IAAI,MAAMlU,CAAA,CAAUyL,GAAA,GAC5B,CAAC,OAAO,IAAI,MAAMzL,CAAA,CAAUmU,GAAA,GAC5B,CAAC,QAAQ,IAAI,MAAML,CAAA,CAASM,IAAA,GAC5B,CAAC,QAAQ,IAAI,MAAMN,CAAA,CAASO,IAAA,GAE5B,CAAC,eAAe,IAAI,MAAMxL,CAAA,CAAAyL,WAAA,EAAazL,CAAA,CAAA0L,0BAAA,GACvC,CAAC,sBAAsB,IAAI,MAAM3W,CAAA,CAAA4W,kBAAA,EAAoB5W,CAAA,CAAA6W,iCAAA,GACrD,CAAC,QAAQ,IAAI,MAAMrU,CAAA,CAAAmS,IAAA,EAAMnS,CAAA,CAAAsU,mBAAA,GACzB,CAAC,QAAQ,IAAI,MAAMZ,CAAA,CAASlV,IAAA,GAC5B,CAAC,QAAQ,IAAI,QAAQkV,CAAA,CAASa,IAAA,EAAMb,CAAA,CAASc,mBAAA,GAC7C,CAAC,QAAQ,IAAI,OAAOd,CAAA,CAASe,OAAA,GAC7B,CAAC,UAAU,IAAI,MAAM1N,CAAA,CAAA2N,MAAA,EAAQ3N,CAAA,CAAA4N,qBAAA,GAC7B,CAAC,QAAQ,IAAI,MAAMhN,CAAA,CAAAiN,IAAA,EAAMjN,CAAA,CAAAkN,mBAAA,GACzB,CAAC,iBAAiB,IAAI,MAAMjN,CAAA,CAAAkN,aAAA,EAAelN,CAAA,CAAAmN,4BAAA,GAC3C,CAAC,OAAO,IAAI,MAAMrB,CAAA,CAASsB,GAAA,GAC3B,CAAC,OAAO,IAAI,MAAMpV,CAAA,CAAUyP,GAAA,GAC5B,CAAC,WAAW,IAAI,MAAMqE,CAAA,CAASuB,QAAA,GAC/B,CAAC,gBAAgB,IAAI,MAAMpN,CAAA,CAAAqN,YAAA,EAAcrN,CAAA,CAAAsN,2BAAA,GACzC,CAAC,SAAS,IAAI,MAAMvV,CAAA,CAAUwV,KAAA,GAC9B,CAAC,OAAO,IAAI,MAAM1B,CAAA,CAAS2B,GAAA,EAAK3B,CAAA,CAAS4B,kBAAA,GACzC,CAAC,OAAO,IAAI,MAAM5B,CAAA,CAAS6B,GAAA,GAC3B,CAAC,WAAW,IAAI,MAAM1S,CAAA,CAAA2S,OAAA,EAAS3S,CAAA,CAAA4S,sBAAA,GAC/B,CAAC,SAAS,IAAI,MAAM/B,CAAA,CAASgC,KAAA,GAC7B,CAAC,aAAa,iBAAiB,MAAM/N,CAAA,CAAAiN,IAAA,EAAMjN,CAAA,CAAAkN,mBAAA,GAC3C,CAAC,UAAU,IAAI,MAAM7M,CAAA,CAAA2N,MAAA,EAAQ3N,CAAA,CAAA4N,qBAAA,GAC7B,CAAC,QAAQ,IAAI,QAAQ9S,CAAA,CAAA+S,IAAA,EAAM/S,CAAA,CAAAgT,qBAAA,GAC3B,CAAC,QAAQ,IAAI,OAAOhT,CAAA,CAAA+S,IAAA,EAAM/S,CAAA,CAAAiT,sBAAA,GAC1B,CAAC,qBAAqB,IAAI,MAAMtN,CAAA,CAAAuN,iBAAA,EAAmBvN,CAAA,CAAAwN,gCAAA,GACnD,CAAC,iBAAiB,IAAI,MAAMxN,CAAA,CAAAyN,aAAA,GAC5B,CAAC,WAAW,IAAI,MAAMtW,CAAA,CAAUuW,OAAA,GAChC,CAAC,YAAY,IAAI,MAAMzC,CAAA,CAASuB,QAAA,GAChC,CAAC,eAAe,IAAI,MAAM/M,CAAA,CAAAkO,WAAA,EAAalO,CAAA,CAAAmO,0BAAA,GACvC,CAAC,yBAAyB,IAAI,MAAMlO,CAAA,CAAAmO,qBAAA,EAAuBnO,CAAA,CAAAoO,oCAAA,GAC3D,CAAC,aAAa,IAAI,MAAM7C,CAAA,CAAS8C,SAAA,EAAW9C,CAAA,CAAS+C,wBAAA,GACrD,CAAC,QAAQ,IAAI,MAAM7W,CAAA,CAAU8W,IAAA,GAC7B,CAAC,OAAO,IAAI,MAAMrO,CAAA,CAAAsO,GAAA,EAAKtO,CAAA,CAAAuO,kBAAA,GACvB,CAAC,OAAO,IAAI,MAAMlD,CAAA,CAASmD,GAAA,GAC3B,CAAC,UAAU,IAAI,MAAMvO,CAAA,CAAAwO,MAAA,EAAQxO,CAAA,CAAAyO,qBAAA,GAE7B,CAAC,WAAW,IAAI,MAAMtO,CAAA,CAAAuO,OAAA,EAASvO,CAAA,CAAAwO,sBAAA,GAC/B,CAAC,OAAO,IAAI,MAAMrX,CAAA,CAAUwP,GAAA,GAC5B,CAAC,OAAO,IAAI,MAAMsE,CAAA,CAASwD,GAAA,GAC3B,CAAC,OAAO,IAAI,MAAMxD,CAAA,CAASyD,GAAA,GAC3B,CAAC,MAAM,IAAI,MAAMvX,CAAA,CAAUwX,EAAA,GAC3B,CAAC,OAAO,IAAI,QAAQ7O,CAAA,CAAA8O,KAAA,EAAO9O,CAAA,CAAA+O,oBAAA,GAC3B,CAAC,OAAO,IAAI,OAAO/O,CAAA,CAAAgP,MAAA,EAAQhP,CAAA,CAAAiP,qBAAA,GAC3B,CAAC,OAAO,IAAI,MAAM5X,CAAA,CAAU6X,GAAA,GAC5B,CAAC,SAAS,IAAI,MAAM7X,CAAA,CAAU8X,KAAA,GAC9B,CAAC,gBAAgB,IAAI,MAAM/O,CAAA,CAAAgP,YAAA,EAAchP,CAAA,CAAAiP,qBAAA,GACzC,CAAC,aAAa,IAAI,MAAMjP,CAAA,CAAAkP,SAAA,EAAWlP,CAAA,CAAAiP,qBAAA,GACnC,CAAC,cAAc,IAAI,MAAMjP,CAAA,CAAAmP,UAAA,EAAYnP,CAAA,CAAAiP,qBAAA,GACrC,CAAC,aAAa,IAAI,MAAMjP,CAAA,CAAAoP,SAAA,EAAWpP,CAAA,CAAAiP,qBAAA,GACnC,CAAC,cAAc,IAAI,MAAMjP,CAAA,CAAAqP,UAAA,EAAYrP,CAAA,CAAAiP,qBAAA,GACrC,CAAC,aAAa,IAAI,QAAQjP,CAAA,CAAAsP,SAAA,EAAWtP,CAAA,CAAAiP,qBAAA,GACrC,CAAC,mBAAmB,IAAI,MAAMjP,CAAA,CAAAuP,kBAAA,EAAoBvP,CAAA,CAAAiP,qBAAA,GAClD,CAAC,QAAQ,IAAI,MAAMlE,CAAA,CAASyE,IAAA,GAC5B,CAAC,WAAW,IAAI,MAAMnF,CAAA,CAAAoF,OAAA,GACtB,CAAC,UAAU,IAAI,MAAMnF,CAAA,CAAAoF,MAAA,EAAQpF,CAAA,CAAAqF,wBAAA,GAC7B,CAAC,UAAU,IAAI,OAAOrF,CAAA,CAAAoF,MAAA,EAAQpF,CAAA,CAAAsF,wBAAA,GAC9B,CAAC,SAAS,IAAI,MAAMrF,CAAA,CAAA9I,KAAA,GACpB,CAAC,WAAW,IAAI,MAAMsJ,CAAA,CAAS8E,OAAA,GAC/B,CAAC,OAAO,IAAI,MAAM9E,CAAA,CAAS+E,GAAA,GAC3B,CAAC,SAAS,IAAI,OAAOtF,CAAA,CAAAuF,QAAA,GACrB,CAAC,SAAS,IAAI,OAAOvF,CAAA,CAAA3J,KAAA,EAAO2J,CAAA,CAAAwF,oBAAA,GAE5B,CAAC,WAAW,IAAI,QAAQvF,CAAA,CAAAwF,OAAA,EAASxF,CAAA,CAAAyF,sBAAA,GACjC,CAAC,WAAW,IAAI,OAAOzF,CAAA,CAAA0F,UAAA,EAAY1F,CAAA,CAAA2F,yBAAA,GAKnC,CAAC,SAAS,IAAI,QAAQ1F,CAAA,CAAA/G,KAAA,EAAO+G,CAAA,CAAA2F,oBAAA,GAC7B,CAAC,QAAQ,IAAI,MAAMtF,CAAA,CAASuF,IAAA,GAC5B,CAAC,WAAW,IAAI,QAAQ3F,CAAA,CAAA4F,OAAA,EAAS5F,CAAA,CAAA6F,sBAAA,GACjC,CAAC,WAAW,IAAI,OAAO7F,CAAA,CAAA8F,UAAA,GACvB,CAAC,OAAO,IAAI,MAAMxZ,CAAA,CAAUuP,GAAA,GAC5B,CAAC,OAAO,IAAI,MAAMoE,CAAA,CAAA8F,GAAA,GAClB,CAAC,OAAO,IAAI,MAAM3F,CAAA,CAAS4F,GAAA,GAC3B,CAAC,QAAQ,IAAI,MAAM5F,CAAA,CAAS6F,IAAA,GAC5B,CAAC,QAAQ,IAAI,MAAM/F,CAAA,CAAAgG,IAAA,GACnB,CAAC,aAAa,IAAI,MAAM/F,CAAA,CAAAgG,SAAA,EAAWhG,CAAA,CAAAiG,wBAAA,GACnC,CAAC,YAAY,IAAI,OAAOzc,CAAA,CAAA0c,QAAA,EAAU1c,CAAA,CAAA2c,yBAAA,GAClC,CAAC,YAAY,IAAI,KAAK3c,CAAA,CAAA0c,QAAA,EAAU1c,CAAA,CAAA4c,yBAAA,GAChC,CAAC,aAAa,IAAI,QAAQlG,CAAA,CAAAmG,SAAA,EAAWnG,CAAA,CAAAoG,wBAAA,GACrC,CAAC,aAAa,IAAI,OAAOpG,CAAA,CAAAqG,YAAA,GACzB,CAAC,OAAO,IAAI,MAAMpa,CAAA,CAAUqa,GAAA,E;;;;;;;;QCzH9B,MAAAnd,CAAA,GAAAC,CAAA;UAIAC,CAAA,GAAAD,CAAA;UAEAQ,CAAA,GAAAR,CAAA;UAQMS,CAAA,GAAoC;YACxC8C,IAAA,EAAM;YACN4G,UAAA,EAAY,CAAC,KAAK,SAAS,KAAK,QAAQ;YACxC2I,UAAA,EACI,CAACtS,CAAA,CAAAoT,WAAA,CAAYgB,QAAA,EAAUpU,CAAA,CAAAoT,WAAA,CAAYgB,QAAA,EAAUpU,CAAA,CAAAoT,WAAA,CAAYgB,QAAA,EAAUpU,CAAA,CAAAoT,WAAA,CAAYgB,QAAA,EAAUpU,CAAA,CAAAoT,WAAA,CAAYgB,QAAA;UAAA;QAG9FpV,CAAA,CAAA6X,kBAAA,GACT,CAAC9X,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA,MAC1DiD,CAAA,CAAezD,CAAA,GAQR,CAPQD,CAAA,CAAiBmU,GAAA,CAAItR,MAAA,CAADC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAE1B5B,CAAA,GAAiC;UACpCuS,SAAA,EAAWhT,CAAA,CAAWsC,QAAA;UACtByB,GAAA,EAAKA,CAAA,KAAMlB,CAAA,CAAoCtD,CAAA,EAAkBC,CAAA,EAAQQ,CAAA;QAAA,IAE3ER,CAAA,KAIGA,CAAA,CAAA8X,iCAAA,GACR/X,CAAA;UACC,MAAMC,CAAA,GAAUD,CAAA,CAAK4d,UAAA,CAAWrZ,QAAA,CAAS,WAAW;YAC9C9D,CAAA,GAAWT,CAAA,CAAK4d,UAAA,CAAWrZ,QAAA,CAAS,YAAY;YAChD7D,CAAA,GAAUV,CAAA,CAAK4d,UAAA,CAAWnZ,MAAA,CAAO,WAAW;UAClD,QAAO,GAAAjE,CAAA,CAAA6C,2BAAA,EAA4B;YAACwa,OAAA,EAAA5d,CAAA;YAAS6d,QAAA,EAAArd,CAAA;YAAUsd,OAAA,EAAArd;UAAA,EAAS;QAAA;QAGtE,MAAM4C,CAAA,GACF0a,CAAChe,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA;YAEtD,MAAMD,CAAA,IAAO,GAAAE,CAAA,CAAAmJ,OAAA,EAAQ7J,CAAA,CAAiBiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUnF,OAAA;cAC1DW,CAAA,GAAOrD,CAAA,CAAO,GAAG4T,IAAA,CAAK/R,MAAA;cAAA,CACrB4B,CAAA,EAAY+G,CAAA,IACfzK,CAAA,CAAiBoT,8BAAA,CAA+BnT,CAAA,CAAO,GAAG4T,IAAA,EAAM5S,CAAA,CAAAoT,WAAA,CAAYgB,QAAA;cAC1EhK,CAAA,GAAe,yBACT/H,CAAA,gEAC2BI,CAAA,KAAe+G,CAAA,yCAC5BjK,CAAA,CAAKkK,SAAA,yDACNlK,CAAA,CAAKkK,SAAA,4DACDlK,CAAA,CAAKkK,SAAA,yDACZlK,CAAA,CAAKkK,SAAA,wFAE+BjK,CAAA,CAAWod,OAAA;YAErE,OAAOhb,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK5B,CAAA,GAAiC;cACpC4I,MAAA,EAAQ;gBAAC+J,IAAA,EAAM5T,CAAA,CAAO,GAAG4T,IAAA;gBAAM7O,IAAA,EAAM/E,CAAA,CAAO,GAAG+E,IAAA;gBAAM8O,WAAA,EAAa7S,CAAA,CAAAoT,WAAA,CAAYgB;cAAA;cAC9ExE,YAAA,EAAAxF;YAAA,EAAY;UAAA;UAIlB3H,CAAA,GAAkB1D,CAAA;YACtB,KAAKA,CAAA,IAA4B,MAAlBA,CAAA,CAAO8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM;YAGlB,MAAMpE,CAAA,GAAID,CAAA,CAAO;cACXS,CAAA,GAAQT,CAAA,CAAO;cACfQ,CAAA,GAAIR,CAAA,CAAO;cACXU,CAAA,GAAOV,CAAA,CAAO;cACdiB,CAAA,GAAOjB,CAAA,CAAO;YAIpB,IAAIC,CAAA,CAAE4T,IAAA,CAAK/R,MAAA,GAAS,KAA2B,MAAtBrB,CAAA,CAAMoT,IAAA,CAAK/R,MAAA,IAAkC,MAAlBtB,CAAA,CAAEqT,IAAA,CAAK/R,MAAA,IAAqC,MAArBpB,CAAA,CAAKmT,IAAA,CAAK/R,MAAA,IAC5D,MAArBb,CAAA,CAAK4S,IAAA,CAAK/R,MAAA,EACZ,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAI5D,CAAA,CAAMoT,IAAA,CAAK,OAAO5T,CAAA,CAAE4T,IAAA,CAAK,MAAMrT,CAAA,CAAEqT,IAAA,CAAK,OAAO5T,CAAA,CAAE4T,IAAA,CAAK,MAAMnT,CAAA,CAAKmT,IAAA,CAAK,OAAO5T,CAAA,CAAE4T,IAAA,CAAK,MAClF5S,CAAA,CAAK4S,IAAA,CAAK,OAAO5T,CAAA,CAAE4T,IAAA,CAAK,IAC1B,MAAM,IAAIxP,KAAA,CAAM;YAElB,IAAgB,cAAXpE,CAAA,CAAE+E,IAAA,IAAiC,cAAX/E,CAAA,CAAE+E,IAAA,IAAuC,cAAfvE,CAAA,CAAMuE,IAAA,IAAqC,cAAfvE,CAAA,CAAMuE,IAAA,IACzE,cAAXxE,CAAA,CAAEwE,IAAA,IAAiC,cAAXxE,CAAA,CAAEwE,IAAA,IAAsC,cAAdtE,CAAA,CAAKsE,IAAA,IAAoC,cAAdtE,CAAA,CAAKsE,IAAA,IACpE,cAAd/D,CAAA,CAAK+D,IAAA,IAAoC,cAAd/D,CAAA,CAAK+D,IAAA,EACnC,MAAM,IAAIX,KAAA,CAAM,8B;;;;;;;;;QCzFpB,MAAA7D,CAAA,GAAAC,CAAA;UACAC,CAAA,GAAAD,CAAA;UACAQ,CAAA,GAAAR,CAAA;UAEAS,CAAA,GAAAT,CAAA;QAEA,SAAgB6C,EAAA;UACd,MAAMtD,CAAA,GAAO;UASb,OAAO;YAACoQ,IAAA,EARK,aACLpQ,CAAA,wDAGDA,CAAA;YAIOgE,IAAA,EAAAhE,CAAA;YAAMgF,IAAA,EAAMtE,CAAA,CAAAyN,YAAA,CAAaC;UAAA,CACzC;QAAA;QACA,SAAgB1K,EAAA;UACd,MAAM1D,CAAA,GAAO;UASb,OAAO;YAACoQ,IAAA,EARK,aACLpQ,CAAA,wDAGDA,CAAA;YAIOgE,IAAA,EAAAhE,CAAA;YAAMgF,IAAA,EAAMtE,CAAA,CAAAyN,YAAA,CAAaC;UAAA,CACzC;QAAA;QACA,SAAgB3D,EAAA;UACd,MAAMzK,CAAA,GAAO;UASb,OAAO;YAACoQ,IAAA,EARK,aACLpQ,CAAA,wDAGDA,CAAA;YAIOgE,IAAA,EAAAhE,CAAA;YAAMgF,IAAA,EAAMtE,CAAA,CAAAyN,YAAA,CAAaC;UAAA,CACzC;QAAA;QACA,SAAgB/C,EAAA;UACd,MAAMrL,CAAA,GAAO;UASb,OAAO;YAACoQ,IAAA,EARK,aACLpQ,CAAA,wDAGDA,CAAA;YAIOgE,IAAA,EAAAhE,CAAA;YAAMgF,IAAA,EAAMtE,CAAA,CAAAyN,YAAA,CAAaC;UAAA,CACzC;QAAA;QACA,SAAgB9C,EAAA;UACd,MAAMtL,CAAA,GAAO;UASb,OAAO;YAACoQ,IAAA,EARK,aACLpQ,CAAA,gEAGDA,CAAA;YAIOgE,IAAA,EAAAhE,CAAA;YAAMgF,IAAA,EAAMtE,CAAA,CAAAyN,YAAA,CAAaC;UAAA,CACzC;QAAA;QACA,SAAgB7C,EAAA;UACd,MAAMvL,CAAA,GAAO;UAYb,OAAO;YAACoQ,IAAA,EAXK,aACLpQ,CAAA,+DAGDA,CAAA;YAOOgE,IAAA,EAAAhE,CAAA;YAAMgF,IAAA,EAAMtE,CAAA,CAAAyN,YAAA,CAAaC;UAAA,CACzC;QAAA;QACA,SAAgB7H,EAAA;UACd,MAAMvG,CAAA,GAAO;UAYb,OAAO;YAACoQ,IAAA,EAXK,aACLpQ,CAAA,+DAGDA,CAAA;YAOOgE,IAAA,EAAAhE,CAAA;YAAMgF,IAAA,EAAMtE,CAAA,CAAAyN,YAAA,CAAaC;UAAA,CACzC;QAAA;QACA,SAAgB1C,EAAA;UACd,MAAM1L,CAAA,GAAO;UAcb,OAAO;YAACoQ,IAAA,EAbK,aACLpQ,CAAA,8EAGDA,CAAA;YASOgE,IAAA,EAAAhE,CAAA;YAAMgF,IAAA,EAAMtE,CAAA,CAAAyN,YAAA,CAAaC;UAAA,CACzC;QAAA;QACA,SAAgB5H,EAAA;UACd,MAAMxG,CAAA,GAAO;UAcb,OAAO;YAACoQ,IAAA,EAbK,aACLpQ,CAAA,8EAGDA,CAAA;YASOgE,IAAA,EAAAhE,CAAA;YAAMgF,IAAA,EAAMtE,CAAA,CAAAyN,YAAA,CAAaC;UAAA,CACzC;QAAA;QACA,SAAgBxC,EAAA;UACd,MAAM5L,CAAA,GAAO;UAcb,OAAO;YAACoQ,IAAA,EAbK,aACLpQ,CAAA,8EAGDA,CAAA;YASOgE,IAAA,EAAAhE,CAAA;YAAMgF,IAAA,EAAMtE,CAAA,CAAAyN,YAAA,CAAaC;UAAA,CACzC;QAAA;QACA,SAAgBvC,EAAA;UACd,OAoBF,UAA2B7L,CAAA;YACzB,MAAMC,CAAA,GAAO,GAAGD,CAAA;YAShB,OAAO;cAACoQ,IAAA,EARK,aACLnQ,CAAA,oCACGD,CAAA,wBAEJC,CAAA,oCACID,CAAA;cAGGgE,IAAA,EAAA/D,CAAA;cAAM+E,IAAA,EAAMtE,CAAA,CAAAyN,YAAA,CAAaC;YAAA,CACzC;UAAA,CA/BS,CAAkB,MAC3B;QAAA;QACA,SAAgBrC,EAAA;UACd,MAAM/L,CAAA,GAAO;UAcb,OAAO;YAACoQ,IAAA,EAbK,aACLpQ,CAAA,qEAGDA,CAAA;YASOgE,IAAA,EAAAhE,CAAA;YAAMgF,IAAA,EAAMtE,CAAA,CAAAyN,YAAA,CAAaC;UAAA,CACzC;QAAA;QAhKAnO,CAAA,CAAAge,OAAA,GAAA3a,CAAA,EAYArD,CAAA,CAAAie,OAAA,GAAAxa,CAAA,EAYAzD,CAAA,CAAAke,OAAA,GAAA1T,CAAA,EAYAxK,CAAA,CAAAme,OAAA,GAAA/S,CAAA,EAYApL,CAAA,CAAAoe,SAAA,GAAA/S,CAAA,EAYArL,CAAA,CAAAqe,WAAA,GAAA/S,CAAA,EAeAtL,CAAA,CAAAse,QAAA,GAAAhY,CAAA,EAeAtG,CAAA,CAAAue,OAAA,GAAA9S,CAAA,EAiBAzL,CAAA,CAAAwe,MAAA,GAAAjY,CAAA,EAiBAvG,CAAA,CAAAye,OAAA,GAAA9S,CAAA,EAiBA3L,CAAA,CAAA0e,OAAA,GAAA9S,CAAA,EAGA5L,CAAA,CAAA2e,SAAA,GAAA7S,CAAA;QA+BA,MAAMC,CAAA,GACF6S,CAAC7e,CAAA,EAAgCC,CAAA,EAAkBQ,CAAA,EAClDD,CAAA,GAAoCP,CAAA,CAAO,GAAG+E,IAAA,EAAMtE,CAAA;YACnD,MAAMO,CAAA,GAAcjB,CAAA,CAAQiT,OAAA,CAAQrL,IAAA,GAAO1G,CAAA,CAAAmT,WAAA,CAAYC,MAAA,GAASpT,CAAA,CAAAmT,WAAA,CAAYgB,QAAA;YAC5E,OAAO;cACLrR,IAAA,EAAMvD,CAAA,CAASuD,IAAA;cACf4G,UAAA,EAAY,CAAC,KAAK;cAClB2I,UAAA,EAAY,CAACtS,CAAA,EAAaA,CAAA;cAC1BwS,SAAA,EAAW/S,CAAA;cACX8D,GAAA,EAAKA,CAAA,KAAMyH,CAAA,CAAwBjM,CAAA,EAASC,CAAA,EAAQQ,CAAA,EAAUD,CAAA;YAAA,CAC/D;UAAA;UAGDyL,CAAA,GACF6S,CAAC9e,CAAA,EAAgCC,CAAA,EAAkBQ,CAAA,EAClDC,CAAA,GAAoCT,CAAA,CAAO,GAAG+E,IAAA;YAC7C,MAAM1B,CAAA,GAActD,CAAA,CAAQiT,OAAA,CAAQrL,IAAA,GAAO1G,CAAA,CAAAmT,WAAA,CAAYC,MAAA,GAASpT,CAAA,CAAAmT,WAAA,CAAYgB,QAAA;cACtE3R,CAAA,IAAelD,CAAA,CAAA0L,SAAA,CAAU6S,QAAA,CAAS9e,CAAA,CAAO,GAAG4T,IAAA,EAAM5T,CAAA,CAAO,GAAG4T,IAAA;YAClE,IAAIpJ,CAAA,GAAcxK,CAAA,CAAO,GAAG4T,IAAA;YAE5B,MAAMxI,CAAA,GAAmBrL,CAAA,CAAQiT,OAAA,CAAQrL,IAAA;YAEzC,IAAIlE,CAAA,EAAa;cACf,MAAMxC,CAAA,GAAkBV,CAAA,CAAAgL,aAAA,CAAcwT,SAAA,CAAU/e,CAAA,CAAO,GAAG4T,IAAA,EAAM5T,CAAA,CAAO,GAAG4T,IAAA,GAAM;cAChF,KAAK3S,CAAA,EACH,MAAM,IAAImD,KAAA,CAAM;cAElBoG,CAAA,GAAcvJ,CAAA;cACd,MAAMwC,CAAA,GAAa+G,CAAA,CAAY3I,MAAA;gBACzBwJ,CAAA,GAAkC,MAA1BrL,CAAA,CAAO,GAAG4T,IAAA,CAAK/R,MAAA,GAAe7B,CAAA,CAAO,GAAG4T,IAAA,CAAK/R,MAAA,GAAS;gBAC9DyJ,CAAA,GAAkC,MAA1BtL,CAAA,CAAO,GAAG4T,IAAA,CAAK/R,MAAA,GAAe7B,CAAA,CAAO,GAAG4T,IAAA,CAAK/R,MAAA,GAAS;gBAC9DyE,CAAA,GAAmC,MAA1BtG,CAAA,CAAO,GAAG4T,IAAA,CAAK/R,MAAA,GAAe,uCAAuC;gBAC9E4J,CAAA,GAAmC,MAA1BzL,CAAA,CAAO,GAAG4T,IAAA,CAAK/R,MAAA,GAAe,uCAAuC;gBAE9E0E,CAAA,IAAO,GAAAvF,CAAA,CAAA4I,OAAA,EAAQ7J,CAAA,CAAQiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUnF,OAAA;gBACjDiJ,CAAA,GAAeP,CAAA,GAAmB,WACxC5K,CAAA,CAAS2P,IAAA,0HAIO3P,CAAA,CAASuD,IAAA,oBACvBwC,CAAA,CAAKsD,MAAA,wBAEiC,WACxCrJ,CAAA,CAAS2P,IAAA,qCACiB1M,CAAA,8BACX4H,CAAA,4BACAC,CAAA,eACbhF,CAAA,aACAmF,CAAA,oBACOjL,CAAA,CAASuD,IAAA;cAGlB,OAAO;gBACLA,IAAA,EAAMvD,CAAA,CAASuD,IAAA;gBACf4G,UAAA,EAAY,CAAC,KAAK;gBAClB2I,UAAA,EAAY,CAACjQ,CAAA,EAAaA,CAAA;gBAC1BwG,MAAA,EAAQ;kBAAC+J,IAAA,EAAMpJ,CAAA;kBAAazF,IAAA,EAAMtE,CAAA;kBAAkBoT,WAAA,EAAAxQ;gBAAA;gBACpDuN,YAAA,EAAAjF,CAAA;gBACAkF,OAAA,EAASzF;cAAA,C;;YAGb,MAAMC,CAAA,IAAO,GAAArK,CAAA,CAAA4I,OAAA,EAAQ7J,CAAA,CAAQiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUnF,OAAA;cACjD4I,CAAA,GAAe,SACrB9K,CAAA,CAAS2P,IAAA,wCAEG9E,CAAA,CAAKZ,SAAA,oCACLY,CAAA,CAAKZ,SAAA,wCACDjK,CAAA,CAASuD,IAAA,oBACvBsH,CAAA,CAAKxB,MAAA;YAIP,OAAO;cACL9F,IAAA,EAAMvD,CAAA,CAASuD,IAAA;cACf4G,UAAA,EAAY,CAAC,KAAK;cAClB2I,UAAA,EAAY,CAACjQ,CAAA,EAAaA,CAAA;cAC1BwG,MAAA,EAAQ;gBAAC+J,IAAA,EAAM5T,CAAA,CAAO,GAAG4T,IAAA;gBAAM7O,IAAA,EAAMtE,CAAA;gBAAkBoT,WAAA,EAAAxQ;cAAA;cACvDuN,YAAA,EAAAtF,CAAA;cACAuF,OAAA,GAAS;YAAA,CACV;UAAA;QAGM7Q,CAAA,CAAA8O,GAAA,GAAM,CAAC/O,CAAA,EAAgCC,CAAA,KACpC,CAACD,CAAA,CAAQmU,GAAA,CAAInI,CAAA,CAA8BhM,CAAA,EAASC,CAAA,EAAQqD,CAAA,KAAYrD,CAAA,IAE3EA,CAAA,CAAAwX,GAAA,GAAM,CAACzX,CAAA,EAAgCC,CAAA,KACpC,CAACD,CAAA,CAAQmU,GAAA,CAAInI,CAAA,CAA8BhM,CAAA,EAASC,CAAA,EAAQyL,CAAA,IAAW,SAASzL,CAAA,IAEnFA,CAAA,CAAA8S,GAAA,GAAM,CAAC/S,CAAA,EAAgCC,CAAA,KACpC,CAACD,CAAA,CAAQmU,GAAA,CAAInI,CAAA,CAA8BhM,CAAA,EAASC,CAAA,EAAQyD,CAAA,KAAYzD,CAAA,IAE3EA,CAAA,CAAA6Y,KAAA,GAAQ,CAAC9Y,CAAA,EAAgCC,CAAA,KACtC,CAACD,CAAA,CAAQmU,GAAA,CAAInI,CAAA,CAA8BhM,CAAA,EAASC,CAAA,EAAQqL,CAAA,IAAa,SAASrL,CAAA,IAErFA,CAAA,CAAA4Z,OAAA,GAAU,CAAC7Z,CAAA,EAAgCC,CAAA,KACxC,CAACD,CAAA,CAAQmU,GAAA,CAAInI,CAAA,CAA8BhM,CAAA,EAASC,CAAA,EAAQsL,CAAA,IAAe,SAAStL,CAAA,IAEvFA,CAAA,CAAAma,IAAA,GAAO,CAACpa,CAAA,EAAgCC,CAAA,KACrC,CAACD,CAAA,CAAQmU,GAAA,CAAInI,CAAA,CAA8BhM,CAAA,EAASC,CAAA,EAAQsG,CAAA,IAAY,SAAStG,CAAA,IAEpFA,CAAA,CAAA6S,GAAA,GAAM,CAAC9S,CAAA,EAAgCC,CAAA,KACpC,CAACD,CAAA,CAAQmU,GAAA,CAAInI,CAAA,CAA8BhM,CAAA,EAASC,CAAA,EAAQwK,CAAA,KAAYxK,CAAA,IAE3EA,CAAA,CAAA6a,EAAA,GAAK,CAAC9a,CAAA,EAAgCC,CAAA,KACnC,CAACD,CAAA,CAAQmU,GAAA,CAAInI,CAAA,CAA8BhM,CAAA,EAASC,CAAA,EAAQuG,CAAA,IAAU,SAASvG,CAAA,IAElFA,CAAA,CAAAkb,GAAA,GAAM,CAACnb,CAAA,EAAgCC,CAAA,KACpC,CAACD,CAAA,CAAQmU,GAAA,CAAInI,CAAA,CAA8BhM,CAAA,EAASC,CAAA,EAAQ4L,CAAA,KAAY5L,CAAA,IAE3EA,CAAA,CAAAmb,KAAA,GAAQ,CAACpb,CAAA,EAAgCC,CAAA,KACtC,CAACD,CAAA,CAAQmU,GAAA,CAAInI,CAAA,CAA8BhM,CAAA,EAASC,CAAA,EAAQ8L,CAAA,KAAc9L,CAAA,IAE7EA,CAAA,CAAA4S,GAAA,GAAM,CAAC7S,CAAA,EAAgCC,CAAA,KACpC,CAACD,CAAA,CAAQmU,GAAA,CAAInI,CAAA,CAA8BhM,CAAA,EAASC,CAAA,EAAQoL,CAAA,KAAYpL,CAAA,IAE3EA,CAAA,CAAA0d,GAAA,GAAM,CAAC3d,CAAA,EAAgCC,CAAA,KACpC,CAACD,CAAA,CAAQmU,GAAA,CAAInI,CAAA,CAA8BhM,CAAA,EAASC,CAAA,EAAQ2L,CAAA,IAAW,SAAS3L,CAAA,E;;;;;;;;QCxShG,MAAAO,CAAA,GAAAC,CAAA;QAGaR,CAAA,CAAA4V,IAAA,GACT,CAAC7V,CAAA,EAAgCC,CAAA,EAAkBQ,CAAA,MACjDC,CAAA,CAAeT,CAAA,GACR,CAACD,CAAA,CAAQ6V,IAAA,CAAK5V,CAAA,CAAO,IAAIQ,CAAA,KAGzBR,CAAA,CAAA+X,mBAAA,GAAgEhY,CAAA,IACzEQ,CAAA,CAAAye,SAAA,CAAUC,uBAAA,CAAwBlf,CAAA,CAAK4d,UAAA,CAAWnZ,MAAA,CAAO;QAE7D,MAAM/D,CAAA,GAAkBV,CAAA;UACtB,KAAKA,CAAA,IAA4B,MAAlBA,CAAA,CAAO8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM;UAGlB,IAAuB,aAAnBrE,CAAA,CAAO,GAAGgF,IAAA,EACZ,MAAM,IAAIX,KAAA,CAAM,sB;;;;;;;;;QCpBpB,MAAA7D,CAAA,GAAAC,CAAA;UAEAC,CAAA,GAAAD,CAAA;UACAQ,CAAA,GAAAR,CAAA;UAGAS,CAAA,GAAAT,CAAA;QAoHaR,CAAA,CAAAkf,mCAAA,GACT,CAACnf,CAAA,EAAgCC,CAAA,EAAkBQ,CAAA;UACjD,MAAMiD,CAAA,IApH+B+G,CAAA,GAoHcxK,CAAA,CAAO6B,MAAA,EApHDuJ,CAAA,GAoHS5K,CAAA,CAAWsC,QAAA,EApHE;YACnFiB,IAAA,EAAM;YACN4G,UAAA,EAAY5E,KAAA,CAAMoZ,IAAA,CAAK;cAACtd,MAAA,EAAQ2I;YAAA,GAAa,CAACzK,CAAA,EAAGC,CAAA,KAAM,IAAIA,CAAA;YAC3DsT,UAAA,EAAYvN,KAAA,CAAMyE,CAAA,EAAY4U,IAAA,CAAK3e,CAAA,CAAA2T,WAAA,CAAYC,MAAA;YAC/Cb,SAAA,EAAApI;UAAA;UAJwC,IAACZ,CAAA,EAAoBY,CAAA;UAqHzD,OAAOxI,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAWY,CAAA,GAAQ;YAAEc,GAAA,EAAKA,CAAA,KA7G5B,EAACxE,CAAA,EAAgCC,CAAA,EAA2BQ,CAAA,EAAkBiD,CAAA;cAC5E,MAAM+G,CAAA,GAAahK,CAAA,CAAO,GAAGoT,IAAA,CAAK3G,KAAA;cAClC,IAAIxJ,CAAA,IAAQ+G,CAAA,CAAW3I,MAAA,IAAU4B,CAAA,IAAS,IAAI+G,CAAA,CAAW3I,MAAA,EACvD,MAAM,IAAIuC,KAAA,CAAM;cAEdX,CAAA,GAAO,MACTA,CAAA,GAAO+G,CAAA,CAAW3I,MAAA,GAAS4B,CAAA;cAI7B,MAAM2H,CAAA,GAAcZ,CAAA,CAAWyC,KAAA,CAAM;cACrC,KAAK,IAAIlN,CAAA,GAAI,GAAGA,CAAA,GAAIS,CAAA,CAAOqB,MAAA,EAAQ9B,CAAA,IAAK;gBACtC,MAAMC,CAAA,GAAaQ,CAAA,CAAOT,CAAA,EAAG6T,IAAA,CAAK3G,KAAA;gBAClC,KAAK,IAAIlN,CAAA,GAAY,GAAGA,CAAA,GAAYyK,CAAA,CAAW3I,MAAA,EAAQ9B,CAAA,IAErD,IAAIA,CAAA,KAAc0D,CAAA,EAChB2H,CAAA,CAAY3H,CAAA,KAASzD,CAAA,CAAWD,CAAA,OAG7B,IAAIyK,CAAA,CAAWzK,CAAA,MAAeC,CAAA,CAAWD,CAAA,GAC5C,MAAM,IAAIqE,KAAA,CAAM,mC;;cAKtB,MAAMiH,CAAA,GAAOD,CAAA,CAAYvJ,MAAA;gBACnByJ,CAAA,IAAS,GAAArK,CAAA,CAAAoe,WAAA,EAAY,UAAUhU,CAAA;gBAC/B/E,CAAA,IAAQ,GAAAtF,CAAA,CAAA0K,iBAAA,EAAkBL,CAAA;gBAC1BI,CAAA,IAAgB,GAAAxK,CAAA,CAAAqe,iBAAA;gBAEhB/Y,CAAA,GAAS/F,CAAA,CAAO0C,GAAA,CAAInD,CAAA,IAAKA,CAAA,CAAE6T,IAAA;gBAC3BjI,CAAA,IAAW,GAAA3K,CAAA,CAAA6K,aAAA,EAAcR,CAAA;gBACzBO,CAAA,GAAoB,IAAI7F,KAAA,CAAMQ,CAAA,CAAO1E,MAAA,GAAS;cAEpD+J,CAAA,CAAQ,KAAKrF,CAAA,CAAO,GAAG9C,CAAA;cACvB,KAAK,IAAI1D,CAAA,GAAI,GAAGA,CAAA,GAAI6L,CAAA,CAAQ/J,MAAA,EAAQ9B,CAAA,IAClC6L,CAAA,CAAQ7L,CAAA,IAAK6L,CAAA,CAAQ7L,CAAA,GAAI,KAAKwG,CAAA,CAAOxG,CAAA,EAAG0D,CAAA;cAG1C,MAAMqI,CAAA,GAAUH,CAAA,CAASlI,CAAA;gBACnBsI,CAAA,GAAeJ,CAAA,CAASsB,KAAA,EAAO;gBAC/BjB,CAAA,GAAcL,CAAA,CAASxI,IAAA;cAE7B,IAAI+I,CAAA,GAAkB,OAAOJ,CAAA,MAAaF,CAAA,CAAQ,wDAEpCI,CAAA,WAAsBD,CAAA,CAAa5I,IAAA;cAEjD,KAAK,IAAIpD,CAAA,GAAI,GAAGA,CAAA,GAAI6L,CAAA,CAAQ/J,MAAA,EAAQ9B,CAAA,IAAK;gBACvC,MAAMC,CAAA,GAAQ4L,CAAA,CAAQ7L,CAAA,GAAI;gBAC1BmM,CAAA,IAAmB,qBACTJ,CAAA,MAAaF,CAAA,CAAQ7L,CAAA,SAAU+L,CAAA,OAAcF,CAAA,CAAQ7L,CAAA,GAAI,gEAErDA,CAAA,IAAKsD,CAAA,CAA0BsI,CAAA,EAAUG,CAAA,EAAS9L,CAAA,6BACjDqD,CAAA,CAA0B0I,CAAA,EAAcD,CAAA,EAAS9L,CAAA,qB;;cAGlE,MAAMoM,CAAA,GAAYR,CAAA,CAAQ/J,MAAA;gBACpB4U,CAAA,GAAQ7K,CAAA,CAAQA,CAAA,CAAQ/J,MAAA,GAAS;cACvCqK,CAAA,IAAmB,uDAELE,CAAA,IAAa/I,CAAA,CAA0BsI,CAAA,EAAUG,CAAA,EAAS2K,CAAA,2BACzDpT,CAAA,CAA0B0I,CAAA,EAAcD,CAAA,EAAS2K,CAAA;cAEhE,MAAMC,CAAA,IAAO,GAAAnW,CAAA,CAAAqJ,OAAA,EAAQ7J,CAAA,CAAQiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUnF,OAAA;gBAEjDiU,CAAA,GAAe,eACflL,CAAA,8BACeE,CAAA,CAASzI,GAAA,CAAInD,CAAA,IAAK,SAASA,CAAA,qBACxCmM,CAAA,yDAIA5F,CAAA,kEACqBqF,CAAA,CAASN,CAAA,GAAO,2BAC9BM,CAAA,CAASN,CAAA,GAAO,eAAeM,CAAA,CAASN,CAAA,GAAO,2BAC/CM,CAAA,CAASN,CAAA,GAAO,4DAEKC,CAAA,kCAE5BA,CAAA,CAAOD,CAAA,GAAO,QAAQC,CAAA,CAAOD,CAAA,GAAO,4BAChCC,CAAA,CAAOD,CAAA,GAAO,QAAQD,CAAA,CAAYC,CAAA,GAAO,4CACvBC,CAAA,oCAGtBA,CAAA,CAAOD,CAAA,GAAO,QAAQC,CAAA,CAAOD,CAAA,GAAO,4BAChCC,CAAA,CAAOD,CAAA,GAAO,QAAQD,CAAA,CAAYC,CAAA,GAAO,4CACvBC,CAAA,oCAGtBA,CAAA,CAAOD,CAAA,GAAO,QAAQC,CAAA,CAAOD,CAAA,GAAO,4BAChCC,CAAA,CAAOD,CAAA,GAAO,QAAQD,CAAA,CAAYC,CAAA,GAAO,0BACzCC,CAAA,CAAOD,CAAA,GAAO,QAAQD,CAAA,CAAYC,CAAA,GAAO,4CACvBC,CAAA,kCAEtBoL,CAAA,CAAK7M,MAAA;cAIb,OAAOjH,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK7C,CAAA,GAAQ;gBACX6J,MAAA,EAAQ;kBAAC+J,IAAA,EAAMxI,CAAA;kBAAarG,IAAA,EAAMvE,CAAA,CAAO,GAAGuE,IAAA;kBAAM8O,WAAA,EAAapT,CAAA,CAAA2T,WAAA,CAAYC;gBAAA;gBAC3EzD,YAAA,EAAA+F,CAAA;gBACA9F,OAAA,GAAS;cAAA,EAAI;YAAA,GAO+C9Q,CAAA,EAAS0D,CAAA,EAAUzD,CAAA,EAAQQ,CAAA,CAAW+e,IAAA;UAAA,EAAK;QAAA;QAG/G,MAAMlc,CAAA,GAA4Bmc,CAACzf,CAAA,EAAoBC,CAAA,EAAiBQ,CAAA;UACtE,MAAMD,CAAA,GAAaR,CAAA,CAASoM,OAAA,CAAQnM,CAAA;UAQpC,OAPYD,CAAA,CAASmD,GAAA,CAAI,CAACnD,CAAA,EAAGC,CAAA,KACvBA,CAAA,KAAQO,CAAA,GACH,GAAGR,CAAA,MAAOS,CAAA,KAEVT,CAAA,EAGAoD,IAAA,EAAM;QAAA,C;;;;;;;;QC1InB,MAAA5C,CAAA,GAAAC,CAAA;UAKAC,CAAA,GAAAD,CAAA;UAEAQ,CAAA,GAAAR,CAAA;QAMaR,CAAA,CAAAmY,MAAA,GACT,CAACpY,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA,MAC1D6K,CAAA,CAAerL,CAAA,GACXD,CAAA,CAAiBiT,OAAA,CAAQrL,IAAA,IAAQ3H,CAAA,CAAO,GAAG4T,IAAA,CAAK/R,MAAA,GAAS,IAGpD,CADH9B,CAAA,CAAiBmU,GAAA,EAAI,GAAAlT,CAAA,CAAAke,mCAAA,EAAoCnf,CAAA,EAAkBC,CAAA,EAAQQ,CAAA,GAAaR,CAAA,KAK7F,CADHD,CAAA,CAAiBmU,GAAA,CAAIjT,CAAA,CAAsClB,CAAA,EAAkBC,CAAA,EAAQQ,CAAA,GAAaR,CAAA;QAK9G,MAwEMiB,CAAA,GACFwe,CAAC1f,CAAA,EAAgCC,CAAA,EAAkBQ,CAAA;YACjD,MAAMD,CAAA,IA1EiCS,CAAA,GA0EchB,CAAA,CAAO6B,MAAA,EA1EDZ,CAAA,GA0EST,CAAA,CAAWsC,QAAA,EA1EE;cACrFiB,IAAA,EAAM;cACN4G,UAAA,EAAY5E,KAAA,CAAMoZ,IAAA,CAAK;gBAACtd,MAAA,EAAQb;cAAA,GAAa,CAACjB,CAAA,EAAGC,CAAA,KAAM,IAAIA,CAAA;cAC3DsT,UAAA,EAAYvN,KAAA,CAAM/E,CAAA,EAAYoe,IAAA,CAAK3e,CAAA,CAAA2T,WAAA,CAAYgB,QAAA;cAC/C5B,SAAA,EAAAvS;YAAA;YAJ0C,IAACD,CAAA,EAAoBC,CAAA;YA2E3D,OAAO2B,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAWtC,CAAA,GAAQ;cAAEgE,GAAA,EAAKA,CAAA,KAnE5B,EAACxE,CAAA,EAAgCC,CAAA,EAA2BQ,CAAA,EAAkBD,CAAA;gBAC5E,MAAMS,CAAA,GAAaR,CAAA,CAAO,GAAGoT,IAAA,CAAK3G,KAAA;gBAClC,IAAI1M,CAAA,IAAQS,CAAA,CAAWa,MAAA,IAAUtB,CAAA,IAAS,IAAIS,CAAA,CAAWa,MAAA,EACvD,MAAM,IAAIuC,KAAA,CAAM;gBAEd7D,CAAA,GAAO,MACTA,CAAA,GAAOS,CAAA,CAAWa,MAAA,GAAStB,CAAA;gBAI7B,MAAMU,CAAA,GAAcD,CAAA,CAAWiM,KAAA,CAAM;gBACrC,KAAK,IAAIlN,CAAA,GAAI,GAAGA,CAAA,GAAIS,CAAA,CAAOqB,MAAA,EAAQ9B,CAAA,IAAK;kBACtC,MAAMC,CAAA,GAAaQ,CAAA,CAAOT,CAAA,EAAG6T,IAAA,CAAK3G,KAAA;kBAClC,KAAK,IAAIlN,CAAA,GAAY,GAAGA,CAAA,GAAYiB,CAAA,CAAWa,MAAA,EAAQ9B,CAAA,IAErD,IAAIA,CAAA,KAAcQ,CAAA,EAChBU,CAAA,CAAYV,CAAA,KAASP,CAAA,CAAWD,CAAA,OAG7B,IAAIiB,CAAA,CAAWjB,CAAA,MAAeC,CAAA,CAAWD,CAAA,GAC5C,MAAM,IAAIqE,KAAA,CAAM,mC;;gBAKtB,MAAMiH,CAAA,GAAOpK,CAAA,CAAYY,MAAA;kBAEnByJ,CAAA,GAAmB,IAAIvF,KAAA,CAAcvF,CAAA,CAAOqB,MAAA;gBAClD,IAAIyE,CAAA,GAAc;gBAClB,KAAK,IAAIvG,CAAA,GAAI,GAAGA,CAAA,GAAIuL,CAAA,CAAiBzJ,MAAA,IAAU9B,CAAA,EAC7CuG,CAAA,IAAe9F,CAAA,CAAOT,CAAA,EAAG6T,IAAA,CAAKrT,CAAA,GAC9B+K,CAAA,CAAiBvL,CAAA,IAAKuG,CAAA;gBAGxB,IAAImF,CAAA,GAAwC;gBAG1CA,CAAA,GADEjL,CAAA,CAAOqB,MAAA,GAAS,IACsBwB,CAAA,CAA4CiI,CAAA,IAE5C7H,CAAA,CAA4C6H,CAAA;gBAGtF,MAEM/E,CAAA,GAAe,aAFqBiE,CAAA,CAAqChK,CAAA,CAAOqB,MAAA,EAAQwJ,CAAA,cAC9CD,CAAA,CAA2CE,CAAA,cAIvFG,CAAA,uCAC0BJ,CAAA,0EAC+B9K,CAAA,iEAG7CA,CAAA,eAAmBA,CAAA;gBAKnC,OAAOqC,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK7C,CAAA,GAAQ;kBACX6J,MAAA,EAAQ;oBAAC+J,IAAA,EAAM3S,CAAA;oBAAa8D,IAAA,EAAMvE,CAAA,CAAO,GAAGuE,IAAA;oBAAM8O,WAAA,EAAapT,CAAA,CAAA2T,WAAA,CAAYgB;kBAAA;kBAC3ExE,YAAA,EAAArK;gBAAA,EAAY;cAAA,GAOkD,GAAShG,CAAA,EAAUP,CAAA,EAAQQ,CAAA,CAAW+e,IAAA;YAAA,EAAK;UAAA;UAG3Glc,CAAA,GAA+CtD,CAAA,IAG5C,sDAFYA,CAAA,CAAiBmD,GAAA,CAAI,CAACnD,CAAA,EAAMC,CAAA,KAAM,YAAYD,CAAA,aAAiBC,CAAA,QAGjEmD,IAAA,CAAK;UAKlBM,CAAA,GAA+C1D,CAAA,IACjDsD,CAAA,CAA4CtD,CAAA;UAE1CyK,CAAA,GAAuCkV,CAAC3f,CAAA,EAAyBC,CAAA;YACrE,MAAMQ,CAAA,GAAsB,CAAC,mEAAmER,CAAA;YAChG,KAAK,IAAIA,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,IAAmBC,CAAA,EAC3B,MAANA,CAAA,GACFQ,CAAA,CAAUuG,IAAA,CAEN,yBAAuB/G,CAAA,gBAAiBA,CAAA,kBACnCA,CAAA,KAAMD,CAAA,GAAkB,IACjCS,CAAA,CAAUuG,IAAA,CAEN,qBAAmB/G,CAAA,kBAEvBQ,CAAA,CAAUuG,IAAA,CAEN,8BAA4B/G,CAAA,gBAAiBA,CAAA;YAMrD,OAHAQ,CAAA,CAAUuG,IAAA,CACN,QAEGvG,CAAA,CAAU2C,IAAA,CAAK,KAAK;UAAA;UAGvBiI,CAAA,GAA8CrL,CAAA;YAClD,MAAMC,CAAA,GAAsB,CAAC;YAC7B,KAAK,IAAIQ,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAiB8B,MAAA,IAAUrB,CAAA,EACnC,MAANA,CAAA,GACFR,CAAA,CAAU+G,IAAA,CAEN,kBAAgBvG,CAAA,cAAeT,CAAA,CAAiBS,CAAA,UAC3CA,CAAA,KAAMT,CAAA,CAAiB8B,MAAA,GAAS,IACzC7B,CAAA,CAAU+G,IAAA,CAEN,mBAAiBhH,CAAA,CAAiBS,CAAA,UAEtCR,CAAA,CAAU+G,IAAA,CAEN,uBAAqBvG,CAAA,cAAeT,CAAA,CAAiBS,CAAA;YAO7D,OAJAR,CAAA,CAAU+G,IAAA,CACN,QAGG/G,CAAA,CAAUmD,IAAA,CAAK,KAAK;UAAA;QAGhBnD,CAAA,CAAAoY,qBAAA,GAAmErY,CAAA,KAC5E,GAAAQ,CAAA,CAAA6C,2BAAA,EAA4B;UAACmc,IAAA,EAAMxf,CAAA,CAAK4d,UAAA,CAAWnZ,MAAA,CAAO;QAAA;QAE9D,MAAM6G,CAAA,GAAkBtL,CAAA;UACtB,KAAKA,CAAA,IAAUA,CAAA,CAAO8B,MAAA,GAAS,GAC7B,MAAM,IAAIuC,KAAA,CAAM;UAGlB,MAAMpE,CAAA,GAAYD,CAAA,CAAO,GAAGgF,IAAA;YACtBvE,CAAA,GAAsBT,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA;UAG3C,IAAkB,aAAd7B,CAAA,EACF,MAAM,IAAIoE,KAAA,CAAM;UAGlB,KAAK,MAAM7D,CAAA,IAASR,CAAA,EAAQ;YAE1B,IAAIQ,CAAA,CAAMwE,IAAA,KAAS/E,CAAA,EACjB,MAAM,IAAIoE,KAAA,CAAM;YAIlB,IAAI7D,CAAA,CAAMqT,IAAA,CAAK/R,MAAA,KAAWrB,CAAA,EACxB,MAAM,IAAI4D,KAAA,CAAM,2C;;;;;;;;;;QC5LtB,MAAA7D,CAAA,GAAAC,CAAA;UAEAC,CAAA,GAAAD,CAAA;UAEAQ,CAAA,GAAAR,CAAA;UAEAS,CAAA,GAAAT,CAAA;UACA6C,CAAA,GAAA7C,CAAA;QAyEaR,CAAA,CAAA2f,0CAAA,GACT,CAAC5f,CAAA,EAAyCC,CAAA,EAA2BQ,CAAA;UAE/D,MAAMiD,CAAA,IA1EkC+G,CAAA,GA0EkBxK,CAAA,CAAO6B,MAAA,GAAS,GA1EhBuJ,CAAA,GA0EmB5K,CAAA,CAAWsC,QAAA,EA1ES;YACzGiB,IAAA,EAAM;YACN4G,UAAA,EAAYH,CAAA,GAAU,CAAC,KAAK,KAAK,UAAU,CAAC,KAAK;YACjD8I,UAAA,EAAY9I,CAAA,GAAU,CAACxJ,CAAA,CAAAoT,WAAA,CAAYgB,QAAA,EAAUpU,CAAA,CAAAoT,WAAA,CAAYgB,QAAA,EAAUpU,CAAA,CAAAoT,WAAA,CAAYgB,QAAA,IACzD,CAACpU,CAAA,CAAAoT,WAAA,CAAYgB,QAAA,EAAUpU,CAAA,CAAAoT,WAAA,CAAYgB,QAAA;YACzD5B,SAAA,EAAApI;UAAA;UAL+C,IAACZ,CAAA,EAAkBY,CAAA;UA2E1D,OAAOxI,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKY,CAAA,GAAQ;YACXc,GAAA,EAAKA,CAAA,KApEb,EAACxE,CAAA,EAAyCC,CAAA,EAA2BQ,CAAA,EACpEiD,CAAA;cACC,MACM+G,CAAA,GADUxK,CAAA,CAAO6B,MAAA,GAAS,IACF,sCAAsC;gBAC9DuJ,CAAA,GAASpL,CAAA,CAAO,GAAG4T,IAAA,CAAK3G,KAAA;gBACxB5B,CAAA,GAASrL,CAAA,CAAO,GAAG4T,IAAA,CAAK3G,KAAA;gBACxB3B,CAAA,GAAyBD,CAAA,CAAO,KAAK5H,CAAA,CAAWmc,KAAA;cACtDrf,CAAA,CAAAwH,MAAA,CAAOE,OAAA,CACH,eACA,WAAWxE,CAAA,CAAWoc,OAAA,eAAsBpc,CAAA,CAAWqc,SAAA,WAAoBrc,CAAA,CAAWmc,KAAA,iBAClFnc,CAAA,CAAWsc,WAAA,UAAqBtc,CAAA,CAAWuc,IAAA,aAAiBvc,CAAA,CAAWqK,OAAA;cAC/E,MAAMxH,CAAA,IACF,GAAArF,CAAA,CAAAgf,oBAAA,EAAqB7U,CAAA,EAAQC,CAAA,EAAQ5H,CAAA,CAAWqc,SAAA,EAAWrc,CAAA,CAAWuc,IAAA,EAAMvc,CAAA,CAAWqK,OAAA;gBACrFrC,CAAA,IAAO,GAAAhL,CAAA,CAAAmJ,OAAA,EAAQ7J,CAAA,CAAiBiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUnF,OAAA;gBAAA;kBAC1Dwd,kBAAA,EAAC3Z,CAAA;kBAAkB4Z,eAAA,EAAExU;gBAAA,KAAmB,GAAAtI,CAAA,CAAA+c,oBAAA,EAAqB3c,CAAA;gBAE7DmI,CAAA,GAAe,mCACKnI,CAAA,CAAWqK,OAAA,CAAQ,OAAOrK,CAAA,CAAWqK,OAAA,CAAQ,oCAChDrK,CAAA,CAAWuc,IAAA,CAAK,OAAOvc,CAAA,CAAWuc,IAAA,CAAK,WAChEzZ,CAAA,mNAMkC+E,CAAA,0EAGMD,CAAA,CAAO,6DACZA,CAAA,CAAO,2DACNA,CAAA,CAAO,mEACC5H,CAAA,CAAWqc,SAAA,CAAU,gDAE7B1U,CAAA,CAAO,kFAIPC,CAAA,CAAO,kEACC5H,CAAA,CAAWqc,SAAA,CAAU,8CAC7B1U,CAAA,CAAO,8PAUzCZ,CAAA,SACAmB,CAAA,SACAF,CAAA,CAAK5B,MAAA;cAGL,OAAOjH,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKrC,CAAA,GAAQ;gBACXqJ,MAAA,EAAQ;kBAAC+J,IAAA,EAAMtN,CAAA;kBAAavB,IAAA,EAAM/E,CAAA,CAAO,GAAG+E,IAAA;kBAAM8O,WAAA,EAAa7S,CAAA,CAAAoT,WAAA,CAAYgB;gBAAA;gBAC3ExE,YAAA,EAAAhF,CAAA;gBACAiF,OAAA,GAAS;cAAA,EAAI;YAAA,GAUuC9Q,CAAA,EAAkBC,CAAA,EAAQyD,CAAA,EAAUjD,CAAA;UAAA,EAAW;QAAA,C;;;;;;;;QCnF3G,MAAAD,CAAA,GAAAC,CAAA;UACAC,CAAA,GAAAD,CAAA;UACAQ,CAAA,GAAAR,CAAA;QAEaR,CAAA,CAAAqgB,qBAAA,GACT,CAACtgB,CAAA,EAAyCC,CAAA,EAA2BQ,CAAA;UACnE,MAAMC,CAAA,GAAST,CAAA,CAAO,GAAG4T,IAAA;YACnB3S,CAAA,GAASjB,CAAA,CAAO,GAAG4T,IAAA;YACnBvQ,CAAA,IACF,GAAA9C,CAAA,CAAA0f,oBAAA,EAAqBxf,CAAA,EAAQQ,CAAA,EAAQT,CAAA,CAAWsf,SAAA,EAAWtf,CAAA,CAAWwf,IAAA,EAAMxf,CAAA,CAAWsN,OAAA;YACrFrK,CAAA,GAAY1D,CAAA,CAAiByV,aAAA,CAAcxV,CAAA,CAAO,IAAI,CAACS,CAAA,CAAO,IAAIA,CAAA,CAAO,KAAKA,CAAA,CAAO;YACrF+J,CAAA,GAAYzK,CAAA,CAAiByV,aAAA,CAAcxV,CAAA,CAAO,IAAI,CAACiB,CAAA,CAAO,IAAIA,CAAA,CAAO;YAEzEmK,CAAA,GAAepL,CAAA,CAAO6B,MAAA,GAAS,IAAI,CAAC2I,CAAA,EAAW/G,CAAA,EAAWzD,CAAA,CAAO,MAAM,CAACwK,CAAA,EAAW/G,CAAA;YACnF4H,CAAA,GAAetL,CAAA,CAAiBmU,GAAA,EAClC,GAAAlT,CAAA,CAAAsf,mCAAA,EAAoCvgB,CAAA,EAAkBqL,CAAA,EAAc5K,CAAA,GAAa4K,CAAA;UACrF,OAAOrL,CAAA,CAAiByV,aAAA,CAAcnK,CAAA,EAAchI,CAAA,CAAY;QAAA,GAGzDrD,CAAA,CAAAugB,YAAA,GACT,CAACxgB,CAAA,EAAyCC,CAAA,EAA2BQ,CAAA;UACnE,MAAMS,CAAA,GAASjB,CAAA,CAAO,GAAG4T,IAAA;YACnBvQ,CAAA,GAASrD,CAAA,CAAO,GAAG4T,IAAA;YACnBnQ,CAAA,IACF,GAAAlD,CAAA,CAAA0f,oBAAA,EAAqBhf,CAAA,EAAQoC,CAAA,EAAQ7C,CAAA,CAAWsf,SAAA,EAAWtf,CAAA,CAAWwf,IAAA,EAAMxf,CAAA,CAAWsN,OAAA;YAGrFtD,CAAA,GAAezK,CAAA,CAAiBmU,GAAA,EAClC,GAAAzT,CAAA,CAAA+f,mCAAA,EAAoCzgB,CAAA,EAAkBC,CAAA,CAAO,IAAIA,CAAA,CAAO,IAAIyD,CAAA,EAAajD,CAAA,GACzF,CAACR,CAAA,CAAO;YAGNoL,CAAA,GAAiBrL,CAAA,CAAiByV,aAAA,CAAcxV,CAAA,CAAO,IAAI,CAACqD,CAAA,CAAO,IAAIA,CAAA,CAAO,KAAKA,CAAA,CAAO,KAAKA,CAAA,CAAO;YAGtGgI,CAAA,GACiB,MAAlBrL,CAAA,CAAO6B,MAAA,GAAgB,CAACuJ,CAAA,EAAgBZ,CAAA,EAAcxK,CAAA,CAAO,MAAM,CAACoL,CAAA,EAAgBZ,CAAA;YACnFc,CAAA,GAAevL,CAAA,CAAiBmU,GAAA,EAClC,GAAAlT,CAAA,CAAAsf,mCAAA,EAAoCvgB,CAAA,EAAkBsL,CAAA,EAAc7K,CAAA,GAAa6K,CAAA;UAIrF,OADuBtL,CAAA,CAAiByV,aAAA,CAAclK,CAAA,EAAc7H,CAAA,CAC/C;QAAA,C;;;;;;;;QC7C3B,MAAAlD,CAAA,GAAAC,CAAA;UAKAC,CAAA,GAAAD,CAAA;UAEAQ,CAAA,GAAAR,CAAA;UAGAS,CAAA,GAAAT,CAAA;UAEM6C,CAAA,GACFod,CAAC1gB,CAAA,EAAeC,CAAA,EAAgBQ,CAAA,EAAaD,CAAA,EAAgBE,CAAA,EAAkBO,CAAA,MAC1EjB,CAAA,GAAQ,KAAKC,CAAA,GAASQ,CAAA,IAAOD,CAAA,GAAS,KAAKE,CAAA,GAAW,IAAIO,CAAA;UAE7DyC,CAAA,GAAoBid,CAAC3gB,CAAA,EAAkBC,CAAA,EAAiBQ,CAAA,EAAgBD,CAAA,EAAcE,CAAA;YAC1F,MAAMO,CAAA,GAAWe,IAAA,CAAKoX,KAAA,CAAMpZ,CAAA,GAAW;YACvB,iBAAZC,CAAA,IACFQ,CAAA,CAAKD,CAAA,IAAQS,CAAA,EACbR,CAAA,CAAKC,CAAA,IAAQV,CAAA,GAAWiB,CAAA,IACH,iBAAZhB,CAAA,KACTQ,CAAA,CAAKD,CAAA,IAAQR,CAAA,GAAWiB,CAAA,EACxBR,CAAA,CAAKC,CAAA,IAAQO,CAAA,C;;QA0BJhB,CAAA,CAAAuY,aAAA,GACT,CAACxY,CAAA,EAAoCC,CAAA,EAAkBQ,CAAA,MACrD8K,CAAA,CAAetL,CAAA,EAAQQ,CAAA,GAChBgK,CAAA,CAAgBzK,CAAA,EAAkBC,CAAA,EAAQQ,CAAA;QAGvD,MAAMgK,CAAA,GACFmW,CAAC5gB,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA;YAC1D,MAAMD,CAAA,GAAqB8K,CAAA,CAAmC7K,CAAA,EAAYR,CAAA;YAC1E,OAAO,CAACoL,CAAA,CAAwBrL,CAAA,EAAkBC,CAAA,EAAQO,CAAA,EAAoB;UAAA;UAiF9E6K,CAAA,GACFwV,CAAC7gB,CAAA,EAAyCC,CAAA,EAA2BQ,CAAA,KAEhDT,CAAA,CAAiBmU,GAAA,CAbtC,EAACnU,CAAA,EAAyCC,CAAA,EAA2BQ,CAAA;YAE/D,MAAMD,CAAA,IAtE4B8C,CAAA,GAsEkBrD,CAAA,CAAO6B,MAAA,GAAS,GAtEhB4B,CAAA,GAsEmBjD,CAAA,CAAWsC,QAAA,EAtER;cAClFiB,IAAA,EAAM;cACN4G,UAAA,EAAYtH,CAAA,GAAU,CAAC,KAAK,KAAK,OAAO,CAAC,KAAK;cAC9CiQ,UAAA,EAAYjQ,CAAA,GAAU,CAACrC,CAAA,CAAAoT,WAAA,CAAYgB,QAAA,EAAUpU,CAAA,CAAAoT,WAAA,CAAYgB,QAAA,EAAUpU,CAAA,CAAAoT,WAAA,CAAYgB,QAAA,IACzD,CAACpU,CAAA,CAAAoT,WAAA,CAAYgB,QAAA,EAAUpU,CAAA,CAAAoT,WAAA,CAAYgB,QAAA;cACzD5B,SAAA,EAAA/P;YAAA;YALyC,IAACJ,CAAA,EAAkBI,CAAA;YAuEpD,OAAOb,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKtC,CAAA,GAAQ;cACXgE,GAAA,EAAKA,CAAA,KAhEb,EAACxE,CAAA,EAAyCC,CAAA,EAA2BQ,CAAA,EACpED,CAAA;gBACC,MACM8C,CAAA,GADUrD,CAAA,CAAO6B,MAAA,GAAS,IACJ,yBAAyB;kBAC/C4B,CAAA,GAASzD,CAAA,CAAO,GAAG4T,IAAA;kBACnBpJ,CAAA,GAASxK,CAAA,CAAO,GAAG4T,IAAA;kBACnBxI,CAAA,GAAyBZ,CAAA,CAAO;kBAChCa,CAAA,GAAwBb,CAAA,CAAO,KAAKjK,CAAA,CAAWqf,KAAA;kBAC/CtU,CAAA,GAAc,CAACtL,CAAA,CAAO,GAAG4T,IAAA,CAAK,IAAI5T,CAAA,CAAO,GAAG4T,IAAA,CAAK,KAAKrT,CAAA,CAAWqf,KAAA,KAAUrf,CAAA,CAAWsgB,WAAA;kBACtFva,CAAA,IAAO,GAAA7F,CAAA,CAAAmJ,OAAA,EAAQ7J,CAAA,CAAiBiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUnF,OAAA;kBAAA;oBAC1Dwd,kBAAA,EAACzU,CAAA;oBAAkB0U,eAAA,EAAE5Z;kBAAA,KAAmB,GAAAtF,CAAA,CAAAmf,oBAAA,EAAqB7f,CAAA;kBAE7DoL,CAAA,GAAe,mCACKpL,CAAA,CAAWuN,OAAA,CAAQ,OAAOvN,CAAA,CAAWuN,OAAA,CAAQ,oCAChDvN,CAAA,CAAWyf,IAAA,CAAK,OAAOzf,CAAA,CAAWyf,IAAA,CAAK,WAChEvU,CAAA,uMAQkCL,CAAA,wDACcA,CAAA,0BAEhC/H,CAAA,0DACkCgI,CAAA,gEACfA,CAAA,0DACHb,CAAA,CAAO,uDACLA,CAAA,CAAO,wDACNjK,CAAA,CAAWuf,SAAA,CAAU,eAAevf,CAAA,CAAWuf,SAAA,CAAU,wLAKtDrc,CAAA,CAAO,kDACPA,CAAA,CAAO,yPAS3C8C,CAAA,SACAD,CAAA,CAAKuD,MAAA;gBAGL,OAAOjH,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKrC,CAAA,GAAQ;kBACXqJ,MAAA,EAAQ;oBAAC+J,IAAA,EAAMtI,CAAA;oBAAavG,IAAA,EAAM/E,CAAA,CAAO,GAAG+E,IAAA;oBAAM8O,WAAA,EAAa7S,CAAA,CAAAoT,WAAA,CAAYgB;kBAAA;kBAC3ExE,YAAA,EAAAjF,CAAA;kBACAkF,OAAA,GAAS;gBAAA,EAAI;cAAA,GAUyC9Q,CAAA,EAAkBC,CAAA,EAAQO,CAAA,EAAUC,CAAA;YAAA,EAAW;UAAA,GASlDT,CAAA,EAAkBC,CAAA,EAAQQ,CAAA,GAAaR,CAAA;UAI5FqL,CAAA,GAAqCyV,CAAoC/gB,CAAA,EAAeC,CAAA;YAC5F,MAAMQ,CAAA,GAAcT,CAAA,CAAWggB,WAAA,CAAY9S,KAAA;YAE3C,IAAsC,MAAlClN,CAAA,CAAWggB,WAAA,CAAYle,MAAA,EACzB,KAAK,IAAI9B,CAAA,GAAI,GAAGA,CAAA,GAAIC,CAAA,CAAO,GAAG4T,IAAA,CAAK/R,MAAA,IAAU9B,CAAA,EAC3CS,CAAA,CAAYuG,IAAA,CAAK/G,CAAA,CAAO,GAAG4T,IAAA,CAAK7T,CAAA;YAIpC,MAAMQ,CAAA,GAAOR,CAAA,CAAWigB,IAAA,CAAK/S,KAAA;cACvBxM,CAAA,GAAcV,CAAA,CAAW8gB,WAAA,CAAY5T,KAAA;YAjIzC,EAAClN,CAAA,EAA+BC,CAAA,EAAgCQ,CAAA,EAA8BD,CAAA,EAC7FE,CAAA,EAAgBO,CAAA,EAA4BC,CAAA,EAAkCuJ,CAAA;cAC7E,MAAMY,CAAA,GAAcrL,CAAA,CAAW8B,MAAA,GAAS;gBAClCwJ,CAAA,GAAqC,MAAvBb,CAAA,CAAY3I,MAAA;cAChC,KAAK,IAAIyJ,CAAA,GAAI,GAAGA,CAAA,GAAIF,CAAA,IAAeE,CAAA,EAAG;gBACpC,MAAMhF,CAAA,GAAU+E,CAAA,GAActL,CAAA,CAAWuL,CAAA,GAAI,KAAKtK,CAAA,CAAQsK,CAAA,IAAKd,CAAA,CAAYc,CAAA;kBACrEG,CAAA,GAAWpI,CAAA,CAAgBtD,CAAA,CAAWuL,CAAA,GAAI,IAAItK,CAAA,CAAQsK,CAAA,GAAI7K,CAAA,CAAK6K,CAAA,GAAItL,CAAA,CAAYsL,CAAA,GAAI9K,CAAA,CAAU8K,CAAA,GAAIhF,CAAA;gBACvG7C,CAAA,CAAkBgI,CAAA,EAAUlL,CAAA,EAASE,CAAA,EAAM6K,CAAA,EAAGA,CAAA,GAAIF,CAAA,GAC9CC,CAAA,IACFb,CAAA,CAAYzD,IAAA,CACR/F,CAAA,CAAQsK,CAAA,KAAMvL,CAAA,CAAWuL,CAAA,GAAI,KAAK,KAAKrK,CAAA,CAAcqK,CAAA,KAAMtL,CAAA,CAAYsL,CAAA,IAAK,KAAK9K,CAAA,CAAU8K,CAAA,IAAK,IAChG7K,CAAA,CAAK6K,CAAA,IAAK7K,CAAA,CAAK6K,CAAA,GAAIF,CAAA,E;;eAuHZpL,CAAA,CAAO,GAAG4T,IAAA,EAIbpT,CAAA,EAAaT,CAAA,CAAW+f,SAAA,EAAW/f,CAAA,CAAW8f,OAAA,EAAStf,CAAA,EAAMR,CAAA,CAAW+N,OAAA,EACpF/N,CAAA,CAAWghB,aAAA,EAAetgB,CAAA;YAG9B,MAAMO,CAAA,GAAmB4B,MAAA,CAAOC,MAAA,CAAO,CAAC,GAAG9C,CAAA;YAE3C,OADA6C,MAAA,CAAOC,MAAA,CAAO7B,CAAA,EAAe;cAAC+e,WAAA,EAAAvf,CAAA;cAAawf,IAAA,EAAAzf,CAAA;cAAMsgB,WAAA,EAAApgB,CAAA;cAAaqC,QAAA,EAAU/C,CAAA,CAAW+C;YAAA,IAC5E9B,CAAa;UAAA;QAGThB,CAAA,CAAAwY,4BAAA,GACRzY,CAAA;UACC,MAAMC,CAAA,GAAaD,CAAA,CAAK4d,UAAA;YAClBnd,CAAA,IAAuB,GAAAS,CAAA,CAAA+f,iCAAA,EAAkChhB,CAAA;YAEzDS,CAAA,GAAUT,CAAA,CAAWyE,SAAA,CAAU,YAAY;YAC3CzD,CAAA,GAAYhB,CAAA,CAAW4E,OAAA,CAAQ,aAAa,CAAC,GAAG;YAChDvB,CAAA,GAAQrD,CAAA,CAAWwE,MAAA,CAAO,SAAS;YACnCf,CAAA,GAAczD,CAAA,CAAW4E,OAAA,CAAQ,gBAAgB;YACjD4F,CAAA,GAAgBxK,CAAA,CAAW4E,OAAA,CAAQ,kBAAkB,CAAC,GAAG;YACzDwG,CAAA,GAAcpL,CAAA,CAAW4E,OAAA,CAAQ,gBAAgB;YACjDyG,CAAA,GAAOrL,CAAA,CAAW4E,OAAA,CAAQ,QAAQ,CAAC,GAAG,GAAG,GAAG;YAC5C0G,CAAA,GAAUtL,CAAA,CAAW4E,OAAA,CAAQ,WAAW,CAAC,GAAG;UAElD,QAAO,GAAArE,CAAA,CAAA6C,2BAAA,EAA2BR,MAAA,CAAAC,MAAA;YAC7Bgd,OAAA,EAAApf,CAAA;YAASqf,SAAA,EAAA9e,CAAA;YAAW4e,KAAA,EAAAvc,CAAA;YAAO0c,WAAA,EAAAtc,CAAA;YAAasd,aAAA,EAAAvW,CAAA;YAAeqW,WAAA,EAAAzV,CAAA;YAAa4U,IAAA,EAAA3U,CAAA;YAAMyC,OAAA,EAAAxC;UAAA,GAAY9K,CAAA,EAAsB;QAAA;QAGvH,MAAM8K,CAAA,GAAiB2V,CAAClhB,CAAA,EAAkBC,CAAA;UAGxC,KAAKD,CAAA,IAA6B,MAAlBA,CAAA,CAAO8B,MAAA,IAAkC,MAAlB9B,CAAA,CAAO8B,MAAA,EAC5C,MAAM,IAAIuC,KAAA,CAAM;UAIlB,IAA8B,MAA1BrE,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,IAA0C,MAA1B9B,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,EAChD,MAAM,IAAIuC,KAAA,CAAM;UAMlB,IAFoBrE,CAAA,CAAO,GAAG6T,IAAA,CAAK,OACX7T,CAAA,CAAO,GAAG6T,IAAA,CAAK,IAErC,MAAM,IAAIxP,KAAA,CAAM;UAGlB,MAAM5D,CAAA,GAAcT,CAAA,CAAO,GAAG6T,IAAA,CAAK,KAAK5T,CAAA,CAAW4f,KAAA;UAGnD,IAAsB,MAAlB7f,CAAA,CAAO8B,MAAA,KAA2C,MAA1B9B,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,IAAgB9B,CAAA,CAAO,GAAG6T,IAAA,CAAK,OAAOpT,CAAA,GAC/E,MAAM,IAAI4D,KAAA,CAAM;UAGlB,MAAM7D,CAAA,GAAcR,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,GAAS;UAE5C,IAAI7B,CAAA,CAAW8f,SAAA,CAAUje,MAAA,KAAWtB,CAAA,EAClC,MAAM,IAAI6D,KAAA,CAAM,uBAAuB7D,CAAA;UAIzC,IAAIP,CAAA,CAAW8N,OAAA,CAAQjM,MAAA,KAAWtB,CAAA,EAChC,MAAM,IAAI6D,KAAA,CAAM,qBAAqB7D,CAAA;UAIvC,IAAIP,CAAA,CAAWggB,IAAA,CAAKne,MAAA,KAAyB,IAAdtB,CAAA,EAC7B,MAAM,IAAI6D,KAAA,CAAM,kBAAgC,IAAd7D,CAAA;UAIpC,IAAIP,CAAA,CAAW+gB,aAAA,CAAclf,MAAA,KAAWtB,CAAA,EACtC,MAAM,IAAI6D,KAAA,CAAM,4BAA4B7D,CAAA;UAK9C,IAAsC,MAAlCP,CAAA,CAAW+f,WAAA,CAAYle,MAAA,IAAgB7B,CAAA,CAAW+f,WAAA,CAAYle,MAAA,KAAW9B,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,GAAS,GACnG,MAAM,IAAIuC,KAAA,CAAM;UAIlB,IAAsC,MAAlCpE,CAAA,CAAW6gB,WAAA,CAAYhf,MAAA,IAAgB7B,CAAA,CAAW6gB,WAAA,CAAYhf,MAAA,KAAW9B,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,GAAS,GACnG,MAAM,IAAIuC,KAAA,CAAM;UAIlB,IAAuB,cAAnBrE,CAAA,CAAO,GAAGgF,IAAA,IAAyC,cAAnBhF,CAAA,CAAO,GAAGgF,IAAA,EAC5C,MAAM,IAAIX,KAAA,CAAM;UAGlB,IAAsB,MAAlBrE,CAAA,CAAO8B,MAAA,IAAmC,cAAnB9B,CAAA,CAAO,GAAGgF,IAAA,EACnC,MAAM,IAAIX,KAAA,CAAM,mD;;;;;;;;;QC7PpB,MAAA7D,CAAA,GAAAC,CAAA;UAKAC,CAAA,GAAAD,CAAA;UAGAQ,CAAA,GAAAR,CAAA;UACAS,CAAA,GAAAT,CAAA;UACA6C,CAAA,GAAA7C,CAAA;UACAiD,CAAA,GAAAjD,CAAA;UACAgK,CAAA,GAAAhK,CAAA;UACA4K,CAAA,GAAA5K,CAAA;QAGaR,CAAA,CAAAigB,oBAAA,GACT,CAAClgB,CAAA,EAA+BC,CAAA,EAAgCQ,CAAA,EAC/DD,CAAA,EAA+BE,CAAA;UAC9B,MAAMO,CAAA,GAAYjB,CAAA,CAAW;YACvBkB,CAAA,GAAoBlB,CAAA,CAAWkN,KAAA,CAAM;YACrC5J,CAAA,GAAcpC,CAAA,CAAkBY,MAAA;YAChC4B,CAAA,GAAczD,CAAA,CAAY;YAE1BwK,CAAA,GADqBxK,CAAA,CAAYiN,KAAA,CAAM,GACC/J,GAAA,CAAI,CAACnD,CAAA,EAAGC,CAAA,KAAMD,CAAA,IAAKA,CAAA,GAAI,MAAMS,CAAA,CAAUR,CAAA,IAAK;YAEpFoL,CAAA,GAD2BnK,CAAA,CAAkBiC,GAAA,CAAI,CAACnD,CAAA,EAAGC,CAAA,KAAMD,CAAA,GAAIQ,CAAA,CAAWP,CAAA,IAAKO,CAAA,CAAWP,CAAA,GAAIqD,CAAA,GAEvEH,GAAA,CAAI,CAACnD,CAAA,EAAGC,CAAA,KAAM+B,IAAA,CAAKoX,KAAA,EAAOpZ,CAAA,GAAIyK,CAAA,CAAmBxK,CAAA,IAAKS,CAAA,CAAQT,CAAA,KAAMS,CAAA,CAAQT,CAAA;UAEzG,OADoB,CAACgB,CAAA,EAAWyC,CAAA,EAAa0U,MAAA,IAAU/M,CAAA,CACrC;QAAA,GAYXpL,CAAA,CAAAqY,IAAA,GACT,CAACtY,CAAA,EAAoCC,CAAA,EAAkBQ,CAAA,MACrD+F,CAAA,CAAevG,CAAA,EAAQQ,CAAA,GAChB6K,CAAA,CAAOtL,CAAA,EAAkBC,CAAA,EAAQQ,CAAA;QAG9C,MAAM6K,CAAA,GACF6V,CAACnhB,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA;YAC1D,MAAMD,CAAA,GAAqBkL,CAAA,CAA0BjL,CAAA,EAAYR,CAAA;cAC3DS,CAAA,GAAWV,CAAA,CAAiBiT,OAAA,CAAQrL,IAAA;cACpCtE,CAAA,GAAoD,MAAtC9C,CAAA,CAAmBwf,WAAA,CAAY,MAAkD,MAAtCxf,CAAA,CAAmBwf,WAAA,CAAY;YAC9F,OAAIxf,CAAA,CAAmBqf,KAAA,GAAQ,IAGtB,CAFQ7f,CAAA,CAAiBmU,GAAA,EAC5B,GAAAlT,CAAA,CAAA2e,0CAAA,EAA2C5f,CAAA,EAAkBC,CAAA,EAAQO,CAAA,GAAqBP,CAAA,KAErFqD,CAAA,IAAe5C,CAAA,GACjB,CAAC6K,CAAA,CAAwBvL,CAAA,EAAkBC,CAAA,EAAQO,CAAA,KACjDE,CAAA,IAAsC,MAA1BT,CAAA,CAAO,GAAG4T,IAAA,CAAK/R,MAAA,IAAsC,MAAtB7B,CAAA,CAAO,GAAG4T,IAAA,CAAK,OAAavQ,CAAA,GACzE,EAAC,GAAApC,CAAA,CAAAsf,YAAA,EAAaxgB,CAAA,EAAkBC,CAAA,EAAQO,CAAA,KAExC,CAAC+F,CAAA,CAAevG,CAAA,EAAkBC,CAAA,EAAQO,CAAA,E;;UAInD+K,CAAA,GACF6V,CAACphB,CAAA,EAAyCS,CAAA,EAA2BD,CAAA;YACnE,MAAME,CAAA,GAASD,CAAA,CAAO,GAAGoT,IAAA;cACnB5S,CAAA,GAASR,CAAA,CAAO,GAAGoT,IAAA;cACnB3S,CAAA,IACF,GAAAjB,CAAA,CAAAigB,oBAAA,EAAqBxf,CAAA,EAAQO,CAAA,EAAQT,CAAA,CAAWuf,SAAA,EAAWvf,CAAA,CAAWyf,IAAA,EAAMzf,CAAA,CAAWuN,OAAA;cACrFzK,CAAA,GAAYtD,CAAA,CAAiBoV,eAAA,CAAgB3U,CAAA,CAAO,IAAI,CAACC,CAAA,CAAO,IAAIA,CAAA,CAAO,KAAKA,CAAA,CAAO;cACvFgD,CAAA,GAAY1D,CAAA,CAAiBoV,eAAA,CAAgB3U,CAAA,CAAO,IAAI,CAACQ,CAAA,CAAO,IAAIA,CAAA,CAAO;cAE3EwJ,CAAA,GAAehK,CAAA,CAAOqB,MAAA,GAAS,IAAI,CAAC4B,CAAA,EAAWJ,CAAA,EAAW7C,CAAA,CAAO,MAAM,CAACiD,CAAA,EAAWJ,CAAA;cACnFgI,CAAA,GAAetL,CAAA,CAAiBmU,GAAA,EAAI,GAAA9I,CAAA,CAAAgW,6BAAA,EAA8B5W,CAAA,EAAcjK,CAAA,GAAaiK,CAAA;YACnG,OAAOzK,CAAA,CAAiBoV,eAAA,CAAgB9J,CAAA,EAAcpK,CAAA,CAAY;UAAA;UAGlEqF,CAAA,GACF+a,CAACthB,CAAA,EAAyCS,CAAA,EAA2BD,CAAA;YACnE,MAAME,CAAA,GAASD,CAAA,CAAO,GAAGoT,IAAA;cACnB5S,CAAA,GAASR,CAAA,CAAO,GAAGoT,IAAA;cACnB3S,CAAA,IACF,GAAAjB,CAAA,CAAAigB,oBAAA,EAAqBxf,CAAA,EAAQO,CAAA,EAAQT,CAAA,CAAWuf,SAAA,EAAWvf,CAAA,CAAWyf,IAAA,EAAMzf,CAAA,CAAWuN,OAAA;cACrFrK,CAAA,GAAU1D,CAAA,CAAiBmU,GAAA,EAC7B,GAAA1J,CAAA,CAAA8W,6BAAA,EAA8BvhB,CAAA,EAAkBS,CAAA,CAAO,IAAIA,CAAA,CAAO,IAAIS,CAAA,EAAaV,CAAA,GAAa,CAACC,CAAA,CAAO;cAEtG4K,CAAA,GAAqC,MAAlB5K,CAAA,CAAOqB,MAAA,GAAe,CAAC4B,CAAA,EAASjD,CAAA,CAAO,IAAIA,CAAA,CAAO,MAAM,CAACiD,CAAA,EAASjD,CAAA,CAAO;YAGlG,OAFeT,CAAA,CAAiBmU,GAAA,EAC5B,GAAA7Q,CAAA,CAAAke,iCAAA,EAAkCxhB,CAAA,EAAkBS,CAAA,EAAQS,CAAA,EAAaV,CAAA,GAAa6K,CAAA,CAC7E;UAAA;UAGbK,CAAA,GAA4B+V,CAA2BzhB,CAAA,EAAeC,CAAA;YAC1E,MAAMQ,CAAA,GAAcT,CAAA,CAAWggB,WAAA,CAAY9S,KAAA;YAE3C,IAAsC,MAAlClN,CAAA,CAAWggB,WAAA,CAAYle,MAAA,EACzB,KAAK,IAAI9B,CAAA,GAAI,GAAGA,CAAA,GAAIC,CAAA,CAAO,GAAG4T,IAAA,CAAK/R,MAAA,IAAU9B,CAAA,EAC3CS,CAAA,CAAYuG,IAAA,CAAK/G,CAAA,CAAO,GAAG4T,IAAA,CAAK7T,CAAA;YAGpC,MAAMQ,CAAA,GAAOR,CAAA,CAAWigB,IAAA,CAAK/S,KAAA;YAC7BxM,CAAA,CAAAghB,YAAA,CAAaC,wBAAA,CACT1hB,CAAA,CAAO,GAAG4T,IAAA,EAAM7T,CAAA,CAAW+N,OAAA,EAAS/N,CAAA,CAAW+f,SAAA,EAAWtf,CAAA,EAAaD,CAAA,EAAMR,CAAA,CAAW8f,OAAA;YAG5F,MAAM7e,CAAA,GAAmB4B,MAAA,CAAOC,MAAA,CAAO,CAAC,GAAG9C,CAAA;YAE3C,OADA6C,MAAA,CAAOC,MAAA,CAAO7B,CAAA,EAAe;cAAC+e,WAAA,EAAAvf,CAAA;cAAawf,IAAA,EAAAzf,CAAA;cAAMuC,QAAA,EAAU/C,CAAA,CAAW+C;YAAA,IAC/D9B,CAAa;UAAA;QAGThB,CAAA,CAAAsY,mBAAA,GAA+DvY,CAAA;UAC1E,MAAMC,CAAA,GAAaD,CAAA,CAAK4d,UAAA;YAClBnd,CAAA,IAAuB,GAAAiD,CAAA,CAAAud,iCAAA,EAAkChhB,CAAA;YAEzDS,CAAA,GAAUT,CAAA,CAAWyE,SAAA,CAAU,YAAY;YAC3CzD,CAAA,GAAYhB,CAAA,CAAW4E,OAAA,CAAQ,aAAa,CAAC,GAAG;YAChD3D,CAAA,GAAQjB,CAAA,CAAWwE,MAAA,CAAO,SAAS;YACnCnB,CAAA,GAAcrD,CAAA,CAAW4E,OAAA,CAAQ,gBAAgB;YACjD4F,CAAA,GAAOxK,CAAA,CAAW4E,OAAA,CAAQ,QAAQ,CAAC,GAAG,GAAG,GAAG;YAC5CwG,CAAA,GAAUpL,CAAA,CAAW4E,OAAA,CAAQ,WAAW,CAAC,GAAG;UAElD,QAAO,GAAArE,CAAA,CAAA6C,2BAAA,EAA2BR,MAAA,CAAAC,MAAA;YAAEgd,OAAA,EAAApf,CAAA;YAASqf,SAAA,EAAA9e,CAAA;YAAW4e,KAAA,EAAA3e,CAAA;YAAO8e,WAAA,EAAA1c,CAAA;YAAa2c,IAAA,EAAAxV,CAAA;YAAMsD,OAAA,EAAA1C;UAAA,GAAY5K,CAAA,EAAsB;QAAA;QAGtH,MAAM+F,CAAA,GAAiB0a,CAAClhB,CAAA,EAAkBC,CAAA;UAGxC,KAAKD,CAAA,IAA6B,MAAlBA,CAAA,CAAO8B,MAAA,IAAkC,MAAlB9B,CAAA,CAAO8B,MAAA,EAC5C,MAAM,IAAIuC,KAAA,CAAM;UAIlB,IAA8B,MAA1BrE,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,IAA0C,MAA1B9B,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,EAChD,MAAM,IAAIuC,KAAA,CAAM;UAMlB,IAFoBrE,CAAA,CAAO,GAAG6T,IAAA,CAAK,OACX7T,CAAA,CAAO,GAAG6T,IAAA,CAAK,KAAK5T,CAAA,CAAW4f,KAAA,EAErD,MAAM,IAAIxb,KAAA,CAAM;UAIlB,IAAsB,MAAlBrE,CAAA,CAAO8B,MAAA,KAA2C,MAA1B9B,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,IAAgB9B,CAAA,CAAO,GAAG6T,IAAA,CAAK,OAAO7T,CAAA,CAAO,GAAG6T,IAAA,CAAK,KAC9F,MAAM,IAAIxP,KAAA,CAAM;UAGlB,MAAM5D,CAAA,GAAcT,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,GAAS;UAE5C,IAAI7B,CAAA,CAAW8f,SAAA,CAAUje,MAAA,KAAWrB,CAAA,EAClC,MAAM,IAAI4D,KAAA,CAAM,uBAAuB5D,CAAA;UAIzC,IAAIR,CAAA,CAAW8N,OAAA,CAAQjM,MAAA,KAAWrB,CAAA,EAChC,MAAM,IAAI4D,KAAA,CAAM,qBAAqB5D,CAAA;UAIvC,IAAIR,CAAA,CAAWggB,IAAA,CAAKne,MAAA,KAAyB,IAAdrB,CAAA,EAC7B,MAAM,IAAI4D,KAAA,CAAM,kBAAgC,IAAd5D,CAAA;UAKpC,IAAsC,MAAlCR,CAAA,CAAW+f,WAAA,CAAYle,MAAA,IAAgB7B,CAAA,CAAW+f,WAAA,CAAYle,MAAA,KAAW9B,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,GAAS,GACnG,MAAM,IAAIuC,KAAA,CAAM;UAIlB,IAAuB,cAAnBrE,CAAA,CAAO,GAAGgF,IAAA,IAAyC,cAAnBhF,CAAA,CAAO,GAAGgF,IAAA,EAC5C,MAAM,IAAIX,KAAA,CAAM;UAGlB,IAAsB,MAAlBrE,CAAA,CAAO8B,MAAA,IAAmC,cAAnB9B,CAAA,CAAO,GAAGgF,IAAA,EACnC,MAAM,IAAIX,KAAA,CAAM,0C;;;;;;;;;QC7KpB,MAAA7D,CAAA,GAAAC,CAAA;QAOaR,CAAA,CAAA2Y,YAAA,GACT,CAAC5Y,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA;UAC1DC,CAAA,CAAeT,CAAA;UACf,MAAMgB,CAAA,GAAYR,CAAA,CAAWmhB,SAAA;YACvB1gB,CAAA,GAAeD,CAAA,GAAYA,CAAA;YAC3BqC,CAAA,GAAoC,UAApB7C,CAAA,CAAWohB,IAAA,GAAiB,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,KAAK,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG;YACjFne,CAAA,GAAwC,UAApBjD,CAAA,CAAWohB,IAAA,GACjC,CACE5hB,CAAA,CAAO,GAAG4T,IAAA,CAAK,IAAI5S,CAAA,EAAWA,CAAA,EAAWhB,CAAA,CAAO,GAAG4T,IAAA,CAAK,KAAK3S,CAAA,EAAcjB,CAAA,CAAO,GAAG4T,IAAA,CAAK,IAC1F5T,CAAA,CAAO,GAAG4T,IAAA,CAAK,MAEjB,CACE5T,CAAA,CAAO,GAAG4T,IAAA,CAAK,IAAI5T,CAAA,CAAO,GAAG4T,IAAA,CAAK,KAAK3S,CAAA,EAAcD,CAAA,EAAWA,CAAA,EAAWhB,CAAA,CAAO,GAAG4T,IAAA,CAAK,IAC1F5T,CAAA,CAAO,GAAG4T,IAAA,CAAK;YASfpJ,CAAA,GAAsBzK,CAAA,CAAiBoV,eAAA,CAAgBnV,CAAA,CAAO,IAAIyD,CAAA;YAGlE2H,CAAA,GAA2C;cAACyW,IAAA,EAAMxe,CAAA;cAAeP,QAAA,EAAU,GAAGO,CAAA;YAAA;YAAA,CAC7EgI,CAAA,KAAmB,GAAA9K,CAAA,CAAA2c,SAAA,EAAUnd,CAAA,EAAkB,CAACyK,CAAA,GAAsBY,CAAA;YAGvEE,CAAA,GAAqB,CACzBtL,CAAA,CAAO,GAAG4T,IAAA,CAAK,IAAI5T,CAAA,CAAO,GAAG4T,IAAA,CAAK,KAAK3S,CAAA,EAAcjB,CAAA,CAAO,GAAG4T,IAAA,CAAK,KAAK5S,CAAA,EACzEhB,CAAA,CAAO,GAAG4T,IAAA,CAAK,KAAK5S,CAAA;UAGtB,OAAO,CADQjB,CAAA,CAAiBoV,eAAA,CAAgB9J,CAAA,EAAiBC,CAAA,EAClD;QAAA,GAGRtL,CAAA,CAAA4Y,2BAAA,GACR7Y,CAAA;UAEC,MAAMC,CAAA,GAAYD,CAAA,CAAK4d,UAAA,CAAWnZ,MAAA,CAAO;UACzC,IAAIxE,CAAA,GAAY,GACd,MAAM,IAAIoE,KAAA,CAAM,qCAAqCpE,CAAA;UAEvD,MAAMQ,CAAA,GAAOT,CAAA,CAAK4d,UAAA,CAAWlZ,SAAA,CAAU,QAAQ;UAC/C,IAAa,UAATjE,CAAA,IAA2B,UAATA,CAAA,EACpB,MAAM,IAAI4D,KAAA,CAAM,sBAAsB5D,CAAA;UAExC,OAAO;YAACohB,IAAA,EAAAphB,CAAA;YAAMmhB,SAAA,EAAA3hB;UAAA,CAAU;QAAA;QAG9B,MAAMS,CAAA,GAAkBV,CAAA;UACtB,IAAsB,MAAlBA,CAAA,CAAO8B,MAAA,EACT,MAAM,IAAIuC,KAAA,CAAM,yCAAyCrE,CAAA,CAAO8B,MAAA;UAKlE,IAAuB,aAAnB9B,CAAA,CAAO,GAAGgF,IAAA,IAA+C,MAA1BhF,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,EAChD,MAAM,IAAIigB,SAAA,CAAU,oD;;;;;;;;;QCtExB,MAAAvhB,CAAA,GAAAC,CAAA;UACAC,CAAA,GAAAD,CAAA;UAEAQ,CAAA,GAAAR,CAAA;UAEAS,CAAA,GAAAT,CAAA;UACA6C,CAAA,GAAA7C,CAAA;QA2DaR,CAAA,CAAAuhB,iCAAA,GACT,CAACxhB,CAAA,EAAyCC,CAAA,EAA2BQ,CAAA,EACpEiD,CAAA;UACC,MAAM+G,CAAA,GA5D4B,EAACzK,CAAA,EAAkBC,CAAA,MAA6C;YACtG+D,IAAA,EAAM;YACN4G,UAAA,EAAY5K,CAAA,GAAU,CAAC,UAAU,KAAK,OAAO,CAAC,UAAU;YACxDuT,UAAA,EAAYvT,CAAA,GAAU,CAACiB,CAAA,CAAAoT,WAAA,CAAYgB,QAAA,EAAUpU,CAAA,CAAAoT,WAAA,CAAYK,mBAAA,EAAqBzT,CAAA,CAAAoT,WAAA,CAAYgB,QAAA,IACpE,CAACpU,CAAA,CAAAoT,WAAA,CAAYgB,QAAA,EAAUpU,CAAA,CAAAoT,WAAA,CAAYK,mBAAA;YACzD3R,QAAA,EAAU9C,CAAA,CAAW+hB;UAAA,IAuDgC/hB,CAAA,CAAO6B,MAAA,GAAS,GAAG4B,CAAA;UACpE,OAAOb,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK2H,CAAA,GAAQ;YACXjG,GAAA,EAAKA,CAAA,KAtDT,EAACxE,CAAA,EAAyCC,CAAA,EAA2BQ,CAAA,EACpEiD,CAAA,EAAuB+G,CAAA;cACtB,MAAMY,CAAA,GAAS5K,CAAA,CAAO,GAAGoT,IAAA;gBACnBvI,CAAA,GAAS7K,CAAA,CAAO,GAAGoT,IAAA;gBACnBtI,CAAA,GAAsB,CAACD,CAAA,CAAO,IAAItJ,IAAA,CAAKE,IAAA,CAAMmJ,CAAA,CAAO,KAAKC,CAAA,CAAO,KAAKA,CAAA,CAAO,KAAM;gBAClF/E,CAAA,IAAc,GAAAjD,CAAA,CAAA2e,mBAAA,EAAoB5W,CAAA,EAAQC,CAAA,EAAQ5H,CAAA;gBAAA,CACjDgI,CAAA,EAAQlF,CAAA,IACXxG,CAAA,CAAiBoT,8BAAA,CAA+B7H,CAAA,EAAqBtK,CAAA,CAAAoT,WAAA,CAAYK,mBAAA;gBAE/E9I,CAAA,GAAgBpL,CAAA,CAAA0L,SAAA,CAAUqJ,cAAA,CAAehP,CAAA;gBAAA,CACxCsF,CAAA,EAAaE,CAAA,IAChB/L,CAAA,CAAiBoT,8BAAA,CAA+B7M,CAAA,EAAatF,CAAA,CAAAoT,WAAA,CAAYK,mBAAA;gBACvE1I,CAAA,GAAOtI,CAAA,CAAY5B,MAAA;gBAEnBmK,CAAA,GAAaxL,CAAA,CAAOqB,MAAA,GAAS,IAAK,QAAQ;gBAC1CqK,CAAA,GAAYnK,IAAA,CAAKE,IAAA,CAAKmJ,CAAA,CAAO,KAAKC,CAAA,CAAO,KAAKA,CAAA,CAAO,KAAK;gBAAA;kBAC1D6U,kBAAA,EAAC9T,CAAA;kBAAkB+T,eAAA,EAAE1J;gBAAA,KAAmB,GAAAxV,CAAA,CAAAmf,oBAAA,EAAqB5V,CAAA;gBAC7DkM,CAAA,IAAO,GAAAjW,CAAA,CAAAmJ,OAAA,EAAQ7J,CAAA,CAAiBiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUnF,OAAA;gBAC1DiU,CAAA,GAAe,KACzBvK,CAAA,+BAC0BL,CAAA,gLAOOJ,CAAA,CAAc,oBAAoBA,CAAA,CAAc,oBACzEA,CAAA,CAAc,0CACYL,CAAA,CAAoB,wBACtCU,CAAA,4BACME,CAAA,kEAC+BN,CAAA,KAAgBE,CAAA,4DAChBL,CAAA,KAAWlF,CAAA,wBAC/CmQ,CAAA,CAAKjM,SAAA,2BAAoCiM,CAAA,CAAKjM,SAAA,yEAI7DgM,CAAA;cAGE,OAAO7T,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK7C,CAAA,GAAQ;gBACX6J,MAAA,EAAQ;kBAAC+J,IAAA,EAAMnQ,CAAA;kBAAasB,IAAA,EAAMvE,CAAA,CAAO,GAAGuE,IAAA;kBAAM8O,WAAA,EAAa7S,CAAA,CAAAoT,WAAA,CAAYgB;gBAAA;gBAC3ExE,YAAA,EAAA+F;cAAA,EAAY;YAAA,GAU2B5W,CAAA,EAAkByK,CAAA,EAAUxK,CAAA,EAAQQ,CAAA,EAAaiD,CAAA;UAAA,EAAW;QAAA,C;;;;;;;;QCrE3G,MAAAlD,CAAA,GAAAC,CAAA;QAGaR,CAAA,CAAAiZ,OAAA,GACT,CAAClZ,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA;UAC1DC,CAAA,CAAeT,CAAA,EAAQQ,CAAA;UAEvB,MAAMQ,CAAA,GAAaT,CAAA,CAAA0L,SAAA,CAAUgW,YAAA,CAAajiB,CAAA,CAAO,GAAG4T,IAAA,EAAMpT,CAAA;UAC1D,OAAO,CAACT,CAAA,CAAiBoV,eAAA,CAAgBnV,CAAA,CAAO,IAAIgB,CAAA,EAAY;QAAA,GAGzDhB,CAAA,CAAAkZ,sBAAA,GAA0DnZ,CAAA,IACnEA,CAAA,CAAK4d,UAAA,CAAWnZ,MAAA,CAAO,QAAQ;QAEnC,MAAM/D,CAAA,GAAiBwgB,CAAClhB,CAAA,EAAkBC,CAAA;UACxC,KAAKD,CAAA,IAA4B,MAAlBA,CAAA,CAAO8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM;UAGlB,MAAM5D,CAAA,GAAIT,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA;UACzB,IAAU,MAANrB,CAAA,EACF,MAAM,IAAI4D,KAAA,CAAM;UAGlB,IAAIpE,CAAA,IAAQQ,CAAA,IAAKR,CAAA,GAAOQ,CAAA,EACtB,MAAM,IAAI4D,KAAA,CAAM;UAIlB,IAAuB,aAAnBrE,CAAA,CAAO,GAAGgF,IAAA,EACZ,MAAM,IAAIX,KAAA,CAAM,kC;;;;;;;;;QChCpB,MAAA7D,CAAA,GAAAC,CAAA;UAGAC,CAAA,GAAAD,CAAA;QASAR,CAAA,CAAAogB,oBAAA,aAAqCrgB,CAAA;UACnC,IAAIC,CAAA;UACJ,QAAQD,CAAA,CAAWmiB,UAAA;YACjB,KAAK;cACHliB,CAAA,IAAO,GAAAS,CAAA,CAAA0hB,QAAA;cACP;YACF,KAAK;cACHniB,CAAA,IAAO,GAAAS,CAAA,CAAA2hB,WAAA;cACP;YACF,KAAK;cACHpiB,CAAA,IAAO,GAAAS,CAAA,CAAA4hB,QAAA,EAAStiB,CAAA,CAAWuiB,OAAA,EAAUviB,CAAA,CAAWwiB,OAAA;cAChD;YAEF;cACE,OAAO;gBAACrC,kBAAA,EAAoB;gBAAIC,eAAA,EAAiB;cAAA;UAAA;UAGrD,MAAM3f,CAAA,GAAiBR,CAAA,CAAK+D,IAAA;UAG5B,OAAO;YAACmc,kBAAA,EAFmBlgB,CAAA,CAAKmQ,IAAA;YAEJgQ,eAAA,EADJ,WAAW3f,CAAA;UAAA,CAErC;QAAA,GAEaR,CAAA,CAAAghB,iCAAA,GAAqCjhB,CAAA;UAChD,MAAMC,CAAA,GAAaD,CAAA,CAAW0E,SAAA,CAAU,cAAc;UAEtD,IAAmB,WAAfzE,CAAA,EAAuB;YACzB,OAAOQ,CAAA,EAASC,CAAA,IAAWV,CAAA,CAAW4E,SAAA,CAAU,qBAAqB,CAACpE,CAAA,CAAAiiB,QAAA,EAAUjiB,CAAA,CAAAkiB,QAAA;YAChF,OAAO;cAACP,UAAA,EAAAliB,CAAA;cAAYuiB,OAAA,EAAA9hB,CAAA;cAAS6hB,OAAA,EAAA9hB,CAAA;cAASuhB,kBAAA,EAAoB,GAAG/hB,CAAA,IAAcQ,CAAA,IAAWC,CAAA;YAAA,C;;UAExF,OAAO;YAACyhB,UAAA,EAAAliB,CAAA;YAAY+hB,kBAAA,EAAoB/hB;UAAA,CAAW;QAAA,C;;;;;;;;QC3CrD,MAAAO,CAAA,GAAAC,CAAA;UAEAC,CAAA,GAAAD,CAAA;UAEAQ,CAAA,GAAAR,CAAA;UAEAS,CAAA,GAAAT,CAAA;QAMaR,CAAA,CAAAoZ,MAAA,GACT,CAACrZ,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA,MAC1DgK,CAAA,CAAexK,CAAA,EAAQQ,CAAA,CAAW+e,IAAA,GAE3B,CADQxf,CAAA,CAAiBmU,GAAA,CAAIzQ,CAAA,CAA8B1D,CAAA,EAAkBC,CAAA,EAAQQ,CAAA,GAAaR,CAAA,KAIlGA,CAAA,CAAAqZ,qBAAA,GAAmEtZ,CAAA,KAC5E,GAAAQ,CAAA,CAAA6C,2BAAA,EAA4B;UAACmc,IAAA,EAAMxf,CAAA,CAAK4d,UAAA,CAAWnZ,MAAA,CAAO,QAAQ;QAAA;QAEtE,MAAMnB,CAAA,GAAwB;YAC5BU,IAAA,EAAM;YACN4G,UAAA,EAAY,CAAC,KAAK;YAClB2I,UAAA,EAAY,CAACrS,CAAA,CAAAmT,WAAA,CAAYgB,QAAA,EAAUnU,CAAA,CAAAmT,WAAA,CAAYgB,QAAA;UAAA;UAmD3C3R,CAAA,GACFif,CAAC3iB,CAAA,EAAgCC,CAAA,EAAkBQ,CAAA;YACjD,MAAMD,CAAA,GAAWqC,MAAA,CAAHC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAOQ,CAAA,GAAqB;cAAEmQ,SAAA,EAAWhT,CAAA,CAAWsC;YAAA;YAClE,OAAOF,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAWtC,CAAA,GAAQ;cAAEgE,GAAA,EAAKA,CAAA,KAlD5B,EAACxE,CAAA,EAAgCC,CAAA,EAA2BQ,CAAA,EAAkBD,CAAA;gBAC5E,MAAME,CAAA,GAAaD,CAAA,CAAO,GAAGoT,IAAA,CAAK3G,KAAA;kBAC5B5J,CAAA,GAAiB7C,CAAA,CAAO,GAAGoT,IAAA,CAAK3G,KAAA;kBAChCxJ,CAAA,GAAc,IAAIsC,KAAA,CAAMtF,CAAA,CAAWoB,MAAA,GAASwB,CAAA,CAAexB,MAAA,GAAS;gBAE1EtB,CAAA,GAAOS,CAAA,CAAAiL,SAAA,CAAU0W,aAAA,CAAcpiB,CAAA,EAAME,CAAA,CAAWoB,MAAA;gBAChD,MAAM2I,CAAA,GAAyB;gBAC/B,KAAK,IAAIzK,CAAA,GAAI,GAAGA,CAAA,GAAI0D,CAAA,CAAY5B,MAAA,EAAQ9B,CAAA,IAMlCA,CAAA,GAAIQ,CAAA,IACNkD,CAAA,CAAY1D,CAAA,IAAKU,CAAA,CAAWV,CAAA,GAC5ByK,CAAA,CAAazD,IAAA,CAAK,YAAYhH,CAAA,iBAAkBA,CAAA,SAE5CA,CAAA,GAAIQ,CAAA,GAAO8C,CAAA,CAAexB,MAAA,IAC5B4B,CAAA,CAAY1D,CAAA,IAAKsD,CAAA,CAAetD,CAAA,GAAIQ,CAAA,GACpCiK,CAAA,CAAazD,IAAA,CAAK,gBAAgBhH,CAAA,GAAIQ,CAAA,iBAAqBR,CAAA,UAE3D0D,CAAA,CAAY1D,CAAA,IAAKU,CAAA,CAAWV,CAAA,GAAIsD,CAAA,CAAexB,MAAA,GAAS,IACxD2I,CAAA,CAAazD,IAAA,CAAK,YAAYhH,CAAA,GAAIsD,CAAA,CAAexB,MAAA,GAAS,kBAAkB9B,CAAA;gBAKlF,MAGMqL,CAAA,GAAe,uCAHP3H,CAAA,CAAY5B,MAAA,IAAU,+BACtBpB,CAAA,CAAWoB,MAAA,gCACVwB,CAAA,CAAexB,MAAA,IAAU,8CAMpC2I,CAAA,CAAarH,IAAA,CAAK,6EAET5C,CAAA,uBAA2BE,CAAA,CAAWF,CAAA;gBAGnD,OAAOqC,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK7C,CAAA,GAAQ;kBACX6J,MAAA,EAAQ;oBAAC+J,IAAA,EAAMnQ,CAAA;oBAAasB,IAAA,EAAMvE,CAAA,CAAO,GAAGuE,IAAA;oBAAM8O,WAAA,EAAa5S,CAAA,CAAAmT,WAAA,CAAYgB;kBAAA;kBAC3ExE,YAAA,EAAAxF;gBAAA,EAAY;cAAA,GAO0C,GAAS7K,CAAA,EAAUP,CAAA,EAAQQ,CAAA,CAAW+e,IAAA;YAAA,EAAK;UAAA;UAGnG/U,CAAA,GAAiByW,CAAClhB,CAAA,EAAkBC,CAAA;YACxC,KAAKD,CAAA,IAA4B,MAAlBA,CAAA,CAAO8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM;YAElB,MAAM5D,CAAA,GAAaT,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA;YAClC,IAAIrB,CAAA,GAAa,GACf,MAAM,IAAI4D,KAAA,CAAM;YAElB,IAAIpE,CAAA,IAAQQ,CAAA,IAAcR,CAAA,GAAOQ,CAAA,GAAa,GAC5C,MAAM,IAAI4D,KAAA,CAAM;YAElB,KAA8C,MAA1C3D,CAAA,CAAAmiB,YAAA,CAAazW,OAAA,CAAQpM,CAAA,CAAO,GAAGgF,IAAA,GACjC,MAAM,IAAIX,KAAA,CAAM;YAElB,IAAuB,YAAnBrE,CAAA,CAAO,GAAGgF,IAAA,IAAuC,YAAnBhF,CAAA,CAAO,GAAGgF,IAAA,EAC1C,MAAM,IAAIX,KAAA,CAAM,qB;;;;;;;;;QCjGpB,MAAA7D,CAAA,GAAAC,CAAA;UAIAC,CAAA,GAAAD,CAAA;UAEAQ,CAAA,GAAAR,CAAA;QAUaR,CAAA,CAAAsZ,IAAA,GACT,CAACvZ,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA,MAC1DgK,CAAA,CAAexK,CAAA,EAAQQ,CAAA,GAEhB,CADQT,CAAA,CAAiBmU,GAAA,CAAI7Q,CAAA,CAA4BrD,CAAA,EAAQQ,CAAA,GAAaR,CAAA;QAI3F,MAAMiB,CAAA,GAAsB4hB,CAAC9iB,CAAA,EAAkBC,CAAA;UAC7C,MAAMQ,CAAA,GAAiD,MAAxCT,CAAA,CAAK4d,UAAA,CAAWnZ,MAAA,CAAO,UAAU;YAC1C/D,CAAA,GAAiD,MAAxCV,CAAA,CAAK4d,UAAA,CAAWnZ,MAAA,CAAO,UAAU;YAC1CxD,CAAA,GAAQjB,CAAA,CAAK4d,UAAA,CAAWrZ,QAAA,CAAS,SAAS;YAC1CrD,CAAA,GAAOlB,CAAA,CAAK4d,UAAA,CAAWrZ,QAAA,CAAS,QAAQ;UAC9C,QAAO,GAAA/D,CAAA,CAAA6C,2BAAA,EAA4B;YAAC0f,MAAA,EAAAtiB,CAAA;YAAQuiB,MAAA,EAAAtiB,CAAA;YAAQuiB,KAAA,EAAAhiB,CAAA;YAAOiiB,IAAA,EAAAhiB,CAAA;YAAMiiB,WAAA,EAAAljB;UAAA,EAAa;QAAA;QAGnEA,CAAA,CAAAuZ,qBAAA,GAAiExZ,CAAA,IAC1EkB,CAAA,CAAoBlB,CAAA,GAAM,IAEjBC,CAAA,CAAAwZ,sBAAA,GAAkEzZ,CAAA,IAC3EkB,CAAA,CAAoBlB,CAAA,GAAM;QAE9B,MAAMsD,CAAA,GAA8B8f,CAACpjB,CAAA,EAAkBC,CAAA;YACrD,MAAMQ,CAAA,GAAW;cACfuD,IAAA,EAAM;cACN4G,UAAA,EAA8B,MAAlB5K,CAAA,CAAO8B,MAAA,GAAe,CAAC,KAAK,KAAK,OAAO,CAAC,KAAK;cAC1DyR,UAAA,EAA8B,MAAlBvT,CAAA,CAAO8B,MAAA,GAAe,CAACb,CAAA,CAAAoT,WAAA,CAAYgB,QAAA,EAAUpU,CAAA,CAAAoT,WAAA,CAAYgB,QAAA,EAAUpU,CAAA,CAAAoT,WAAA,CAAYgB,QAAA,IACzD,CAACpU,CAAA,CAAAoT,WAAA,CAAYgB,QAAA,EAAUpU,CAAA,CAAAoT,WAAA,CAAYgB,QAAA;cACrEgO,GAAA,EAAKpjB,CAAA,CAAW8C;YAAA;YAGlB,OAAOF,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAWrC,CAAA,GAAQ;cAAE+D,GAAA,EAAKA,CAAA,KAAMd,CAAA,CAAsBjD,CAAA,EAAUT,CAAA,EAAQC,CAAA;YAAA,EAAW;UAAA;UAG/EyD,CAAA,GACF4f,CAACtjB,CAAA,EAA2BC,CAAA,EAAkBQ,CAAA;YAC5C,MAAMD,CAAA,GAASP,CAAA,CAAO,GAAG4T,IAAA,CAAK3G,KAAA;cACxBhM,CAAA,GAASjB,CAAA,CAAO,GAAG4T,IAAA,CAAK3G,KAAA;cAAA,CACvB5J,CAAA,EAAGI,CAAA,IAAKhD,CAAA,CAAA6iB,QAAA,CAASC,oBAAA,CACpBhjB,CAAA,EAAQC,CAAA,CAAWsiB,MAAA,EAAQ7hB,CAAA,EAAQT,CAAA,CAAWuiB,MAAA,EAA0B,MAAlB/iB,CAAA,CAAO6B,MAAA,GAAe7B,CAAA,CAAO,GAAG4T,IAAA,QAAO;cAC3FpJ,CAAA,GAAc,CAACnH,CAAA,EAAGI,CAAA;YACxB,KAAK+G,CAAA,EACH,MAAM,IAAIpG,KAAA,CAAM;YAElB,IAAIgH,CAAA,GAAY7K,CAAA,CAAOA,CAAA,CAAOsB,MAAA,GAAS;cACnCwJ,CAAA,GAAO;YACP7K,CAAA,CAAWsiB,MAAA,KACb1X,CAAA,GAAY7K,CAAA,CAAO,KAEjBC,CAAA,CAAWsiB,MAAA,IAAUtiB,CAAA,CAAWuiB,MAAA,GAClC1X,CAAA,GAAO,gCACE7K,CAAA,CAAWsiB,MAAA,KAAWtiB,CAAA,CAAWuiB,MAAA,GAC1C1X,CAAA,GAAO,+BACG7K,CAAA,CAAWsiB,MAAA,IAAUtiB,CAAA,CAAWuiB,MAAA,GAC1C1X,CAAA,GAAO,8BACG7K,CAAA,CAAWsiB,MAAA,IAAWtiB,CAAA,CAAWuiB,MAAA,KAC3C1X,CAAA,GAAO;YAET,MAAMC,CAAA,GAAOd,CAAA,CAAY3I,MAAA;cAInByE,CAAA,GAAe,qCACOgF,CAAA,yBAChBA,CAAA,uBACAA,CAAA,iBANuB,MAAlBtL,CAAA,CAAO6B,MAAA,GAAe,SAAS7B,CAAA,CAAO,GAAG4T,IAAA,CAAK/R,MAAA,OAAa,mFACvC,MAAlB7B,CAAA,CAAO6B,MAAA,GAAe,gCAAgC,iEAanDuJ,CAAA,6BACVE,CAAA,GAAO,4BACPA,CAAA,GAAO,0BACTD,CAAA,gEAf2B,MAAlBrL,CAAA,CAAO6B,MAAA,GAAe,2BAA2B;YAsBpE,OAAOe,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK9C,CAAA,GAAQ;cACX8J,MAAA,EAAQ;gBAAC+J,IAAA,EAAMpJ,CAAA;gBAAazF,IAAA,EAAM/E,CAAA,CAAO,GAAG+E,IAAA;gBAAM8O,WAAA,EAAa7S,CAAA,CAAAoT,WAAA,CAAYgB;cAAA;cAC3EnE,SAAA,EAAW,CACT;gBAAClN,IAAA,EAAM;gBAASgB,IAAA,EAAM;gBAASye,IAAA,EAAMhjB,CAAA,CAAWwiB;cAAA,GAAQ;gBAACjf,IAAA,EAAM;gBAAQgB,IAAA,EAAM;gBAASye,IAAA,EAAMhjB,CAAA,CAAWyiB;cAAA;cAEzGrS,YAAA,EAAAtK;YAAA,EAAY;UAAA;UAIdkE,CAAA,GAAiByW,CAAClhB,CAAA,EAAkBC,CAAA;YACxC,KAAKD,CAAA,EACH,MAAM,IAAIqE,KAAA,CAAM;YAElB,IAAIpE,CAAA,CAAWkjB,WAAA,KAAgBnjB,CAAA,CAAO8B,MAAA,GAAS,KAAK9B,CAAA,CAAO8B,MAAA,GAAS,IAClE,MAAM,IAAIuC,KAAA,CAAM;YAElB,KAAKpE,CAAA,CAAWkjB,WAAA,IAAiC,MAAlBnjB,CAAA,CAAO8B,MAAA,EACpC,MAAM,IAAIuC,KAAA,CAAM;YAIlB,IAAsB,MAAlBrE,CAAA,CAAO8B,MAAA,IAA0C,MAA1B9B,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,IAA0C,MAA1B9B,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,EACvE,MAAM,IAAIuC,KAAA,CAAM;YAGlB,IAAwB,cAAnBrE,CAAA,CAAO,GAAGgF,IAAA,IAAyC,cAAnBhF,CAAA,CAAO,GAAGgF,IAAA,IACvB,cAAnBhF,CAAA,CAAO,GAAGgF,IAAA,IAAyC,cAAnBhF,CAAA,CAAO,GAAGgF,IAAA,IACxB,MAAlBhF,CAAA,CAAO8B,MAAA,IAAmC,cAAnB9B,CAAA,CAAO,GAAGgF,IAAA,IAAyC,cAAnBhF,CAAA,CAAO,GAAGgF,IAAA,EACpE,MAAM,IAAIX,KAAA,CAAM;YAGlB,IAAKrE,CAAA,CAAO,GAAGgF,IAAA,KAAShF,CAAA,CAAO,GAAGgF,IAAA,IAA4B,MAAlBhF,CAAA,CAAO8B,MAAA,IAAgB9B,CAAA,CAAO,GAAGgF,IAAA,KAAShF,CAAA,CAAO,GAAGgF,IAAA,EAC9F,MAAM,IAAIX,KAAA,CAAM,6B;;;;;;;;;QClIpB,MAAA7D,CAAA,GAAAC,CAAA;UAEAC,CAAA,GAAAD,CAAA;UAGAQ,CAAA,GAAAR,CAAA;QA0EaR,CAAA,CAAAwgB,mCAAA,GACT,CAACzgB,CAAA,EAAyCC,CAAA,EAAWQ,CAAA,EAAWS,CAAA,EAC/DoC,CAAA;UACC,MAAMI,CAAA,IA3E+B+G,CAAA,GA2EcnH,CAAA,CAAWP,QAAA,EA3EH;YAC/DiB,IAAA,EAAM;YACN4G,UAAA,EAAY,CAAC;YACb2I,UAAA,EAAY,CAAC7S,CAAA,CAAA2T,WAAA,CAAYC,MAAA;YACzBb,SAAA,EAAAhJ;UAAA;UAJwC,IAACA,CAAA;UA4ErC,OAAO5H,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKY,CAAA,GAAQ;YACXc,GAAA,EAAKA,CAAA,KAtET,EAACxE,CAAA,EAAyCC,CAAA,EAA2BQ,CAAA,EAAWS,CAAA,EAC/EoC,CAAA,EAAgCI,CAAA;cAC/B,MAAM+G,CAAA,GAAShK,CAAA,CAAEoT,IAAA;gBACXxI,CAAA,GAASnK,CAAA,CAAE2S,IAAA;gBAGXvI,CAAA,GAAOhI,CAAA,CAAYxB,MAAA;gBACnByJ,CAAA,GAAc,CAACF,CAAA,CAAO,KAAKA,CAAA,CAAO,KAAKA,CAAA,CAAO,IAAI/H,CAAA,CAAY,KAAKA,CAAA,CAAY;gBAC/EiD,CAAA,GAAa8E,CAAA,CAAO,KAAKA,CAAA,CAAO;gBAChCK,CAAA,IAAgB,GAAAzK,CAAA,CAAAse,iBAAA;gBAChB/Y,CAAA,IAAO,GAAAhG,CAAA,CAAAqJ,OAAA,EAAQ7J,CAAA,CAAiBiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUnF,OAAA;cAChE,IAAIiJ,CAAA,GAAW;cAEf,KAAK,IAAI5L,CAAA,GAAM,GAAGA,CAAA,IAAO,GAAGA,CAAA,IAC1B,KAAK,IAAIC,CAAA,GAAM,GAAGA,CAAA,IAAO,GAAGA,CAAA,IAC1B2L,CAAA,IAAY,qCACY3L,CAAA,+BACPD,CAAA,oCAEGuL,CAAA,CAAY,eAAeA,CAAA,CAAY,oDACzBjI,CAAA,CAAYgI,CAAA,GAAO,UAAU5H,CAAA,CAAWqK,OAAA,CAAQ,yBAC1ErK,CAAA,CAAWuc,IAAA,CAAK,qCACHvc,CAAA,CAAWqc,SAAA,CAAU,mBAAmBxZ,CAAA,OAAiB8E,CAAA,CAAO,iCAEvEZ,CAAA,CApBH,gEAqBwBnH,CAAA,CAAYgI,CAAA,GAAO,SAAS5H,CAAA,CAAWqK,OAAA,CAAQ,2BACxErK,CAAA,CAAWuc,IAAA,CAAK,uCACHvc,CAAA,CAAWqc,SAAA,CAAU,uBAAuBxZ,CAAA,MAAgB8E,CAAA,CAAO,mCAE1EZ,CAAA,CAxBL,8DA0BoBlE,CAAA,kFAEN,IAANvG,CAAA,GAAUC,CAAA;cAWjC,MAAM4L,CAAA,GAAe,WACnBH,CAAA,0MAOIE,CAAA,eACApF,CAAA,CAAKsD,MAAA;cAGX,OAAOjH,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK7C,CAAA,GAAQ;gBACX6J,MAAA,EAAQ;kBAAC+J,IAAA,EAAMtI,CAAA;kBAAavG,IAAA,EAAMvE,CAAA,CAAEuE,IAAA;kBAAM8O,WAAA,EAAapT,CAAA,CAAA2T,WAAA,CAAYC;gBAAA;gBACnEzD,YAAA,EAAAhF,CAAA;gBACAiF,OAAA,GAAS;cAAA,EAAI;YAAA,GAU4B9Q,CAAA,EAAkB0D,CAAA,EAAUzD,CAAA,EAAGQ,CAAA,EAAGS,CAAA,EAAaoC,CAAA;UAAA,EAAW;QAAA,C;;;;;;;;QCpF3G,MAAA9C,CAAA,GAAAC,CAAA;QAwEaR,CAAA,CAAAshB,6BAAA,GACT,CAACvhB,CAAA,EAAyCS,CAAA,EAAWC,CAAA,EAAWO,CAAA,EAC/DC,CAAA;UACC,MAAMoC,CAAA,IAvEyBI,CAAA,GAuEcxC,CAAA,CAAW6B,QAAA,EAvEH;YACzDiB,IAAA,EAAM;YACN4G,UAAA,EAAY,CAAC;YACb2I,UAAA,EAAY,CAAC/S,CAAA,CAAA6T,WAAA,CAAYgB,QAAA;YACzB5B,SAAA,EAAA/P;UAAA;UAJkC,IAACA,CAAA;UAwE/B,OAAOb,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKQ,CAAA,GAAQ;YACXkB,GAAA,EAAKA,CAAA,KAlET,EAACxE,CAAA,EAAyCS,CAAA,EAA2BC,CAAA,EAAWO,CAAA,EAC/EC,CAAA,EAAgCoC,CAAA;cAC/B,MAAMI,CAAA,GAAShD,CAAA,CAAEmT,IAAA;gBACXpJ,CAAA,GAASxJ,CAAA,CAAE4S,IAAA;gBAEXxI,CAAA,GAAOnK,CAAA,CAAYY,MAAA;gBACnBwJ,CAAA,IAAa,GAAArL,CAAA,CAAAgiB,mBAAA,EAAoBve,CAAA,EAAQ+G,CAAA,EAAQvJ,CAAA,EAAa;gBAE9DqK,CAAA,GAAe,4BACF7H,CAAA,CAAO,+BACPA,CAAA,CAAO,+BACPA,CAAA,CAAO,+BACPJ,CAAA,CAAW0c,WAAA,CAAY,+BACvB1c,CAAA,CAAW0c,WAAA,CAAY,sCAChB1c,CAAA,CAAWyc,SAAA,CAAU,sCACrBzc,CAAA,CAAWyc,SAAA,CAAU,oCACvBzc,CAAA,CAAWyK,OAAA,CAAQ,oCACnBzK,CAAA,CAAWyK,OAAA,CAAQ,iCACtBzK,CAAA,CAAW2c,IAAA,CAAK,iCAChB3c,CAAA,CAAW2c,IAAA,CAAK,wJAIR5U,CAAA,mnBAab3H,CAAA,CAAO5B,MAAA;cAiBvB,OAAOe,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKrC,CAAA,GAAQ;gBACXqJ,MAAA,EAAQ;kBAAC+J,IAAA,EAAMvI,CAAA;kBAAYtG,IAAA,EAAMtE,CAAA,CAAEsE,IAAA;kBAAM8O,WAAA,EAAatT,CAAA,CAAA6T,WAAA,CAAYK;gBAAA;gBAClE7D,YAAA,EAAAtF;cAAA,EAAY;YAAA,GAUuB,GAAkBjI,CAAA,EAAU7C,CAAA,EAAGC,CAAA,EAAGO,CAAA,EAAaC,CAAA;UAAA,EAAW;QAAA,GAKxFjB,CAAA,CAAAgiB,mBAAA,GACT,CAACjiB,CAAA,EAA+BC,CAAA,EAAgCQ,CAAA,EAAgCD,CAAA,GAAW,MAEnG,CAACC,CAAA,CAAY,IAAIA,CAAA,CAAY,IAAIA,CAAA,CAAY,IAC5CuB,IAAA,CAAKE,IAAA,CAAKlC,CAAA,CAAW,KAAKC,CAAA,CAAY,KAAKA,CAAA,CAAY,KAAKO,CAAA,E;;;;;;;;QCzFzE,MAAAA,CAAA,GAAAC,CAAA;UAKAC,CAAA,GAAAD,CAAA;QAOaR,CAAA,CAAA6Z,WAAA,GACT,CAAC9Z,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA,MAC1DiD,CAAA,CAAezD,CAAA,GAGR,CADHD,CAAA,CAAiBmU,GAAA,CAAIjT,CAAA,CAAmClB,CAAA,EAAkBC,CAAA,EAAQQ,CAAA,GAAaR,CAAA,KAI5FA,CAAA,CAAA8Z,0BAAA,GACR/Z,CAAA;UACC,MAAMC,CAAA,GAAQD,CAAA,CAAK4d,UAAA,CAAWrZ,QAAA,CAAS;YACjC9D,CAAA,GAAOT,CAAA,CAAK4d,UAAA,CAAWhZ,SAAA,CAAU;UACvC,QAAO,GAAApE,CAAA,CAAA6C,2BAAA,EAA4B;YAACqgB,KAAA,EAAAzjB,CAAA;YAAO0jB,IAAA,EAAAljB;UAAA,EAAM;QAAA;QAGvD,MAAMQ,CAAA,GAA6B;YACjC+C,IAAA,EAAM;YACN4G,UAAA,EAAY,CAAC;YACb2I,UAAA,EAAY,CAAC7S,CAAA,CAAA2T,WAAA,CAAYgB,QAAA;UAAA;UAyBrBnU,CAAA,GACF0iB,CAAC5jB,CAAA,EAAgCC,CAAA,EAAkBQ,CAAA;YACjD,MAAMD,CAAA,GAAWqC,MAAA,CAAHC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAO7B,CAAA,GAA0B;cAAEwS,SAAA,EAAWhT,CAAA,CAAWsC;YAAA;YACvE,OAAOF,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAWtC,CAAA,GAAQ;cAAEgE,GAAA,EAAKA,CAAA,KAxB5B,EAACxE,CAAA,EAAgCC,CAAA,EAA2BQ,CAAA,EAAkBD,CAAA;gBAExE,MAAMS,CAAA,GAAcR,CAAA,CAAO,GAAGoT,IAAA,CAAK3G,KAAA;kBAC7BhM,CAAA,GAAOD,CAAA,CAAYa,MAAA;kBAEnB4B,CAAA,GAAe,WADCJ,CAAA,CAAoB9C,CAAA,CAAWmjB,IAAA,CAAK7hB,MAAA,sCAGlCZ,CAAA;gBAGxB,OAAO2B,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK7C,CAAA,GAAQ;kBACX6J,MAAA,EAAQ;oBAAC+J,IAAA,EAAM5S,CAAA;oBAAa+D,IAAA,EAAMvE,CAAA,CAAO,GAAGuE,IAAA;oBAAM8O,WAAA,EAAapT,CAAA,CAAA2T,WAAA,CAAYgB;kBAAA;kBAC3EnE,SAAA,EAAW,CACT;oBAAClN,IAAA,EAAM;oBAAQgB,IAAA,EAAM;oBAASqM,WAAA,EAAa7Q,CAAA,CAAWmjB,IAAA,CAAK7hB,MAAA;oBAAQ2hB,IAAA,EAAMjjB,CAAA,CAAWmjB;kBAAA,GACpF;oBAAC3f,IAAA,EAAM;oBAASgB,IAAA,EAAM;oBAASye,IAAA,EAAMjjB,CAAA,CAAWkjB;kBAAA;kBAElD7S,YAAA,EAAAnN;gBAAA,EAAY;cAAA,GAO2C,GAASlD,CAAA,EAAUP,CAAA,EAAQQ,CAAA;YAAA,EAAW;UAAA;UAGnG6C,CAAA,GAAuBtD,CAAA;YAC3B,MAAMC,CAAA,GAAsB,CAAC,4BAA4BD,CAAA;YACzD,KAAK,IAAIS,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,IAAeS,CAAA,EACvB,MAANA,CAAA,GACFR,CAAA,CAAU+G,IAAA,CAEN,oBAAkBvG,CAAA,mBAAoBA,CAAA,UACjCA,CAAA,KAAMT,CAAA,GAAc,IAC7BC,CAAA,CAAU+G,IAAA,CAEN,wBAAsBvG,CAAA,UAE1BR,CAAA,CAAU+G,IAAA,CAEN,yBAAuBvG,CAAA,mBAAoBA,CAAA;YAMnD,OAHAR,CAAA,CAAU+G,IAAA,CACN,QAEG/G,CAAA,CAAUmD,IAAA,CAAK,KAAK;UAAA;UAGvBM,CAAA,GAAkB1D,CAAA;YACtB,KAAKA,CAAA,IAA4B,MAAlBA,CAAA,CAAO8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAA8B,MAA1BrE,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,EACjB,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAuB,cAAnBrE,CAAA,CAAO,GAAGgF,IAAA,IAAyC,cAAnBhF,CAAA,CAAO,GAAGgF,IAAA,EAC5C,MAAM,IAAIX,KAAA,CAAM,sB;;;;;;;;;QCzFpB,MAAA7D,CAAA,GAAAC,CAAA;UAEAC,CAAA,GAAAD,CAAA;QAEaR,CAAA,CAAA+Z,qBAAA,GACT,CAACha,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA;UAC1DgK,CAAA,CAAexK,CAAA;UAEf,MAAMO,CAAA,GAAkBR,CAAA,CAAiBmU,GAAA,CAAIjT,CAAA,CAAuCjB,CAAA,CAAO,KAAKA,CAAA;UAIhG,OAAO,CAHQD,CAAA,CAAiBmU,GAAA,CAC5BzQ,CAAA,CAAqC1D,CAAA,EAAkBC,CAAA,CAAO,IAAIQ,CAAA,EAASD,CAAA,CAAgBqT,IAAA,GAC3F,CAAC5T,CAAA,CAAO,IAAIO,CAAA,EAAiBP,CAAA,CAAO,IAAIA,CAAA,CAAO,KACpC;QAAA,GAGRA,CAAA,CAAAga,oCAAA,GAAwEja,CAAA,IACjFA,CAAA,CAAK4d,UAAA,CAAWrZ,QAAA,CAAS,WAAW;QAExC,MAAMtD,CAAA,GAAiC;YACrC+C,IAAA,EAAM;YACN4G,UAAA,EAAY,CAAC;YACb2I,UAAA,EAAY,CAAC7S,CAAA,CAAA2T,WAAA,CAAYgB,QAAA;UAAA;UA8CrBnU,CAAA,GAA0ClB,CAAA,IAAsC6C,MAAA,CAADC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAChF7B,CAAA,GAA8B;YACjCuD,GAAA,EAAKA,CAAA,KA7CkC,EAACxE,CAAA,EAA2BC,CAAA;cACnE,MAAMQ,CAAA,GAAQR,CAAA,CAAM4T,IAAA,CAAK3G,KAAA;gBACnB1M,CAAA,GAAUC,CAAA,CAAM;gBAChBQ,CAAA,GAAcR,CAAA,CAAM,KAAKA,CAAA,CAAM;gBAC/BS,CAAA,GAAc,CAACT,CAAA,CAAM,IAAID,CAAA;gBAEzB8C,CAAA,GAAe,uMAOI7C,CAAA,CAAM,iEAEJA,CAAA,CAAM,wJAMCQ,CAAA,qDAETR,CAAA,CAAM,iEAEJA,CAAA,CAAM,4LAONQ,CAAA;cAI3B,OAAO4B,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK9C,CAAA,GAAQ;gBACX8J,MAAA,EAAQ;kBAAC+J,IAAA,EAAM3S,CAAA;kBAAa8D,IAAA,EAAM/E,CAAA,CAAM+E,IAAA;kBAAM8O,WAAA,EAAapT,CAAA,CAAA2T,WAAA,CAAYK;gBAAA;gBACvE7D,YAAA,EAAAvN;cAAA,EAAY;YAAA,GAM8BrC,CAAA,EAAgCjB,CAAA;UAAA;UAGxEsD,CAAA,GAA+B;YACnCU,IAAA,EAAM;YACN4G,UAAA,EAAY,CAAC,KAAK,mBAAmB,SAAS;YAC9C2I,UAAA,EAAY,CAAC7S,CAAA,CAAA2T,WAAA,CAAYgB,QAAA,EAAU3U,CAAA,CAAA2T,WAAA,CAAYK,mBAAA,EAAqBhU,CAAA,CAAA2T,WAAA,CAAYgB,QAAA,EAAU3U,CAAA,CAAA2T,WAAA,CAAYgB,QAAA;UAAA;UAwClG3R,CAAA,GACFmgB,CAAC7jB,CAAA,EAAyCC,CAAA,EAAeQ,CAAA,EAAiBQ,CAAA;YAEpE,MAAMC,CAAA,GAAW2B,MAAA,CAAHC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAOQ,CAAA,GAA4B;cAAEmQ,SAAA,EAAW,GAAGhT,CAAA;YAAA;YACjE,OAAOoC,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK5B,CAAA,GAAQ;cACXsD,GAAA,EAAKA,CAAA,KA1Cb,EAACxE,CAAA,EAAyCC,CAAA,EAA2BQ,CAAA,EAAeQ,CAAA,EACnFC,CAAA;gBACC,MAAMoC,CAAA,IAAO,GAAA9C,CAAA,CAAAqJ,OAAA,EAAQ7J,CAAA,CAAiBiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUnF,OAAA;kBAAA,CACzDe,CAAA,EAAc+G,CAAA,IACjBzK,CAAA,CAAiBoT,8BAAA,CAA+BlS,CAAA,EAAsBR,CAAA,CAAA2T,WAAA,CAAYK,mBAAA;kBAAA,CAC/ErJ,CAAA,EAAsBC,CAAA,IAAyB,CAAC5H,CAAA,GAAe,GAAG+G,CAAA;kBACnEc,CAAA,GAAe,0JAGoBF,CAAA,KAAyBC,CAAA,sBACvDhI,CAAA,CAAKoH,SAAA;gBAkBhB,OAAO7H,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK7C,CAAA,GAAQ;kBACX6J,MAAA,EAAQ;oBAAC+J,IAAA,EAAMpT,CAAA,CAAMoT,IAAA;oBAAM7O,IAAA,EAAMvE,CAAA,CAAMuE,IAAA;oBAAM8O,WAAA,EAAapT,CAAA,CAAA2T,WAAA,CAAYgB;kBAAA;kBACtEnE,SAAA,EAAW,CAAC;oBAAClN,IAAA,EAAM;oBAAWgB,IAAA,EAAM;oBAASye,IAAA,EAAMxiB;kBAAA;kBACnD4P,YAAA,EAAAtF;gBAAA,EAAY;cAAA,GAUkCvL,CAAA,EAAkBkB,CAAA,EAAUjB,CAAA,EAAOQ,CAAA,EAASQ,CAAA;YAAA,EAAqB;UAAA;UAIjHwJ,CAAA,GAAkBzK,CAAA;YACtB,KAAKA,CAAA,IAA4B,MAAlBA,CAAA,CAAO8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM;YAGlB,MAAMpE,CAAA,GAAID,CAAA,CAAO;cACXS,CAAA,GAAQT,CAAA,CAAO;cACfQ,CAAA,GAAIR,CAAA,CAAO;YAIjB,IAAIC,CAAA,CAAE4T,IAAA,CAAK/R,MAAA,GAAS,KAA2B,MAAtBrB,CAAA,CAAMoT,IAAA,CAAK/R,MAAA,IAAkC,MAAlBtB,CAAA,CAAEqT,IAAA,CAAK/R,MAAA,EACzD,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAI5D,CAAA,CAAMoT,IAAA,CAAK,OAAO5T,CAAA,CAAE4T,IAAA,CAAK,MAAMrT,CAAA,CAAEqT,IAAA,CAAK,OAAO5T,CAAA,CAAE4T,IAAA,CAAK,IACtD,MAAM,IAAIxP,KAAA,CAAM;YAElB,IAAgB,cAAXpE,CAAA,CAAE+E,IAAA,IAAiC,cAAX/E,CAAA,CAAE+E,IAAA,IAAuC,cAAfvE,CAAA,CAAMuE,IAAA,IAAqC,cAAfvE,CAAA,CAAMuE,IAAA,IACzE,cAAXxE,CAAA,CAAEwE,IAAA,IAAiC,cAAXxE,CAAA,CAAEwE,IAAA,EAC7B,MAAM,IAAIX,KAAA,CAAM;YAElB,IAA8B,MAA1BrE,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,EACjB,MAAM,IAAIuC,KAAA,CAAM,gC;;;;;;;;;QCtJpB,MAAA7D,CAAA,GAAAC,CAAA;UAKAC,CAAA,GAAAD,CAAA;QASaR,CAAA,CAAAoa,GAAA,GACT,CAACra,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA,MAC1D6C,CAAA,CAAerD,CAAA,GAMR,CAACD,CAAA,CAAiBmU,GAAA,CAAIjT,CAAA,CAA2BjB,CAAA,EAAQQ,CAAA,GAAaR,CAAA,KAItEA,CAAA,CAAAqa,kBAAA,GAA6Dta,CAAA;UACxE,MAAMC,CAAA,GAAQD,CAAA,CAAK4d,UAAA,CAAWrZ,QAAA,CAAS,SAAS;YAC1C9D,CAAA,GAAOT,CAAA,CAAK4d,UAAA,CAAWrZ,QAAA,CAAS,QAAQ;YACxC7D,CAAA,GAAOV,CAAA,CAAK4d,UAAA,CAAWrZ,QAAA,CAAS,QAAQ;YACxCtD,CAAA,GAAOjB,CAAA,CAAK4d,UAAA,CAAWnZ,MAAA,CAAO;UAEpC,QAAO,GAAAjE,CAAA,CAAA6C,2BAAA,EAA4B;YAAC4f,KAAA,EAAAhjB,CAAA;YAAOijB,IAAA,EAAAziB,CAAA;YAAMkjB,IAAA,EAAAjjB,CAAA;YAAM0D,IAAA,EAAAnD;UAAA,EAAM;QAAA;QAG/D,MAAMA,CAAA,GAAqB;UACzB+C,IAAA,EAAM;UACN4G,UAAA,EAAY,CAAC;UACb2I,UAAA,EAAY,CAAC7S,CAAA,CAAA2T,WAAA,CAAYgB,QAAA;QAAA;QAoC3B,SAAgBnU,EAA2BlB,CAAA,EAAkBC,CAAA;UAC3D,OAAO4C,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAW7B,CAAA,GAAkB;YAAEwS,SAAA,EAAWxT,CAAA,CAAW8C,QAAA;YAAUyB,GAAA,EAAKA,CAAA,KAlCtE,UAA8BxE,CAAA,EAAkBC,CAAA;cAC9C,MAAMQ,CAAA,GAAIT,CAAA,CAAO,GAAG6T,IAAA,CAAK;gBACnBrT,CAAA,GAAOR,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA;gBACtBZ,CAAA,IAAQc,IAAA,CAAKoX,KAAA,EAAOnZ,CAAA,CAAWmE,IAAA,GAAO,KAAK;gBAC3Cd,CAAA,GAAKtB,IAAA,CAAKE,IAAA,EAAMjC,CAAA,CAAWmE,IAAA,GAAO,KAAK;gBACvCV,CAAA,GAAQ,SAASzD,CAAA,CAAWgjB,KAAA,aAAkBhjB,CAAA,CAAWmE,IAAA;gBAIzDqG,CAAA,GAAe,mCACSjK,CAAA,8HAKTU,CAAA,UAAcoC,CAAA,qEAEP7C,CAAA,kKAXNR,CAAA,CAAW0jB,IAAA,OAiBAjgB,CAAA,wBAhBXzD,CAAA,CAAWijB,IAAA;cAkBjC,OAAOrgB,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK7B,CAAA,GAAkB;gBACrBwS,SAAA,EAAWxT,CAAA,CAAW8C,QAAA;gBACtB+G,MAAA,EAAQ;kBAAC+J,IAAA,EAAM7T,CAAA,CAAO,GAAG6T,IAAA;kBAAM7O,IAAA,EAAMhF,CAAA,CAAO,GAAGgF,IAAA;kBAAM8O,WAAA,EAAapT,CAAA,CAAA2T,WAAA,CAAYgB;gBAAA;gBAC9ExE,YAAA,EAAApG;cAAA,EAEJ;YAAA,CAG4E,CAAqBzK,CAAA,EAAQC,CAAA;UAAA,EACzG;QAAA;QAFAA,CAAA,CAAA6jB,0BAAA,GAAA5iB,CAAA;QAIA,MAAMoC,CAAA,GAAkBtD,CAAA;UACtB,KAAKA,CAAA,IAA4B,MAAlBA,CAAA,CAAO8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM;UAElB,IAA8B,MAA1BrE,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,EACjB,MAAM,IAAIuC,KAAA,CAAM;UAElB,IAAuB,cAAnBrE,CAAA,CAAO,GAAGgF,IAAA,EACZ,MAAM,IAAIX,KAAA,CAAM,6B;;;;;;;;;QCrFpB,MAAA7D,CAAA,GAAAC,CAAA;UACAC,CAAA,GAAAD,CAAA;UAEAQ,CAAA,GAAAR,CAAA;UACAS,CAAA,GAAAT,CAAA;UAEA6C,CAAA,GAAA7C,CAAA;UACAiD,CAAA,GAAAjD,CAAA;QAyEaR,CAAA,CAAAsgB,mCAAA,GACT,CAACvgB,CAAA,EAAyCC,CAAA,EACzCQ,CAAA;UACC,MAAMgK,CAAA,IA1E+BY,CAAA,GA0EcpL,CAAA,CAAO6B,MAAA,GAAS,GA1EZwJ,CAAA,GA0Ee7K,CAAA,CAAqBuhB,kBAAA,EA1Ed;YACjFhe,IAAA,EAAM;YACN4G,UAAA,EAAYS,CAAA,GAAU,CAAC,KAAK,KAAK,UAAU,CAAC,KAAK;YACjDkI,UAAA,EAAYlI,CAAA,GAAU,CAACpK,CAAA,CAAAoT,WAAA,CAAYC,MAAA,EAAQrT,CAAA,CAAAoT,WAAA,CAAYC,MAAA,EAAQrT,CAAA,CAAAoT,WAAA,CAAYC,MAAA,IACrD,CAACrT,CAAA,CAAAoT,WAAA,CAAYC,MAAA,EAAQrT,CAAA,CAAAoT,WAAA,CAAYC,MAAA;YACvDb,SAAA,EAAAnI;UAAA;UALwC,IAACD,CAAA,EAAkBC,CAAA;UA2EvD,OAAOzI,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK2H,CAAA,GAAQ;YACXjG,GAAA,EAAKA,CAAA,KApET,EAACxE,CAAA,EAAyCC,CAAA,EAA2BQ,CAAA,EACpEgK,CAAA;cACC,MAAMY,CAAA,GAAU5K,CAAA,CAAOqB,MAAA,GAAS;gBAC1BwJ,CAAA,GAAcD,CAAA,GAAU,iCAAiC;gBACzDE,CAAA,GAAS9K,CAAA,CAAO,GAAGoT,IAAA;gBACnBtN,CAAA,GAAS9F,CAAA,CAAO,GAAGoT,IAAA;gBACnBnI,CAAA,GAAclL,CAAA,CAAAgL,aAAA,CAAcwT,SAAA,CAAUzT,CAAA,EAAQhF,CAAA,GAAQ;gBACtDC,CAAA,IAAehG,CAAA,CAAA0L,SAAA,CAAU6S,QAAA,CAASte,CAAA,CAAO,GAAGoT,IAAA,EAAMpT,CAAA,CAAO,GAAGoT,IAAA;cAElE,KAAKnI,CAAA,EACH,MAAM,IAAIrH,KAAA,CAAM;cAElB,MAAMuH,CAAA,GAAYL,CAAA,CAAOA,CAAA,CAAOzJ,MAAA,GAAS;gBACnC+J,CAAA,GAAiB7J,IAAA,CAAKE,IAAA,CAAK0J,CAAA,GAAY;gBACvCG,CAAA,GAAQR,CAAA,CAAOzJ,MAAA;gBACfkK,CAAA,GAAQzF,CAAA,CAAOzE,MAAA;gBAEfmK,CAAA,IAAO,GAAAvL,CAAA,CAAAmJ,OAAA,EAAQ7J,CAAA,CAAiBiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUnF,OAAA;gBAC1DwJ,CAAA,IAAiB,GAAAjL,CAAA,CAAAyK,iBAAA,EAAkBD,CAAA,CAAY5J,MAAA;gBAC/CuK,CAAA,GAAUX,CAAA,CAAY5J,MAAA;gBACtB4U,CAAA,IAAgB,GAAAxV,CAAA,CAAA4K,aAAA;gBAAA;kBAChBqU,kBAAA,EAACxJ,CAAA;kBAAkByJ,eAAA,EAAExJ;gBAAA,KAAmB,GAAAtT,CAAA,CAAA+c,oBAAA,EAAqB5V,CAAA;gBAE7DoM,CAAA,GACFxL,CAAA,GAAU,IAAG,GAAA3H,CAAA,CAAAqgB,gBAAA,EAAiB5X,CAAA,EAAgBuK,CAAA,EAAejW,CAAA,CAAO,GAAGoT,IAAA,EAAMnI,CAAA,GAAa,OAAU;gBAElGoL,CAAA,GACFtQ,CAAA,GAAc,GA6CxB,UACIxG,CAAA,EAAwBC,CAAA,EAAkCQ,CAAA,EAAkBC,CAAA;kBAC9E,IAAIO,CAAA,GAAyB;oBACzBC,CAAA,GAAyB;kBAE7B,MAAMoC,CAAA,GAAW7C,CAAA,CAAO,GAAGoT,IAAA;oBACrBnQ,CAAA,GAAWjD,CAAA,CAAO,GAAGoT,IAAA;oBAErBpJ,CAAA,GAAUnH,CAAA,CAASxB,MAAA;oBACnBuJ,CAAA,GAAU3H,CAAA,CAAS5B,MAAA;oBAEnBwJ,CAAA,GAAU5K,CAAA,CAASoB,MAAA;oBACnByJ,CAAA,GAAYD,CAAA,GAAUb,CAAA;oBACtBlE,CAAA,GAAY+E,CAAA,GAAUD,CAAA;kBAE5BpK,CAAA,GAAyBqC,CAAA,CAASH,GAAA,CAAI,CAACnD,CAAA,EAAGS,CAAA,KAAM,UAAUR,CAAA,CAAcQ,CAAA,GAAI8K,CAAA,MAC5EtK,CAAA,CAAuBwJ,CAAA,GAAU,KAAK,OACtCxJ,CAAA,CAAuBmC,IAAA,CAAK,OAC5BlC,CAAA,GAAyBwC,CAAA,CAASP,GAAA,CAAI,CAACnD,CAAA,EAAGS,CAAA,KAAM,UAAUR,CAAA,CAAcQ,CAAA,GAAI8F,CAAA,MAC5ErF,CAAA,CAAuBmK,CAAA,GAAU,KAAK,OACtCnK,CAAA,CAAuBkC,IAAA,CAAK;kBAE5B,MAAMsI,CAAA,GAAiBlL,CAAA,CAAAgL,aAAA,CAAcC,gBAAA,CAAiBnI,CAAA,EAAU5C,CAAA;oBAC1D8F,CAAA,GAAiBhG,CAAA,CAAAgL,aAAA,CAAcC,gBAAA,CAAiB/H,CAAA,EAAUhD,CAAA;oBAE1DkL,CAAA,GAAiBF,CAAA,CAAevI,GAAA,CAAInD,CAAA,IAAK,UAAUC,CAAA,CAAcD,CAAA,GAAIuL,CAAA,UAAmBnI,IAAA,CAAK;oBAC7FyI,CAAA,GAAiBrF,CAAA,CAAerD,GAAA,CAAInD,CAAA,IAAK,UAAUC,CAAA,CAAcD,CAAA,GAAIuG,CAAA,UAAmBnD,IAAA,CAAK;oBAC7F2I,CAAA,GAAiB,wBAAwB9L,CAAA,CAAcqL,CAAA,GAAU,iBAC9DrL,CAAA,CAAcqL,CAAA,GAAU,eAAerL,CAAA,CAAcqL,CAAA,GAAU,iBAC/DrL,CAAA,CAAcqL,CAAA,GAAU;kBAmBjC,OAjBoC,4CAElCtL,CAAA,mCACA+L,CAAA,OACAH,CAAA,+BACwB3K,CAAA,0EAKxBjB,CAAA,mCACA+L,CAAA,OACAF,CAAA,+BACwB3K,CAAA,8BAK5B;gBAAA,CA9F2B,CAAyBiL,CAAA,EAAgBuK,CAAA,EAAejW,CAAA,EAAQiL,CAAA,MAAiB;gBAEhGqL,CAAA,GAA2BvQ,CAAA,GAAc,6BAA6B,QA8FlF,UAAcxG,CAAA,EAAyBC,CAAA;kBACrC,IAAIQ,CAAA,GAAM;kBACV,KAAK,IAAID,CAAA,GAAI,GAAGA,CAAA,GAAIP,CAAA,GAAO,GAAGO,CAAA,IAC5BC,CAAA,IAAO,MAAMT,CAAA,CAAcQ,CAAA;kBAI7B,OAFAC,CAAA,IAAO,MAAMT,CAAA,CAAcC,CAAA,GAAO,WAE3BQ,CACT;gBAAA,CAtG0F,CAAKiW,CAAA,EAAe3K,CAAA;gBAClGiL,CAAA,GAA2BxQ,CAAA,GAAc,6BAA6B,QAuGlF,UAAcxG,CAAA,EAAyBC,CAAA;kBACrC,IAAIQ,CAAA,GAAM;kBACV,KAAK,IAAID,CAAA,GAAI,GAAGA,CAAA,GAAIP,CAAA,GAAO,GAAGO,CAAA,IAC5BC,CAAA,IAAO,MAAMT,CAAA,CAAcQ,CAAA;kBAI7B,OAFAC,CAAA,IACI,WAAMT,CAAA,CAAcC,CAAA,GAAO,MACxBQ,CACT;gBAAA,CA/G0F,CAAKiW,CAAA,EAAe1K,CAAA;gBAKlGiL,CAAA,GAAe,iBACbH,CAAA,iBACAD,CAAA,iBACAF,CAAA,8CAPuBnQ,CAAA,GAAc,KAAK,GAAG2F,CAAA,wDACXuK,CAAA,CAAcrK,CAAA,GAAU,UAAUqK,CAAA,CAAcrK,CAAA,GAAU,sBAC3FqK,CAAA,CAAcrK,CAAA,GAAU,UAAUqK,CAAA,CAAcrK,CAAA,GAAU,qGAUrCR,CAAA,sCACTkL,CAAA,+BACAC,CAAA,iIAKX1L,CAAA,mBACAsL,CAAA,mBACA3K,CAAA,CAAKnC,MAAA;cAEf,OAAOjH,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK7C,CAAA,GAAQ;gBACX6J,MAAA,EAAQ;kBAAC+J,IAAA,EAAMnI,CAAA;kBAAa1G,IAAA,EAAMvE,CAAA,CAAO,GAAGuE,IAAA;kBAAM8O,WAAA,EAAa7S,CAAA,CAAAoT,WAAA,CAAYC;gBAAA;gBAC3EzD,YAAA,EAAAoG,CAAA;gBACAnG,OAAA,GAAS;cAAA,EAAI;YAAA,GAU4B9Q,CAAA,EAAkByK,CAAA,EAAUxK,CAAA,EAAQQ,CAAA;UAAA,EAAqB;QAAA,C;;;;;;;;QCpF1G,MAAAD,CAAA,GAAAC,CAAA;UAEAC,CAAA,GAAAD,CAAA;UACAQ,CAAA,GAAAR,CAAA;UAEAS,CAAA,GAAAT,CAAA;UACA6C,CAAA,GAAA7C,CAAA;QAEaR,CAAA,CAAAua,MAAA,GACT,CAACxa,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA,MAC1D4K,CAAA,CAAepL,CAAA,GAEXD,CAAA,CAAiBiT,OAAA,CAAQrL,IAAA,GACpB,CAAC5H,CAAA,CAAiBmU,GAAA,EACrB,GAAA7Q,CAAA,CAAAid,mCAAA,EAAoCvgB,CAAA,EAAkBC,CAAA,EAAQQ,CAAA,GAAaR,CAAA,KAExE,CAACD,CAAA,CAAiBmU,GAAA,CAAI1J,CAAA,CAA8BxK,CAAA,EAAQQ,CAAA,GAAaR,CAAA,KAI3EA,CAAA,CAAAwa,qBAAA,GACRza,CAAA,KAAmD,GAAAkB,CAAA,CAAA+f,iCAAA,EAAkCjhB,CAAA,CAAK4d,UAAA;QAE/F,MAAMla,CAAA,GAA8BsgB,CAAChkB,CAAA,EAAkBC,CAAA,MAAsB;UAC3E+D,IAAA,EAAM;UACN4G,UAAA,EAAY5K,CAAA,GAAU,CAAC,KAAK,KAAK,UAAU,CAAC,KAAK;UACjDuT,UAAA,EAAYvT,CAAA,GAAU,CAACU,CAAA,CAAA2T,WAAA,CAAYgB,QAAA,EAAU3U,CAAA,CAAA2T,WAAA,CAAYgB,QAAA,EAAU3U,CAAA,CAAA2T,WAAA,CAAYgB,QAAA,IACzD,CAAC3U,CAAA,CAAA2T,WAAA,CAAYgB,QAAA,EAAU3U,CAAA,CAAA2T,WAAA,CAAYgB,QAAA;UACzD5B,SAAA,EAAAxT;QAAA;QAkDF,SAAgBwK,EACZzK,CAAA,EAAkBC,CAAA;UACpB,MAAMQ,CAAA,GAAWiD,CAAA,CAA4B1D,CAAA,CAAO8B,MAAA,GAAS,GAAG7B,CAAA,CAAqB+hB,kBAAA;UACrF,OAAOnf,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAWrC,CAAA,GAAQ;YAAE+D,GAAA,EAAKA,CAAA,KAlD5B,UACIxE,CAAA,EAA2BC,CAAA,EAAkBQ,CAAA;cAC/C,MAAM6C,CAAA,GAASrD,CAAA,CAAO,GAAG4T,IAAA;gBACnBnQ,CAAA,GAASzD,CAAA,CAAO,GAAG4T,IAAA;gBACnBpJ,CAAA,GAAcjK,CAAA,CAAAgL,aAAA,CAAcwT,SAAA,CAAU1b,CAAA,EAAQI,CAAA,GAAQ;cAC5D,KAAK+G,CAAA,EACH,MAAM,IAAIpG,KAAA,CAAM;cAElB,MAAMgH,CAAA,IAAiB,GAAApK,CAAA,CAAA0K,iBAAA,EAAkBlB,CAAA,CAAY3I,MAAA;gBAC/CyJ,CAAA,IAAgB,GAAAtK,CAAA,CAAA6K,aAAA;gBAAA;kBAChBqU,kBAAA,EAAC5Z,CAAA;kBAAkB6Z,eAAA,EAAE1U;gBAAA,KAAmB,GAAAxK,CAAA,CAAAmf,oBAAA,EAAqB5f,CAAA;gBAE7D+F,CAAA,GAAUvG,CAAA,CAAO6B,MAAA,GAAS;gBAC1B8J,CAAA,GAAcpF,CAAA,GAAU,iCAAiC;gBACzDqF,CAAA,GACFrF,CAAA,GAAU,GAAG8E,CAAA,CAAiBD,CAAA,EAAgBE,CAAA,EAAetL,CAAA,CAAO,GAAG4T,IAAA,EAAMpJ,CAAA,GAAa,OAAW;gBAEnGsB,CAAA,GAAOtB,CAAA,CAAY3I,MAAA;gBACnBkK,CAAA,GAAQ1I,CAAA,CAAOxB,MAAA;gBACfmK,CAAA,GAAQvI,CAAA,CAAO5B,MAAA;gBAEfqK,CAAA,GAAe,SACjB5F,CAAA,SACAsF,CAAA,mCAC0BE,CAAA,uBAChBC,CAAA,qBACAC,CAAA,6IANI3I,CAAA,CAAOA,CAAA,CAAOxB,MAAA,GAAS,6BAY3BkK,CAAA,GAAQ,0BACRC,CAAA,GAAQ,oEAGdL,CAAA,aACAF,CAAA;cAGR,OAAO7I,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK9C,CAAA,GAAQ;gBACX8J,MAAA,EAAQ;kBAAC+J,IAAA,EAAMpJ,CAAA;kBAAazF,IAAA,EAAM/E,CAAA,CAAO,GAAG+E,IAAA;kBAAM8O,WAAA,EAAapT,CAAA,CAAA2T,WAAA,CAAYgB;gBAAA;gBAC3ExE,YAAA,EAAA1E;cAAA,EAEJ;YAAA,CAKkC,CAAwB1L,CAAA,EAAUT,CAAA,EAAQC,CAAA;UAAA,EAC5E;QAAA;QAJAA,CAAA,CAAAohB,6BAAA,GAAA5W,CAAA;QAMA,MAAMY,CAAA,GAAkBrL,CAAA;UACtB,KAAKA,CAAA,IAA4B,MAAlBA,CAAA,CAAO8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM;UAGlB,IAAIrE,CAAA,CAAO,GAAG6T,IAAA,CAAK7T,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,GAAS,OAAO9B,CAAA,CAAO,GAAG6T,IAAA,CAAK7T,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,GAAS,IACvF,MAAM,IAAIuC,KAAA,CAAM;UAGlB,IAAwB,cAAnBrE,CAAA,CAAO,GAAGgF,IAAA,IAAyC,cAAnBhF,CAAA,CAAO,GAAGgF,IAAA,IACvB,cAAnBhF,CAAA,CAAO,GAAGgF,IAAA,IAAyC,cAAnBhF,CAAA,CAAO,GAAGgF,IAAA,EAC7C,MAAM,IAAIX,KAAA,CAAM;UAGlB,IAAIrE,CAAA,CAAO,GAAGgF,IAAA,KAAShF,CAAA,CAAO,GAAGgF,IAAA,EAC/B,MAAM,IAAIX,KAAA,CAAM,4B;;QAIpB,SAAgBiH,EACZtL,CAAA,EAAwBC,CAAA,EAAkCQ,CAAA,EAA4BC,CAAA,EACtFO,CAAA;UACF,IAAIC,CAAA,GAAwB;UAC5B,MAAMoC,CAAA,GAAS7C,CAAA,CAAQqB,MAAA;YACjB4B,CAAA,GAAUhD,CAAA,CAASoB,MAAA;YACnB2I,CAAA,GAAW/G,CAAA,GAAUJ,CAAA;UAEzBpC,CAAA,GADEwC,CAAA,GAAU,KAAKJ,CAAA,GAAS,IACF,WAEA7C,CAAA,CAAQ0C,GAAA,CAAI,CAACnD,CAAA,EAAGS,CAAA,KAAM,UAAUR,CAAA,CAAcQ,CAAA,GAAIgK,CAAA,KAAarH,IAAA,CAAK;UAE9F,MACMiI,CAAA,GADgB7K,CAAA,CAAAgL,aAAA,CAAcC,gBAAA,CAAiBhL,CAAA,EAASC,CAAA,EAC1ByC,GAAA,CAAInD,CAAA,IAAK,UAAUC,CAAA,CAAcD,CAAA,GAAIyK,CAAA,UAAkBrH,IAAA,CAAK;UAGhG,IAAIkI,CAAA,GAAS;UAkBb,OAnBiC,MADlB9K,CAAA,CAAA0L,SAAA,CAAU9H,IAAA,CAAK3D,CAAA,MAI5B6K,CAAA,GAAS,wBAEoBrK,CAAA,GAAW,kCAExCjB,CAAA,mCACAqL,CAAA,kCAC2BnK,CAAA,gBACpBoK,CAAA,SAEiC,mCAExCtL,CAAA,mCACAqL,CAAA,kCAKJ;QAAA;QAnCApL,CAAA,CAAA8jB,gBAAA,GAAAzY,C;;;;;;;;QCzGA,MAAA9K,CAAA,GAAAC,CAAA;UAEAC,CAAA,GAAAD,CAAA;UACAQ,CAAA,GAAAR,CAAA;UAEAS,CAAA,GAAAT,CAAA;UAEM6C,CAAA,GAAsB;YAC1BU,IAAA,EAAM;YACN4G,UAAA,EAAY,CAAC;YACb2I,UAAA,EAAY,CAAC7S,CAAA,CAAA2T,WAAA,CAAY4P,gBAAA;UAAA;QA+CdhkB,CAAA,CAAAuW,2BAAA,GAA8B,CAACxW,CAAA,EAAgCC,CAAA,KACvE4C,MAAA,CAADC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAKQ,CAAA,GAAmB;UAAEkB,GAAA,EAAKA,CAAA,KA7CL,EAACxE,CAAA,EAAgCC,CAAA;YAC7D,MAAMQ,CAAA,IAAO,GAAAD,CAAA,CAAAqJ,OAAA,EAAQ7J,CAAA,CAAQiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUnF,OAAA;cACjDe,CAAA,GAAazD,CAAA,CAAM4T,IAAA;cAEnBpJ,CAAA,GAAY/G,CAAA,CAAW5B,MAAA;cAEvBuJ,CAAA,GAAapL,CAAA,CAAM4T,IAAA,CAAK/R,MAAA;cAExBwJ,CAAA,IAAiB,GAAArK,CAAA,CAAA0K,iBAAA,EAAkBN,CAAA;cACnCE,CAAA,IAAW,GAAArK,CAAA,CAAAoe,WAAA,EAAY,MAAMjU,CAAA;cAC7B9E,CAAA,IA8FUmF,CAAA,GA9FOL,CAAA,EA8FO7E,CAAA,GA9FK+E,CAAA,EA8FWK,CAAA,GA9FDlI,CAAA,CAAWA,CAAA,CAAW5B,MAAA,GAAS,IA8FhB+J,CAAA,GA9FoBnI,CAAA,CAAWA,CAAA,CAAW5B,MAAA,GAAS,IA+FlG,MAAT4J,CAAA,IAAuB,MAATA,CAAA,GACT,KAIO,iBACJlF,CAAA,CAAKkF,CAAA,GAAO,oBACZlF,CAAA,CAAKkF,CAAA,GAAO,sBACVlF,CAAA,CAAKkF,CAAA,GAAO,0BACZlF,CAAA,CAAKkF,CAAA,GAAO,oCACFG,CAAA,8BACAD,CAAA;YAZ1B,IAAkBF,CAAA,EAAclF,CAAA,EAAgBoF,CAAA,EAAcC,CAAA;YA5F5D,IAAIE,CAAA;YAEFA,CAAA,GADgB,MAAdtB,CAAA,GACgB,CAAC,GAAG,KACC,MAAdA,CAAA,GACS,CAAC/G,CAAA,CAAW,IAAI,KAEhB,CAACA,CAAA,CAAW2H,CAAA,GAAa,IAAI3H,CAAA,CAAW2H,CAAA,GAAa;YAEzE,MAAMW,CAAA,GA8BR,UAAiChM,CAAA,EAAcC,CAAA,EAA0BQ,CAAA;gBACvE,IAAa,MAATT,CAAA,EACF,OAAO;gBAET,IAAa,MAATA,CAAA,EACF,OAAO,QAAQC,CAAA,CAAM;gBAGvB,IAAIO,CAAA,GAAO;gBACX,KAAK,IAAIE,CAAA,GAAIV,CAAA,GAAO,GAAGU,CAAA,GAAIV,CAAA,EAAMU,CAAA,IAC/BF,CAAA,IAAQ,GAAGC,CAAA,CAAKC,CAAA,QAAST,CAAA,CAAMS,CAAA,GAAIV,CAAA,GAAO,MACtCU,CAAA,GAAIV,CAAA,GAAO,MACbQ,CAAA,IAAQ;gBAIZ,OAAOA,CACT;cAAA,CA/C+B,CAAwB6K,CAAA,EAAYU,CAAA,EAAiBR,CAAA;cAC5EU,CAAA,GAmDR,UAAmBjM,CAAA,EAA0BC,CAAA;gBAC3C,MAAMQ,CAAA,GAAOT,CAAA,CAAM8B,MAAA;gBAEnB,IAAa,MAATrB,CAAA,EACF,OAAO;gBAGT,IAAa,MAATA,CAAA,EACF,OAAO,oCACaT,CAAA,CAAM;gBAQ5B,IAAIQ,CAAA,GAAI;gBACR,IAAIC,CAAA,GAAO,GACT,KAAK,IAAIT,CAAA,GAAI,GAAGA,CAAA,GAAIS,CAAA,GAAO,KAAKT,CAAA,EAC9BQ,CAAA,IAAQ,GAAGP,CAAA,CAAKD,CAAA;gBAGpB,OAAO,QAAQQ,CAAA,uCACaA,CAAA,yCACAA,CAAA,kDACSA,CAAA,WACvC;cAAA,CA9EiB,CAAUkD,CAAA,EAAY6H,CAAA;cAE/BY,CAAA,GAAe,sCAEXb,CAAA,4CAEGU,CAAA,oBACDvL,CAAA,CAAKqJ,MAAA,gDAELvD,CAAA,mBAEA9F,CAAA,CAAKqJ,MAAA,WAAiBmC,CAAA;YAIlC,OAAOpJ,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKQ,CAAA,GAAmB;cACtBwN,OAAA,GAAS;cACThH,MAAA,EAAQ;gBAAC+J,IAAA,EAAM5T,CAAA,CAAM4T,IAAA;gBAAM7O,IAAA,EAAM/E,CAAA,CAAM+E,IAAA;gBAAM8O,WAAA,EAAapT,CAAA,CAAA2T,WAAA,CAAYC;cAAA;cACtEzD,YAAA,EAAA1E;YAAA,EAAY;UAAA,GAK+CnM,CAAA,EAASC,CAAA;QAAA,E;;;;;;;;QC3DxE,MAAAO,CAAA,GAAAC,CAAA;QAEA,SAAgBC,EAAeV,CAAA,EAAcC,CAAA;UAC3C,QAAO,GAAAO,CAAA,CAAAsL,aAAA,EAAc7L,CAAA,EAAMkD,GAAA,CAAIlD,CAAA,IAAK,GAAGD,CAAA,IAAQC,CAAA,GACjD;QAAA;QAFAA,CAAA,CAAAikB,cAAA,GAAAxjB,CAAA,EAIAT,CAAA,CAAAqf,WAAA,aAA4Btf,CAAA,EAAcC,CAAA;UACxC,OAAa,MAATA,CAAA,GACK,CAACD,CAAA,IAEHU,CAAA,CAAeV,CAAA,EAAMC,CAAA,CAC9B;QAAA,GAEAA,CAAA,CAAAsf,iBAAA;UACE,OAAO,mXAaT;QAAA,C;;;;;;;;QC3BA,MAAA/e,CAAA,GAAAC,CAAA;UAIAC,CAAA,GAAAD,CAAA;UACAQ,CAAA,GAAAR,CAAA;UAEAS,CAAA,GAAAT,CAAA;UAQM6C,CAAA,GAAqB;YACzBU,IAAA,EAAM;YACN4G,UAAA,EAAY,CAAC;YACb2I,UAAA,EAAY,CAACrS,CAAA,CAAAmT,WAAA,CAAYgB,QAAA;UAAA;QAGdpV,CAAA,CAAA8a,KAAA,GACT,CAAC/a,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA,MAC1D4K,CAAA,CAAiBpL,CAAA,GAQV,CAPQD,CAAA,CAAiBmU,GAAA,CAAItR,MAAA,CAADC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAE1BQ,CAAA,GAAkB;UACrBmQ,SAAA,EAAWhT,CAAA,CAAWsC,QAAA;UACtByB,GAAA,EAAKA,CAAA,KAAMiG,CAAA,CAAqBzK,CAAA,EAAkBC,CAAA,CAAO,IAAIQ,CAAA;QAAA,IAE/DR,CAAA,KAIGA,CAAA,CAAA+a,oBAAA,GAA+Dhb,CAAA;UAC1E,MAAMC,CAAA,GAAOD,CAAA,CAAK4d,UAAA,CAAWlZ,SAAA,CAAU,QAAQ;YACzCjE,CAAA,GAAQT,CAAA,CAAK4d,UAAA,CAAWrZ,QAAA,CAAS,SAAS;YAC1C7D,CAAA,GAAOV,CAAA,CAAK4d,UAAA,CAAW/Y,OAAA,CAAQ;UACrC,QAAO,GAAArE,CAAA,CAAA6C,2BAAA,EAA4B;YAACwe,IAAA,EAAA5hB,CAAA;YAAMkkB,KAAA,EAAA1jB,CAAA;YAAOwf,IAAA,EAAAvf;UAAA,EAAM;QAAA,GAG5CT,CAAA,CAAAgb,MAAA,GACT,CAACjb,CAAA,EAAyCS,CAAA,EAAkBD,CAAA;UAC1D8K,CAAA,CAAkB7K,CAAA;UAClB,MAAMC,CAAA,GAAagD,CAAA,CAAgC1D,CAAA,EAAkBS,CAAA,EAAQD,CAAA;UAC7E,QAAO,GAAAP,CAAA,CAAA8a,KAAA,EAAM/a,CAAA,EAAkB,CAACS,CAAA,CAAO,KAAKC,CAAA,CAAW;QAAA,GAGhDT,CAAA,CAAAib,qBAAA,GAAyDlb,CAAA,IAClEA,CAAA,CAAK4d,UAAA,CAAWlZ,SAAA,CAAU,QAAQ;QAEtC,MAAMhB,CAAA,GACF0gB,CAACpkB,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA;YAC1D,KAAKT,CAAA,CAAiBiT,OAAA,CAAQgD,aAAA,CAAchW,CAAA,CAAO,GAAGuU,MAAA,KACjDvU,CAAA,CAAO6B,MAAA,IAAU,MAAM9B,CAAA,CAAiBiT,OAAA,CAAQgD,aAAA,CAAchW,CAAA,CAAO,GAAGuU,MAAA,GAC3E,MAAM,IAAInQ,KAAA,CAAM;YAGlB,MAAM3D,CAAA,GAAOsF,KAAA,CAAMoZ,IAAA,CAAKnf,CAAA,CAAO,GAAGokB,WAAA;cAC5BpjB,CAAA,GAAShB,CAAA,CAAO6B,MAAA,IAAU,IAAK7B,CAAA,CAAO,GAAGqkB,SAAA,CAAU,KAAK;YAE9D,QAAO,GAAA9jB,CAAA,CAAA6C,2BAAA,EAA4B;cAACwe,IAAA,EAAAphB,CAAA;cAAMwf,IAAA,EAAAvf,CAAA;cAAMyjB,KAAA,EAAAljB;YAAA,EAAO;UAAA;UAGvDwJ,CAAA,GACF8Z,CAACvkB,CAAA,EAAyCC,CAAA,EAAeQ,CAAA;YACvD,MAAMD,CAAA,GAAcE,CAAA,CAAAwL,SAAA,CAAUsY,QAAA,CAASvkB,CAAA,CAAM4T,IAAA,CAAK3G,KAAA,IAASzM,CAAA,CAAWwf,IAAA;cAChEhf,CAAA,GAAOT,CAAA,CAAYsB,MAAA;cAEnBwB,CAAA,GAAe,WADDiI,CAAA,CAAevL,CAAA,EAAkBC,CAAA,EAAOQ,CAAA,8BAGxCQ,CAAA;YAGpB,OAAO;cACL+C,IAAA,EAAM;cACN4G,UAAA,EAAY,CAAC;cACb2I,UAAA,EAAY,CAACrS,CAAA,CAAAmT,WAAA,CAAYgB,QAAA;cACzBvL,MAAA,EAAQ;gBAAC+J,IAAA,EAAMrT,CAAA;gBAAawE,IAAA,EAAM/E,CAAA,CAAM+E,IAAA;gBAAM8O,WAAA,EAAa5S,CAAA,CAAAmT,WAAA,CAAYgB;cAAA;cACvExE,YAAA,EAAAvN;YAAA,CACD;UAAA;UAGD+H,CAAA,GAAoBrL,CAAA;YACxB,KAAKA,CAAA,IAA4B,MAAlBA,CAAA,CAAO8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAuB,cAAnBrE,CAAA,CAAO,GAAGgF,IAAA,IAAyC,cAAnBhF,CAAA,CAAO,GAAGgF,IAAA,EAC5C,MAAM,IAAIX,KAAA,CAAM,sB;;UAIdiH,CAAA,GAAqBtL,CAAA;YACzB,KAAKA,CAAA,IAA6B,MAAlBA,CAAA,CAAO8B,MAAA,IAAkC,MAAlB9B,CAAA,CAAO8B,MAAA,EAC5C,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAuB,YAAnBrE,CAAA,CAAO,GAAGgF,IAAA,EACZ,MAAM,IAAIX,KAAA,CAAM;YAElB,IAAIrE,CAAA,CAAO8B,MAAA,IAAU,KAAwB,aAAnB9B,CAAA,CAAO,GAAGgF,IAAA,EAClC,MAAM,IAAIX,KAAA,CAAM,sB;;UAIdkH,CAAA,GAAiBkZ,CAACzkB,CAAA,EAAyCC,CAAA,EAAeQ,CAAA;YAC9E,MAAMD,CAAA,IAAO,GAAAS,CAAA,CAAA4I,OAAA,EAAQ7J,CAAA,CAAiBiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUnF,OAAA;cAAA,CACzDW,CAAA,EAAOI,CAAA,IAAU1D,CAAA,CAAiBoT,8BAAA,CAA+BnT,CAAA,CAAM4T,IAAA,EAAM3S,CAAA,CAAAmT,WAAA,CAAYgB,QAAA;cAC1F5K,CAAA,GAAU/J,CAAA,CAAAwL,SAAA,CAAUqJ,cAAA,CAAetV,CAAA,CAAM4T,IAAA;YAE/C,QAAQpT,CAAA,CAAWohB,IAAA;cACjB,KAAK;gBACH,OAAOtb,CAAA,CAAe/F,CAAA,EAAMP,CAAA,CAAM4T,IAAA,EAAMpJ,CAAA,EAASnH,CAAA,EAAOI,CAAA,EAAQjD,CAAA,CAAWwf,IAAA,EAAMxf,CAAA,CAAW0jB,KAAA;cAC9F,KAAK;gBACH,OAAOzY,CAAA,CAAclL,CAAA,EAAMP,CAAA,CAAM4T,IAAA,EAAMpJ,CAAA,EAASnH,CAAA,EAAOI,CAAA,EAAQjD,CAAA,CAAWwf,IAAA;cAC5E,KAAK;gBACH,OAAOzZ,CAAA,CAAWhG,CAAA,EAAMP,CAAA,CAAM4T,IAAA,EAAMpJ,CAAA,EAASnH,CAAA,EAAOI,CAAA,EAAQjD,CAAA,CAAWwf,IAAA;cACzE;gBACE,MAAM,IAAI5b,KAAA,CAAM;YAAA;;UAIhBkC,CAAA,GACFme,CAAC1kB,CAAA,EAAYC,CAAA,EAA0BQ,CAAA,EAA4BD,CAAA,EAAeE,CAAA,EAAgBO,CAAA,EACjGC,CAAA;YACC,MAAMoC,CAAA,GAAOrD,CAAA,CAAM6B,MAAA;YACnB,IAAI4B,CAAA,GAAQ;YACZ,KAAK,IAAI1D,CAAA,GAAIsD,CAAA,GAAO,GAAGtD,CAAA,IAAK,KAAKA,CAAA,EAC/B0D,CAAA,IAAS,mBACD1D,CAAA,OAAQiB,CAAA,CAAKjB,CAAA,8DAEVC,CAAA,CAAMD,CAAA,8CACDS,CAAA,CAAQT,CAAA;YAG1B,OAAO,4BACYsD,CAAA,8CACcpC,CAAA,4DAG7BwC,CAAA,kDACqClD,CAAA,KAAUE,CAAA,6CACjBV,CAAA,CAAK0K,SAAA,uDAGtC;UAAA;UAGDgB,CAAA,GACFiZ,CAAC3kB,CAAA,EAAYC,CAAA,EAA0BQ,CAAA,EAA4BD,CAAA,EAAeE,CAAA,EAAgBO,CAAA;YAE5F,MAAMC,CAAA,GAAOjB,CAAA,CAAM6B,MAAA;YAEnB,IAAIwB,CAAA,GAAQ;YACZ,KAAK,IAAItD,CAAA,GAAIkB,CAAA,GAAO,GAAGlB,CAAA,IAAK,KAAKA,CAAA,EAC/BsD,CAAA,IAAS,mBACLtD,CAAA,OAAQiB,CAAA,CAAKjB,CAAA,8EAGC,KAAKC,CAAA,CAAMD,CAAA,IAAK,gFAE1BC,CAAA,CAAMD,CAAA,2DAEFS,CAAA,CAAQT,CAAA;YAGtB,OAAO,4BACQkB,CAAA,8DAGfoC,CAAA,kDACqC9C,CAAA,KAAUE,CAAA,6CACjBV,CAAA,CAAK0K,SAAA,uDAGtC;UAAA;UAGDlE,CAAA,GACFoe,CAAC5kB,CAAA,EAAYC,CAAA,EAA0BQ,CAAA,EAA4BD,CAAA,EAAeE,CAAA,EAAgBO,CAAA;YAE5F,MAAMC,CAAA,GAAOjB,CAAA,CAAM6B,MAAA;YAEnB,IAAIwB,CAAA,GAAQ;YACZ,KAAK,IAAItD,CAAA,GAAIkB,CAAA,GAAO,GAAGlB,CAAA,IAAK,KAAKA,CAAA,EAC/BsD,CAAA,IAAS,mBACLtD,CAAA,OAAQiB,CAAA,CAAKjB,CAAA,oDAEVC,CAAA,CAAMD,CAAA,UAAWC,CAAA,CAAMD,CAAA,IAAK,6BACvBS,CAAA,CAAQT,CAAA;YAGtB,OAAO,4BACQkB,CAAA,8DAGfoC,CAAA,kDACqC9C,CAAA,KAAUE,CAAA,6CACjBV,CAAA,CAAK0K,SAAA,uDAGtC;UAAA,C;;;;;;;;QCxMP,MAAAlK,CAAA,GAAAC,CAAA;UAIAC,CAAA,GAAAD,CAAA;UAEAQ,CAAA,GAAAR,CAAA;QAWaR,CAAA,CAAA2X,WAAA,GACT,CAAC5X,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA;UAC1D6K,CAAA,CAAerL,CAAA;UACf,MAAMO,CAAA,GACF;YAACwD,IAAA,EAAM;YAAe4G,UAAA,EAAY,CAAC;YAAM2I,UAAA,EAAY,CAACtS,CAAA,CAAAoT,WAAA,CAAYgB,QAAA;YAAW5B,SAAA,EAAWhT,CAAA,CAAWsC;UAAA;UAGvG,OAAO,CAFQ/C,CAAA,CAAiBmU,GAAA,CAAItR,MAAA,CAADC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAC3BtC,CAAA,GAAQ;YAAEgE,GAAA,EAAKA,CAAA,KAAMtD,CAAA,CAA6BjB,CAAA,EAAQO,CAAA,GAAU,GAAOC,CAAA;UAAA,IAAcR,CAAA,EAClF;QAAA,GAGRA,CAAA,CAAA4X,0BAAA,GACR7X,CAAA;UACC,MAAMC,CAAA,GAAUD,CAAA,CAAK4d,UAAA,CAAWlZ,SAAA,CAAU,YAAY;YAChDjE,CAAA,GAAWT,CAAA,CAAK4d,UAAA,CAAWnZ,MAAA,CAAO,aAAa;YAC/C/D,CAAA,GAAsE,MAAnDV,CAAA,CAAK4d,UAAA,CAAWnZ,MAAA,CAAO,qBAAqB;YAC/DxD,CAAA,GAAcjB,CAAA,CAAK4d,UAAA,CAAW/Y,OAAA,CAAQ;YACtC3D,CAAA,GAAUlB,CAAA,CAAK4d,UAAA,CAAW/Y,OAAA,CAAQ,WAAW;YAC7CvB,CAAA,GAAOtD,CAAA,CAAK4d,UAAA,CAAW/Y,OAAA,CAAQ,QAAQ;UAG7C,IAAiB,MAAbpE,CAAA,EACF,MAAM,IAAI4D,KAAA,CAAM;UAGlB,QAAO,GAAA7D,CAAA,CAAA6C,2BAAA,EAA4B;YAACyc,OAAA,EAAA7f,CAAA;YAAS4kB,QAAA,EAAApkB,CAAA;YAAUqkB,eAAA,EAAApkB,CAAA;YAAiBsf,WAAA,EAAA/e,CAAA;YAAa8M,OAAA,EAAA7M,CAAA;YAAS+e,IAAA,EAAA3c;UAAA,EAAM;QAAA;QAG1G,MAAMpC,CAAA,GACF6jB,CAAC/kB,CAAA,EAAkBC,CAAA,EAA2BQ,CAAA,EAA2BD,CAAA;UAEnE,OAAOU,CAAA,EAAoBoC,CAAA,IACvBI,CAAA,CAAwC1D,CAAA,EAAQQ,CAAA,EAAYC,CAAA;YAC1DgK,CAAA,GAAa/J,CAAA,CAAAwL,SAAA,CAAU9H,IAAA,CAAKlD,CAAA,CAAmB8e,WAAA;UAErD,IAAI3U,CAAA,GAAM;UACNnK,CAAA,CAAmB4jB,eAAA,GACrBzZ,CAAA,IAAO,kBAAkBZ,CAAA,OAEzBY,CAAA,IAAO,kBAAkBZ,CAAA;UAE3B,MACMa,CAAA,GAAe,aADDC,CAAA,CAAoBvL,CAAA,CAAO,GAAG6T,IAAA,EAAM3S,CAAA,EAP5C,mBAOqEmK,CAAA,EAAK;UAItF,OAAOxI,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK7C,CAAA,GAAQ;YACX6J,MAAA,EAAQ;cAAC+J,IAAA,EAAMvQ,CAAA;cAAa0B,IAAA,EAAMhF,CAAA,CAAO,GAAGgF,IAAA;cAAM8O,WAAA,EAAa7S,CAAA,CAAAoT,WAAA,CAAYgB;YAAA;YAC3ExE,YAAA,EAAAvF;UAAA,EAAY;QAAA;QAIXrL,CAAA,CAAAyZ,iBAAA,GACT,CAAC1Z,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA;UAC1D6K,CAAA,CAAerL,CAAA;UACf,MAAMO,CAAA,GAAW;YACfwD,IAAA,EAAM;YACN4G,UAAA,EAAY,CAAC;YACb2I,UAAA,EAAY,CAACtS,CAAA,CAAAoT,WAAA,CAAYgB,QAAA;YACzB5B,SAAA,EAAW,GAAGhT,CAAA,CAAWqkB,eAAA;UAAA;UAI3B,OAAO,CAFQ9kB,CAAA,CAAiBmU,GAAA,CAAItR,MAAA,CAADC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAC3BtC,CAAA,GAAQ;YAAEgE,GAAA,EAAKA,CAAA,KAAMtD,CAAA,CAA6BjB,CAAA,EAAQO,CAAA,GAAU,GAAMC,CAAA;UAAA,IAAcR,CAAA,EACjF;QAAA,GAGRA,CAAA,CAAA0Z,gCAAA,GACR3Z,CAAA;UACC,MAAMC,CAAA,GAAsE,MAAnDD,CAAA,CAAK4d,UAAA,CAAWnZ,MAAA,CAAO,qBAAqB;UACrE,QAAO,GAAAjE,CAAA,CAAA6C,2BAAA,EACH;YAACyc,OAAA,EAAS;YAAI+E,QAAA,EAAU;YAAGC,eAAA,EAAA7kB,CAAA;YAAiB+f,WAAA,EAAa;YAAIjS,OAAA,EAAS;YAAIkS,IAAA,EAAM;UAAA,EAAI;QAAA,GAQjFhgB,CAAA,CAAAya,OAAA,GACT,CAAC1a,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA;UAC1D6K,CAAA,CAAerL,CAAA;UACf,MAAMO,CAAA,GACF;YAACwD,IAAA,EAAM;YAAW4G,UAAA,EAAY,CAAC;YAAM2I,UAAA,EAAY,CAACtS,CAAA,CAAAoT,WAAA,CAAYgB,QAAA;YAAW5B,SAAA,EAAWhT,CAAA,CAAWsC;UAAA;UAGnG,OAAO,CAFQ/C,CAAA,CAAiBmU,GAAA,CAAItR,MAAA,CAADC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAC3BtC,CAAA,GAAQ;YAAEgE,GAAA,EAAKA,CAAA,KAAMlB,CAAA,CAAyBrD,CAAA,EAAQO,CAAA,GAAU,GAAOC,CAAA;UAAA,IAAcR,CAAA,EAC9E;QAAA,GAGRA,CAAA,CAAA0a,sBAAA,GACR3a,CAAA;UACC,MAAMC,CAAA,GAAUD,CAAA,CAAK4d,UAAA,CAAWlZ,SAAA,CAAU,YAAY;YAChDjE,CAAA,GAAWT,CAAA,CAAK4d,UAAA,CAAWnZ,MAAA,CAAO,aAAa;YAC/C/D,CAAA,GAAcV,CAAA,CAAK4d,UAAA,CAAW/Y,OAAA,CAAQ;YACtC5D,CAAA,GAAUjB,CAAA,CAAK4d,UAAA,CAAW/Y,OAAA,CAAQ,WAAW;YAC7C3D,CAAA,GAAOlB,CAAA,CAAK4d,UAAA,CAAW/Y,OAAA,CAAQ,QAAQ;YACvCvB,CAAA,GAAetD,CAAA,CAAK4d,UAAA,CAAWnZ,MAAA,CAAO,iBAAiB;YACvDf,CAAA,GAAY1D,CAAA,CAAK4d,UAAA,CAAW/Y,OAAA,CAAQ,aAAa;UAGvD,IAAqB,MAAjBvB,CAAA,EACF,MAAM,IAAIe,KAAA,CAAM;UAElB,IAAiB,MAAb5D,CAAA,EACF,MAAM,IAAI4D,KAAA,CAAM;UAGlB,QAAO,GAAA7D,CAAA,CAAA6C,2BAAA,EACH;YAACyc,OAAA,EAAA7f,CAAA;YAAS4kB,QAAA,EAAApkB,CAAA;YAAUqkB,eAAA,GAAiB;YAAO9E,WAAA,EAAAtf,CAAA;YAAaqN,OAAA,EAAA9M,CAAA;YAASgf,IAAA,EAAA/e,CAAA;YAAM8jB,YAAA,EAAA1hB,CAAA;YAAcyc,SAAA,EAAArc;UAAA,EAAW;QAAA;QAG3G,MAAMJ,CAAA,GACF2hB,CAACjlB,CAAA,EAAkBC,CAAA,EAA2BQ,CAAA,EAA2BD,CAAA;YAEnE,OAAOE,CAAA,EAAoBQ,CAAA,IACvBwC,CAAA,CAAwC1D,CAAA,EAAQQ,CAAA,EAAYC,CAAA;cAM1D6C,CAAA,GAAe,WADDiI,CAAA,CAAoBvL,CAAA,CAAO,GAAG6T,IAAA,EAAMnT,CAAA,EAJ5C,4CAGA,IAC0E;YAItF,OAAOmC,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK7C,CAAA,GAAQ;cACX6J,MAAA,EAAQ;gBAAC+J,IAAA,EAAM3S,CAAA;gBAAa8D,IAAA,EAAMhF,CAAA,CAAO,GAAGgF,IAAA;gBAAM8O,WAAA,EAAa7S,CAAA,CAAAoT,WAAA,CAAYgB;cAAA;cAC3ExE,YAAA,EAAAvN;YAAA,EAAY;UAAA;UAIlBI,CAAA,GACFwhB,CAACllB,CAAA,EAAkBC,CAAA,EAAqDQ,CAAA;YAElE,MAAMD,CAAA,GAAaR,CAAA,CAAO,GAAG6T,IAAA,CAAK3G,KAAA;cAC5BjM,CAAA,GAAe4B,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKnlB,CAAA,EAAY;cACtDiB,CAAA,GAAcjB,CAAA,CAAW+f,WAAA,CAAY9S,KAAA;cACrC5J,CAAA,GAAUrD,CAAA,CAAW8N,OAAA,CAAQb,KAAA;cAC7BxJ,CAAA,GAAsBzC,CAAA,GAAgBhB,CAAA,CAAiC8f,SAAA,CAAU7S,KAAA,KAAU;cAC3FzC,CAAA,GAAOxK,CAAA,CAAWggB,IAAA,CAAK/S,KAAA;YAC7BxM,CAAA,CAAAghB,YAAA,CAAa2D,oBAAA,CAAqB5kB,CAAA,EAAkBD,CAAA,EAAYU,CAAA,EAAaoC,CAAA,EAASI,CAAA,EAAW+G,CAAA;YAEjG,MAAMY,CAAA,GAAc3K,CAAA,CAAAghB,YAAA,CAAa4D,sBAAA,CAC7B7kB,CAAA,EAAkBD,CAAA,EAAY8C,CAAA,EAASI,CAAA,EAAWxC,CAAA,EAAauJ,CAAA,EAAMxK,CAAA,CAAW6f,OAAA;cAE9ExU,CAAA,GAAgBzI,MAAA,CAAOC,MAAA,CAAO,CAAC,GAAG7C,CAAA;YAMxC,OALIgB,CAAA,GACF4B,MAAA,CAAOC,MAAA,CAAOwI,CAAA,EAAe;cAAC0U,WAAA,EAAA9e,CAAA;cAAa6M,OAAA,EAAAzK,CAAA;cAAS2c,IAAA,EAAAxV,CAAA;cAAMsV,SAAA,EAAArc,CAAA;cAAWX,QAAA,EAAU9C,CAAA,CAAW8C;YAAA,KAE1FF,MAAA,CAAOC,MAAA,CAAOwI,CAAA,EAAe;cAAC0U,WAAA,EAAA9e,CAAA;cAAa6M,OAAA,EAAAzK,CAAA;cAAS2c,IAAA,EAAAxV,CAAA;cAAM1H,QAAA,EAAU9C,CAAA,CAAW8C;YAAA,IAE1E,CAACuI,CAAA,EAAeD,CAAA,CAAY;UAAA;UAGvCZ,CAAA,GAA0B;YAC9BqV,OAAA,EAAS;YACT+E,QAAA,EAAU;YACVC,eAAA,GAAiB;YACjB9E,WAAA,EAAa;YACbjS,OAAA,EAAS;YACTkS,IAAA,EAAM;YACN+E,YAAA,EAAc;YACdjF,SAAA,EAAW;YACXhd,QAAA,EAAU;UAAA;UAGNsI,CAAA,GAAwB;YAC5BrH,IAAA,EAAM;YACN4G,UAAA,EAAY,CAAC;YACb2I,UAAA,EAAY,CAACtS,CAAA,CAAAoT,WAAA,CAAYgB,QAAA;UAAA;QAGdpV,CAAA,CAAA2Z,aAAA,GAAgB,CAAC5Z,CAAA,EAAyCC,CAAA,MACrEqL,CAAA,CAAerL,CAAA,GAOR,CANQD,CAAA,CAAiBmU,GAAA,CAAItR,MAAA,CAADC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAE1BuI,CAAA,GAAqB;UACxB7G,GAAA,EAAKA,CAAA,KAAMlB,CAAA,CAAyBrD,CAAA,EAAQoL,CAAA,GAAuB,GAAMZ,CAAA;QAAA,IAE3ExK,CAAA;QAIN,MAAMqL,CAAA,GAAkBtL,CAAA;YACtB,KAAKA,CAAA,IAA4B,MAAlBA,CAAA,CAAO8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAuB,cAAnBrE,CAAA,CAAO,GAAGgF,IAAA,IAAyC,cAAnBhF,CAAA,CAAO,GAAGgF,IAAA,EAC5C,MAAM,IAAIX,KAAA,CAAM,sB;;UAIdkH,CAAA,GACFga,CAACvlB,CAAA,EAA8BC,CAAA,EAAmCQ,CAAA,EAAaD,CAAA,EAAaS,CAAA;YAEtF,MAAMC,CAAA,GAAOlB,CAAA,CAAU8B,MAAA;YACvB,IAAI7B,CAAA,CAAW+f,WAAA,CAAYle,MAAA,IAAU,GAAG;cACtC,MAAMpB,CAAA,GAAKT,CAAA,CAAW+f,WAAA,CAAY/f,CAAA,CAAW+f,WAAA,CAAYle,MAAA,GAAS;gBAC5DwB,CAAA,GAAKrD,CAAA,CAAW8N,OAAA,CAAQ9N,CAAA,CAAW8N,OAAA,CAAQjM,MAAA,GAAS;gBACpD4B,CAAA,GAAUzD,CAAA,CAAWggB,IAAA,CAAKhgB,CAAA,CAAWggB,IAAA,CAAKne,MAAA,GAAS,IAAI;gBACvD2I,CAAA,GAAQxK,CAAA,CAAWggB,IAAA,CAAKhgB,CAAA,CAAWggB,IAAA,CAAKne,MAAA,GAAS;gBACjDuJ,CAAA,GAAOrL,CAAA,CAAUkB,CAAA,GAAO;cAC9B,IAAIoK,CAAA,GAAQ;gBACRC,CAAA,GAAQ;gBACRhF,CAAA,GAAW;cAmBf,IAjBE+E,CAAA,GADE5H,CAAA,GAAU+G,CAAA,KAAU,IACd,mCACU/J,CAAA,2BAChBQ,CAAA,mBAAuBA,CAAA,WAAeoC,CAAA,MAAQI,CAAA,4BAC1CxC,CAAA,kBAAsBA,CAAA,YAAgBmK,CAAA,kFAI5C5K,CAAA,kBAGQ,mCACUC,CAAA,2BAChBQ,CAAA,mBAAuBA,CAAA,WAAeoC,CAAA,MAAQI,CAAA,sBAChDjD,CAAA,iBAIoC,MAAlCR,CAAA,CAAW+f,WAAA,CAAYle,MAAA,EAAc;gBACvC,MAAMrB,CAAA,GAAKR,CAAA,CAAW+f,WAAA,CAAY/f,CAAA,CAAW+f,WAAA,CAAYle,MAAA,GAAS;kBAC5DtB,CAAA,GAAKP,CAAA,CAAW8N,OAAA,CAAQ9N,CAAA,CAAW8N,OAAA,CAAQjM,MAAA,GAAS;kBACpDb,CAAA,GAAUhB,CAAA,CAAWggB,IAAA,CAAKhgB,CAAA,CAAWggB,IAAA,CAAKne,MAAA,GAAS,IAAI;kBACvDwB,CAAA,GAAQrD,CAAA,CAAWggB,IAAA,CAAKhgB,CAAA,CAAWggB,IAAA,CAAKne,MAAA,GAAS;kBACjD4B,CAAA,GAAO1D,CAAA,CAAUkB,CAAA,GAAO;gBAE5BqK,CAAA,GADEtK,CAAA,GAAUqC,CAAA,KAAU,IACd,qCACU7C,CAAA,6BAChBS,CAAA,mBAAuBA,CAAA,WAAeV,CAAA,MAAQS,CAAA,8BAC1CC,CAAA,kBAAsBA,CAAA,YAAgBwC,CAAA,8BACpChD,CAAA,8DAKA,qCACUD,CAAA,6BAChBS,CAAA,mBAAuBA,CAAA,WAAeV,CAAA,MAAQS,CAAA,uBAGlDsF,CAAA,GAAW,yB;;cAmBb,OAdoB,uCACIrF,CAAA,yBAClBA,CAAA,iEAGQD,CAAA,wCAEdsK,CAAA,eACAD,CAAA,eACA/E,CAAA,eACA/F,CAAA,8C;;YAKK;cACL,MAAM8C,CAAA,GAAa5C,CAAA,CAAAwL,SAAA,CAAU9H,IAAA,CAAKnE,CAAA,CAAW+f,WAAA;gBACvCtc,CAAA,GAAgBhD,CAAA,CAAAwL,SAAA,CAAUqJ,cAAA,CAAetV,CAAA,CAAW+f,WAAA;gBACpDvV,CAAA,GAAc/G,CAAA,CAAc5B,MAAA;gBAC5BuJ,CAAA,GAAWpL,CAAA,CAAWggB,IAAA,CAAKne,MAAA;gBAC3BwJ,CAAA,GAA0BI,CAAA,CAAgBjB,CAAA;gBAC1Cc,CAAA,GAAgBhF,CAAA,CAAUvG,CAAA,EAAW;gBACrCwG,CAAA,GAAWD,CAAA,CAAUtG,CAAA,CAAWggB,IAAA,EAAM;gBACtCrU,CAAA,GAAoBrF,CAAA,CAAU7C,CAAA,EAAe;gBAC7CmI,CAAA,GAActF,CAAA,CAAUtG,CAAA,CAAW8N,OAAA,EAAS;cAElD,IAAIhC,CAAA,GAAU;cAiDd,OA/CEA,CAAA,GAHc9L,CAAA,CAAWggB,IAAA,CAAKuF,MAAA,CAAO,CAACxlB,CAAA,EAAKC,CAAA,KAAQD,CAAA,GAAMC,CAAA,IAG/C,oMAQVQ,CAAA,kBAGU,4BAEZA,CAAA,cAGoB,aACtB6K,CAAA,uCAC0BpK,CAAA,yBAClBA,CAAA,4DAEKuJ,CAAA,0BACFY,CAAA,+BACKnK,CAAA,mCACIuJ,CAAA,6BACNA,CAAA,iBACZjE,CAAA,eACA+E,CAAA,eACAM,CAAA,eACAD,CAAA,+BAEc3K,CAAA,2FAGMqC,CAAA,0HAGLpC,CAAA,MAAUuJ,CAAA,SAAoBvJ,CAAA,2DACTA,CAAA,MAAUuJ,CAAA,mCAC3BvJ,CAAA,MAAUuJ,CAAA,mCACzBsB,CAAA,4BAEJvL,CAAA,gD;;;UASN+F,CAAA,GAAYkf,CAACzlB,CAAA,EAA0BC,CAAA;YAC3C,IAAIQ,CAAA,GAAQ;YACZ,KAAK,IAAID,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAM8B,MAAA,EAAQtB,CAAA,IAChCC,CAAA,IAAS,WACLR,CAAA,IAAaO,CAAA,OAAQR,CAAA,CAAMQ,CAAA;YAGjC,OAAOC,CAAK;UAAA;UAGRiL,CAAA,GAAmB1L,CAAA,IAAyB,4CACTA,CAAA,sBAA0BA,CAAA,yBACzDA,CAAA,2DAGgBA,CAAA,uHAIZA,CAAA,sB;;;;;;;;QC1Wd,MAAAQ,CAAA,GAAAC,CAAA;UAEAC,CAAA,GAAAD,CAAA;UAEAQ,CAAA,GAAAR,CAAA;UAEAS,CAAA,GAAAT,CAAA;UAUM6C,CAAA,GACFkiB,CAACxlB,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA,EAA8BD,CAAA,EACzFE,CAAA;YACC+J,CAAA,CAAexK,CAAA;YAEf,MAAMgB,CAAA,GAAwB;cAC5B+C,IAAA,EAAAxD,CAAA;cACAoK,UAAA,EAAY,CAAC;cACb2I,UAAA,EAAY,CAACrS,CAAA,CAAAmT,WAAA,CAAYgB,QAAA;YAAA;YAW3B,OAAO,CARQrV,CAAA,CAAiBmU,GAAA,CAAItR,MAAA,CAADC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAE1B7B,CAAA,GAAqB;cACxBwS,SAAA,EAAWhT,CAAA,CAAWsC,QAAA;cACtByB,GAAA,EAAKA,CAAA,KACDd,CAAA,CAAwB1D,CAAA,EAAkBC,CAAA,EAAQQ,CAAA,EAAYD,CAAA,EAAME,CAAA,EAAUO,CAAA;YAAA,IAEpFhB,CAAA,EACW;UAAA;QAGRA,CAAA,CAAAqb,qBAAA,GAAmEtb,CAAA;UAC9E,MAAMC,CAAA,GAAOD,CAAA,CAAK4d,UAAA,CAAW/Y,OAAA,CAAQ,QAAQ;YACvCpE,CAAA,GAAqD,MAA1CT,CAAA,CAAK4d,UAAA,CAAWnZ,MAAA,CAAO,YAAY;UACpD,QAAO,GAAAjE,CAAA,CAAA6C,2BAAA,EAA4B;YAACqiB,IAAA,EAAAzlB,CAAA;YAAM0lB,QAAA,EAAAllB;UAAA,EAAU;QAAA;QAGtD,MAAMiD,CAAA,GACFkiB,CAAC5lB,CAAA,EAAgCC,CAAA,EAAkBQ,CAAA,EAA8BD,CAAA,EAAcE,CAAA,EAC9F4C,CAAA;YACC,MAAMI,CAAA,GAAwB;cACxB+G,CAAA,GAAQxK,CAAA,CAAO,GAAG4T,IAAA,CAAK/R,MAAA,IAAU;cAEjCuJ,CAAA,GAAU;cAEVC,CAAA,GAAOrK,CAAA,CAAAiL,SAAA,CAAU2Z,aAAA,CAAcplB,CAAA,CAAWilB,IAAA,EAAMzlB,CAAA,CAAO,GAAG4T,IAAA,CAAK/R,MAAA;cAC/DyJ,CAAA,GAAM7K,CAAA,CAAST,CAAA,EAAQqL,CAAA;YAC7B,IAAI/E,CAAA,GAAYgF,CAAA,CAAI;YAEpB,KAAK,IAAIvL,CAAA,GAAI,GAAGA,CAAA,GAAIC,CAAA,CAAO,GAAG4T,IAAA,CAAK/R,MAAA,EAAQ9B,CAAA,IAErCsL,CAAA,CAAKc,OAAA,CAAQpM,CAAA,KAAM,KAAqB,MAAhBsL,CAAA,CAAKxJ,MAAA,IAC3BrB,CAAA,CAAWklB,QAAA,IACbjiB,CAAA,CAAYsD,IAAA,CAAK,IAInBT,CAAA,GAAY,wBACDvG,CAAA,UAAWA,CAAA,MAAOC,CAAA,CAAO,GAAG4T,IAAA,CAAK7T,CAAA,OAAQA,CAAA,+BACvCA,CAAA,QAASA,CAAA,kBAClBuG,CAAA,oBAGJ8E,CAAA,CAAQrE,IAAA,CAAK,YAAYhH,CAAA,iBAAkB0D,CAAA,CAAY5B,MAAA,OAEvD4B,CAAA,CAAYsD,IAAA,CAAK/G,CAAA,CAAO,GAAG4T,IAAA,CAAK7T,CAAA;YAIpC,MAEM0L,CAAA,GAAe,uCAFPhI,CAAA,CAAY5B,MAAA,IAAU,qFAKnB2I,CAAA,6CACbY,CAAA,CAAQjI,IAAA,CAAK,kBACbmI,CAAA,CAAI,oDACJhF,CAAA,aACAgF,CAAA,CAAI;YAIR,OAAO1I,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKQ,CAAA,GAAqB;cACxBwG,MAAA,EAAQ;gBAAC+J,IAAA,EAAMnQ,CAAA;gBAAasB,IAAA,EAAM/E,CAAA,CAAO,GAAG+E,IAAA;gBAAM8O,WAAA,EAAa5S,CAAA,CAAAmT,WAAA,CAAYgB;cAAA;cAC3ExE,YAAA,EAAAnF;YAAA,EAAY;UAAA;UAIdjB,CAAA,GAAkBzK,CAAA;YAEtB,KAAKA,CAAA,IAA4B,MAAlBA,CAAA,CAAO8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM;YAGlB,KAA8C,MAA1C3D,CAAA,CAAAmiB,YAAA,CAAazW,OAAA,CAAQpM,CAAA,CAAO,GAAGgF,IAAA,GACjC,MAAM,IAAIX,KAAA,CAAM,sB;;QAIPpE,CAAA,CAAA0b,SAAA,GACT,CAAC3b,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA,KAEnD6C,CAAA,CAAOtD,CAAA,EAAkBC,CAAA,EAAQQ,CAAA,EAAY,aADzB,MAAgB,CAAC,gBAAgB,0BAA0B,MAI/ER,CAAA,CAAAub,UAAA,GACT,CAACxb,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA,KAWnD6C,CAAA,CAAOtD,CAAA,EAAkBC,CAAA,EAAQQ,CAAA,EAAY,cAVzB,CAACT,CAAA,EAAkBC,CAAA;UAC5C,IAAIQ,CAAA,GAAO;UACX,KAAK,IAAID,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,EAAQtB,CAAA,KACrCP,CAAA,CAAKmM,OAAA,CAAQ5L,CAAA,KAAM,KAAqB,MAAhBP,CAAA,CAAK6B,MAAA,MAC/BrB,CAAA,IAAQT,CAAA,CAAO,GAAG6T,IAAA,CAAKrT,CAAA;UAI3B,OAAO,CAAC,gBAAgB,0BAA0B,YAAYC,CAAA,KAAS;QAAA,IAKlER,CAAA,CAAAsb,SAAA,GACT,CAACvb,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA,KAWnD6C,CAAA,CAAOtD,CAAA,EAAkBC,CAAA,EAAQQ,CAAA,EAAY,aAVzB,CAACT,CAAA,EAAkBC,CAAA;UAC5C,MAAMQ,CAAA,GAAU;UAChB,KAAK,IAAID,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,EAAQtB,CAAA,KACrCP,CAAA,CAAKmM,OAAA,CAAQ5L,CAAA,KAAM,KAAqB,MAAhBP,CAAA,CAAK6B,MAAA,KAC/BrB,CAAA,CAAQuG,IAAA,CAAK,YAAYxG,CAAA;UAI7B,OAAO,CAAC,GAAGC,CAAA,CAAQ2C,IAAA,CAAK,gCAAgC,qCAAqC,GAAG;QAAA,IAK3FnD,CAAA,CAAAwb,SAAA,GACT,CAACzb,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA,KAWnD6C,CAAA,CAAOtD,CAAA,EAAkBC,CAAA,EAAQQ,CAAA,EAAY,aAVzB,CAACT,CAAA,EAAkBC,CAAA;UAC5C,MAAMQ,CAAA,GAAU;UAChB,KAAK,IAAID,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,EAAQtB,CAAA,KACrCP,CAAA,CAAKmM,OAAA,CAAQ5L,CAAA,KAAM,KAAqB,MAAhBP,CAAA,CAAK6B,MAAA,KAC/BrB,CAAA,CAAQuG,IAAA,CAAK,YAAYxG,CAAA;UAI7B,OAAO,CAAC,GAAGC,CAAA,CAAQ2C,IAAA,CAAK,gCAAgC,qCAAqC,GAAG;QAAA,IAK3FnD,CAAA,CAAAyb,UAAA,GACT,CAAC1b,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA,KAEnD6C,CAAA,CAAOtD,CAAA,EAAkBC,CAAA,EAAQQ,CAAA,EAAY,cADzB,MAAgB,CAAC,gBAAgB,0BAA0B,MAI/ER,CAAA,CAAAob,YAAA,GACT,CAACrb,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA,KAEnD6C,CAAA,CAAOtD,CAAA,EAAkBC,CAAA,EAAQQ,CAAA,EAAY,gBADzB,MAAgB,CAAC,gBAAgB,0BAA0B,yBAI/ER,CAAA,CAAA2b,kBAAA,GACT,CAAC5b,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA,KAEnD6C,CAAA,CAAOtD,CAAA,EAAkBC,CAAA,EAAQQ,CAAA,EAAY,sBADzB,MAAgB,CAAC,yBAAyB,qCAAqC,I;;;;;;;;QC3KhH,MAAAD,CAAA,GAAAC,CAAA;UACAC,CAAA,GAAAD,CAAA;UAEAQ,CAAA,GAAAR,CAAA;UAEAS,CAAA,GAAAT,CAAA;QAyEaR,CAAA,CAAA2V,sCAAA,GACT,CAAC5V,CAAA,EAAgCC,CAAA,EAAiBQ,CAAA;UAChD,MAAM6C,CAAA,GAzEiC,CAACtD,CAAA,KAC1C;YAAEgE,IAAA,EAAM;YAAoBuP,UAAA,EAAY,CAACtS,CAAA,CAAAoT,WAAA,CAAYC,MAAA;YAAS1J,UAAA,EAAY,CAAC;YAAM6I,SAAA,EAAW,GAAGzT,CAAA;UAAA,IAwEvCS,CAAA;UACtD,OAAOoC,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAWQ,CAAA,GAAQ;YAAEkB,GAAA,EAAKA,CAAA,KAtE5B,EAACxE,CAAA,EAAgCC,CAAA,EAAiBQ,CAAA,EAA2B6C,CAAA;cAEvE,MAAMI,CAAA,GAAezD,CAAA,CAAQ4T,IAAA;gBACvBpJ,CAAA,GAAsBnH,CAAA;cAE5B,IAAI+H,CAAA,GAAW;cACf,KAAK,IAAIrL,CAAA,GAAI,GAAGA,CAAA,GAAI,GAAGA,CAAA,IAAK;gBAC1B,IAAIC,CAAA,GAAe;gBACnB,QAAQD,CAAA;kBACN,KAAK;oBACHC,CAAA,GAAe;oBACf;kBACF,KAAK;oBACHA,CAAA,GAAe;oBACf;kBACF,KAAK;oBACHA,CAAA,GAAe;oBACf;kBACF,KAAK;oBACHA,CAAA,GAAe;oBACf;kBACF;oBACE,MAAM,IAAIoE,KAAA;gBAAA;gBAGdgH,CAAA,IAAY,aACdpL,CAAA,aACAD,CAAA,GAAI,IAAI,wDAAwD,+OAMvDA,CAAA,gFAETA,CAAA,GAAI,IAAI,MAAM,Y;;cAGd,MAAMsL,CAAA,IAAO,GAAA5K,CAAA,CAAAmJ,OAAA,EAAQ7J,CAAA,CAAQiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUnF,OAAA;gBAEjD4I,CAAA,GAAe,WAsE/B,UAAgCvL,CAAA;kBAC9B,MAAMC,CAAA,GAAUO,CAAA,CAAA0L,SAAA,CAAUqJ,cAAA,CAAevV,CAAA;oBACnCS,CAAA,GAAS,CAAC,KAAK,KAAK;oBACpBC,CAAA,GAAQ;kBAWd,OAAO,oEAVwBT,CAAA,CACKkD,GAAA,CAAI,CAACnD,CAAA,EAAQQ,CAAA,KAKL,OAJcC,CAAA,CAAOD,CAAA,OAAQE,CAAA,MAAWV,CAAA,KACjCQ,CAAA,KAAMP,CAAA,CAAQ6B,MAAA,GAAS,IACjC,OAAOrB,CAAA,CAAOD,CAAA,GAAI,QAAQE,CAAA,MAAWD,CAAA,CAAOD,CAAA,OAAQR,CAAA,KACpD,YAAYS,CAAA,CAAOD,CAAA,OAAQR,CAAA,OAGhCoD,IAAA,CAAK,8CAQ3C;gBAAA,CAzFQ,CAAuBM,CAAA,YA2F/B,UAAiC1D,CAAA;kBAC/B,MAAMC,CAAA,GAAUO,CAAA,CAAA0L,SAAA,CAAUqJ,cAAA,CAAevV,CAAA;kBAEzC,OAAO,+FAGeC,CAAA,CAAQ,mBAAmBA,CAAA,CAAQ,uBAG3D;gBAAA,CAnGQ,CAAwBwK,CAAA,aACxB,GAAAvJ,CAAA,CAAAqe,iBAAA,4JAQa9U,CAAA,CAAoB,2BACpBA,CAAA,CAAoB,kBAE/BY,CAAA,aACAC,CAAA,CAAKxB,MAAA;cAIL,OAAOjH,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKrC,CAAA,GAAQ;gBACXqJ,MAAA,EAAQ;kBAAC+J,IAAA,EAAMpJ,CAAA;kBAAqBzF,IAAA,EAAM/E,CAAA,CAAQ+E,IAAA;kBAAM8O,WAAA,EAAa7S,CAAA,CAAAoT,WAAA,CAAYC;gBAAA;gBACjFzD,YAAA,EAAAtF,CAAA;gBACAuF,OAAA,GAAS;cAAA,EAAI;YAAA,GAO8C9Q,CAAA,EAASC,CAAA,EAASqD,CAAA,EAAU7C,CAAA;UAAA,EAAc;QAAA,GAGjHR,CAAA,CAAA0V,aAAA,aAA8B3V,CAAA;UAC5B,IAAqB,MAAjBA,CAAA,CAAM8B,MAAA,EACR,OAAO,CAAC,GAAG,GAAG;UAGhB,IAAI7B,CAAA,GAAQ;UACZ,KAAK,IAAIQ,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAM8B,MAAA,GAAS,KAAKrB,CAAA,EACtCR,CAAA,IAASD,CAAA,CAAMS,CAAA;UAEjB,OAAO,CAACR,CAAA,EAAOD,CAAA,CAAM8B,MAAA,GAAS,IAAI9B,CAAA,CAAMA,CAAA,CAAM8B,MAAA,GAAS,KAAK,GAAG9B,CAAA,CAAMA,CAAA,CAAM8B,MAAA,GAAS,GACtF;QAAA,GAaA7B,CAAA,CAAAyV,cAAA,aAA+B1V,CAAA,EAAyBC,CAAA;UACtD,IAAIQ,CAAA,IAAiB;UAUrB,OAREA,CAAA,GADkB,MAAhBT,CAAA,CAAK8B,MAAA,IAAwC,MAAxB7B,CAAA,CAAa6B,MAAA,KAE3B9B,CAAA,CAAK8B,MAAA,GAAS,KAAK7B,CAAA,CAAa6B,MAAA,GAAS,IACjC9B,CAAA,CAAKA,CAAA,CAAK8B,MAAA,GAAS,OAAO7B,CAAA,CAAaA,CAAA,CAAa6B,MAAA,GAAS,KAE7D9B,CAAA,CAAKA,CAAA,CAAK8B,MAAA,GAAS,OAAO7B,CAAA,CAAaA,CAAA,CAAa6B,MAAA,GAAS,MAC1E9B,CAAA,CAAKA,CAAA,CAAK8B,MAAA,GAAS,OAAO7B,CAAA,CAAaA,CAAA,CAAa6B,MAAA,GAAS,KAG5DrB,CACT;QAAA,C;;;;;;;;QCvHA,MAAAD,CAAA,GAAAC,CAAA;QAGaR,CAAA,CAAA6b,OAAA,GAAU,CAAC9b,CAAA,EAAgCC,CAAA;UACtD,MAAMQ,CAAA,GAAeD,CAAA,CAAA0L,SAAA,CAAU4Z,qBAAA,CAAsB7lB,CAAA,CAAO,GAAG4T,IAAA,EAAM5T,CAAA,CAAO,GAAGokB,WAAA;UAC/E,OAAIrkB,CAAA,CAAQiT,OAAA,CAAQrL,IAAA,GACX,CAAC5H,CAAA,CAAQyV,aAAA,CAAcxV,CAAA,CAAO,IAAIQ,CAAA,KAElC,CAACT,CAAA,CAAQoV,eAAA,CAAgBnV,CAAA,CAAO,IAAIQ,CAAA,E;;;;;;;;;QCN/C,MAAAD,CAAA,GAAAC,CAAA;UAEAC,CAAA,GAAAD,CAAA;UACAQ,CAAA,GAAAR,CAAA;UAEAS,CAAA,GAAAT,CAAA;UACA6C,CAAA,GAAA7C,CAAA;UAEMiD,CAAA,GAAwB;YAC5BM,IAAA,EAAM;YACN4G,UAAA,EAAY,CAAC;YACb2I,UAAA,EAAY,CAAC7S,CAAA,CAAA2T,WAAA,CAAYC,MAAA;UAAA;QAGdrU,CAAA,CAAA8b,MAAA,GACT,CAAC/b,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA,OAC1D,GAAA6C,CAAA,CAAA4d,cAAA,EAAejhB,CAAA,EAAQQ,CAAA,GAQhB,CAPQT,CAAA,CAAiBmU,GAAA,CAAItR,MAAA,CAADC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAE1BY,CAAA,GAAqB;UACxB+P,SAAA,EAAWhT,CAAA,CAAWsC,QAAA;UACtByB,GAAA,EAAKA,CAAA,KAAMiG,CAAA,CAA8BzK,CAAA,EAAkBC,CAAA,EAAQQ,CAAA;QAAA,IAErER,CAAA,KAIGA,CAAA,CAAA+b,wBAAA,GACRhc,CAAA,KAAyC,GAAAsD,CAAA,CAAAyiB,uBAAA,EAAwB/lB,CAAA,EAAM,KAE/DC,CAAA,CAAAgc,wBAAA,GACRjc,CAAA,KAAyC,GAAAsD,CAAA,CAAAyiB,uBAAA,EAAwB/lB,CAAA,EAAM;QAE5E,MAAMyK,CAAA,GACFub,CAAChmB,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA;YAC1D,MAAM6C,CAAA,IAAO,GAAA9C,CAAA,CAAAqJ,OAAA,EAAQ7J,CAAA,CAAiBiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUnF,OAAA;cAAA,CACzD8H,CAAA,EAAQa,CAAA,IAAeD,CAAA,CAAcpL,CAAA,EAAQQ,CAAA;YAIpD,IADIgK,CAAA,CAAOwb,KAAA,CAAOjmB,CAAA,IAAoB,MAANA,CAAA,KAAmD,yBAAvCS,CAAA,CAAWylB,uBAAA,EAErD,OAAOrjB,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKY,CAAA,GAAqB;cACxBoG,MAAA,EAAQ;gBAAC+J,IAAA,EAAMvI,CAAA;gBAAatG,IAAA,EAAM/E,CAAA,CAAO,GAAG+E,IAAA;gBAAM8O,WAAA,EAAapT,CAAA,CAAA2T,WAAA,CAAYC;cAAA;cAC3ExD,OAAA,GAAS;cACTD,YAAA,EAAc,+CACOvN,CAAA,CAAKoH,SAAA,wCACdpH,CAAA,CAAKwG,MAAA;YAAA;YAKrB,MAAMyB,CAAA,GAAMD,CAAA,CAAYxJ,MAAA;YACxB,IAAIyJ,CAAA,GAAM,GACR,MAAM,IAAIlH,KAAA,CAAM,kDAAkDkH,CAAA;YAGpE,MAAMhF,CAAA,GAAe+E,CAAA,CAAYC,CAAA,GAAM;cACjCG,CAAA,GAAcJ,CAAA,CAAYC,CAAA,GAAM;cAEhC/E,CAAA,GAAavG,CAAA,CAAO,GAAG4T,IAAA;YAC7B,IAAItI,CAAA,KAAQ/E,CAAA,CAAW1E,MAAA,EACrB,MAAM,IAAIuC,KAAA,CAAM,uCAAuCmC,CAAA,CAAW1E,MAAA,aAAmByJ,CAAA;YAEvF,MAAMK,CAAA,GAAcpF,CAAA,CAAW+E,CAAA,GAAM;cAC/BM,CAAA,GAAarF,CAAA,CAAW+E,CAAA,GAAM;cAE9BQ,CAAA,GAAetB,CAAA,CAAOc,CAAA,GAAM;cAC5BS,CAAA,GAAcvB,CAAA,CAAOc,CAAA,GAAM;YAEjC,IAAIU,CAAA,GAAqB;YAEzB,IAAwB,aAApBxL,CAAA,CAAWohB,IAAA,EAEb,MAAM,IAAIxd,KAAA,CAAM,2CAA2C5D,CAAA,CAAWohB,IAAA;YAExE,QAAQphB,CAAA,CAAWylB,uBAAA;cACjB,KAAK;gBACHja,CAAA,GAAqB;gBAKrB;cACF,KAAK;gBACHA,CAAA,GAAqB;gBAKrB;cACF,KAAK;gBACHA,CAAA,GAAqB,0LAIDP,CAAA,wFACAnF,CAAA,wFACAmF,CAAA,wFACAnF,CAAA;gBAIpB;cACF,KAAK;gBACH0F,CAAA,GAAqB,8GAEeP,CAAA,aAAwBnF,CAAA,aAAyBmF,CAAA,0CACjEnF,CAAA,4DACiBsF,CAAA,aAAuBD,CAAA,aAAwBC,CAAA,0CAChED,CAAA;gBAKpB;cACF;gBAEE,MAAM,IAAIvH,KAAA,CAAM,8FACS5D,CAAA,CAAWylB,uBAAA;YAAA;YAGxC,MAAM/Z,CAAA,IAAiB,GAAAlL,CAAA,CAAA0K,iBAAA,EAAkBJ,CAAA;cAEnCc,CAAA,GAAe,2CACaT,CAAA,OAAkBC,CAAA,uDACVE,CAAA,YAAwBC,CAAA,YAAuBD,CAAA,YACrFC,CAAA,qBAJkB,GAAA9K,CAAA,CAAAqe,iBAAA,oBAMdtT,CAAA,gMAKIE,CAAA,q8BAiByB5F,CAAA,GAAe,gDACfmF,CAAA,GAAc,urEAsCvCpI,CAAA,CAAKwG,MAAA;YAGjB,OAAOjH,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKY,CAAA,GAAqB;cACxBoG,MAAA,EAAQ;gBAAC+J,IAAA,EAAMvI,CAAA;gBAAatG,IAAA,EAAM/E,CAAA,CAAO,GAAG+E,IAAA;gBAAM8O,WAAA,EAAapT,CAAA,CAAA2T,WAAA,CAAYC;cAAA;cAC3ExD,OAAA,GAAS;cACTD,YAAA,EAAAxE;YAAA,EAAY;UAAA;UAKdhB,CAAA,GAAgB8a,CAACnmB,CAAA,EAAkBC,CAAA;YACvC,MACMQ,CAAA,GADIT,CAAA,CAAO,GACD6T,IAAA;YAEhB,IACIrT,CAAA;cADAE,CAAA,GAAST,CAAA,CAAWmmB,MAAA;YAExB,IAAsB,MAAlB1lB,CAAA,CAAOoB,MAAA,EAAc;cACvB,MAAMb,CAAA,GAAejB,CAAA,CAAOC,CAAA,CAAWomB,cAAA;cACvC,IAAIplB,CAAA,IAAsC,MAAtBA,CAAA,CAAamD,IAAA,EAAY;gBAC3C,IAAIpE,CAAA,CAAOC,CAAA,CAAWqmB,aAAA,GACpB,MAAM,IAAIjiB,KAAA,CAAM;gBAElB3D,CAAA,GAAS4K,CAAA,CAAgBrK,CAAA,EAAchB,CAAA,CAAW4hB,IAAA,EAAM5hB,CAAA,CAAWsmB,QAAA,C;qBAC9D;gBACL,MAAMtlB,CAAA,GAAcjB,CAAA,CAAOC,CAAA,CAAWqmB,aAAA;gBACtC,KAAKrlB,CAAA,IAAoC,MAArBA,CAAA,CAAYmD,IAAA,EAC9B,MAAM,IAAIC,KAAA,CAAM;gBAGlB7D,CAAA,GAAcwF,KAAA,CAAMoZ,IAAA,CAAKne,CAAA,CAAYojB,WAAA,GACrC3jB,CAAA,GAAS6K,CAAA,CAA8B/K,CAAA,EAAaC,CAAA,EAAOR,CAAA,CAAW4hB,IAAA,EAAM5hB,CAAA,CAAWsmB,QAAA,C;;mBAGzF,IAAIvmB,CAAA,CAAOC,CAAA,CAAWqmB,aAAA,GACpB,MAAM,IAAIjiB,KAAA,CAAM;YAIpB,MAAMpD,CAAA,GAAQT,CAAA,IAAgBC,CAAA,CAAM0C,GAAA,CAAI,CAACnD,CAAA,EAAKC,CAAA,KAAM+B,IAAA,CAAKoX,KAAA,CAAMpZ,CAAA,GAAMU,CAAA,CAAOT,CAAA;YAE5E,OAAO,CAACS,CAAA,EAAQO,CAAA,CAAM;UAAA;UAGlBqK,CAAA,GAAkBkb,CAACxmB,CAAA,EAAeC,CAAA,EAAcQ,CAAA;YACpD,MAAMD,CAAA,GAASwF,KAAA,CAAMoZ,IAAA,CAAKpf,CAAA,CAAMskB,SAAA;YAEhC,QADA,GAAAhhB,CAAA,CAAAmjB,gBAAA,EAAiBjmB,CAAA,EAAQP,CAAA,EAAMQ,CAAA,GACxBD,CAAM;UAAA;UAGT+K,CAAA,GACFmb,CAAC1mB,CAAA,EAA0BC,CAAA,EAA0BQ,CAAA,EAAcD,CAAA;YACjE,MAAME,CAAA,GAAST,CAAA,CAAM6B,MAAA;cACfb,CAAA,GAAS,IAAI+E,KAAA,CAActF,CAAA;YAEjC,KAAK,IAAID,CAAA,GAAI,GAAGD,CAAA,GAAME,CAAA,EAAQD,CAAA,GAAID,CAAA,EAAKC,CAAA,IACrC,IAAiB,MAAbR,CAAA,CAAMQ,CAAA,GAAU;cAClB,IAAiB,MAAbT,CAAA,CAAMS,CAAA,GACR,MAAM,IAAI4D,KAAA,CAAM;cAElBpD,CAAA,CAAOR,CAAA,IAAK,C;mBAEZQ,CAAA,CAAOR,CAAA,IAAKT,CAAA,CAAMS,CAAA,IAAKR,CAAA,CAAMQ,CAAA;YAIjC,QADA,GAAA6C,CAAA,CAAAmjB,gBAAA,EAAiBxlB,CAAA,EAAQR,CAAA,EAAMD,CAAA,GACxBS,CAAM;UAAA,C;;;;;;;;QCpQnB,MAAAT,CAAA,GAAAC,CAAA;QAGaR,CAAA,CAAA6N,KAAA,GAAQ,CAAC9N,CAAA,EAAyCC,CAAA,MAC7DS,CAAA,CAAeT,CAAA,GACR,CAAC,IAAIO,CAAA,CAAAyF,MAAA,CAAO,CAAChG,CAAA,CAAO,GAAG4T,IAAA,CAAK/R,MAAA,GAAS,cAAS,QAAW,GAAW,IAAI6kB,UAAA,CAAW1mB,CAAA,CAAO,GAAG4T,IAAA;QAGtG,MAAMnT,CAAA,GAAkBV,CAAA;UACtB,KAAKA,CAAA,IAA4B,MAAlBA,CAAA,CAAO8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM,0B;;;;;;;;;QCVpB,MAAA7D,CAAA,GAAAC,CAAA;UAEAC,CAAA,GAAAD,CAAA;UAEAQ,CAAA,GAAAR,CAAA;UAEAS,CAAA,GAAAT,CAAA;UAQM6C,CAAA,GAAuB;YAC3BU,IAAA,EAAM;YACN4G,UAAA,EAAY,CAAC;YACb2I,UAAA,EAAY,CAACrS,CAAA,CAAAmT,WAAA,CAAYgB,QAAA;UAAA;QAGdpV,CAAA,CAAAiN,KAAA,GACT,CAAClN,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA,MAC1DgK,CAAA,CAAexK,CAAA,GAQR,CAPQD,CAAA,CAAiBmU,GAAA,CAAItR,MAAA,CAADC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAE1BQ,CAAA,GAAoB;UACvBmQ,SAAA,EAAWhT,CAAA,CAAWsC,QAAA;UACtByB,GAAA,EAAKA,CAAA,KAAMd,CAAA,CAAuB1D,CAAA,EAAkBC,CAAA,CAAO,IAAIQ,CAAA;QAAA,IAEjER,CAAA,KAIGA,CAAA,CAAAoc,oBAAA,GAAiErc,CAAA;UAC5E,MAAMC,CAAA,GAASD,CAAA,CAAK4d,UAAA,CAAW/Y,OAAA,CAAQ;YACjCpE,CAAA,GAAOT,CAAA,CAAK4d,UAAA,CAAW/Y,OAAA,CAAQ;YAC/BnE,CAAA,GAAOV,CAAA,CAAK4d,UAAA,CAAW/Y,OAAA,CAAQ,QAAQ;UAC7C,QAAO,GAAArE,CAAA,CAAA6C,2BAAA,EAA4B;YAACujB,MAAA,EAAA3mB,CAAA;YAAQ4mB,IAAA,EAAApmB,CAAA;YAAMilB,IAAA,EAAAhlB;UAAA,EAAM;QAAA;QAG1D,MAAMgD,CAAA,GACFojB,CAAC9mB,CAAA,EAAyCC,CAAA,EAAeQ,CAAA;YACvD,MAAMD,CAAA,GAAmC,MAA3BC,CAAA,CAAWilB,IAAA,CAAK5jB,MAAA,GAAgB7B,CAAA,CAAM4T,IAAA,CAAK3G,KAAA,CAAM,GAAG/J,GAAA,CAAI,CAACnD,CAAA,EAAKC,CAAA,KAAMA,CAAA,IAAKQ,CAAA,CAAWilB,IAAA;cAC5FhlB,CAAA,GAAiBO,CAAA,CAAAiL,SAAA,CAAU2Z,aAAA,CAAcrlB,CAAA,EAAMP,CAAA,CAAM4T,IAAA,CAAK/R,MAAA;cAC1D4B,CAAA,GAASjD,CAAA,CAAWmmB,MAAA,CAAOzjB,GAAA,CAAI,CAACnD,CAAA,EAAOS,CAAA,KACvCT,CAAA,GAAQC,CAAA,CAAM4T,IAAA,CAAKnT,CAAA,CAAeD,CAAA,KAAM,IACnCR,CAAA,CAAM4T,IAAA,CAAKnT,CAAA,CAAeD,CAAA,KAE5BQ,CAAA,CAAAiL,SAAA,CAAU0W,aAAA,CAAc5iB,CAAA,EAAOC,CAAA,CAAM4T,IAAA,CAAKnT,CAAA,CAAeD,CAAA;cAE5DgK,CAAA,GAAOhK,CAAA,CAAWomB,IAAA,CAAK1jB,GAAA,CAAI,CAACnD,CAAA,EAAKS,CAAA,KACjCT,CAAA,GAAMC,CAAA,CAAM4T,IAAA,CAAKnT,CAAA,CAAeD,CAAA,KAAM,IACjCR,CAAA,CAAM4T,IAAA,CAAKnT,CAAA,CAAeD,CAAA,KAE5BQ,CAAA,CAAAiL,SAAA,CAAU0W,aAAA,CAAc5iB,CAAA,EAAKC,CAAA,CAAM4T,IAAA,CAAKnT,CAAA,CAAeD,CAAA;cAG1D4K,CAAA,GAAcpL,CAAA,CAAM4T,IAAA,CAAK3G,KAAA;cAEzB5B,CAAA,GAAqB;YAC3B,KAAK,IAAItL,CAAA,GAAI,GAAGA,CAAA,GAAIU,CAAA,CAAeoB,MAAA,EAAQ9B,CAAA,IACzCqL,CAAA,CAAY3K,CAAA,CAAeV,CAAA,KAAMyK,CAAA,CAAKzK,CAAA,IAAK0D,CAAA,CAAO1D,CAAA,GAC9C0D,CAAA,CAAO1D,CAAA,IAAK,KACdsL,CAAA,CAAStE,IAAA,CAAK,aAAatG,CAAA,CAAeV,CAAA,SAAU0D,CAAA,CAAO1D,CAAA;YAI/D,MACMuL,CAAA,GAAe,uCADRF,CAAA,CAAYvJ,MAAA,iBAGrBwJ,CAAA,CAASlI,IAAA,CAAK;YAGlB,OAAOP,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKQ,CAAA,GAAoB;cACvBwG,MAAA,EAAQ;gBAAC+J,IAAA,EAAMxI,CAAA;gBAAarG,IAAA,EAAM/E,CAAA,CAAM+E,IAAA;gBAAM8O,WAAA,EAAa5S,CAAA,CAAAmT,WAAA,CAAYgB;cAAA;cACvExE,YAAA,EAAAtF;YAAA,EAAY;UAAA;UAIdd,CAAA,GAAkBzK,CAAA;YACtB,KAAKA,CAAA,IAA4B,MAAlBA,CAAA,CAAO8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM;YAElB,KAA8C,MAA1C3D,CAAA,CAAAmiB,YAAA,CAAazW,OAAA,CAAQpM,CAAA,CAAO,GAAGgF,IAAA,GACjC,MAAM,IAAIX,KAAA,CAAM,sB;;QAIPpE,CAAA,CAAAmc,QAAA,GAAW,CAACpc,CAAA,EAAyCC,CAAA;UAChEqL,CAAA,CAAkBrL,CAAA;UAClB,MAAMQ,CAAA,GAAa4K,CAAA,CAAkCrL,CAAA,EAAkBC,CAAA;UAQvE,OAAO,CAPQD,CAAA,CAAiBmU,GAAA,CAAItR,MAAA,CAADC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAE1BQ,CAAA,GAAoB;YACvBmQ,SAAA,EAAWhT,CAAA,CAAWsC,QAAA;YACtByB,GAAA,EAAKA,CAAA,KAAMd,CAAA,CAAuB1D,CAAA,EAAkBC,CAAA,CAAO,IAAIQ,CAAA;UAAA,IAEjE,CAACR,CAAA,CAAO,KACG;QAAA;QAGjB,MAAMoL,CAAA,GACF0b,CAAC/mB,CAAA,EAAyCC,CAAA;YACxC,KAAKD,CAAA,CAAiBiT,OAAA,CAAQgD,aAAA,CAAchW,CAAA,CAAO,GAAGuU,MAAA,MACjDxU,CAAA,CAAiBiT,OAAA,CAAQgD,aAAA,CAAchW,CAAA,CAAO,GAAGuU,MAAA,KACjDvU,CAAA,CAAO6B,MAAA,IAAU,MAAM9B,CAAA,CAAiBiT,OAAA,CAAQgD,aAAA,CAAchW,CAAA,CAAO,GAAGuU,MAAA,KACxEvU,CAAA,CAAO6B,MAAA,IAAU,MAAM9B,CAAA,CAAiBiT,OAAA,CAAQgD,aAAA,CAAchW,CAAA,CAAO,GAAGuU,MAAA,GAC3E,MAAM,IAAInQ,KAAA,CAAM;YAGlB,IAAIpE,CAAA,CAAO6B,MAAA,IAAU,KAAK7B,CAAA,CAAO,GAAGokB,WAAA,CAAY2C,IAAA,CAAMhnB,CAAA,IAAoB,MAANA,CAAA,GAClE,MAAM,IAAIqE,KAAA,CAAM;YAGlB,MAAM5D,CAAA,GAASuF,KAAA,CAAMoZ,IAAA,CAAKnf,CAAA,CAAO,GAAGokB,WAAA;cAC9B7jB,CAAA,GAAOwF,KAAA,CAAMoZ,IAAA,CAAKnf,CAAA,CAAO,GAAGokB,WAAA;cAC5B3jB,CAAA,GAAOT,CAAA,CAAO6B,MAAA,IAAU,IAAIkE,KAAA,CAAMoZ,IAAA,CAAKnf,CAAA,CAAO,GAAGokB,WAAA,IAAe;YAEtE,OAAO;cAACuC,MAAA,EAAAnmB,CAAA;cAAQomB,IAAA,EAAArmB,CAAA;cAAMklB,IAAA,EAAAhlB,CAAA;cAAMqC,QAAA,EADX,GAAGrC,CAAA,IAAQD,CAAA,IAAUD,CAAA;YAAA,CACD;UAAA;UAGrC8K,CAAA,GAAqBtL,CAAA;YACzB,KAAKA,CAAA,IAAUA,CAAA,CAAO8B,MAAA,GAAS,KAAK9B,CAAA,CAAO8B,MAAA,GAAS,GAClD,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAuB,YAAnBrE,CAAA,CAAO,GAAGgF,IAAA,IAA8C,MAA1BhF,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,EAC/C,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAuB,YAAnBrE,CAAA,CAAO,GAAGgF,IAAA,IAA8C,MAA1BhF,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,EAC/C,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAIrE,CAAA,CAAO8B,MAAA,IAAU,MAAyB,YAAnB9B,CAAA,CAAO,GAAGgF,IAAA,IAA8C,MAA1BhF,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,GACtE,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAIrE,CAAA,CAAO8B,MAAA,IAAU,MAAyB,YAAnB9B,CAAA,CAAO,GAAGgF,IAAA,IAA8C,MAA1BhF,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,GACtE,MAAM,IAAIuC,KAAA,CAAM,sB;;;;;;;;;QCxIpB,MAAA7D,CAAA,GAAAC,CAAA;UAIAC,CAAA,GAAAD,CAAA;UACAQ,CAAA,GAAAR,CAAA;UAEAS,CAAA,GAAAT,CAAA;UAEA6C,CAAA,GAAA7C,CAAA;UAMMiD,CAAA,GAAmC;YACvCM,IAAA,EAAM;YACN4G,UAAA,EAAY,CAAC;YACb2I,UAAA,EAAY,CAACrS,CAAA,CAAAmT,WAAA,CAAYgB,QAAA;UAAA;UAGrB5K,CAAA,GAAqC;YACzCzG,IAAA,EAAM;YACN4G,UAAA,EAAY,CAAC,KAAK;YAClB2I,UAAA,EAAY,CAACrS,CAAA,CAAAmT,WAAA,CAAYgB,QAAA,EAAUnU,CAAA,CAAAmT,WAAA,CAAYgB,QAAA;UAAA;UAG3ChK,CAAA,GAAyB;YAC7BrH,IAAA,EAAM;YACN4G,UAAA,EAAY,CAAC,KAAK,OAAO;YACzB2I,UAAA,EAAY,CAACrS,CAAA,CAAAmT,WAAA,CAAYgB,QAAA,EAAUnU,CAAA,CAAAmT,WAAA,CAAYgB,QAAA,EAAUnU,CAAA,CAAAmT,WAAA,CAAYgB,QAAA;UAAA;QAG1DpV,CAAA,CAAAqc,OAAA,GACT,CAACtc,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA;UAC1D+F,CAAA,CAAevG,CAAA;UAEf,MAAMO,CAAA,GAAaP,CAAA,CAAO,GAAG4T,IAAA,CAAK3G,KAAA;YAC5BjM,CAAA,GAAOP,CAAA,CAAAwL,SAAA,CAAU0W,aAAA,CAAcniB,CAAA,CAAW+e,IAAA,EAAMhf,CAAA,CAAWsB,MAAA;YAC3DZ,CAAA,GAAkBR,CAAA,CAAAwL,SAAA,CAAU+a,eAAA,CAAgBzmB,CAAA,EAAYS,CAAA;YACxDqC,CAAA,GAAe5C,CAAA,CAAAwL,SAAA,CAAUgb,iBAAA,CAAkB1mB,CAAA,EAAYS,CAAA;UAG7D,OADeqK,CAAA,CAAetL,CAAA,EAAkBC,CAAA,EAAQQ,CAAA,EAAYS,CAAA,EAAiBoC,CAAA,CACxE;QAAA,GAGNrD,CAAA,CAAAsc,sBAAA,GACRvc,CAAA,KAAwC,GAAAQ,CAAA,CAAA6C,2BAAA,EAA4B;UAACmc,IAAA,EAAMxf,CAAA,CAAK4d,UAAA,CAAWnZ,MAAA,CAAO,QAAQ;QAAA,IAElGxE,CAAA,CAAAwc,yBAAA,GACRzc,CAAA,KAAwC,GAAAQ,CAAA,CAAA6C,2BAAA,EAA4B;UAACmc,IAAA,EAAMxf,CAAA,CAAK4d,UAAA,CAAWnZ,MAAA,CAAO,SAAS;QAAA,IAQnGxE,CAAA,CAAAuc,UAAA,GACT,CAACxc,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA;UAC1D+F,CAAA,CAAevG,CAAA;UAEf,MAAMgB,CAAA,GAAahB,CAAA,CAAO,GAAG4T,IAAA,CAAK3G,KAAA;YAC5BhM,CAAA,GAAOR,CAAA,CAAAwL,SAAA,CAAU0W,aAAA,CAAcniB,CAAA,CAAW+e,IAAA,EAAMve,CAAA,CAAWa,MAAA;YAC3D4B,CAAA,GAAOzC,CAAA,CAAWa,MAAA;YAElB2I,CAAA,GAAuBvJ,CAAA,KAASwC,CAAA,GAAO;YACvC2H,CAAA,GAAiC;UACvC,IAEIE,CAAA;YAFAhF,CAAA,GAAiB;YACjBmF,CAAA,GAA6B;UAG7BjB,CAAA,KACFlE,CAAA,GAAOP,KAAA,CAAMoZ,IAAA,CAAK;YAACtd,MAAA,EAAQ4B;UAAA,GAAOP,GAAA,CAAI,CAACnD,CAAA,EAAGC,CAAA,KAAMA,CAAA,GAGhDsG,CAAA,CAAKrF,CAAA,IAAQwC,CAAA,GAAO,GACpB6C,CAAA,CAAK7C,CAAA,GAAO,KAAKxC,CAAA,EAEjBqF,CAAA,CAAKpD,GAAA,CAAInD,CAAA,IAAKqL,CAAA,CAAqBrE,IAAA,CAAK/F,CAAA,CAAWjB,CAAA,KAEnDuL,CAAA,IAAqB,GAAA/K,CAAA,CAAA6C,2BAAA,EAA4B;YAACye,IAAA,EAAAvb;UAAA,IAClDmF,CAAA,IAAmB,GAAApI,CAAA,CAAA6Z,SAAA,EAAUnd,CAAA,EAAkBC,CAAA,EAAQsL,CAAA;UAGzD,MAAMK,CAAA,GAAkBnB,CAAA,GAAsB/J,CAAA,CAAAwL,SAAA,CAAU+a,eAAA,CAAgB5b,CAAA,EAAsB3H,CAAA,GAAO,KACvDhD,CAAA,CAAAwL,SAAA,CAAU+a,eAAA,CAAgBhmB,CAAA,EAAYyC,CAAA,GAAO;YACrFmI,CAAA,GAAepB,CAAA,GAAsB/J,CAAA,CAAAwL,SAAA,CAAUgb,iBAAA,CAAkB7b,CAAA,EAAsB3H,CAAA,GAAO,KACzDhD,CAAA,CAAAwL,SAAA,CAAUgb,iBAAA,CAAkBjmB,CAAA,EAAYyC,CAAA,GAAO;YAEpFqI,CAAA,GAAST,CAAA,CACXtL,CAAA,EAAkByK,CAAA,GAAsBiB,CAAA,GAAmBzL,CAAA,EAAQQ,CAAA,EAAYmL,CAAA,EAAiBC,CAAA;UAEpG,OAAIpB,CAAA,IACqB,GAAAnH,CAAA,CAAA6Z,SAAA,EAAUnd,CAAA,EAAkB+L,CAAA,EAAQR,CAAA,IAGpDQ,C;;QAIf,MAAMT,CAAA,GACF6b,CAACnnB,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA,EAA+BD,CAAA,EAC1FE,CAAA;YACC,MAAMO,CAAA,GACFsK,CAAA,CAA4BvL,CAAA,EAAkBC,CAAA,CAAO,IAAIO,CAAA,EAAiBE,CAAA,EAAc,CAACF,CAAA;cACvFU,CAAA,GAAMlB,CAAA,CAAiBmU,GAAA,CAAItR,MAAA,CAADC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACxBY,CAAA,GAAgC;gBAAE+P,SAAA,EAAWhT,CAAA,CAAWsC,QAAA;gBAAUyB,GAAA,EAAKA,CAAA,KAAMvD;cAAA,IACjFhB,CAAA;cAEEqD,CAAA,GAA0BiD,CAAA,CAC5BvG,CAAA,EAAkBC,CAAA,CAAO,IAAIO,CAAA,EAAiBE,CAAA,EAAcO,CAAA,CAAsB6I,MAAA,CAAO+J,IAAA,EACzF,CAACrT,CAAA;cACC8K,CAAA,GAAQtL,CAAA,CAAiBmU,GAAA,CAAItR,MAAA,CAADC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAC1B2H,CAAA,GAAkC;gBAAEgJ,SAAA,EAAWhT,CAAA,CAAWsC,QAAA;gBAAUyB,GAAA,EAAKA,CAAA,KAAMlB;cAAA,IACnF,CAACrD,CAAA,CAAO,IAAIiB,CAAA;cAEVsF,CAAA,GAAqBkF,CAAA,CACvB1L,CAAA,EAAkBC,CAAA,CAAO,IAAIO,CAAA,EAAiBE,CAAA,EAAcO,CAAA,CAAsB6I,MAAA,CAAO+J,IAAA,EACzFvQ,CAAA,CAAwBwG,MAAA,CAAO+J,IAAA;YAInC,OAAO,CAHQ7T,CAAA,CAAiBmU,GAAA,CAAItR,MAAA,CAADC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAC3BuI,CAAA,GAAsB;cAAEoI,SAAA,EAAWhT,CAAA,CAAWsC,QAAA;cAAUyB,GAAA,EAAKA,CAAA,KAAMgC;YAAA,IACvE,CAACvG,CAAA,CAAO,IAAIiB,CAAA,EAAKoK,CAAA,GACN;UAAA;UAMfC,CAAA,GACF6b,CAACpnB,CAAA,EAAyCC,CAAA,EAAeQ,CAAA,EAAyBD,CAAA,EACjFE,CAAA;YACC,OAAO4C,CAAA,EAAcmH,CAAA,IACjBzK,CAAA,CAAiBoT,8BAAA,CAA+BnT,CAAA,CAAM4T,IAAA,EAAM3S,CAAA,CAAAmT,WAAA,CAAYgB,QAAA;cACtEhK,CAAA,GAAO3K,CAAA,CAAYoB,MAAA;YAEzB,IAAIrB,CAAA,GAAkB,KAAKD,CAAA,GAAe,GACxC,MAAM,IAAI6D,KAAA,CAAM;YAGlB,IAA2B,MAAvB3D,CAAA,CAAYoB,MAAA,EACd,MAAM,IAAIuC,KAAA,CAAM;YAGlB,IAAI3D,CAAA,CAAY,OAAOD,CAAA,EACrB,MAAM,IAAI4D,KAAA,CAAM;YAGlB,MAAMiH,CAAA,IAAO,GAAArK,CAAA,CAAA4I,OAAA,EAAQ7J,CAAA,CAAiBiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUnF,OAAA;cAC1D4I,CAAA,GAAe,6BACDF,CAAA,qEAC4B7K,CAAA,4CAEhB8K,CAAA,CAAKZ,SAAA,gDAAyDpH,CAAA,cAC1FmH,CAAA,iCACejK,CAAA,gEAEmB8K,CAAA,CAAKZ,SAAA,iEACnCpH,CAAA,KAAiBmH,CAAA;YAOzB,OAAO5H,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKY,CAAA,GAAgC;cACnCoG,MAAA,EAAQ;gBAAC+J,IAAA,EAAMnT,CAAA;gBAAasE,IAAA,EAAM/E,CAAA,CAAM+E,IAAA;gBAAM8O,WAAA,EAAa5S,CAAA,CAAAmT,WAAA,CAAYgB;cAAA;cACvExE,YAAA,EAAAtF;YAAA,EAAY;UAAA;UAOdhF,CAAA,GACF8gB,CAACrnB,CAAA,EAAyCC,CAAA,EAAeQ,CAAA,EAAyBD,CAAA,EACjFE,CAAA,EAA4C4C,CAAA;YAC3C,OAAOI,CAAA,EAAc2H,CAAA,IACjBrL,CAAA,CAAiBoT,8BAAA,CAA+BnT,CAAA,CAAM4T,IAAA,EAAM3S,CAAA,CAAAmT,WAAA,CAAYgB,QAAA;cACtE/J,CAAA,GAAOhI,CAAA,CAAYxB,MAAA;YAEzB,IAAIrB,CAAA,GAAkB,KAAKD,CAAA,GAAe,GACxC,MAAM,IAAI6D,KAAA,CAAM;YAGlB,IAA2B,MAAvBf,CAAA,CAAYxB,MAAA,EACd,MAAM,IAAIuC,KAAA,CAAM;YAGlB,IAAIf,CAAA,CAAY,OAAO7C,CAAA,EACrB,MAAM,IAAI4D,KAAA,CAAM;YAGlB,IAAuC,MAAnC3D,CAAA,CAAwBoB,MAAA,EAC1B,MAAM,IAAIuC,KAAA,CAAM;YAGlB,IAAI3D,CAAA,CAAwB,OAAOD,CAAA,EACjC,MAAM,IAAI4D,KAAA,CAAM;YAGlB,MACMkH,CAAA,GAAe,6BACDD,CAAA,qEAC4B9K,CAAA,qGAI7BA,CAAA,oEAPN,GAAAS,CAAA,CAAA4I,OAAA,EAAQ7J,CAAA,CAAiBiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUnF,OAAA,EASlB+H,SAAA,iEACtChH,CAAA,KAAiB2H,CAAA;YAKzB,OAAOxI,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK2H,CAAA,GAAkC;cACrCX,MAAA,EAAQ;gBAAC+J,IAAA,EAAMvQ,CAAA;gBAAa0B,IAAA,EAAM/E,CAAA,CAAM+E,IAAA;gBAAM8O,WAAA,EAAa5S,CAAA,CAAAmT,WAAA,CAAYgB;cAAA;cACvExE,YAAA,EAAAtF;YAAA,EAAY;UAAA;UAIdG,CAAA,GACF4b,CAACtnB,CAAA,EAAyCC,CAAA,EAAeQ,CAAA,EAAyBD,CAAA,EACjFE,CAAA,EAA4CO,CAAA;YAC3C,OAAOqC,CAAA,EAAcI,CAAA,IACjB1D,CAAA,CAAiBoT,8BAAA,CAA+BnT,CAAA,CAAM4T,IAAA,EAAM3S,CAAA,CAAAmT,WAAA,CAAYgB,QAAA;cACtE5K,CAAA,GAAOxK,CAAA,CAAM4T,IAAA,CAAK/R,MAAA;YAExB,IAAIrB,CAAA,GAAkB,KAAKD,CAAA,GAAe,GACxC,MAAM,IAAI6D,KAAA,CAAM;YAGlB,IAAuC,MAAnC3D,CAAA,CAAwBoB,MAAA,IAAsD,MAAtCb,CAAA,CAA2Ba,MAAA,EACrE,MAAM,IAAIuC,KAAA,CAAM;YAGlB,IAAI3D,CAAA,CAAwB,OAAOD,CAAA,IAAmBQ,CAAA,CAA2B,OAAOR,CAAA,EACtF,MAAM,IAAI4D,KAAA,CAAM;YAGlB,MAAMiH,CAAA,GAAe,6BACDb,CAAA,kKAGqBnH,CAAA,KAAiBI,CAAA,kIAIxBlD,CAAA;YAYlC,OAAOqC,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKuI,CAAA,GAAsB;cACzBvB,MAAA,EAAQ;gBAAC+J,IAAA,EAAM5T,CAAA,CAAM4T,IAAA;gBAAM7O,IAAA,EAAM/E,CAAA,CAAM+E,IAAA;gBAAM8O,WAAA,EAAa5S,CAAA,CAAAmT,WAAA,CAAYgB;cAAA;cACtExE,YAAA,EAAAvF;YAAA,EAAY;UAAA;UAId9E,CAAA,GAAkBxG,CAAA;YACtB,KAAKA,CAAA,IAA4B,MAAlBA,CAAA,CAAO8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM;YAGlB,IAAuB,cAAnBrE,CAAA,CAAO,GAAGgF,IAAA,IAAyC,cAAnBhF,CAAA,CAAO,GAAGgF,IAAA,EAC5C,MAAM,IAAIX,KAAA,CAAM,qB;;;;;;;;;QCpRpB,MAAA7D,CAAA,GAAAC,CAAA;UAIAC,CAAA,GAAAD,CAAA;UAEAQ,CAAA,GAAAR,CAAA;UAQMS,CAAA,GAAuB;YAC3B8C,IAAA,EAAM;YACN4G,UAAA,EAAY,CAAC;YACb2I,UAAA,EAAY,CAACtS,CAAA,CAAAoT,WAAA,CAAYgB,QAAA;UAAA;QAGdpV,CAAA,CAAA+P,KAAA,GACT,CAAChQ,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA;UAC1DgK,CAAA,CAAexK,CAAA;UAEf,MAAMO,CAAA,GAAOE,CAAA,CAAAwL,SAAA,CAAU0W,aAAA,CAAcniB,CAAA,CAAW+e,IAAA,EAAMvf,CAAA,CAAO,GAAG4T,IAAA,CAAK/R,MAAA;YAC/Db,CAAA,GAAQqC,CAAA,CAAgBtD,CAAA,EAAkBC,CAAA,EAAQO,CAAA,EAAMC,CAAA;YACxD4K,CAAA,GAAmB;UACzB,KAAK,IAAI3K,CAAA,GAAI,GAAGA,CAAA,GAAIO,CAAA,IAASP,CAAA,EAC3B2K,CAAA,CAAOrE,IAAA,CAAKhH,CAAA,CAAiBmU,GAAA,CAAItR,MAAA,CAADC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAEvB5B,CAAA,GAAoB;YACvBuS,SAAA,EAAW,GAAGhT,CAAA,CAAWsC,QAAA,IAAYrC,CAAA;YACrC8D,GAAA,EAAKA,CAAA,KAAMd,CAAA,CAAuB1D,CAAA,EAAkBC,CAAA,CAAO,IAAIQ,CAAA,EAAYD,CAAA,EAAME,CAAA;UAAA,IAEnFT,CAAA;UAGN,OAAOoL,CAAM;QAAA,GAGNpL,CAAA,CAAAyc,oBAAA,GAAiE1c,CAAA;UAC5E,MAAMC,CAAA,GAAOD,CAAA,CAAK4d,UAAA,CAAWnZ,MAAA,CAAO,QAAQ;YACtChE,CAAA,GAAQT,CAAA,CAAK4d,UAAA,CAAW/Y,OAAA,CAAQ,SAAS;YACzCnE,CAAA,GAAaV,CAAA,CAAKunB,OAAA,CAAQzlB,MAAA;UAChC,QAAO,GAAAtB,CAAA,CAAA6C,2BAAA,EAA4B;YAACmc,IAAA,EAAAvf,CAAA;YAAM+P,KAAA,EAAAvP,CAAA;YAAO+mB,UAAA,EAAA9mB;UAAA,EAAY;QAAA;QAG/D,MAAM4C,CAAA,GACFmkB,CAACznB,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA,EAAcD,CAAA;YACxE,SAASS,CAAA,IAAWP,CAAA,CAAAgnB,SAAA,CAAUC,UAAA,CAAW1nB,CAAA,CAAO,GAAG4T,IAAA,EAAMpT,CAAA,EAAMD,CAAA,CAAWwP,KAAA,EAAOxP,CAAA,CAAWgnB,UAAA;YAC5F,OAAOvmB,CAAA,CAAQa,MAAM;UAAA;UAGrB4B,CAAA,GACFkkB,CAAC5nB,CAAA,EAAyCC,CAAA,EAAeQ,CAAA,EAA6BD,CAAA,EAAc8C,CAAA;YAE9F,OAAOI,CAAA,EAAQ+G,CAAA,IAAW/J,CAAA,CAAAgnB,SAAA,CAAUC,UAAA,CAAW1nB,CAAA,CAAM4T,IAAA,EAAMrT,CAAA,EAAMC,CAAA,CAAWuP,KAAA,EAAOvP,CAAA,CAAW+mB,UAAA;cACxFnc,CAAA,GAASZ,CAAA,CAAQnH,CAAA;cACjBgI,CAAA,GAAc5H,CAAA,CAAOJ,CAAA;cAErBiI,CAAA,GAAe,qCADRD,CAAA,CAAYxJ,MAAA,yBAGjBtB,CAAA,QAAY6K,CAAA;YAIpB,OAAOxI,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK5B,CAAA,GAAoB;cACvBuS,SAAA,EAAW,GAAGhT,CAAA,CAAWsC,QAAA,IAAYO,CAAA;cACrCwG,MAAA,EAAQ;gBAAC+J,IAAA,EAAMvI,CAAA;gBAAatG,IAAA,EAAM/E,CAAA,CAAM+E,IAAA;gBAAM8O,WAAA,EAAa7S,CAAA,CAAAoT,WAAA,CAAYgB;cAAA;cACvExE,YAAA,EAAAtF;YAAA,EAAY;UAAA;UAIlBd,CAAA,GAAkBzK,CAAA;YACtB,KAAKA,CAAA,IAA4B,MAAlBA,CAAA,CAAO8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM;YAGlB,IAAuB,WAAnBrE,CAAA,CAAO,GAAGgF,IAAA,IAAsC,YAAnBhF,CAAA,CAAO,GAAGgF,IAAA,IAAuC,YAAnBhF,CAAA,CAAO,GAAGgF,IAAA,IAClD,aAAnBhF,CAAA,CAAO,GAAGgF,IAAA,IAAwC,YAAnBhF,CAAA,CAAO,GAAGgF,IAAA,IAAuC,aAAnBhF,CAAA,CAAO,GAAGgF,IAAA,IACpD,cAAnBhF,CAAA,CAAO,GAAGgF,IAAA,IAAyC,cAAnBhF,CAAA,CAAO,GAAGgF,IAAA,IAAyC,WAAnBhF,CAAA,CAAO,GAAGgF,IAAA,EAC5E,MAAM,IAAIX,KAAA,CAAM,sB;;;;;;;;;QC/EpB,MAAA7D,CAAA,GAAAC,CAAA;QAGaR,CAAA,CAAA2c,OAAA,GACT,CAAC5c,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA;UAC1DC,CAAA,CAAeT,CAAA;UACf,MAAMgB,CAAA,GAAcT,CAAA,CAAA0L,SAAA,CAAU0B,YAAA,CAAa3N,CAAA,CAAO,GAAG4T,IAAA,EAAMpT,CAAA;UAE3D,OAAO,CADQT,CAAA,CAAiBoV,eAAA,CAAgBnV,CAAA,CAAO,IAAIgB,CAAA,EAC5C;QAAA,GAGRhB,CAAA,CAAA6c,UAAA,GAAa,CAAC9c,CAAA,EAAyCS,CAAA,MAClEQ,CAAA,CAAkBR,CAAA,IACX,GAAAR,CAAA,CAAA2c,OAAA,EAAQ5c,CAAA,EAAkB,CAACS,CAAA,CAAO,KAAKuF,KAAA,CAAMoZ,IAAA,CAAK3e,CAAA,CAAO,GAAG4jB,WAAA,KAGxDpkB,CAAA,CAAA4c,sBAAA,GAA4D7c,CAAA,IACrEA,CAAA,CAAK4d,UAAA,CAAW/Y,OAAA,CAAQ;QAE5B,MAAMnE,CAAA,GAAkBV,CAAA;YACtB,KAAKA,CAAA,IAA4B,MAAlBA,CAAA,CAAO8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM;YAGlB,IAAuB,aAAnBrE,CAAA,CAAO,GAAGgF,IAAA,EACZ,MAAM,IAAIX,KAAA,CAAM,8B;;UAIdpD,CAAA,GAAqBjB,CAAA;YACzB,KAAKA,CAAA,IAA4B,MAAlBA,CAAA,CAAO8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM;YAGlB,IAAuB,YAAnBrE,CAAA,CAAO,GAAGgF,IAAA,EACZ,MAAM,IAAIX,KAAA,CAAM,sB;;;;;;;;;QCrCpB,MAAA7D,CAAA,GAAAC,CAAA;UAEAC,CAAA,GAAAD,CAAA;QAEaR,CAAA,CAAA8c,GAAA,GAAM,CAAC/c,CAAA,EAAyCC,CAAA;UAC3DiB,CAAA,CAAejB,CAAA;UAEf,MAAMQ,CAAA,GAAqB;YACzBuD,IAAA,EAAM;YACN4G,UAAA,EAAY3K,CAAA,CAAOkD,GAAA,CAAI,CAACnD,CAAA,EAAGC,CAAA,KAAM,IAAIA,CAAA;YACrCsT,UAAA,EAAY,IAAIvN,KAAA,CAAM/F,CAAA,CAAO6B,MAAA,EAAQud,IAAA,CAAK3e,CAAA,CAAA2T,WAAA,CAAYgB,QAAA;UAAA;UAKxD,OAAO,CAFQrV,CAAA,CAAiBmU,GAAA,CAAItR,MAAA,CAADC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAC3BrC,CAAA,GAAkB;YAAE+D,GAAA,EAAKA,CAAA,KAAMvD,CAAA,CAAqBjB,CAAA,EAAkBC,CAAA,EAAQQ,CAAA;UAAA,IAAsBR,CAAA,EAC7F;QAAA;QAGjB,MAAMgB,CAAA,GACF4mB,CAAC7nB,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA;YAC1D,MAAMQ,CAAA,IAAO,GAAAT,CAAA,CAAAqJ,OAAA,EAAQ7J,CAAA,CAAiBiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUnF,OAAA;cAC1DzB,CAAA,GAAcjB,CAAA,CAAO,GAAG4T,IAAA,CAAK3G,KAAA;cAE7B5J,CAAA,GAAe,gDADLrD,CAAA,CAAOkD,GAAA,CAAI,CAACnD,CAAA,EAAGC,CAAA,KAAM,GAAGgB,CAAA,CAAKyJ,SAAA,KAAczK,CAAA,eAAgBmD,IAAA,CAAK,oBAI5EnC,CAAA,CAAK6I,MAAA;YAGT,OAAOjH,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKrC,CAAA,GAAkB;cACrBqJ,MAAA,EAAQ;gBAAC+J,IAAA,EAAM3S,CAAA;gBAAa8D,IAAA,EAAM/E,CAAA,CAAO,GAAG+E,IAAA;gBAAM8O,WAAA,EAAapT,CAAA,CAAA2T,WAAA,CAAYgB;cAAA;cAC3EvE,OAAA,GAAS;cACTD,YAAA,EAAAvN;YAAA,EAAY;UAAA;UAIdpC,CAAA,GAAkBlB,CAAA;YACtB,KAAKA,CAAA,IAA4B,MAAlBA,CAAA,CAAO8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM;YAGlB,MAAMpE,CAAA,GAASD,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA;YAC9B,KAAK,IAAIrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAO8B,MAAA,EAAQrB,CAAA,IAAK;cACtC,IAAIR,CAAA,KAAWD,CAAA,CAAOS,CAAA,EAAGoT,IAAA,CAAK/R,MAAA,EAC5B,MAAM,IAAIuC,KAAA,CAAM;cAGlB,KAAK,IAAI7D,CAAA,GAAI,GAAGA,CAAA,GAAIP,CAAA,EAAQO,CAAA,IAC1B,IAAIR,CAAA,CAAO,GAAG6T,IAAA,CAAKrT,CAAA,MAAOR,CAAA,CAAOS,CAAA,EAAGoT,IAAA,CAAKrT,CAAA,GACvC,MAAM,IAAI6D,KAAA,CAAM,gC;;YAKtB,IAAuB,cAAnBrE,CAAA,CAAO,GAAGgF,IAAA,IAAyC,cAAnBhF,CAAA,CAAO,GAAGgF,IAAA,EAC5C,MAAM,IAAIX,KAAA,CAAM;YAElB,KAAK,IAAIpE,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAO8B,MAAA,EAAQ7B,CAAA,IACjC,IAAID,CAAA,CAAO,GAAGgF,IAAA,KAAShF,CAAA,CAAOC,CAAA,EAAG+E,IAAA,EAC/B,MAAM,IAAIX,KAAA,CAAM,+B;;;;;;;;;QC7DtB,MAAA7D,CAAA,GAAAC,CAAA;UAGAC,CAAA,GAAAD,CAAA;QAEaR,CAAA,CAAAid,IAAA,GAAO,CAACld,CAAA,EAAyCC,CAAA;UAC5DiB,CAAA,CAAejB,CAAA;UAEf,MAAMQ,CAAA,GAAsB;YAC1BuD,IAAA,EAAM;YACN4G,UAAA,EAAY,CAAC;YACb2I,UAAA,EAAY,CAAC7S,CAAA,CAAA2T,WAAA,CAAYgB,QAAA;UAAA;UAM3B,OAAO,CAHQrV,CAAA,CAAiBmU,GAAA,CAAItR,MAAA,CAADC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAC3BrC,CAAA,GAAmB;YAAE+D,GAAA,EAAKA,CAAA,KAAMvD,CAAA,CAAsBjB,CAAA,EAAkBC,CAAA,EAAQQ,CAAA;UAAA,IACpFR,CAAA,EACW;QAAA;QAGjB,MAAMgB,CAAA,GACF6mB,CAAC9nB,CAAA,EAAgCC,CAAA,EAAkBQ,CAAA;YACjD,MAAMD,CAAA,GAAaP,CAAA,CAAO,GAAG4T,IAAA,CAAK3G,KAAA;cAC5BjM,CAAA,GAAc,IAAI+E,KAAA,CAAMxF,CAAA,CAAWsB,MAAA;cAEnCZ,CAAA,GAAoB;YAC1B,KAAK,IAAIlB,CAAA,GAAI,GAAGA,CAAA,GAAIQ,CAAA,CAAWsB,MAAA,EAAQ9B,CAAA,IACrCiB,CAAA,CAAYjB,CAAA,IAAKQ,CAAA,CAAWR,CAAA,IAAKC,CAAA,CAAO,GAAG0U,UAAA,CAAW3U,CAAA,GACtDkB,CAAA,CAAQ8F,IAAA,CAAK,YAAYhH,CAAA,+BAAgCA,CAAA,OAAQQ,CAAA,CAAWR,CAAA;YAG9E,MAAMsD,CAAA,GAAOrC,CAAA,CAAYa,MAAA;cACnB4B,CAAA,GAAe,uCACSJ,CAAA,8BACbA,CAAA,eACbpC,CAAA,CAAQkC,IAAA,CAAK;YAIjB,OAAOP,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKrC,CAAA,GAAmB;cACtBqJ,MAAA,EAAQ;gBAAC+J,IAAA,EAAM5S,CAAA;gBAAa+D,IAAA,EAAM/E,CAAA,CAAO,GAAG+E,IAAA;gBAAM8O,WAAA,EAAapT,CAAA,CAAA2T,WAAA,CAAYgB;cAAA;cAC3ExE,YAAA,EAAAnN;YAAA,EAAY;UAAA;UAIdxC,CAAA,GAAkBlB,CAAA;YACtB,KAAKA,CAAA,IAA4B,MAAlBA,CAAA,CAAO8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAA8B,MAA1BrE,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,EACjB,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAIrE,CAAA,CAAO,GAAG6T,IAAA,CAAK,OAAO7T,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,EACvC,MAAM,IAAIuC,KAAA,CAAM;YAElB,KAA8C,MAA1C7D,CAAA,CAAAqiB,YAAA,CAAazW,OAAA,CAAQpM,CAAA,CAAO,GAAGgF,IAAA,GACjC,MAAM,IAAIX,KAAA,CAAM;YAElB,IAAuB,YAAnBrE,CAAA,CAAO,GAAGgF,IAAA,IAAuC,YAAnBhF,CAAA,CAAO,GAAGgF,IAAA,EAC1C,MAAM,IAAIX,KAAA,CAAM,uB;;;;;;;;;QC5DpB,MAAA7D,CAAA,GAAAC,CAAA;UAIAC,CAAA,GAAAD,CAAA;UAEAQ,CAAA,GAAAR,CAAA;UAMMS,CAAA,GAA2B;YAC/B8C,IAAA,EAAM;YACN4G,UAAA,EAAY,CAAC;YACb2I,UAAA,EAAY,CAACtS,CAAA,CAAAoT,WAAA,CAAYgB,QAAA;UAAA;QAGdpV,CAAA,CAAAkd,SAAA,GACT,CAACnd,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA,MAC1D6K,CAAA,CAAerL,CAAA,GAQR,CAPQD,CAAA,CAAiBmU,GAAA,CAAItR,MAAA,CAADC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAE1B5B,CAAA,GAAwB;UAC3BuS,SAAA,EAAWhT,CAAA,CAAWsC,QAAA;UACtByB,GAAA,EAAKA,CAAA,KAAMlB,CAAA,CAA2BtD,CAAA,EAAkBC,CAAA,CAAO,IAAIQ,CAAA,CAAWqhB,IAAA;QAAA,IAEhF7hB,CAAA,KAIGA,CAAA,CAAAmd,wBAAA,GACRpd,CAAA,KAA0C,GAAAQ,CAAA,CAAA6C,2BAAA,EAA4B;UAACye,IAAA,EAAM9hB,CAAA,CAAK4d,UAAA,CAAW/Y,OAAA,CAAQ,QAAQ;QAAA;QAElH,MAAMvB,CAAA,GACFykB,CAAC/nB,CAAA,EAAyCC,CAAA,EAAeQ,CAAA;YACvD,MAAMD,CAAA,GAAaP,CAAA,CAAM4T,IAAA;YACzBpT,CAAA,GAAOiD,CAAA,CAAgBlD,CAAA,EAAYC,CAAA;YACnC,MAAMC,CAAA,GAAsB+J,CAAA,CAAejK,CAAA,EAAYC,CAAA;cACjD6C,CAAA,GAAO9C,CAAA,CAAWsB,MAAA;cAIlBwJ,CAAA,GAAe,WACnBD,CAAA,CAAoB,QAAQ5K,CAAA,EAAM6C,CAAA,sCACRA,CAAA,uBAClBA,CAAA;YAIV,OAAOT,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK5B,CAAA,GAAwB;cAC3B4I,MAAA,EAAQ;gBAAC+J,IAAA,EAAMnT,CAAA;gBAAqBsE,IAAA,EAAM/E,CAAA,CAAM+E,IAAA;gBAAM8O,WAAA,EAAa7S,CAAA,CAAAoT,WAAA,CAAYgB;cAAA;cAC/ExE,YAAA,EAAAvF;YAAA,EAAY;UAAA;UAId5H,CAAA,GAAkBskB,CAAChoB,CAAA,EAA+BC,CAAA,MAClDA,CAAA,IAAQA,CAAA,CAAK6B,MAAA,KAAW9B,CAAA,CAAW8B,MAAA,KACrC7B,CAAA,GAAO,IAAKD,CAAA,CAAW0Q,IAAA,IAAS7C,OAAA,KAE3B5N,CAAA;UAGHwK,CAAA,GAAiBwd,CAACjoB,CAAA,EAA+BC,CAAA,MACrDA,CAAA,GAAOyD,CAAA,CAAgB1D,CAAA,EAAYC,CAAA,GAC5BS,CAAA,CAAAwL,SAAA,CAAUgc,eAAA,CAAgBloB,CAAA,EAAYC,CAAA;UAGzCoL,CAAA,GAAsB8c,CAACnoB,CAAA,EAAcC,CAAA,EAAgBQ,CAAA;YACzD,MAAMD,CAAA,GAAc;YACpBA,CAAA,CAAYwG,IAAA,CAAK,QAAQhH,CAAA,cAAkBS,CAAA,cAAkBA,CAAA;YAC7D,KAAK,IAAIT,CAAA,GAAI,GAAGA,CAAA,GAAIS,CAAA,IAAQT,CAAA,EAC1BQ,CAAA,CAAYwG,IAAA,CAAK,OAAO/G,CAAA,CAAKD,CAAA,UAAWA,CAAA;YAG1C,OADAQ,CAAA,CAAYwG,IAAA,CAAK,QACVxG,CAAA,CAAY4C,IAAA,CAAK,KAAK;UAAA;UAGzBkI,CAAA,GAAkBtL,CAAA;YACtB,KAAKA,CAAA,IAA4B,MAAlBA,CAAA,CAAO8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM;YAGlB,IAAuB,cAAnBrE,CAAA,CAAO,GAAGgF,IAAA,IAAyC,cAAnBhF,CAAA,CAAO,GAAGgF,IAAA,EAC5C,MAAM,IAAIX,KAAA,CAAM,+B;;;;;;;;;QCrFpB,MAAA7D,CAAA,GAAAC,CAAA;UAEAC,CAAA,GAAAD,CAAA;QAEaR,CAAA,CAAAsW,aAAA,GAAgB,CAACvW,CAAA,EAAyCC,CAAA;UACrE,MAAMQ,CAAA,GAAcR,CAAA,CAAM6N,KAAA;YACpB7M,CAAA,IAAO,GAAAT,CAAA,CAAAqJ,OAAA,EAAQ7J,CAAA,CAAiBiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUnF,OAAA;YAI1DzB,CAAA,GAAe,0oCA6CDD,CAAA,CAAKyJ,SAAA,2BACnBzJ,CAAA,CAAK6I,MAAA;YAELxG,CAAA,GAAc;cAClBU,IAAA,EAAM;cACNuP,UAAA,EAAY,CAAC7S,CAAA,CAAA2T,WAAA,CAAYgB,QAAA;cACzBzK,UAAA,EAAY,CAAC;cACbd,MAAA,EAAQ;gBAAC+J,IAAA,EAAMpT,CAAA;gBAAauE,IAAA,EAAM/E,CAAA,CAAMmU,MAAA,CAAOpP,IAAA;gBAAM8O,WAAA,EAAapT,CAAA,CAAA2T,WAAA,CAAY+T;cAAA;cAC9EvX,YAAA,EAAA3P,CAAA;cACA4P,OAAA,GAAS;YAAA;UAEX,OAAO9Q,CAAA,CAAiBsT,cAAA,CAAehQ,CAAA,EAAa,CAACrD,CAAA,CAAMmU,MAAA,EAAQ;QAAA,C;;;;;;;;QClErE,MAAA5T,CAAA,GAAAC,CAAA;UAGAC,CAAA,GAAAD,CAAA;UACAQ,CAAA,GAAAR,CAAA;UACAS,CAAA,GAAAT,CAAA;UAEA6C,CAAA,GAAA7C,CAAA;QAEA,SAAgBiD,EAAA;UACd,OAAOsT,CAAA,CAAiB,MAC1B;QAAA;QACA,SAAgBvM,EAAA;UACd,OAAOuM,CAAA,CAAiB,OAC1B;QAAA;QACA,SAAgB3L,EAAA;UACd,OAAO2L,CAAA,CAAiB,OAC1B;QAAA;QACA,SAAgB1L,EAAA;UACd,OAAO0L,CAAA,CAAiB,OAC1B;QAAA;QACA,SAAgBzL,EAAA;UACd,OAAOyL,CAAA,CAAiB,OAC1B;QAAA;QACA,SAAgBzQ,EAAA;UACd,OAAOyQ,CAAA,CAAiB,MAC1B;QAAA;QACA,SAAgBtL,EAAQ1L,CAAA;UACtB,MAAMC,CAAA,GAAO;UAWb,OAAO;YAACmQ,IAAA,EAVK,iCACepQ,CAAA,iBAEpBC,CAAA,+EAGDA,CAAA,gCACSA,CAAA,WAAeA,CAAA,WAAeA,CAAA,WAAeA,CAAA;YAG/C+D,IAAA,EAAA/D,CAAA;YAAM+E,IAAA,EAAM/D,CAAA,CAAAkN,YAAA,CAAaC;UAAA,CACzC;QAAA;QACA,SAAgB5H,EAAA;UACd,OAAOwQ,CAAA,CAAiB,MAC1B;QAAA;QACA,SAAgBpL,EAAA;UACd,OAAOoL,CAAA,CAAiB,QAC1B;QAAA;QACA,SAAgBnL,EAAS7L,CAAA,EAAaC,CAAA;UACpC,MAAMQ,CAAA,GAAO;UAYb,OAAO;YAAC2P,IAAA,EAXK,+BACapQ,CAAA,iCACAC,CAAA,iBAElBQ,CAAA,6DAGDA,CAAA;YAIOuD,IAAA,EAAAvD,CAAA;YAAMuE,IAAA,EAAM/D,CAAA,CAAAkN,YAAA,CAAaC;UAAA,CACzC;QAAA;QACA,SAAgBrC,EAAA;UACd,MAAM/L,CAAA,GAAO;UASb,OAAO;YAACoQ,IAAA,EARK,aACLpQ,CAAA,4CAGDA,CAAA;YAIOgE,IAAA,EAAAhE,CAAA;YAAMgF,IAAA,EAAM/D,CAAA,CAAAkN,YAAA,CAAaC;UAAA,CACzC;QAAA;QACA,SAAgBpC,EAAchM,CAAA;UAC5B,MAAMC,CAAA,GAAO;UAWb,OAAO;YAACmQ,IAAA,EAVK,iCACepQ,CAAA,iBAEpBC,CAAA,kEAGDA,CAAA,gCACSA,CAAA,WAAeA,CAAA,WAAeA,CAAA,WAAeA,CAAA;YAG/C+D,IAAA,EAAA/D,CAAA;YAAM+E,IAAA,EAAM/D,CAAA,CAAAkN,YAAA,CAAaC;UAAA,CACzC;QAAA;QACA,SAAgBnC,EAAA;UACd,OAAO+K,CAAA,CAAiB,MAC1B;QAAA;QACA,SAAgB7K,EAAA;UACd,MAAMnM,CAAA,GAAO;UASb,OAAO;YAACoQ,IAAA,EARK,aACLpQ,CAAA,6CAGDA,CAAA;YAIOgE,IAAA,EAAAhE,CAAA;YAAMgF,IAAA,EAAM/D,CAAA,CAAAkN,YAAA,CAAaC;UAAA,CACzC;QAAA;QACA,SAAgB/B,EAAA;UACd,MAAMrM,CAAA,GAAO;UAeb,OAAO;YAACoQ,IAAA,EAdK,aACLpQ,CAAA,6DAGDA,CAAA,4CAGAA,CAAA,+FAGCA,CAAA;YAIMgE,IAAA,EAAAhE,CAAA;YAAMgF,IAAA,EAAM/D,CAAA,CAAAkN,YAAA,CAAaC;UAAA,CACzC;QAAA;QACA,SAAgBsI,EAAA;UACd,OAAOM,CAAA,CAAiB,MAC1B;QAAA;QACA,SAAgBL,EAAA;UACd,MAAM3W,CAAA,GAAO;UASb,OAAO;YAACoQ,IAAA,EARK,aACLpQ,CAAA,wDAGDA,CAAA;YAIOgE,IAAA,EAAAhE,CAAA;YAAMgF,IAAA,EAAM/D,CAAA,CAAAkN,YAAA,CAAaC;UAAA,CACzC;QAAA;QACA,SAAgBwI,EAAA;UACd,MAAM5W,CAAA,GAAO;UASb,OAAO;YAACoQ,IAAA,EARK,aACLpQ,CAAA,gEAGDA,CAAA;YAIOgE,IAAA,EAAAhE,CAAA;YAAMgF,IAAA,EAAM/D,CAAA,CAAAkN,YAAA,CAAaC;UAAA,CACzC;QAAA;QACA,SAAgByI,EAAA;UACd,OAAOG,CAAA,CAAiB,OAC1B;QAAA;QACA,SAAgBF,EAAA;UACd,OAAOE,CAAA,CAAiB,MAC1B;QAAA;QACA,SAAgBD,EAAA;UACd,MAAM/W,CAAA,GAAO;UAab,OAAO;YAACoQ,IAAA,EAZK,aACLpQ,CAAA,gHAKDA,CAAA;YAMOgE,IAAA,EAAAhE,CAAA;YAAMgF,IAAA,EAAM/D,CAAA,CAAAkN,YAAA,CAAaC;UAAA,CACzC;QAAA;QACA,SAAS4I,EAAiBhX,CAAA;UASxB,OAAO;YAACoQ,IAAA,EARK,aACLpQ,CAAA,4BACGA,CAAA,qBAEJA,CAAA,2BACIA,CAAA;YAGGgE,IAAA,EAAAhE,CAAA;YAAMgF,IAAA,EAAM/D,CAAA,CAAAkN,YAAA,CAAaC;UAAA,CACzC;QAAA;QA3KAnO,CAAA,CAAAooB,OAAA,GAAA3kB,CAAA,EAGAzD,CAAA,CAAAqoB,QAAA,GAAA7d,CAAA,EAGAxK,CAAA,CAAAsoB,QAAA,GAAAld,CAAA,EAGApL,CAAA,CAAAuoB,QAAA,GAAAld,CAAA,EAGArL,CAAA,CAAAwoB,QAAA,GAAAld,CAAA,EAGAtL,CAAA,CAAAyoB,OAAA,GAAAniB,CAAA,EAGAtG,CAAA,CAAA0oB,OAAA,GAAAjd,CAAA,EAcAzL,CAAA,CAAA2oB,OAAA,GAAApiB,CAAA,EAGAvG,CAAA,CAAA4oB,SAAA,GAAAjd,CAAA,EAGA3L,CAAA,CAAAqiB,QAAA,GAAAzW,CAAA,EAeA5L,CAAA,CAAA6oB,YAAA,GAAA/c,CAAA,EAYA9L,CAAA,CAAA8oB,aAAA,GAAA/c,CAAA,EAcA/L,CAAA,CAAA+oB,OAAA,GAAA/c,CAAA,EAGAhM,CAAA,CAAAgpB,OAAA,GAAA9c,CAAA,EAYAlM,CAAA,CAAAipB,OAAA,GAAA7c,CAAA,EAkBApM,CAAA,CAAAkpB,OAAA,GAAAzS,CAAA,EAGAzW,CAAA,CAAAmiB,QAAA,GAAAzL,CAAA,EAYA1W,CAAA,CAAAoiB,WAAA,GAAAzL,CAAA,EAYA3W,CAAA,CAAAmpB,QAAA,GAAAvS,CAAA,EAGA5W,CAAA,CAAAopB,OAAA,GAAAvS,CAAA,EAGA7W,CAAA,CAAAqpB,QAAA,GAAAvS,CAAA;QAgCA,MAoBME,CAAA,GACFsS,CAACvpB,CAAA,EAAgCC,CAAA,EAAeQ,CAAA,EAA6BD,CAAA;UAEvE,MAAME,CAAA,GAAcV,CAAA,CAAQiT,OAAA,CAAQrL,IAAA,GAAOtE,CAAA,CAAA+Q,WAAA,CAAYC,MAAA,GAAShR,CAAA,CAAA+Q,WAAA,CAAYgB,QAAA;YACtEpU,CAAA,GAAW;cAAC+C,IAAA,EAAMvD,CAAA,CAASuD,IAAA;cAAMuP,UAAA,EAAY,CAAC7S,CAAA;cAAckK,UAAA,EAAY,CAAC;cAAM6I,SAAA,EAAWjT;YAAA;UAChG,OAAOqC,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAW7B,CAAA,GAAQ;YAAEuD,GAAA,EAAKA,CAAA,KAxBhC,EAACxE,CAAA,EAAgCC,CAAA,EAA2BQ,CAAA,EAAeD,CAAA;cAErE,MAAME,CAAA,GAAcV,CAAA,CAAQiT,OAAA,CAAQrL,IAAA,GAAOtE,CAAA,CAAA+Q,WAAA,CAAYC,MAAA,GAAShR,CAAA,CAAA+Q,WAAA,CAAYgB,QAAA;gBACtEpU,CAAA,IAAO,GAAAC,CAAA,CAAA2I,OAAA,EAAQ7J,CAAA,CAAQiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUnF,OAAA;cACvD,OAAOE,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK7C,CAAA,GAAQ;gBACX6J,MAAA,EAAQ;kBAAC+J,IAAA,EAAMpT,CAAA,CAAMoT,IAAA;kBAAM7O,IAAA,EAAMvE,CAAA,CAAMuE,IAAA;kBAAM8O,WAAA,EAAApT;gBAAA;gBAC7CmQ,YAAA,EAAc,UACnBrQ,CAAA,CAAS4P,IAAA,yCAEEnP,CAAA,CAAKyJ,SAAA,+BACVlK,CAAA,CAASwD,IAAA,iBACb/C,CAAA,CAAK6I,MAAA;gBAGFgH,OAAA,GAAS;cAAA,EAAI;YAAA,GAS8C9Q,CAAA,EAASiB,CAAA,EAAUhB,CAAA,EAAOQ,CAAA;UAAA,EAAS;QAAA;QAG7FR,CAAA,CAAAsX,GAAA,GAAM,CAACvX,CAAA,EAAgCC,CAAA,KACpC,CAACD,CAAA,CAAQmU,GAAA,CAAI8C,CAAA,CAAmCjX,CAAA,EAASC,CAAA,CAAO,IAAIyD,CAAA,KAAYzD,CAAA,IAEnFA,CAAA,CAAAuX,IAAA,GAAO,CAACxX,CAAA,EAAgCC,CAAA,KACrC,CAACD,CAAA,CAAQmU,GAAA,CAAI8C,CAAA,CAAmCjX,CAAA,EAASC,CAAA,CAAO,IAAIwK,CAAA,KAAaxK,CAAA,IAEpFA,CAAA,CAAAyX,IAAA,GAAO,CAAC1X,CAAA,EAAgCC,CAAA,KACrC,CAACD,CAAA,CAAQmU,GAAA,CAAI8C,CAAA,CAAmCjX,CAAA,EAASC,CAAA,CAAO,IAAIoL,CAAA,KAAapL,CAAA,IAEpFA,CAAA,CAAA0X,IAAA,GAAO,CAAC3X,CAAA,EAAgCC,CAAA,KACrC,CAACD,CAAA,CAAQmU,GAAA,CAAI8C,CAAA,CAAmCjX,CAAA,EAASC,CAAA,CAAO,IAAIqL,CAAA,KAAarL,CAAA,IAOpFA,CAAA,CAAAgY,IAAA,GACT,CAACjY,CAAA,EAAgCC,CAAA,EAAkBQ,CAAA,KAAyC,CAACT,CAAA,CAAQmU,GAAA,CACjG8C,CAAA,CACIjX,CAAA,EAASC,CAAA,CAAO,IAAI4L,CAAA,CAASpL,CAAA,CAAWwB,GAAA,EAAKxB,CAAA,CAAW+oB,GAAA,GAAM/oB,CAAA,CAAWsC,QAAA,GAC7E9C,CAAA,IAEKA,CAAA,CAAAiY,mBAAA,GAAuBlY,CAAA,KAAqC,GAAAQ,CAAA,CAAA6C,2BAAA,EACrE;UAACpB,GAAA,EAAKjC,CAAA,CAAK4d,UAAA,CAAWrZ,QAAA,CAAS,OAAO7D,CAAA,CAAA+hB,QAAA;UAAW+G,GAAA,EAAKxpB,CAAA,CAAK4d,UAAA,CAAWrZ,QAAA,CAAS,OAAO7D,CAAA,CAAAgiB,QAAA;QAAA,IAE7EziB,CAAA,CAAAkY,OAAA,GAAU,CAACnY,CAAA,EAAgCS,CAAA;UACtD,MAAMD,CAAA,GAAa0W,CAAA,CAAiClX,CAAA,EAASS,CAAA;UAC7D,QAAO,GAAAR,CAAA,CAAAgY,IAAA,EAAKjY,CAAA,EAAS,CAACS,CAAA,CAAO,KAAKD,CAAA,CAAW;QAAA;QAG/C,MAAM0W,CAAA,GAAmCuS,CAACzpB,CAAA,EAAgCC,CAAA;UACxE,IAAIA,CAAA,CAAO6B,MAAA,IAAU,OACf9B,CAAA,CAAQiT,OAAA,CAAQgD,aAAA,CAAchW,CAAA,CAAO,GAAGuU,MAAA,MAAYxU,CAAA,CAAQiT,OAAA,CAAQgD,aAAA,CAAchW,CAAA,CAAO,GAAGuU,MAAA,IAChG,MAAM,IAAInQ,KAAA,CAAM;UAGlB,MAAM5D,CAAA,GAAOR,CAAA,CAAO6B,MAAA,IAAU,IAAK7B,CAAA,CAAO,GAAG0U,UAAA,CAAW,KAAKjU,CAAA,CAAA+hB,QAAA;YACvDxhB,CAAA,GAAOhB,CAAA,CAAO6B,MAAA,IAAU,IAAK7B,CAAA,CAAO,GAAG0U,UAAA,CAAW,KAAKjU,CAAA,CAAAgiB,QAAA;UAC7D,QAAO,GAAAliB,CAAA,CAAA6C,2BAAA,EAA4B;YAACpB,GAAA,EAAAxB,CAAA;YAAK+oB,GAAA,EAAAvoB;UAAA,EAAK;QAAA;QAGnChB,CAAA,CAAAiC,IAAA,GAAO,CAAClC,CAAA,EAAgCC,CAAA,KACrC,CAACD,CAAA,CAAQmU,GAAA,CAAI8C,CAAA,CAAmCjX,CAAA,EAASC,CAAA,CAAO,IAAIsL,CAAA,KAAatL,CAAA,IAEpFA,CAAA,CAAAyY,GAAA,GAAM,CAAC1Y,CAAA,EAAgCC,CAAA,KACpC,CAACD,CAAA,CAAQmU,GAAA,CAAI8C,CAAA,CAAmCjX,CAAA,EAASC,CAAA,CAAO,IAAIsG,CAAA,KAAYtG,CAAA,IAMnFA,CAAA,CAAA8Y,GAAA,GACT,CAAC/Y,CAAA,EAAgCC,CAAA,EAAkBQ,CAAA,KAAwC,CAACT,CAAA,CAAQmU,GAAA,CAChG8C,CAAA,CAAmCjX,CAAA,EAASC,CAAA,CAAO,IAAIyL,CAAA,CAAQjL,CAAA,CAAWwiB,KAAA,GAAQxiB,CAAA,CAAWsC,QAAA,GAC7F9C,CAAA,IAEKA,CAAA,CAAA+Y,kBAAA,GAAsBhZ,CAAA,KAC/B,GAAAQ,CAAA,CAAA6C,2BAAA,EAA4B;UAAC4f,KAAA,EAAOjjB,CAAA,CAAK4d,UAAA,CAAWrZ,QAAA,CAAS,SAAS;QAAA,IAE7DtE,CAAA,CAAAgZ,GAAA,GAAM,CAACjZ,CAAA,EAAgCC,CAAA,KACpC,CAACD,CAAA,CAAQmU,GAAA,CAAI8C,CAAA,CAAmCjX,CAAA,EAASC,CAAA,CAAO,IAAIuG,CAAA,KAAYvG,CAAA,IAEnFA,CAAA,CAAAmZ,KAAA,GAAQ,CAACpZ,CAAA,EAAgCC,CAAA,KACtC,CAACD,CAAA,CAAQmU,GAAA,CAAI8C,CAAA,CAAmCjX,CAAA,EAASC,CAAA,CAAO,IAAI2L,CAAA,KAAc3L,CAAA,IAErFA,CAAA,CAAA0Y,QAAA,GAAW,CAAC3Y,CAAA,EAAgCC,CAAA,KACzC,CAACD,CAAA,CAAQmU,GAAA,CAAI8C,CAAA,CAAmCjX,CAAA,EAASC,CAAA,CAAO,IAAI8L,CAAA,KAAiB9L,CAAA,IAMxFA,CAAA,CAAAia,SAAA,GACT,CAACla,CAAA,EAAgCC,CAAA,EAAkBQ,CAAA,KAA8C,CAACT,CAAA,CAAQmU,GAAA,CACtG8C,CAAA,CAAmCjX,CAAA,EAASC,CAAA,CAAO,IAAI+L,CAAA,CAAcvL,CAAA,CAAWwiB,KAAA,GAAQxiB,CAAA,CAAWsC,QAAA,GACnG9C,CAAA,IAEKA,CAAA,CAAAka,wBAAA,GAA4Bna,CAAA,KACrC,GAAAQ,CAAA,CAAA6C,2BAAA,EAA4B;UAAC4f,KAAA,EAAOjjB,CAAA,CAAK4d,UAAA,CAAWrZ,QAAA,CAAS,SAAS;QAAA,IAE7DtE,CAAA,CAAAsa,GAAA,GAAM,CAACva,CAAA,EAAgCC,CAAA,KACpC,CAACD,CAAA,CAAQmU,GAAA,CAAI8C,CAAA,CAAmCjX,CAAA,EAASC,CAAA,CAAO,IAAIgM,CAAA,KAAYhM,CAAA,IAEnFA,CAAA,CAAA2a,GAAA,GAAM,CAAC5a,CAAA,EAAgCC,CAAA,KACpC,CAACD,CAAA,CAAQmU,GAAA,CAAI8C,CAAA,CAAmCjX,CAAA,EAASC,CAAA,CAAO,IAAIkM,CAAA,KAAYlM,CAAA,IAEnFA,CAAA,CAAA4a,GAAA,GAAM,CAAC7a,CAAA,EAAgCC,CAAA,KACpC,CAACD,CAAA,CAAQmU,GAAA,CAAI8C,CAAA,CAAmCjX,CAAA,EAASC,CAAA,CAAO,IAAIoM,CAAA,KAAYpM,CAAA,IAEnFA,CAAA,CAAA4b,IAAA,GAAO,CAAC7b,CAAA,EAAgCC,CAAA,KACrC,CAACD,CAAA,CAAQmU,GAAA,CAAI8C,CAAA,CAAmCjX,CAAA,EAASC,CAAA,CAAO,IAAI0W,CAAA,KAAa1W,CAAA,IAEpFA,CAAA,CAAAic,OAAA,GAAU,CAAClc,CAAA,EAAgCC,CAAA,KACxC,CAACD,CAAA,CAAQmU,GAAA,CAAI8C,CAAA,CAAmCjX,CAAA,EAASC,CAAA,CAAO,IAAI2W,CAAA,KAAgB3W,CAAA,IAEvFA,CAAA,CAAAkc,GAAA,GAAM,CAACnc,CAAA,EAAgCC,CAAA,KACpC,CAACD,CAAA,CAAQmU,GAAA,CAAI8C,CAAA,CAAmCjX,CAAA,EAASC,CAAA,CAAO,IAAIyW,CAAA,KAAYzW,CAAA,IAEnFA,CAAA,CAAA0c,IAAA,GAAO,CAAC3c,CAAA,EAAgCC,CAAA,KACrC,CAACD,CAAA,CAAQmU,GAAA,CAAI8C,CAAA,CAAmCjX,CAAA,EAASC,CAAA,CAAO,IAAI4W,CAAA,KAAa5W,CAAA,IAEpFA,CAAA,CAAA+c,GAAA,GAAM,CAAChd,CAAA,EAAgCC,CAAA,KACpC,CAACD,CAAA,CAAQmU,GAAA,CAAI8C,CAAA,CAAmCjX,CAAA,EAASC,CAAA,CAAO,IAAI6W,CAAA,KAAY7W,CAAA,IAEnFA,CAAA,CAAAgd,IAAA,GAAO,CAACjd,CAAA,EAAgCC,CAAA,KACrC,CAACD,CAAA,CAAQmU,GAAA,CAAI8C,CAAA,CAAmCjX,CAAA,EAASC,CAAA,CAAO,IAAI8W,CAAA,KAAa9W,CAAA,E;;;;;;;;QC/TjG,MAAAO,CAAA,GAAAC,CAAA;UAEAC,CAAA,GAAAD,CAAA;UACAQ,CAAA,GAAAR,CAAA;UAEAS,CAAA,GAAAT,CAAA;UAEM6C,CAAA,GAAwB;YAC5BU,IAAA,EAAM;YACN4G,UAAA,EAAY,CAAC;YACb2I,UAAA,EAAY,CAAC7S,CAAA,CAAA2T,WAAA,CAAYC,MAAA;UAAA;QAGdrU,CAAA,CAAAypB,uBAAA,GAA0B,CAAC1pB,CAAA,EAAgCC,CAAA;UACtE,MAAMQ,CAAA,GAAOR,CAAA,CAAM4T,IAAA,CAAK/R,MAAA;YAElB4B,CAAA,IAAW,GAAAxC,CAAA,CAAAoe,WAAA,EAAY,MAAM7e,CAAA;YAC7BgK,CAAA,GAAY/G,CAAA,CAASwJ,KAAA,EAAO;YAC5B7B,CAAA,IAAiB,GAAApK,CAAA,CAAA0K,iBAAA,EAAkBlL,CAAA;YACnC6K,CAAA,IAAgB,GAAApK,CAAA,CAAAqe,iBAAA;YAEhBhU,CAAA,GADkC,MAAtBtL,CAAA,CAAM4T,IAAA,CAAK/R,MAAA,GACG,KA0BlC,UAAyB9B,CAAA,EAAcC,CAAA;cACrC,IAAa,MAATD,CAAA,EACF,OAAO;cAGT,IAAIS,CAAA,GAAS;cACb,KAAK,IAAID,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,EAAMQ,CAAA,IACxBC,CAAA,IAAUR,CAAA,CAAKO,CAAA,GACXA,CAAA,GAAIR,CAAA,GAAO,MACbS,CAAA,IAAU;cAGd,OAAOA,CACT;YAAA,CAvCuC,CAAgBA,CAAA,EAAMiD,CAAA;YACrD6C,CAAA,GAAS9F,CAAA,IAAQ,IAAI,OAAO,QAAQgK,CAAA,CAAUrH,IAAA,CAAK;YAEnDsI,CAAA,GAAe,SACjBJ,CAAA,8BAEED,CAAA,2IAGyBE,CAAA,iBAPlB,GAAA/K,CAAA,CAAAqJ,OAAA,EAAQ7J,CAAA,CAAQiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUnF,OAAA,EAS3CmH,MAAA,mCAAyCvD,CAAA;UAIrD,OAAO1D,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKQ,CAAA,GAAqB;YACxBwN,OAAA,GAAS;YACThH,MAAA,EAAQ;cAAC+J,IAAA,EAAM5T,CAAA,CAAM4T,IAAA;cAAM7O,IAAA,EAAM/E,CAAA,CAAM+E,IAAA;cAAM8O,WAAA,EAAapT,CAAA,CAAA2T,WAAA,CAAYgB;YAAA;YACtExE,YAAA,EAAAnF;UAAA,EAAY;QAAA,GAIHzL,CAAA,CAAAwW,6BAAA,GAAgC,CAACzW,CAAA,EAAgCS,CAAA,KACzEoC,MAAA,CAADC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAKQ,CAAA,GAAqB;UAAEkB,GAAA,EAAKA,CAAA,MAAM,GAAAvE,CAAA,CAAAypB,uBAAA,EAAwB1pB,CAAA,EAASS,CAAA;QAAA,E;;;;;;;;QC3C5E,MAAAD,CAAA,GAAAC,CAAA;QAGaR,CAAA,CAAAud,SAAA,GACT,CAACxd,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA;UAC1DC,CAAA,CAAeT,CAAA;UACf,MAAMgB,CAAA,GAAcT,CAAA,CAAA0L,SAAA,CAAUyd,cAAA,CAAe1pB,CAAA,CAAO,GAAG4T,IAAA,EAAMpT,CAAA;UAE7D,OAAO,CADQT,CAAA,CAAiBoV,eAAA,CAAgBnV,CAAA,CAAO,IAAIgB,CAAA,EAC5C;QAAA,GAGRhB,CAAA,CAAAyd,YAAA,GAAe,CAAC1d,CAAA,EAAyCS,CAAA,MACpEQ,CAAA,CAAkBR,CAAA,IACX,GAAAR,CAAA,CAAAud,SAAA,EAAUxd,CAAA,EAAkB,CAACS,CAAA,CAAO,KAAKuF,KAAA,CAAMoZ,IAAA,CAAK3e,CAAA,CAAO,GAAG4jB,WAAA,KAG1DpkB,CAAA,CAAAwd,wBAAA,GAA8Dzd,CAAA,IACvEA,CAAA,CAAK4d,UAAA,CAAW/Y,OAAA,CAAQ;QAE5B,MAAMnE,CAAA,GAAkBV,CAAA;YACtB,KAAKA,CAAA,IAA4B,MAAlBA,CAAA,CAAO8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM;YAGlB,IAAuB,aAAnBrE,CAAA,CAAO,GAAGgF,IAAA,EACZ,MAAM,IAAIX,KAAA,CAAM,8B;;UAIdpD,CAAA,GAAqBjB,CAAA;YACzB,KAAKA,CAAA,IAA4B,MAAlBA,CAAA,CAAO8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM;YAGlB,IAAuB,YAAnBrE,CAAA,CAAO,GAAGgF,IAAA,EACZ,MAAM,IAAIX,KAAA,CAAM,sB;;;;;;;;;QCtCpB,MAAA7D,CAAA,GAAAC,CAAA;UAIAC,CAAA,GAAAD,CAAA;UAEAQ,CAAA,GAAAR,CAAA;UAoBMS,CAAA,GAA0B;YAC9B8C,IAAA,EAAM;YACN4G,UAAA,EAAY,CAAC;YACb2I,UAAA,EAAY,CAACtS,CAAA,CAAAoT,WAAA,CAAYgB,QAAA;UAAA;QAGdpV,CAAA,CAAAod,QAAA,GACT,CAACrd,CAAA,EAAyCS,CAAA,EAAkBD,CAAA,OAC1D,GAAAP,CAAA,CAAAihB,cAAA,EAAezgB,CAAA,EAAQD,CAAA,GAQhB,CAPQR,CAAA,CAAiBmU,GAAA,CAAItR,MAAA,CAADC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAE1B5B,CAAA,GAAuB;UAC1BuS,SAAA,EAAWjT,CAAA,CAAWuC,QAAA;UACtByB,GAAA,EAAKA,CAAA,KAAMlB,CAAA,CAA0BtD,CAAA,EAAkBS,CAAA,EAAQD,CAAA;QAAA,IAEjEC,CAAA,KAIGR,CAAA,CAAAqd,yBAAA,GACRtd,CAAA,KAAyC,GAAAC,CAAA,CAAA8lB,uBAAA,EAAwB/lB,CAAA,EAAM,IAE/DC,CAAA,CAAAsd,yBAAA,GACRvd,CAAA,KAAyC,GAAAC,CAAA,CAAA8lB,uBAAA,EAAwB/lB,CAAA,EAAM,IAE/DC,CAAA,CAAA8lB,uBAAA,GAA0B,CAAC/lB,CAAA,EAAkBS,CAAA;UACxD,MAAMC,CAAA,GAAYD,CAAA,IAAS;YAGrBQ,CAAA,GAAOjB,CAAA,CAAK4d,UAAA,CAAWlZ,SAAA,CAAU,QAAQ;UAC/C,IAAa,cAATzD,CAAA,IAA+B,aAATA,CAAA,KAAsBR,CAAA,GAAQ,MAAe,YAATQ,CAAA,GAC5D,MAAM,IAAIoD,KAAA,CAAM,sBAAsBpD,CAAA;UAGxC,IAAIC,CAAA,GAAmB;UACnBT,CAAA,GAAQ,MACVS,CAAA,GAASlB,CAAA,CAAK4d,UAAA,CAAWhZ,SAAA,CAAU,YACnC,GAAA3E,CAAA,CAAAwmB,gBAAA,EAAiBvlB,CAAA,EAAQD,CAAA,EAAMP,CAAA;UAGjC,MAAM4C,CAAA,GAAqBtD,CAAA,CAAK4d,UAAA,CAAWrZ,QAAA,CAAS,uBAAuB;YAErEb,CAAA,GACFjD,CAAA,GAAQ,KAAKT,CAAA,CAAK4d,UAAA,CAAWlZ,SAAA,CAAU,kCAAkC,gBAAgB;UAC7F,KAE4C,MAFxC,CACE,cAAc,sBAAsB,wBAAwB,iBAAiB,sBAAsB,cACnG0H,OAAA,CAAQ1I,CAAA,GACZ,MAAM,IAAIW,KAAA,CAAM,8BAA8BX,CAAA;UAEhD,MAAM+G,CAAA,GAA4C,yBAA5B/G,CAAA;YAChB2H,CAAA,GAAmBZ,CAAA;YAEnBa,CAAA,GACQ,cAATrK,CAAA,IAAsBR,CAAA,IAAS,KAAMT,CAAA,CAAK4d,UAAA,CAAWlZ,SAAA,CAAU,gBAAgB,wBAAwB;UAC5G,KAA+F,MAA3F,CAAC,sBAAsB,qBAAqB,SAAS,QAAQ,IAAI0H,OAAA,CAAQd,CAAA,GAC3E,MAAM,IAAIjH,KAAA,CAAM,iBAAiBiH,CAAA;UAGnC,MAAMC,CAAA,GAAoBvL,CAAA,CAAK4d,UAAA,CAAWrZ,QAAA,CAAS,kBAAkB;YAC/DgC,CAAA,GAAkE,MAAjDvG,CAAA,CAAK4d,UAAA,CAAWnZ,MAAA,CAAO,mBAAmB;UACjE,IAAI8B,CAAA,IAA2B,YAATtF,CAAA,EACpB,MAAM,IAAIoD,KAAA,CAAM;UAGlB,MAAMqH,CAAA,GACDjL,CAAA,GAAQ,MAAuB,cAATQ,CAAA,IAAkD,iBAA5ByC,CAAA,IAA4D,YAAhB4H,CAAA;UAE7F,IAAI9E,CAAA,GAAc;YACdoF,CAAA,GAAiB;YACjBC,CAAA,GAAgB;UAgBpB,OAdIpL,CAAA,GAAQ,KAENT,CAAA,CAAK4pB,MAAA,CAAO9nB,MAAA,GAAS,KACvB0E,CAAA,GAAc,GACdoF,CAAA,GAAiB,GACjBC,CAAA,GAAgB,MAEhBD,CAAA,GAAiB,GACjBC,CAAA,GAAgB,KAEC,MAAVpL,CAAA,KACTmL,CAAA,GAAiB,KAGZ,GAAApL,CAAA,CAAA6C,2BAAA,EAA4B;YACjCwmB,KAAA,EAAAppB,CAAA;YACA8lB,QAAA,EAAA7lB,CAAA;YACAmhB,IAAA,EAAA5gB,CAAA;YACAmlB,MAAA,EAAAllB,CAAA;YACA4oB,kBAAA,EAAAxmB,CAAA;YACA4iB,uBAAA,EAAAxiB,CAAA;YACAqmB,gBAAA,EAAA1e,CAAA;YACA2e,YAAA,EAAAvf,CAAA;YACAwf,WAAA,EAAA3e,CAAA;YACA4e,iBAAA,EAAA3e,CAAA;YACA4e,cAAA,EAAA5jB,CAAA;YACA6jB,wBAAA,EAAA1e,CAAA;YACA2e,WAAA,EAAA7jB,CAAA;YACA6f,cAAA,EAAAza,CAAA;YACA0a,aAAA,EAAAza;UAAA,EACA;QAAA;QAGJ,MAAMvI,CAAA,GACFgnB,CAACtqB,CAAA,EAAyCC,CAAA,EAAkBQ,CAAA;UAC1D,MAAMD,CAAA,IAAO,GAAAE,CAAA,CAAAmJ,OAAA,EAAQ7J,CAAA,CAAiBiT,OAAA,CAAQ9L,OAAA,CAAQW,SAAA,CAAUnF,OAAA;YAAA,CACzDW,CAAA,EAAYI,CAAA,IACf1D,CAAA,CAAiBoT,8BAAA,CAA+BnT,CAAA,CAAO,GAAG4T,IAAA,EAAM5S,CAAA,CAAAoT,WAAA,CAAYgB,QAAA;YAE1E5K,CAAA,GAAcxK,CAAA,CAAO,GAAG4T,IAAA,CAAK1Q,GAAA,CAAI,CAACnD,CAAA,EAAKC,CAAA,KAAM+B,IAAA,CAAKoX,KAAA,CAAMpZ,CAAA,GAAMS,CAAA,CAAW2lB,MAAA,CAAOnmB,CAAA;YAAA,CAC/EoL,CAAA,EAAaC,CAAA,IAChBtL,CAAA,CAAiBoT,8BAAA,CAA+B3I,CAAA,EAAaxJ,CAAA,CAAAoT,WAAA,CAAYgB,QAAA;YACvE9J,CAAA,GAAMd,CAAA,CAAY3I,MAAA;YAElByE,CAAA,GAAgB,IAAIP,KAAA,CAAcuF,CAAA;YAClCG,CAAA,GAAe,IAAI1F,KAAA,CAAcuF,CAAA;UACvC,IAAI/E,CAAA,GAAuB,8BACN+E,CAAA,+BACDA,CAAA;UAEpB,KAAK,IAAIvL,CAAA,GAAIuL,CAAA,GAAM,GAAGvL,CAAA,IAAK,GAAGA,CAAA,IAC5BuG,CAAA,CAAcvG,CAAA,IAAMA,CAAA,KAAMuL,CAAA,GAAM,IAAK,IAAIhF,CAAA,CAAcvG,CAAA,GAAI,KAAKyK,CAAA,CAAYzK,CAAA,GAAI,IAChF0L,CAAA,CAAa1L,CAAA,IAAMA,CAAA,KAAMuL,CAAA,GAAM,IAAK,IAAIG,CAAA,CAAa1L,CAAA,GAAI,KAAKC,CAAA,CAAO,GAAG4T,IAAA,CAAK7T,CAAA,GAAI,IAEjFwG,CAAA,IAAwB,4BACPxG,CAAA,OAAQuG,CAAA,CAAcvG,CAAA,6BACvBA,CAAA,OAAQ0L,CAAA,CAAa1L,CAAA;UAGvC,MAAM4L,CAAA,GAAwB,yFAEUtI,CAAA,KAAeI,CAAA,6CACrBlD,CAAA,CAAKkK,SAAA;YAKjCmB,CAAA,GAAmC,cAApBpL,CAAA,CAAWohB,IAAA,GAE5B,SACJjW,CAAA,mCAC0BL,CAAA,wFAEqBF,CAAA,KAAgBC,CAAA,eAE7D9E,CAAA,sDAGwB+E,CAAA,gZAed,MAARA,CAAA,GAEI,SACRK,CAAA,yHAG+CP,CAAA,KAAgBC,CAAA,eAE7D9E,CAAA,ikCA2B4BvG,CAAA,CAAO,GAAG4T,IAAA,CAAK,ktBAuBrC,SACRjI,CAAA,yHAG+CP,CAAA,KAAgBC,CAAA,eAE7D9E,CAAA,svBAoB4BvG,CAAA,CAAO,GAAG4T,IAAA,CAAK;UAsB7C,OAAOhR,MAAA,CAAPC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACK5B,CAAA,GAAuB;YAC1B4I,MAAA,EAAQ;cAAC+J,IAAA,EAAMpJ,CAAA;cAAazF,IAAA,EAAM/E,CAAA,CAAO,GAAG+E,IAAA;cAAM8O,WAAA,EAAa7S,CAAA,CAAAoT,WAAA,CAAYgB;YAAA;YAC3ExE,YAAA,EAAAhF,CAAA;YACAqF,SAAA,EAAW,CAAC;cACVlN,IAAA,EAAM;cACNgB,IAAA,EAAM;cACNqM,WAAA,EAAa5Q,CAAA,CAAW2lB,MAAA,CAAOtkB,MAAA;cAC/B2hB,IAAA,EAAMhjB,CAAA,CAAW2lB,MAAA,CAAOjjB,GAAA,CAAInD,CAAA,IAAKgC,IAAA,CAAKE,IAAA,CAAKlC,CAAA;YAAA;UAAA,EAC3C;QAAA;QAIGC,CAAA,CAAAihB,cAAA,GAAiB,CAAClhB,CAAA,EAAkBC,CAAA;UAC/C,KAAKD,CAAA,IAAWC,CAAA,CAAU4pB,KAAA,GAAQ,KAAuB,MAAlB7pB,CAAA,CAAO8B,MAAA,IACzC7B,CAAA,CAAU4pB,KAAA,IAAS,KAAK5pB,CAAA,CAAU4pB,KAAA,GAAQ,MAAwB,MAAlB7pB,CAAA,CAAO8B,MAAA,IACvD7B,CAAA,CAAU4pB,KAAA,IAAS,MAAM7pB,CAAA,CAAO8B,MAAA,GAAS,GAC5C,MAAM,IAAIuC,KAAA,CAAM;UAGlB,IAAIpE,CAAA,CAAUmmB,MAAA,CAAOtkB,MAAA,GAAS,KAAK9B,CAAA,CAAO,GAAG6T,IAAA,CAAK/R,MAAA,KAAW7B,CAAA,CAAUmmB,MAAA,CAAOtkB,MAAA,EAC5E,MAAM,IAAIuC,KAAA,CAAM;UAGlB,IAAuB,aAAnBrE,CAAA,CAAO,GAAGgF,IAAA,EACZ,MAAM,IAAIX,KAAA,CAAM,8B;WAIPpE,CAAA,CAAAwmB,gBAAA,GAAmB,CAACzmB,CAAA,EAAkBC,CAAA,EAAcQ,CAAA;UAC/D,IAAKA,CAAA;YAOH,KAAK,MAAMR,CAAA,IAASD,CAAA,EAClB,IAAIC,CAAA,IAAS,GACX,MAAM,IAAIoE,KAAA,CAAM;UAAA,OARpB,KAAK,MAAMpE,CAAA,IAASD,CAAA,EAClB,IAAIC,CAAA,GAAQ,GACV,MAAM,IAAIoE,KAAA,CAAM;UAUtB,MAAa,aAATpE,CAAA,IAA8B,YAATA,CAAA,IACD,MAAlBD,CAAA,CAAO8B,MAAA,IAAmC,MAAlB9B,CAAA,CAAO8B,MAAA,IAA8B,MAAd9B,CAAA,CAAO,MAA0B,MAAdA,CAAA,CAAO,KAC3E,MAAM,IAAIqE,KAAA,CAAM,+KAEL5D,CAAA,GAAW,WAAW,uB;;;;;;;;;QCvVvC,MAAAD,CAAA,GAAAC,CAAA;UAEAC,CAAA,GAAAD,CAAA;UAEAQ,CAAA,GAAAR,CAAA;UACAS,CAAA,GAAAT,CAAA;QAcAR,CAAA,CAAAsqB,cAAA;UAKE3nB,YACW5C,CAAA,EAAqCC,CAAA,EACrCQ,CAAA;YADA,KAAA+pB,QAAA,GAAAxqB,CAAA,EAAqC,KAAA8H,SAAA,GAAA7H,CAAA,EACrC,KAAAwqB,qBAAA,GAAAhqB,CAAA,EACT,KAAKiqB,IAAA,GAAO,IAAI9mB,GAAA,IAChB,KAAK+mB,eAAA,IAAkB,CACzB;UAAA;UACAhX,YAAY3T,CAAA;YACV,OAAO,KAAK0qB,IAAA,CAAKlmB,GAAA,CAAIxE,CAAA,CACvB;UAAA;UACAiU,YAAYjU,CAAA,EAAcC,CAAA;YACxB,KAAKyqB,IAAA,CAAK3mB,GAAA,CAAI/D,CAAA,EAAKC,CAAA,CACrB;UAAA;UACAkU,IAAInU,CAAA,EAAyBC,CAAA,EAAuBQ,CAAA;;YAClD,KAAK+pB,QAAA,CAASI,KAAA,CAAM,MAAM,sBAAoD,UAA9BpqB,CAAA,GAAAR,CAAA,CAAc2K,WAAA,CAAY3G,IAAA,UAAI,MAAAxD,CAAA,GAAAA,CAAA,GAAI,oBAAoB;;cACpG,MAAMS,CAAA,GAAK,KAAK6G,SAAA,CAAU+iB,EAAA;gBACpB3pB,CAAA,GAAUlB,CAAA,CAAc8qB,OAAA;cAC9B7pB,CAAA,CAAG8pB,UAAA,CAAW7pB,CAAA;cACd;gBACE,KAAK8pB,UAAA,CAAWvqB,CAAA,GACX,KAAKkqB,eAAA,IACR,KAAKM,cAAA,CAAejrB,CAAA,CAAckrB,eAAA,GAEpC,KAAKC,YAAA,CAAanrB,CAAA,CAAcorB,gBAAA,EAAqD,UAAnC5qB,CAAA,GAAAR,CAAA,CAAc2K,WAAA,CAAYuG,SAAA,UAAS,MAAA1Q,CAAA,GAAAA,CAAA,GAAI,IAAIP,CAAA,C;eAC7F,QAAOA,CAAA;gBAEP,MADAS,CAAA,CAAAsH,MAAA,CAAOqjB,KAAA,CAAM,kBAAkBrrB,CAAA,CAAc2K,WAAA,CAAYkG,YAAA,GACnD5Q,C;;cAER,KAAKuqB,QAAA,CAASI,KAAA,CAAM,WAAW,oBAAoB;gBACjD,KAAK9iB,SAAA,CAAUwjB,IAAA,EAAM;cAAA,EACrB;YAAA,GACD,KAAKxjB,SAAA,CACV;UAAA;UACAT,QAAA;YACM,KAAKkkB,YAAA,IACP,KAAKzjB,SAAA,CAAU0jB,YAAA,CAAa,KAAKD,YAAA,GAEnC,KAAKb,IAAA,CAAK7f,OAAA,CAAQ7K,CAAA,IAAK,KAAK8H,SAAA,CAAU2jB,aAAA,CAAczrB,CAAA,CAAE8qB,OAAA,EACxD;UAAA;UACA9W,MAAMhU,CAAA,EAA0BC,CAAA,EAAsCQ,CAAA;YACpE,OAAO,KAAK+pB,QAAA,CAASI,KAAA,CAAM,WAAW,wBAAwB;cAC5D,MAAMpqB,CAAA,GAAe,IAAIS,CAAA,CAAAsP,gBAAA,CAAiB,KAAKzI,SAAA,EAAW9H,CAAA,EAAaC,CAAA,EAAqBQ,CAAA;gBACtFC,CAAA,GAAaF,CAAA,CAAaoQ,UAAA;gBAC1B1P,CAAA,GAAU,KAAKwqB,OAAA,CAAQhrB,CAAA;cAQ7B,OAPiB;gBACfiK,WAAA,EAAA3K,CAAA;gBACA8qB,OAAA,EAAA5pB,CAAA;gBACAkqB,gBAAA,EAAkB,KAAKO,mBAAA,CACnBzqB,CAAA,EAASV,CAAA,CAAawI,OAAA,CAAQ2B,WAAA,CAAYC,UAAA,EAAYpK,CAAA,CAAawI,OAAA,CAAQ2B,WAAA,CAAYuG,SAAA;gBAC3Fga,eAAA,EAAiB,KAAKU,kBAAA,CAAmB1qB,CAAA;cAAA,CAE5B;YAAA,EAEnB;UAAA;UACUwqB,QAAQ1rB,CAAA;YAChB,KAAK,KAAKurB,YAAA,EAAc;cACtB7qB,CAAA,CAAAsH,MAAA,CAAOE,OAAA,CAAQ,mBAAmB;cAClC,MAAMlI,CAAA,IAAqB,GAAAkB,CAAA,CAAAsR,qBAAA,EAAsB,KAAK1K,SAAA,CAAUnF,OAAA;cAChE,KAAK4oB,YAAA,GAAe,KAAKzjB,SAAA,CAAU+jB,aAAA,CAAc7rB,CAAA,EAAoB,KAAK8H,SAAA,CAAU+iB,EAAA,CAAGiB,aAAA,C;;YAErFtrB,CAAA,CAAAY,GAAA,CAAI2qB,KAAA,IACNrrB,CAAA,CAAAsH,MAAA,CAAOE,OAAA,CAAQ,mBAAmB,gBACtClI,CAAA;YAGE,MAAMC,CAAA,GAAa,KAAK6H,SAAA,CAAU+jB,aAAA,CAAc7rB,CAAA,EAAkB,KAAK8H,SAAA,CAAU+iB,EAAA,CAAGmB,eAAA;cAC9EvrB,CAAA,GAAU,KAAKqH,SAAA,CAAUmkB,aAAA,CAAc,KAAKV,YAAA,EAActrB,CAAA;YAEhE,OADA,KAAK6H,SAAA,CAAU0jB,YAAA,CAAavrB,CAAA,GACrBQ,CACT;UAAA;UACAuqB,WAAWhrB,CAAA;YACT,MAAMC,CAAA,GAAQD,CAAA,CAAGsJ,KAAA;cACX7I,CAAA,GAAST,CAAA,CAAGuJ,MAAA;YAClB7I,CAAA,CAAAsH,MAAA,CAAOE,OAAA,CACH,mBACA,8CAA8CjI,CAAA,IAASQ,CAAA,WAAiBT,CAAA,CAAG8N,KAAA,UAAe9N,CAAA,CAAGoU,MAAA,CAAOpP,IAAA,KACxG,KAAK8C,SAAA,CAAUokB,iBAAA,CAAkBlsB,CAAA,CAAGwV,OAAA,EAASvV,CAAA,EAAOQ,CAAA,CACtD;UAAA;UACAwqB,eAAejrB,CAAA;YACb,MAAMC,CAAA,GAAiBD,CAAA,CAAgBmsB,QAAA;cACjC1rB,CAAA,GAAqBT,CAAA,CAAgBosB,YAAA;YAC3C,KAAKtkB,SAAA,CAAUukB,mBAAA,CAAoBpsB,CAAA,EAAgBQ,CAAA,GACnD,KAAKkqB,eAAA,IAAkB,CACzB;UAAA;UACAQ,aAAanrB,CAAA,EAA6CC,CAAA,EAA8BQ,CAAA;;YAEtF,MAAMC,CAAA,GAAK,KAAKoH,SAAA,CAAU+iB,EAAA;YAC1B,IAAI5pB,CAAA,GAAkB;YACtB,KAAK;cAAM+C,IAAA,EAAC9C,CAAA;cAAI8D,IAAA,EAAE1B,CAAA;cAAIgpB,QAAA,EAAE5oB,CAAA;cAAQ2N,WAAA,EAAE5G;YAAA,KAAgBzK,CAAA,EAAkB;cAClE,MAAMA,CAAA,GAA4C,UAApCQ,CAAA,GAAAP,CAAA,CAAUssB,IAAA,CAAKvsB,CAAA,IAAKA,CAAA,CAAEgE,IAAA,KAAS9C,CAAA,WAAK,MAAAV,CAAA,YAAAA,CAAA,CAAEijB,IAAA;cACpD,IAAa,gBAATngB,CAAA,KAAyBtD,CAAA,EAC3B,MAAM,IAAIqE,KAAA,CAAM,aAAanD,CAAA;cAE/B,QAAQoC,CAAA;gBACN,KAAK;kBACH,KAAKkpB,WAAA,CAAY/rB,CAAA,CAASQ,CAAA,GAAkByC,CAAA,EAAUzC,CAAA,GACtDA,CAAA;kBACA;gBACF,KAAK;kBACCwJ,CAAA,GACF/J,CAAA,CAAG+rB,UAAA,CAAW/oB,CAAA,EAAU1D,CAAA,IAExBU,CAAA,CAAGgsB,SAAA,CAAUhpB,CAAA,EAAU1D,CAAA;kBAEzB;gBACF,KAAK;kBACCyK,CAAA,GACF/J,CAAA,CAAGisB,UAAA,CAAWjpB,CAAA,EAAU1D,CAAA,IAExBU,CAAA,CAAGksB,SAAA,CAAUlpB,CAAA,EAAU1D,CAAA;kBAEzB;gBACF;kBACE,MAAM,IAAIqE,KAAA,CAAM,4BAA4Bf,CAAA;cAAA;;UAGpD;UACAkpB,YAAYxsB,CAAA,EAAiBC,CAAA,EAAqCQ,CAAA;YAChE,KAAKqH,SAAA,CAAU+kB,oBAAA,CAAqB7sB,CAAA,CAAGwV,OAAA,EAAS/U,CAAA,EAAUR,CAAA,CAC5D;UAAA;UACA2rB,mBAAmB5rB,CAAA;YACjB,OAAO;cACLmsB,QAAA,EAAU,KAAKW,iBAAA,CAAkB9sB,CAAA,EAAS;cAC1CosB,YAAA,EAAc,KAAKU,iBAAA,CAAkB9sB,CAAA,EAAS;YAAA,CAElD;UAAA;UACA2rB,oBAAoB3rB,CAAA,EAAuBC,CAAA,EAAqBQ,CAAA;YAE9D,MAAMD,CAAA,GAA8C;YACpD,IAAIP,CAAA,EACF,KAAK,MAAMQ,CAAA,IAAWR,CAAA,EACpBO,CAAA,CAAiBwG,IAAA,CAAK;cAAChD,IAAA,EAAMvD,CAAA;cAASuE,IAAA,EAAM;cAAasnB,QAAA,EAAU,KAAKS,kBAAA,CAAmB/sB,CAAA,EAASS,CAAA;YAAA;YAGxG,IAAIA,CAAA,EACF,KAAK,MAAMR,CAAA,IAAYQ,CAAA,EACrBD,CAAA,CAAiBwG,IAAA,CAAKnE,MAAA,CAADC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAK7C,CAAA,GAAQ;cAAEqsB,QAAA,EAAU,KAAKS,kBAAA,CAAmB/sB,CAAA,EAASC,CAAA,CAAS+D,IAAA;YAAA;YAG5F,OAAOxD,CACT;UAAA;UACAusB,mBAAmB/sB,CAAA,EAAuBC,CAAA;YACxC,MACMQ,CAAA,GADK,KAAKqH,SAAA,CAAU+iB,EAAA,CACLkC,kBAAA,CAAmB/sB,CAAA,EAASC,CAAA;YACjD,IAAkB,SAAdQ,CAAA,EACF,MAAM,IAAI4D,KAAA,CAAM,WAAWpE,CAAA;YAE7B,OAAOQ,CACT;UAAA;UACAqsB,kBAAkB9sB,CAAA,EAAuBC,CAAA;YAGvC,OAFW,KAAK6H,SAAA,CAAU+iB,EAAA,CACWiC,iBAAA,CAAkB9sB,CAAA,EAASC,CAAA,CAElE;UAAA;QAAA,C;;;;;;;;QC9KF,MAAAO,CAAA,GAAAC,CAAA;UAEAC,CAAA,GAAAD,CAAA;UAKAQ,CAAA,GAAAR,CAAA;UACAS,CAAA,GAAAT,CAAA;UACA6C,CAAA,GAAA7C,CAAA;UACAiD,CAAA,GAAAjD,CAAA;UACAgK,CAAA,GAAAhK,CAAA;QAGAR,CAAA,CAAAmI,mBAAA;UAWExF,YAA4B5C,CAAA,EAAuCC,CAAA;YAAvC,KAAAkH,OAAA,GAAAnH,CAAA,EAAuC,KAAAgJ,OAAA,GAAA/I,CAAA,EACjE,KAAKoT,cAAA,GAAiB,IAAI3P,CAAA,CAAAspB,qBAAA,CAAsBhtB,CAAA,CAAQ8H,SAAA,CAAUmlB,cAAA,GAClE,KAAKvZ,cAAA,GAAiB,IAAIpQ,CAAA,CAAAinB,cAAA,CAAe,KAAKvhB,OAAA,CAAQwhB,QAAA,EAAUxqB,CAAA,CAAQ8H,SAAA,EAAW,KAAKuL,cAAA,GACxF,KAAK4B,cAAA,GAAiB,IAAIxK,CAAA,CAAAyiB,cAAA,CACtBltB,CAAA,CAAQ8H,SAAA,EAAW,KAAKuL,cAAA,EAAgB,KAAKrK,OAAA,CAAQwhB,QAAA,EACrD;cAAC2C,aAAA,EAA4C,WAA7BntB,CAAA,CAAQ2H;YAAA,IAC5B,KAAKuL,sBAAA,GAAyB,IAAItP,GAAA,IAClC,KAAKuP,wBAAA,GAA2B,IAAIvP,GAAA,IACpC,KAAKgE,IAAA,GAAO5H,CAAA,CAAQ4H,IAAA,EACpB,KAAKwlB,cAAA,GAAiB,IAAIxpB,GAAA,IAC1B,KAAKypB,cAAA,GAAiB,IAAIzpB,GAC5B,CAD4B,CAC5B;UAAA;UAEA0pB,uBAAA;YACE,OAAO,IAAIrsB,CAAA,CAAA+R,qBAAA,CAAsB,KACnC;UAAA;UACAua,mBAAmBvtB,CAAA;YACjB,MAAMC,CAAA,GAAeD,CAAA,CAAMwtB,SAAA,GAAYtd,MAAA,CAAOlQ,CAAA,KAAiB,MAAZA,CAAA,CAAEof,IAAA,IAAepf,CAAA,CAAEoU,MAAA,EAAQjR,GAAA,CAAInD,CAAA,IAAKA,CAAA,CAAEoU,MAAA,CAAQI,MAAA;YACjG,KAAKiZ,YAAA,GAAe,IAAI9e,GAAA,CAAI1O,CAAA,CAC9B;UAAA;UACAgW,cAAcjW,CAAA;YACZ,SAAO,KAAKytB,YAAA,IAAe,KAAKA,YAAA,CAAa3e,GAAA,CAAI9O,CAAA,CACnD;UAAA;UACA0tB,eAAe1tB,CAAA;YACb,KAAKytB,YAAA,CAAa1e,GAAA,CAAI/O,CAAA,CACxB;UAAA;UACAuU,eAAevU,CAAA,EAAqBC,CAAA;YAClC,OAAIA,CAAA,GACK,KAAKiT,sBAAA,CAAuB1O,GAAA,CAAIxE,CAAA,IAEhC,KAAKmT,wBAAA,CAAyB3O,GAAA,CAAIxE,CAAA,CAE7C;UAAA;UACAgW,eAAehW,CAAA,EAAqBC,CAAA,EAA0BQ,CAAA,IAAW;YACvED,CAAA,CAAAwH,MAAA,CAAOE,OAAA,CAAQ,uBAAuB,kCAClCzH,CAAA,GACF,KAAKyS,sBAAA,CAAuBnP,GAAA,CAAI/D,CAAA,EAAUC,CAAA,IAE1C,KAAKkT,wBAAA,CAAyBpP,GAAA,CAAI/D,CAAA,EAAUC,CAAA,CAEhD;UAAA;UACAoH,QAAA;YACE,KAAKqM,cAAA,CAAerM,OAAA,IACpB,KAAK4N,cAAA,CAAekB,mBAAA,IACpB,KAAKjD,sBAAA,CAAuBrI,OAAA,CAAQ7K,CAAA,IAAM,KAAKiV,cAAA,CAAemB,cAAA,CAAepW,CAAA,GAAI,KACjF,KAAKkT,sBAAA,GAAyB,IAAItP,GAAA,IAClC,KAAKuP,wBAAA,CAAyBtI,OAAA,CAAQ7K,CAAA,IAAM,KAAKiV,cAAA,CAAemB,cAAA,CAAepW,CAAA,GAAI,KACnF,KAAKmT,wBAAA,GAA2B,IAAIvP,GACtC,CADsC,CACtC;UAAA;UACArB,QAAQvC,CAAA,EAAkBC,CAAA,EAA0BQ,CAAA;YAClD,MAAMD,CAAA,IAAK,GAAAE,CAAA,CAAAitB,eAAA,EAAgB3tB,CAAA,EAAMC,CAAA,EAAQiB,CAAA,CAAAoW,sBAAA;YACzC,OAAO;cAACsW,IAAA,EAAMptB,CAAA,CAAGqtB,MAAA;cAAQ7kB,OAAA,EAASxI,CAAA,CAAGstB,MAAA,GAASttB,CAAA,CAAGstB,MAAA,CAAO9tB,CAAA,EAAMS,CAAA,IAAST;YAAA,CACzE;UAAA;QAAA,C;;;;;;;;QC/EF,MAAAQ,CAAA,GAAAC,CAAA;QAqCAR,CAAA,CAAA8tB,qBAAA;UAKEnrB,YAAY5C,CAAA,EAA4BC,CAAA,GAAW;YACjD,IAAiB,MAAbA,CAAA,EACF,KAAK+tB,cAAA,GAAiBhuB,CAAA,CAAGiuB,IAAA,EACzB,KAAKC,MAAA,GAASluB,CAAA,CAAGmuB,GAAA,EACjB,KAAKra,WAAA,GAAc9T,CAAA,CAAGkF,KAAA,EACtB,KAAKkpB,WAAA,GAAcnuB,CAAA,MACd;cAAA,IAAiB,MAAbA,CAAA,EAMT,MAAM,IAAIoE,KAAA,CAAM,+BAA+BpE,CAAA;cAL/C,KAAK+tB,cAAA,GAAiBhuB,CAAA,CAAGquB,OAAA,EACzB,KAAKH,MAAA,GAASluB,CAAA,CAAGsuB,IAAA,EACjB,KAAKxa,WAAA,GAAc9T,CAAA,CAAGkF,KAAA,EACtB,KAAKkpB,WAAA,GAAcnuB,C;;UAIvB;UACAiP,OAAOlP,CAAA,EAA4BC,CAAA;YACjC,IAAIQ,CAAA,EACAC,CAAA;YAcJ,OAbIV,CAAA,CAAI4C,WAAA,KAAgBgS,YAAA,KACtBpU,CAAA,CAAAwH,MAAA,CAAOG,OAAA,CAAQ,WAAW,4DAC1BzH,CAAA,GAAS,IAAIkU,YAAA,CAAa5U,CAAA,IAExBC,CAAA,GAAc,KAAKmuB,WAAA,GAAcpuB,CAAA,CAAI8B,MAAA,IACvCtB,CAAA,CAAAwH,MAAA,CAAOG,OAAA,CAAQ,WAAW,mDAC1BzH,CAAA,GAASV,CAAA,EACTS,CAAA,GAAS,KAAK8tB,QAAA,CAAStuB,CAAA,GAAc,KAAKmuB,WAAA,GAC1C1tB,CAAA,CAAOmK,OAAA,CAAQ,CAAC7K,CAAA,EAAGC,CAAA,KAAMQ,CAAA,CAAOR,CAAA,IAAKD,CAAA,MAErCU,CAAA,GAASV,CAAA,EACTS,CAAA,GAASC,CAAA,GAEJD,CACT;UAAA;UACA8tB,SAASvuB,CAAA;YACP,OAAO,IAAI4U,YAAA,CAAoB,IAAP5U,CAAA,CAC1B;UAAA;UACAmP,OAAOnP,CAAA,EAA+BC,CAAA;YACpC,OAAyB,MAArB,KAAKmuB,WAAA,GACepuB,CAAA,CAAwBkQ,MAAA,CAAO,CAAClQ,CAAA,EAAOC,CAAA,KAAUA,CAAA,GAAQ,KAAM,GAAG4U,QAAA,CAAS,GAAG5U,CAAA,IAG/FD,CAAA,CAAO6U,QAAA,CAAS,GAAG5U,CAAA,CAC5B;UAAA;QAAA,GAKFA,CAAA,CAAAuuB,oBAAA;UAKE5rB,YAAY5C,CAAA,EAA2BC,CAAA,GAAW,GAAGQ,CAAA;YACnD,IAAiB,MAAbR,CAAA,IAA+B,MAAbA,CAAA,EACpB,MAAM,IAAIoE,KAAA,CAAM,+BAA+BpE,CAAA;YAEjD,KAAK+tB,cAAA,GAAiBhuB,CAAA,CAAGsuB,IAAA,EACzB,KAAKJ,MAAA,GAASluB,CAAA,CAAGsuB,IAAA,EACjB,KAAKF,WAAA,GAAcnuB,CAAA,EACnB,KAAK6T,WAAA,GAAcrT,CAAA,IAAeT,CAAA,CAAGkF,KACvC;UAAA;UACAgK,OAAOlP,CAAA,EAAmBC,CAAA;YACxB,IAAIQ,CAAA,GAAOT,CAAA;YAMX,OALyB,MAArB,KAAKouB,WAAA,KACP5tB,CAAA,CAAAwH,MAAA,CAAOE,OAAA,CAAQ,WAAW,kCAC1BzH,CAAA,GAAO,KAAK8tB,QAAA,CAAStuB,CAAA,GACrBD,CAAA,CAAI6K,OAAA,CAAQ,CAAC7K,CAAA,EAAGC,CAAA,KAAMQ,CAAA,CAAS,IAAJR,CAAA,IAASD,CAAA,IAE/BS,CACT;UAAA;UACA8tB,SAASvuB,CAAA;YACP,OAAO,IAAI4U,YAAA,CAAoB,IAAP5U,CAAA,CAC1B;UAAA;UACAmP,OAAOnP,CAAA,EAA+BC,CAAA;YACpC,OAAyB,MAArB,KAAKmuB,WAAA,GACepuB,CAAA,CAAwBkQ,MAAA,CAAO,CAAClQ,CAAA,EAAOC,CAAA,KAAUA,CAAA,GAAQ,KAAM,GAAG4U,QAAA,CAAS,GAAG5U,CAAA,IAG/FD,CAAA,CAAO6U,QAAA,CAAS,GAAG5U,CAAA,CAC5B;UAAA;QAAA,GAGFA,CAAA,CAAAwuB,gBAAA;UAKE7rB,YAAY5C,CAAA,EAA2BC,CAAA,GAAW;YAChD,IAFF,KAAAmuB,WAAA,GAAc,GAEK,MAAbnuB,CAAA,EACF,KAAK+tB,cAAA,GAAiBhuB,CAAA,CAAG0uB,KAAA,EACzB,KAAKR,MAAA,GAASluB,CAAA,CAAG0uB,KAAA,EACjB,KAAK5a,WAAA,GAAc9T,CAAA,CAAG2uB,aAAA,EACtB,KAAKP,WAAA,GAAcnuB,CAAA,MACd;cAAA,IAAiB,MAAbA,CAAA,EAMT,MAAM,IAAIoE,KAAA,CAAM,+BAA+BpE,CAAA;cAL/C,KAAK+tB,cAAA,GAAiBhuB,CAAA,CAAGsuB,IAAA,EACzB,KAAKJ,MAAA,GAASluB,CAAA,CAAGsuB,IAAA,EACjB,KAAKxa,WAAA,GAAc9T,CAAA,CAAG2uB,aAAA,EACtB,KAAKP,WAAA,GAAcnuB,C;;UAIvB;UACAiP,OAAOlP,CAAA,EAAiBC,CAAA;YACtB,OAAO,IAAIwP,UAAA,CAAWzP,CAAA,CAAI4uB,MAAA,EAAQ5uB,CAAA,CAAI6uB,UAAA,EAAY7uB,CAAA,CAAI8uB,UAAA,CACxD;UAAA;UACAP,SAASvuB,CAAA;YACP,OAAO,IAAIyP,UAAA,CAAWzP,CAAA,GAAO,KAAKouB,WAAA,CACpC;UAAA;UACAjf,OAAOnP,CAAA,EAA+BC,CAAA;YACpC,IAAID,CAAA,YAAkByP,UAAA,EACpB,OAAOzP,CAAA,CAAO6U,QAAA,CAAS,GAAG5U,CAAA;YAE5B,MAAM,IAAIoE,KAAA,CAAM,uBAAuBrE,CAAA,CAAO4C,WAAA,GAChD;UAAA;QAAA,C;;;;;;;;QC3JF,MAAApC,CAAA,GAAAC,CAAA;UACAC,CAAA,GAAAD,CAAA;QAqJA,SAAgBQ,EAAajB,CAAA,EAAiBC,CAAA;UAC5C,MAAMQ,CAAA,GAAqB;YACrBD,CAAA,GAAqB;YACrBE,CAAA,GAAuB,QAART,CAAA,IAAgB+F,KAAA,CAAM+oB,OAAA,CAAQ9uB,CAAA,KAAyB,MAAhBA,CAAA,CAAK6B,MAAA;YAC3Db,CAAA,GAAgB,QAARhB,CAAA,IAAgBS,CAAA,GAAgB,OAAOQ,CAAA,CAAejB,CAAA,EAAMD,CAAA,EAAOkD,IAAA;UACjF,IAAII,CAAA,GAAI;UACR,KAAK,IAAIrD,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAM8B,MAAA,IAAU7B,CAAA,EAAG;YACrC,IAAY,QAARgB,CAAA,EAAc;cAChB,IAAIA,CAAA,CAAKqC,CAAA,MAAOrD,CAAA,IAAkB,MAAbD,CAAA,CAAMC,CAAA,GACzB,MAAM,IAAIoE,KAAA,CAAM,sBAAsBpE,CAAA,mBAAoBD,CAAA,CAAMC,CAAA;cAAA,CAElD,QAAXgB,CAAA,CAAKqC,CAAA,KAAcrC,CAAA,CAAKqC,CAAA,IAAKrD,CAAA,KAAmB,MAAbD,CAAA,CAAMC,CAAA,MAC5CQ,CAAA,CAASuG,IAAA,CAAKhH,CAAA,CAAMC,CAAA,IACpBO,CAAA,CAASwG,IAAA,CAAK/G,CAAA,IAEZgB,CAAA,CAAKqC,CAAA,KAAMrD,CAAA,IACbqD,CAAA,E;;YAGa,MAAbtD,CAAA,CAAMC,CAAA,MACRQ,CAAA,CAASuG,IAAA,CAAKhH,CAAA,CAAMC,CAAA,IACpBO,CAAA,CAASwG,IAAA,CAAK/G,CAAA,E;;UAGlB,OAAO;YAACyN,QAAA,EAAAjN,CAAA;YAAUkN,QAAA,EAAAnN;UAAA,CACpB;QAAA;QAEA,SAAgBU,EAAelB,CAAA,EAAuBC,CAAA;UACpD,MAAMQ,CAAA,GAAOR,CAAA,CAAM6B,MAAA;UAkBnB,OAfA9B,CAAA,GAAe,QAARA,CAAA,GAAeC,CAAA,CAAMkD,GAAA,CAAI,CAACnD,CAAA,EAAGC,CAAA,KAAMA,CAAA,IAAM,GAAgBmY,MAAA,CAAOpY,CAAA,IAGvE,GAAAU,CAAA,CAAAsuB,MAAA,EACIhvB,CAAA,CAAKimB,KAAA,CAAMjmB,CAAA,IAAMA,CAAA,KAAOS,CAAA,IAAQT,CAAA,GAAKS,CAAA,GACrC,MAAM,+CAA+CA,CAAA,KAASA,CAAA,kBAC9CT,CAAA,MAGpB,GAAAU,CAAA,CAAAsuB,MAAA,EACIhvB,CAAA,CAAKimB,KAAA,CAAM3iB,CAAA,GACX,MACI,0DAAYtD,CAAA,KAGbA,CAAA,CAAKmD,GAAA,CAAInD,CAAA,IAAKA,CAAA,GAAI,IAAIS,CAAA,GAAOT,CAAA,GAAIA,CAAA,CAC1C;QAAA;QACA,SAAgBsD,EAAMtD,CAAA;UACpB,OAAOA,CAAA,GAAI,KAAM,CACnB;QAAA;QACA,SAAgB0D,EAAc1D,CAAA;UAC5B,IAAqB,MAAjBA,CAAA,CAAM8B,MAAA,EAER,OAAO;UAET,IAAI7B,CAAA,GAAOD,CAAA,CAAM;UACjB,KAAK,IAAIS,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAM8B,MAAA,EAAQrB,CAAA,IAChCR,CAAA,IAAQD,CAAA,CAAMS,CAAA;UAEhB,OAAOR,CACT;QAAA;QAQA,SAAgBwK,EAAoBzK,CAAA;UAClC,MAAMC,CAAA,GAAQ+B,IAAA,CAAKE,IAAA,CAAKF,IAAA,CAAK2a,IAAA,CAAK3c,CAAA;UAClC,OAAO,CAACC,CAAA,EAAO+B,IAAA,CAAKE,IAAA,CAAKlC,CAAA,GAAOC,CAAA,EAClC;QAAA;QA1MAA,CAAA,CAAAgvB,8BAAA;UACErsB,YAAmB5C,CAAA;YAAA,KAAAitB,cAAA,GAAAjtB,CAAyB;UAAA;UAC5CkvB,iBAAiBlvB,CAAA,EAA0BC,CAAA;YAEzC,IAAqB,MAAjBD,CAAA,CAAM8B,MAAA,EACR,OAAO,CAAC,GAAG;YAEb,MAAMrB,CAAA,GAAiB,KAAKwsB,cAAA;YAC5B,IAAIhtB,CAAA,SAA6B,MAApBA,CAAA,CAAMkvB,SAAA,EAAyB;cAE1C,MAAMzuB,CAAA,GAAQT,CAAA,CAAMkvB,SAAA,IAAanvB,CAAA,CAAM8B,MAAA,GAAS,IAAI9B,CAAA,CAAMkN,KAAA,CAAMjN,CAAA,CAAMkvB,SAAA,EAAW3J,MAAA,CAAO,CAACxlB,CAAA,EAAGC,CAAA,KAAMD,CAAA,GAAIC,CAAA;gBAChGgB,CAAA,GAAQhB,CAAA,CAAMkvB,SAAA,IAAa,IAAI,IAAInvB,CAAA,CAAMkN,KAAA,CAAM,GAAGjN,CAAA,CAAMkvB,SAAA,EAAW3J,MAAA,CAAO,CAACxlB,CAAA,EAAGC,CAAA,KAAMD,CAAA,GAAIC,CAAA;cAC9F,MAAIS,CAAA,GAAQD,CAAA,IAAkBQ,CAAA,GAAQR,CAAA,GAOpC,OAAO,CAACC,CAAA,EAAOO,CAAA;cAJfT,CAAA,CAAAwH,MAAA,CAAOE,OAAA,CACH,iBACA,2DAA2DlI,CAAA,eAAoBC,CAAA,CAAMkvB,SAAA,G;;YAK7F,MAAMzuB,CAAA,GAAYV,CAAA,CAAMwlB,MAAA,CAAO,CAACxlB,CAAA,EAAGC,CAAA,KAAMD,CAAA,GAAIC,CAAA;YAE7C,IAAIgB,CAAA,GAAQe,IAAA,CAAKoX,KAAA,CAAMpX,IAAA,CAAK2a,IAAA,CAAKjc,CAAA;YAEjC,OAAOO,CAAA,GAAQR,CAAA,IAAkBQ,CAAA,GAAQP,CAAA,IACnCA,CAAA,GAAYO,CAAA,IAAU,GADwBA,CAAA;YAMpD,IAAIA,CAAA,IAASR,CAAA,IAAkBC,CAAA,GAAYO,CAAA,IAAU,GACnD,MAAM,IAAIoD,KAAA,CAAM,2DAA2DrE,CAAA;YAE7E,OAAO,CAACiB,CAAA,EAAOP,CAAA,GAAYO,CAAA,CAC7B;UAAA;QAAA,GAGFhB,CAAA,CAAA+sB,qBAAA;UACEpqB,YAAmB5C,CAAA;YAAA,KAAAitB,cAAA,GAAAjtB,CAAyB;UAAA;UAC5CkvB,iBAAiBlvB,CAAA,EAA0BC,CAAA;YACzC,MAAMQ,CAAA,GAAK,KAAK2uB,cAAA,CAAepvB,CAAA,EAAOC,CAAA;YAKtC,OAJIA,CAAA,IAASA,CAAA,CAAMiJ,QAAA,KACjBzI,CAAA,CAAG,MAAM,GACTA,CAAA,CAAG,MAAM,IAEPR,CAAA,IAASA,CAAA,CAAM8U,SAAA,GACV,CAACtU,CAAA,CAAG,IAAIA,CAAA,CAAG,MAEbA,CACT;UAAA;UAEA2uB,eAAepvB,CAAA,EAA0BC,CAAA;YACvC,MAAMQ,CAAA,GAAWR,CAAA,IAASA,CAAA,CAAMiJ,QAAA;YAEhC,IAAqB,MAAjBlJ,CAAA,CAAM8B,MAAA,EACR,OAAOrB,CAAA,GAAW,CAAC,GAAG,KAAK,CAAC,GAAG;YAEjC,IAAIC,CAAA,GAAiB,KAAKusB,cAAA;YAC1B,IAAIhtB,CAAA,SAA6B,MAApBA,CAAA,CAAMkvB,SAAA,EAAyB;cAE1C,MAAM1uB,CAAA,GAAQR,CAAA,CAAMkvB,SAAA,IAAanvB,CAAA,CAAM8B,MAAA,GAAS,IAAI9B,CAAA,CAAMkN,KAAA,CAAMjN,CAAA,CAAMkvB,SAAA,EAAW3J,MAAA,CAAO,CAACxlB,CAAA,EAAGC,CAAA,KAAMD,CAAA,GAAIC,CAAA;gBAChGgB,CAAA,GAAQhB,CAAA,CAAMkvB,SAAA,IAAa,IAAI,IAAInvB,CAAA,CAAMkN,KAAA,CAAM,GAAGjN,CAAA,CAAMkvB,SAAA,EAAW3J,MAAA,CAAO,CAACxlB,CAAA,EAAGC,CAAA,KAAMD,CAAA,GAAIC,CAAA;cAC9F,MAAIQ,CAAA,GAAQC,CAAA,IAAkBO,CAAA,GAAQP,CAAA,GAOpC,OAAO,CAACD,CAAA,EAAOQ,CAAA;cAJfT,CAAA,CAAAwH,MAAA,CAAOE,OAAA,CACH,iBACA,2DAA2DlI,CAAA,eAAoBC,CAAA,CAAMkvB,SAAA,G;;YAK7F,IAAIjuB,CAAA,GAAWlB,CAAA,CAAMkN,KAAA,CAAM;YAoB3B,IAnBIzM,CAAA,KACFC,CAAA,IAAkC,GAOlCQ,CAAA,GAAWA,CAAA,CAASiC,GAAA,CAChB,CAACnD,CAAA,EAAGC,CAAA,KAAMA,CAAA,IAAKiB,CAAA,CAASY,MAAA,GAAS,IAAKZ,CAAA,CAASjB,CAAA,IAAK,KAAM,IAAIiB,CAAA,CAASjB,CAAA,IAAKiB,CAAA,CAASjB,CAAA,IAAK,IAAKiB,CAAA,CAASjB,CAAA,IAIpF,MAApBiB,CAAA,CAASY,MAAA,KACXZ,CAAA,GAAW,CAAC,GAAGA,CAAA,CAAS,OAKJ,MAApBA,CAAA,CAASY,MAAA,EAAc;cACzB,MAAM9B,CAAA,GAAgBiB,CAAA,CAAaC,CAAA;cACnCA,CAAA,GAAWlB,CAAA,CAAc0N,Q;;YAG3B,MAAMpK,CAAA,GAAOI,CAAA,CAAcxC,CAAA;YAC3B,OAAIA,CAAA,CAASY,MAAA,IAAU,KAAKwB,CAAA,IAAQ5C,CAAA,GAC3B,CAAC,GAAG4C,CAAA,IACkB,MAApBpC,CAAA,CAASY,MAAA,IAAgBZ,CAAA,CAAS,MAAMR,CAAA,IAAkBQ,CAAA,CAAS,MAAMR,CAAA,GAC3EQ,CAAA,GACsB,MAApBA,CAAA,CAASY,MAAA,IAAgBZ,CAAA,CAAS,KAAKA,CAAA,CAAS,MAAMR,CAAA,IAAkBQ,CAAA,CAAS,MAAMR,CAAA,GACzF,CAACQ,CAAA,CAAS,KAAKA,CAAA,CAAS,IAAIA,CAAA,CAAS,MACf,MAApBA,CAAA,CAASY,MAAA,IAAgBZ,CAAA,CAAS,MAAMR,CAAA,IAAkBQ,CAAA,CAAS,KAAKA,CAAA,CAAS,MAAMR,CAAA,GACzF,CAACQ,CAAA,CAAS,IAAIA,CAAA,CAAS,KAAKA,CAAA,CAAS,MAEtB,MAApBA,CAAA,CAASY,MAAA,IAAgBZ,CAAA,CAAS,KAAKA,CAAA,CAAS,KAAKA,CAAA,CAAS,MAAMR,CAAA,IACpEQ,CAAA,CAAS,MAAMR,CAAA,GACV,CAACQ,CAAA,CAAS,KAAKA,CAAA,CAAS,KAAKA,CAAA,CAAS,IAAIA,CAAA,CAAS,MAEpC,MAApBA,CAAA,CAASY,MAAA,IAAgBZ,CAAA,CAAS,MAAMR,CAAA,IACxCQ,CAAA,CAAS,KAAKA,CAAA,CAAS,KAAKA,CAAA,CAAS,MAAMR,CAAA,GACtC,CAACQ,CAAA,CAAS,IAAIA,CAAA,CAAS,KAAKA,CAAA,CAAS,KAAKA,CAAA,CAAS,MAEtDT,CAAA,GAMKgK,CAAA,CAAoBnH,CAAA,GAAO,GAAGH,GAAA,CAAInD,CAAA,IAAS,IAAJA,CAAA,IAEzCyK,CAAA,CAAoBnH,CAAA,CAE/B;UAAA;QAAA,GAGFrD,CAAA,CAAA2N,YAAA,GAAA3M,CAAA,EA2BAhB,CAAA,CAAAovB,cAAA,GAAAnuB,CAAA,EAqBAjB,CAAA,CAAAqvB,KAAA,GAAAhsB,CAAA,EAGArD,CAAA,CAAAsvB,aAAA,GAAA7rB,CAAA,EAWAzD,CAAA,CAAAuvB,WAAA,aAA4BxvB,CAAA;UAC1B,IAAqB,MAAjBA,CAAA,CAAM8B,MAAA,EACR,MAAMuC,KAAA,CAAM;UAGd,OAAO,CAACrE,CAAA,CAAM8B,MAAA,GAAS,IAAI9B,CAAA,CAAMA,CAAA,CAAM8B,MAAA,GAAS,KAAK,GAAG9B,CAAA,CAAMA,CAAA,CAAM8B,MAAA,GAAS,GAC/E;QAAA,GACA7B,CAAA,CAAAwvB,mBAAA,GAAAhlB,CAAA,EAIAxK,CAAA,CAAAyvB,WAAA,aAA4B1vB,CAAA,EAAiBC,CAAA,GAAa;UACxD,OAAOyD,CAAA,CAAc1D,CAAA,CAAMkN,KAAA,CAAM,GAAGlN,CAAA,CAAM8B,MAAA,GAAS7B,CAAA,EACrD;QAAA,C;;;;;;;;QCjOA,MAAAO,CAAA,GAAAC,CAAA;UAGAC,CAAA,GAAAD,CAAA;QAEaR,CAAA,CAAA2T,kCAAA,GACT,CAAC5T,CAAA,EAA8CS,CAAA,EAC9CD,CAAA;UACC,MAAMS,CAAA,GAAWT,CAAA,KAAgBE,CAAA,CAAA2T,WAAA,CAAYgB,QAAA,IAAY7U,CAAA,KAAgBE,CAAA,CAAA2T,WAAA,CAAY4P,gBAAA,GAAoB,IAAI;YACvG/iB,CAAA,GAAWV,CAAA,KAAgBE,CAAA,CAAA2T,WAAA,CAAYC,MAAA;YACvChR,CAAA,GAAa9C,CAAA,KAAgBE,CAAA,CAAA2T,WAAA,CAAY4P,gBAAA,IAAoBzjB,CAAA,KAAgBE,CAAA,CAAA2T,WAAA,CAAYC,MAAA;YACzF5Q,CAAA,GAAYlD,CAAA,KAAgBE,CAAA,CAAA2T,WAAA,CAAYK,mBAAA,GAAsBjU,CAAA,CAAMqB,MAAA,GAAS,SAAI;YACjF2I,CAAA,GAAgBjK,CAAA,KAAgBE,CAAA,CAAA2T,WAAA,CAAYK,mBAAA,GAC9CjU,CAAA,CAAM0C,GAAA,CAAI,CAACnD,CAAA,EAAGC,CAAA,KAAMA,CAAA,KAAMQ,CAAA,CAAMqB,MAAA,GAAS,IAAQ,IAAJ9B,CAAA,GAAQA,CAAA,SACrD;UACJ,QAAO,GAAAC,CAAA,CAAA6U,4BAAA,EACH9U,CAAA,EAAuBS,CAAA,EAAOQ,CAAA,EAASwJ,CAAA,EAAe;YAACvB,QAAA,EAAAhI,CAAA;YAAU6T,SAAA,EAAAzR,CAAA;YAAW6rB,SAAA,EAAAzrB;UAAA,EAAW;QAAA,GAGpFzD,CAAA,CAAAmT,8BAAA,GACT,CAACpT,CAAA,EAA8CS,CAAA,EAA0BD,CAAA;UAEnE,MAAME,CAAA,IAAS,GAAAT,CAAA,CAAA2T,kCAAA,EAAmC5T,CAAA,EAAuBS,CAAA,EAAOD,CAAA;UAChF,OAAO,CAACE,CAAA,CAAO4I,KAAA,EAAO5I,CAAA,CAAO6I,MAAA,CAAO;QAAA,GAMjCtJ,CAAA,CAAA6U,4BAAA,GACT,CAAC9U,CAAA,EAA8CC,CAAA,EAA0BQ,CAAA,GAAgB,GACxFC,CAAA,EAAmCO,CAAA;UAClC,MAAMC,CAAA,MAAcD,CAAA,KAASA,CAAA,CAAMiI,QAAA;YAAA,CAC5B5F,CAAA,EAAOI,CAAA,IAAU1D,CAAA,CAAsBkvB,gBAAA,CAAiBhuB,CAAA,IAAWR,CAAA,IAAyBT,CAAA,EAAOgB,CAAA;YACpGwJ,CAAA,GAAOxK,CAAA,CAAM6B,MAAA;UACnB,IAAIuJ,CAAA,GAAepL,CAAA,CAAMiN,KAAA,CAAM;UAI/B,IAHa,MAATzC,CAAA,KACFY,CAAA,GAAe,CAAC,KAED,MAAb5K,CAAA,EAEFC,CAAA,GAAgBT,CAAA,MACX,IAAIiB,CAAA,EAAU;YACnB,IAAiB,MAAbT,CAAA,EACF,MAAM,IAAI4D,KAAA,CAAM;YAElB3D,CAAA,GAAgBT,CAAA,EACZwK,CAAA,GAAO,MACTY,CAAA,CAAaZ,CAAA,GAAO,KAAKzI,IAAA,CAAKE,IAAA,CAAKmJ,CAAA,CAAaZ,CAAA,GAAO,KAAK,KAE1DA,CAAA,GAAO,MACTY,CAAA,CAAaZ,CAAA,GAAO,KAAKzI,IAAA,CAAKE,IAAA,CAAKmJ,CAAA,CAAaZ,CAAA,GAAO,KAAK,G;iBAEzD,KAAK/J,CAAA,EACV,MAAM,IAAI2D,KAAA,CAAM;UAElB,OAAO;YACLiF,KAAA,EAAAhG,CAAA;YACAiG,MAAA,EAAA7F,CAAA;YACA4R,QAAA,EAAA7U,CAAA;YACAyI,QAAA,EAAAhI,CAAA;YACA4M,KAAA,EAAOzC,CAAA;YACP0C,OAAA,EAASvN,CAAA,CAAA0L,SAAA,CAAUqJ,cAAA,CAAelK,CAAA;YAClChC,aAAA,EAAA3I,CAAA;YACAivB,UAAA,EAAa1uB,CAAA,IAASA,CAAA,CAAM8T;UAAA,CAC7B;QAAA,C;;;;;;;;QCjEP,MAAAvU,CAAA,GAAAC,CAAA;QAsBAR,CAAA,CAAAitB,cAAA;UAMEtqB,YACW5C,CAAA,EAAgCC,CAAA,EAA8CQ,CAAA,EAC7ED,CAAA;YADD,KAAAsH,SAAA,GAAA9H,CAAA,EAAgC,KAAAqT,cAAA,GAAApT,CAAA,EAA8C,KAAAuqB,QAAA,GAAA/pB,CAAA,EAC7E,KAAAmvB,MAAA,GAAApvB,CAAA,EAJK,KAAAqvB,WAAA,GAAuE,IAAIjsB,GAAA,IAKtFpD,CAAA,CAAO2sB,aAAA,KACT,KAAK2C,aAAA,GAAgB,IAAIlsB,GAAA,IACzB,KAAKmsB,YAAA,GAAe,IAAInsB,GAAA,IACxB,KAAKosB,aAAA,GAAgB,IAAIpsB,GAAA,GAE7B;UAAA;UACAsR,wBACIlV,CAAA,EAA2BC,CAAA,EAAuBQ,CAAA,EAA0BC,CAAA;YAC9E,MAAMO,CAAA,GAAkB,KAAKgvB,aAAA,CAAcjwB,CAAA;cAErCkB,CAAA,GAAU,KAAK4G,SAAA,CAAUooB,UAAA,CAAWjvB,CAAA,EAAiBhB,CAAA,CAAOqV,QAAA,IAAY,GAAG5U,CAAA;YACjF,IAAIT,CAAA,CAAOiJ,QAAA,IAAsB,MAAVxI,CAAA,EACrB,MAAM,IAAI2D,KAAA,CAAM;YAElB,MAAMf,CAAA,GAAQrD,CAAA,CAAOqJ,KAAA;cACf5F,CAAA,GAASzD,CAAA,CAAOsJ,MAAA;YAEtB,IAAIkB,CAAA,EACAY,CAAA;YACJ,IAAI,KAAKukB,MAAA,CAAOzC,aAAA,EAAe;cAC7B1iB,CAAA,GAAM,GAAGnH,CAAA,IAASI,CAAA,IAAUxC,CAAA,CAAQgtB,MAAA,IAAUhtB,CAAA,CAAQ8sB,cAAA,IAAkB9sB,CAAA,CAAQ4S,WAAA,IAChFzI,CAAA,GAAgB,KAAKykB,aAAA,CAActrB,GAAA,CAAIiG,CAAA,GAClCY,CAAA,KACHA,CAAA,GAAgB,IAChB,KAAKykB,aAAA,CAAc/rB,GAAA,CAAI0G,CAAA,EAAKY,CAAA;cAG9B,MAAMpL,CAAA,GAAe,KAAK8vB,YAAA,CAAavrB,GAAA,CAAIiG,CAAA;cAC3C,IAAIxK,CAAA,IAAgBA,CAAA,CAAa6B,MAAA,GAAS,GAAG;gBAC3C,MAAMtB,CAAA,GAAUP,CAAA,CAAakwB,GAAA;gBAK7B,OAJA9kB,CAAA,CAAcrE,IAAA,CAAKxG,CAAA,GACL,MAAVE,CAAA,IACF,KAAKoH,SAAA,CAAUsoB,aAAA,CAAc5vB,CAAA,EAAS8C,CAAA,EAAOI,CAAA,EAAQxC,CAAA,EAAS,KAAKmvB,aAAA,CAAcrwB,CAAA,EAAUS,CAAA,IAEtFD,C;;;YAIXA,CAAA,CAAAwH,MAAA,CAAOE,OAAA,CAAQ,kBAAkB,gCAAgCjI,CAAA,CAAOqJ,KAAA,IAASrJ,CAAA,CAAOsJ,MAAA;YACxF,MAAM+B,CAAA,GAAU,KAAKxD,SAAA,CAAUwoB,eAAA,CAAgBhtB,CAAA,EAAOI,CAAA,EAAQxC,CAAA,EAAS,KAAKmvB,aAAA,CAAcrwB,CAAA,EAAUS,CAAA;YAMpG,OAJI,KAAKmvB,MAAA,CAAOzC,aAAA,KACd9hB,CAAA,CAAerE,IAAA,CAAKsE,CAAA,GACpB,KAAK0kB,aAAA,CAAcjsB,GAAA,CAAIuH,CAAA,EAASb,CAAA,IAE3Ba,CACT;UAAA;UACAwK,YAAY9V,CAAA,EAAiBC,CAAA,EAA2BQ,CAAA;YAItD,OAHKA,CAAA,KACHA,CAAA,GAAW,IAEN,KAAK+pB,QAAA,CAASI,KAAA,CAAM,WAAW,8BAA8B;cAClE,MAAMpqB,CAAA,GAAWR,CAAA,CAAG8N,KAAA,CAAM0X,MAAA,CAAO,CAACxlB,CAAA,EAAGC,CAAA,KAAMD,CAAA,GAAIC,CAAA,IAAKQ,CAAA;gBAC9CC,CAAA,GAAO,KAAKoH,SAAA,CAAUgO,WAAA,CACxB9V,CAAA,CAAGwV,OAAA,EAASxV,CAAA,CAAGsJ,KAAA,EAAOtJ,CAAA,CAAGuJ,MAAA,EAAQ/I,CAAA,EAAU,KAAKyvB,aAAA,CAAchwB,CAAA,GAAWQ,CAAA;cAC7E,OAAO,KAAK8vB,YAAA,CAAatwB,CAAA,EAAUS,CAAA,CAAK;YAAA,EAE5C;UAAA;UACA,MAAAqV,iBAAuB/V,CAAA,EAAiBC,CAAA,EAA2BQ,CAAA;YACjE,MAAMD,CAAA,GAASR,CAAA,CAAGoU,MAAA,CAAOI,MAAA;YAIzB,IAHK/T,CAAA,KACHA,CAAA,GAAW,IAET,KAAKovB,WAAA,CAAY/gB,GAAA,CAAItO,CAAA,GAAS;cAChC,MAAMR,CAAA,GAAc,KAAK6vB,WAAA,CAAYrrB,GAAA,CAAIhE,CAAA;cACzC,OAAO,IAAI8B,OAAA,CAA2BrC,CAAA,IAAW,QAAAD,CAAA,QAAW,IAAXA,CAAA,CAAagH,IAAA,CAAK/G,CAAA,E;;YAErE,OAAO,KAAKuqB,QAAA,CAASI,KAAA,CAAM,WAAW,mCAAmC;cACvE,KAAKiF,WAAA,CAAY9rB,GAAA,CAAIvD,CAAA,EAAQ;cAC7B,MAAME,CAAA,GAAWV,CAAA,CAAG8N,KAAA,CAAM0X,MAAA,CAAO,CAACxlB,CAAA,EAAGC,CAAA,KAAMD,CAAA,GAAIC,CAAA,IAAKQ,CAAA;cAAA,MAE9C,KAAKqH,SAAA,CAAU0oB,qBAAA;cACrB,MAAMvvB,CAAA,GAAO,KAAK6G,SAAA,CAAUgO,WAAA,CACxB9V,CAAA,CAAGwV,OAAA,EAASxV,CAAA,CAAGsJ,KAAA,EAAOtJ,CAAA,CAAGuJ,MAAA,EAAQ7I,CAAA,EAAU,KAAKuvB,aAAA,CAAchwB,CAAA,GAAWQ,CAAA;gBACvES,CAAA,GAAa,KAAKqvB,YAAA,CAAatwB,CAAA,EAAUgB,CAAA;gBACzCqC,CAAA,GAAc,KAAKusB,WAAA,CAAYrrB,GAAA,CAAIhE,CAAA;cAGzC,OAFA,KAAKqvB,WAAA,CAAYvrB,MAAA,CAAO9D,CAAA,GACxB,QAAA8C,CAAA,IAAAA,CAAA,CAAauH,OAAA,CAAQ7K,CAAA,IAAWA,CAAA,CAAQkB,CAAA,IACjCA,CAAU;YAAA,EAErB;UAAA;UACAoV,wBAAwBtW,CAAA;YACtB,OAAO,KAAKwqB,QAAA,CAASI,KAAA,CAAM,WAAW,0CAA0C;cAC9E,MAAM3qB,CAAA,GAAWD,CAAA,CAAG8N,KAAA,CAAM0X,MAAA,CAAO,CAACxlB,CAAA,EAAGC,CAAA,KAAMD,CAAA,GAAIC,CAAA;gBACzCQ,CAAA,GAAO,KAAKqH,SAAA,CAAUgO,WAAA,CAAY9V,CAAA,CAAGwV,OAAA,EAASxV,CAAA,CAAGsJ,KAAA,EAAOtJ,CAAA,CAAGuJ,MAAA,EAAmB,IAAXtJ,CAAA,EAAc,QAAQ;cAC/F,OAAO,IAAI2U,YAAA,CAAanU,CAAA,CAAKmuB,MAAA,EAAQnuB,CAAA,CAAKouB,UAAA,EAAY5uB,CAAA,CAAS;YAAA,EAEnE;UAAA;UACAmW,eAAepW,CAAA,EAA0BC,CAAA;YACvC,IAAIQ,CAAA;YACJ,IAAI,KAAKmvB,MAAA,CAAOzC,aAAA,KACd1sB,CAAA,GAAM,KAAKuvB,aAAA,CAAcxrB,GAAA,CAAIxE,CAAA,CAAYwV,OAAA,GACrC/U,CAAA,GAAK;cACHR,CAAA,IACF,KAAK+vB,aAAA,CAAc1rB,MAAA,CAAO7D,CAAA;cAE5B,MAAMD,CAAA,GAAgB,KAAKsvB,aAAA,CAActrB,GAAA,CAAI/D,CAAA;cAC7C,IAAID,CAAA,EAAe;gBACjB,MAAMP,CAAA,GAAQO,CAAA,CAAc4L,OAAA,CAAQpM,CAAA,CAAYwV,OAAA;gBAChD,KAAe,MAAXvV,CAAA,EAAc;kBAChBO,CAAA,CAAciwB,MAAA,CAAOxwB,CAAA,EAAO;kBAC5B,IAAIS,CAAA,GAAe,KAAKqvB,YAAA,CAAavrB,GAAA,CAAI/D,CAAA;kBACpCC,CAAA,KACHA,CAAA,GAAe,IACf,KAAKqvB,YAAA,CAAahsB,GAAA,CAAItD,CAAA,EAAKC,CAAA,IAE7BA,CAAA,CAAasG,IAAA,CAAKhH,CAAA,CAAYwV,OAAA,C;;;;YAMjC/U,CAAA,KAAOR,CAAA,KACVO,CAAA,CAAAwH,MAAA,CAAOE,OAAA,CAAQ,kBAAkB,4BAA4BlI,CAAA,CAAYsJ,KAAA,IAAStJ,CAAA,CAAYuJ,MAAA,KAC9F,KAAKzB,SAAA,CAAU4oB,aAAA,CAAc1wB,CAAA,CAAYwV,OAAA,EAE7C;UAAA;UACA+a,aAAavwB,CAAA,EAA2BC,CAAA;YACtC,QAAQD,CAAA;cACN,KAAK;gBACH,OAAOC,CAAA,YAAgB0wB,UAAA,GAAa1wB,CAAA,GAAO0wB,UAAA,CAAWvR,IAAA,CAAKnf,CAAA;cAC7D,KAAK;gBACH,OAAOA,CAAA,YAAgB0mB,UAAA,GAAa1mB,CAAA,GAAO0mB,UAAA,CAAWvH,IAAA,CAAKnf,CAAA;cAC7D,KAAK;gBACH,OAAOA,CAAA,YAAgB2wB,SAAA,GAAY3wB,CAAA,GAAO2wB,SAAA,CAAUxR,IAAA,CAAKnf,CAAA;cAC3D,KAAK;gBACH,OAAOA,CAAA,YAAgB4wB,WAAA,GAAc5wB,CAAA,GAAO4wB,WAAA,CAAYzR,IAAA,CAAKnf,CAAA;cAC/D,KAAK;gBACH,OAAOA,CAAA,YAAgBuP,WAAA,GAAcvP,CAAA,GAAOuP,WAAA,CAAY4P,IAAA,CAAKnf,CAAA;cAC/D,KAAK;cACL,KAAK;gBACH,OAAOA,CAAA,YAAgBwP,UAAA,GAAaxP,CAAA,GAAOwP,UAAA,CAAW2P,IAAA,CAAKnf,CAAA;cAC7D,KAAK;gBACH,OAAOA,CAAA,YAAgB2U,YAAA,GAAe3U,CAAA,GAAO2U,YAAA,CAAawK,IAAA,CAAKnf,CAAA;cACjE,KAAK;gBACH,OAAOA,CAAA,YAAgB6wB,YAAA,GAAe7wB,CAAA,GAAO6wB,YAAA,CAAa1R,IAAA,CAAKnf,CAAA;cACjE;gBACE,MAAM,IAAIoE,KAAA,CAAM,mBAAmBrE,CAAA;YAAA;UAEzC;UACAqwB,cAAcrwB,CAAA,EAA2BC,CAAA;YACvC,IAAKA,CAAA,EAGL,OAAQA,CAAA,YAAgB2U,YAAA,GAAgB3U,CAAA,GAAO,IAAI2U,YAAA,CAAa3U,CAAA,CAmBlE;UAAA;UACAgwB,cAAcjwB,CAAA;YACZ,OAAO,OAgBT;UAAA;UACAmW,oBAAA;YACE,KAAKrO,SAAA,CAAUqO,mBAAA,EACjB;UAAA;QAAA,C;;;;;QCjLF,IAAY1V,CAAA;;;qCAAAA,CAAA,GAAAR,CAAA,CAAAoU,WAAA,KAAApU,CAAA,CAAAoU,WAAA,GAAW,KACrB5T,CAAA,CAAA4U,QAAA,oBACA5U,CAAA,CAAAA,CAAA,CAAAwjB,gBAAA,4BACAxjB,CAAA,CAAAA,CAAA,CAAA6T,MAAA,kBACA7T,CAAA,CAAAA,CAAA,CAAA2nB,oBAAA,gCACA3nB,CAAA,CAAAA,CAAA,CAAAiU,mBAAA,6B;;;;;;;;QC3CF,MAAAlU,CAAA,GAAAC,CAAA;QAOAR,CAAA,CAAA8wB,cAAA,aAA+B/wB,CAAA;UAC7B,MAAMC,CAAA,GAAMD,CAAA,CAAc8B,MAAA;UAC1B,OAAO9B,CAAA,CAAckN,KAAA,CAAM,GAAGjN,CAAA,GAAM,GAAGmY,MAAA,CAAOpY,CAAA,CAAcC,CAAA,GAAM,KAAK,EACzE;QAAA,GAEAA,CAAA,CAAA+wB,WAAA,GAAO,gBACHhxB,CAAA,EAAwBC,CAAA,GAAWD,CAAA,IAAqB,GAAGS,CAAA;UAC7D,OAAO,IAAI6B,OAAA,CAAc,CAAC9B,CAAA,EAASE,CAAA;YACjC,IAAIO,CAAA,GAAW;YAEf,MAAMC,CAAA,GAAQ+vB,CAAA;cACZ,IAAIjxB,CAAA,IAEF,YADAQ,CAAA;cAIFS,CAAA;cAEA,MAAMqC,CAAA,GAAcrD,CAAA,CAAQgB,CAAA;cAEV,QAAdR,CAAA,IAAsBQ,CAAA,IAAYR,CAAA,GACpCC,CAAA,KAGFwwB,UAAA,CAAWhwB,CAAA,EAAOoC,CAAA,CAAY;YAAA;YAGhCpC,CAAA,EAAO;UAAA,EAEX;QAAA,GAMAjB,CAAA,CAAA8K,0CAAA,aAA2D/K,CAAA;UAEzD,QADA,GAAAQ,CAAA,CAAAwuB,MAAA,OAA8B,MAAhBhvB,CAAA,IAAsD,MAAvBA,CAAA,CAAY8B,MAAA,EAAc,MAAM,wCACtE,QAAQ9B,CAAA,CAAYmxB,MAAA,CAAO,GAAGC,WAAA,KAAgBpxB,CAAA,CAAYkN,KAAA,CAAM,EACzE;QAAA,GAMAjN,CAAA,CAAAiL,qDAAA,aAAsElL,CAAA;UAEpE,QADA,GAAAQ,CAAA,CAAAwuB,MAAA,OAA8B,MAAhBhvB,CAAA,IAAsD,MAAvBA,CAAA,CAAY8B,MAAA,EAAc,MAAM,wCACtE,QAAQ9B,CAAA,CAAYmxB,MAAA,CAAO,GAAGC,WAAA,KAAgBpxB,CAAA,CAAYkN,KAAA,CAAM,KAAK,aAC9E;QAAA,GAGAjN,CAAA,CAAAkN,iBAAA,aAAkCnN,CAAA,EAA+BC,CAAA;UAE/D,IAAIQ,CAAA,GAA0B2M,IAAA,CAAKC,KAAA,CAAMD,IAAA,CAAKE,SAAA,CAAUtN,CAAA;UAExD,OADAS,CAAA,GAAgBR,CAAA,EACTQ,CACT;QAAA,GAGAR,CAAA,CAAAuN,iBAAA,aAAkCxN,CAAA,EAAkBC,CAAA;UAClD,OAAOA,CAAA,CAASkD,GAAA,CAAIlD,CAAA,IAAKD,CAAA,CAAOC,CAAA,GAAImD,IAAA,CAAK,KAC3C;QAAA,GAGAnD,CAAA,CAAA0L,iBAAA,aAAkC3L,CAAA;UAChC,IAAIA,CAAA,IAAQ,GACV,OAAO;UACF,IAAa,MAATA,CAAA,EACT,OAAO;UACF,IAAa,MAATA,CAAA,EACT,OAAO;UACF,IAAa,MAATA,CAAA,EACT,OAAO;UACF,IAAa,MAATA,CAAA,EACT,OAAO;UACF,IAAa,MAATA,CAAA,EACT,OAAO;UAEP,MAAMqE,KAAA,CAAM,gBAAgBrE,CAAA,wBAEhC;QAAA,GAEAC,CAAA,CAAA6L,aAAA,aAA8B9L,CAAA,GAAO;UACnC,OAAO,CAAC,KAAK,KAAK,KAAK,KAAK,KAAK,KAAKkN,KAAA,CAAM,GAAGlN,CAAA,CACjD;QAAA,C;;;;;;;;QC1FA,MAAAQ,CAAA,GAAAC,CAAA;UAEAC,CAAA,GAAAD,CAAA;UAEMQ,CAAA,GAA6C,CAAC;QAkDpD,SAAgBC,EAAsBlB,CAAA,EAA2BC,CAAA;UAU/D,IAAIQ,CAAA;UACJ,MAAMQ,CAAA,GAV4C;YAChDgiB,KAAA,GAAO;YACPoO,KAAA,GAAO;YACPC,SAAA,GAAW;YACXC,OAAA,GAAS;YACTC,qBAAA,GAAuB;YACvBC,kBAAA,GAAoB;YACpBC,4BAAA,GAA8B;UAAA;UAIhC,MAAKzxB,CAAA,IAA2B,aAAdA,CAAA,MAChBQ,CAAA,GAAKT,CAAA,CAAO2xB,UAAA,CAAW,UAAU1wB,CAAA,GAC7BR,CAAA,GACF;YACE,OAAO,IAAIC,CAAA,CAAAkxB,YAAA,CAAanxB,CAAA,EAAI,E;WAC5B,QAAOT,CAAA;YACPQ,CAAA,CAAAwH,MAAA,CAAOG,OAAA,CAAQ,oBAAoB,kEAAkEnI,CAAA,G;;UAI3G,MAAKC,CAAA,IAA2B,YAAdA,CAAA,MAChBQ,CAAA,GAAKT,CAAA,CAAO2xB,UAAA,CAAW,SAAS1wB,CAAA,KAAOjB,CAAA,CAAO2xB,UAAA,CAAW,sBAAsB1wB,CAAA,GAC3ER,CAAA,GACF;YACE,OAAO,IAAIC,CAAA,CAAAkxB,YAAA,CAAanxB,CAAA,EAAI,E;WAC5B,QAAOT,CAAA;YACPQ,CAAA,CAAAwH,MAAA,CAAOG,OAAA,CACH,oBACA,yFAAyFnI,CAAA,G;;UAKnG,MAAM,IAAIqE,KAAA,CAAM,yBAClB;QAAA;QA/EApE,CAAA,CAAA8H,kBAAA,YAAgB/H,EAAmBC,CAAA;UACjC,IAAIQ,CAAA;UAOJ,IANMR,CAAA,IAA2B,aAAdA,CAAA,MAA2B,YAAYgB,CAAA,IAE7ChB,CAAA,IAA2B,YAAdA,CAAA,MAA0B,WAAWgB,CAAA,MAC7DR,CAAA,GAAUQ,CAAA,CAAMqG,KAAA,IAFhB7G,CAAA,GAAUQ,CAAA,CAAM4wB,MAAA,GAKbpxB,CAAA,EACH;YAGEA,CAAA,GAAUS,CAAA,CAkFhB;cACE,IAA+B,sBAApB4wB,eAAA,EACT,MAAM,IAAI/P,SAAA,CAAU;cAEtB,OAAO,IAAI+P,eAAA,CAAgB,GAAG,EAChC;YAAA,CAxF8B,IACyB7xB,CAAA,C;WACjD,QAAOD,CAAA;YAGPS,CAAA,GAAUS,CAAA,CAoEhB;cACE,IAAwB,sBAAb6wB,QAAA,EACT,MAAM,IAAIhQ,SAAA,CAAU;cAEtB,MAAM/hB,CAAA,GAA4B+xB,QAAA,CAASC,aAAA,CAAc;cAGzD,OAFAhyB,CAAA,CAAOsJ,KAAA,GAAQ,GACftJ,CAAA,CAAOuJ,MAAA,GAAS,GACTvJ,CACT;YAAA,CA7EqB,IACyBC,CAAA,C;;UAI5CA,CAAA,GAAYA,CAAA,IAAiC,MAApBQ,CAAA,CAAQkC,OAAA,GAAgB,UAAU;UAC3D,MAAMnC,CAAA,GAAKC,CAAA,CAAQoqB,EAAA;UAInB,OAFA5pB,CAAA,CAAMhB,CAAA,IAAaQ,CAAA,EAEfD,CAAA,CAAGyxB,aAAA,aACEhxB,CAAA,CAAMhB,CAAA,GACND,CAAA,CAAmBC,CAAA,MAG5BO,CAAA,CAAG0xB,OAAA,CAAQ1xB,CAAA,CAAG2xB,UAAA,GACd3xB,CAAA,CAAG0xB,OAAA,CAAQ1xB,CAAA,CAAG4xB,YAAA,GACd5xB,CAAA,CAAG0xB,OAAA,CAAQ1xB,CAAA,CAAG6xB,KAAA,GACd7xB,CAAA,CAAG0xB,OAAA,CAAQ1xB,CAAA,CAAG8xB,MAAA,GACd9xB,CAAA,CAAG0xB,OAAA,CAAQ1xB,CAAA,CAAG+xB,mBAAA,GACd/xB,CAAA,CAAG0xB,OAAA,CAAQ1xB,CAAA,CAAGgyB,eAAA,GACdhyB,CAAA,CAAGiyB,MAAA,CAAOjyB,CAAA,CAAGkyB,YAAA,GACblyB,CAAA,CAAGiyB,MAAA,CAAOjyB,CAAA,CAAGmyB,SAAA,GACbnyB,CAAA,CAAGoyB,QAAA,CAASpyB,CAAA,CAAGqyB,IAAA,GAERpyB,CAAA,CACT;QAAA,GAEAR,CAAA,CAAA6yB,qBAAA,GAAA5xB,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QCtDA,MAAAA,CAAA,GAAAT,CAAA;UAEA6C,CAAA,GAAArC,CAAA,CAAAR,CAAA;UAEAiD,CAAA,GAAAjD,CAAA;QAWA,SAAgBgK,EAAqBzK,CAAA;UACnC,IAAIC,CAAA,GAAI;UACR,OAAOA,CAAA,GAAID,CAAA,CAAI8B,MAAA,IACE9B,CAAA,CAAIC,CAAA,OADIA,CAAA;UAMzB,OAAOA,CAAA,GAAI,CACb;QAAA;QATAA,CAAA,CAAA8yB,oBAAA,GAAAtoB,CAAA,EAcAxK,CAAA,CAAA2xB,YAAA;UAwCEhvB,YAAY5C,CAAA,EAA2BC,CAAA;YAF/B,KAAA+yB,gBAAA,IAAmB,GAogBnB,KAAAC,WAAA,GAA0B,IAjgBhC,KAAKpI,EAAA,GAAK7qB,CAAA,EACV,KAAK2C,OAAA,GAAU1C,CAAA,EAEf,KAAKizB,aAAA,IACL,KAAKC,YAAA,GAAe,KAAKC,kBAAA,IACzB,KAAKC,WAAA,GAAc,KAAKC,iBAAA,IACxB,KAAKC,oBAAA,EACP;UAAA;UAEAjD,gBAAgBtwB,CAAA,EAAeC,CAAA,EAAgBQ,CAAA,EAAsBD,CAAA;YACnE,MAAME,CAAA,GAAK,KAAKmqB,EAAA;cAEV5pB,CAAA,GAAUP,CAAA,CAAG8yB,aAAA;YAEnB9yB,CAAA,CAAG8rB,WAAA,CAAY9rB,CAAA,CAAG+yB,UAAA,EAAYxyB,CAAA,GAC9BP,CAAA,CAAGgzB,aAAA,CAAchzB,CAAA,CAAG+yB,UAAA,EAAY/yB,CAAA,CAAGizB,kBAAA,EAAoBjzB,CAAA,CAAGkzB,OAAA,GAC1DlzB,CAAA,CAAGgzB,aAAA,CAAchzB,CAAA,CAAG+yB,UAAA,EAAY/yB,CAAA,CAAGmzB,kBAAA,EAAoBnzB,CAAA,CAAGkzB,OAAA,GAC1DlzB,CAAA,CAAGgzB,aAAA,CAAchzB,CAAA,CAAG+yB,UAAA,EAAY/yB,CAAA,CAAGozB,cAAA,EAAgBpzB,CAAA,CAAGqzB,aAAA,GACtDrzB,CAAA,CAAGgzB,aAAA,CAAchzB,CAAA,CAAG+yB,UAAA,EAAY/yB,CAAA,CAAGszB,cAAA,EAAgBtzB,CAAA,CAAGqzB,aAAA;YACtD,MAAM7yB,CAAA,GAASV,CAAA,GAAOC,CAAA,CAAQyO,MAAA,CAAO1O,CAAA,EAAMR,CAAA,GAAQC,CAAA,IAAU;YAQ7D,OAPAS,CAAA,CAAGuzB,UAAA,CACCvzB,CAAA,CAAG+yB,UAAA,EACH,GACAhzB,CAAA,CAAQutB,cAAA,EAAgBhuB,CAAA,EAAOC,CAAA,EAC/B,GACAQ,CAAA,CAAQytB,MAAA,EAAQztB,CAAA,CAAQqT,WAAA,EAAa5S,CAAA,GACzC,KAAKgzB,UAAA,IACEjzB,CACT;UAAA;UACAmvB,cACIpwB,CAAA,EAAuBC,CAAA,EAAeQ,CAAA,EAAgBD,CAAA,EAAsBE,CAAA;YAC9E,MAAMO,CAAA,GAAK,KAAK4pB,EAAA;YAChB5pB,CAAA,CAAGurB,WAAA,CAAYvrB,CAAA,CAAGwyB,UAAA,EAAYzzB,CAAA;YAC9B,MAAMkB,CAAA,GAASV,CAAA,CAAQ0O,MAAA,CAAOxO,CAAA,EAAMT,CAAA,GAAQQ,CAAA;YAC5CQ,CAAA,CAAGkzB,aAAA,CACClzB,CAAA,CAAGwyB,UAAA,EACH,GACA,GACA,GACAxzB,CAAA,EAAOQ,CAAA,EAAQD,CAAA,CAAQ0tB,MAAA,EAAQ1tB,CAAA,CAAQsT,WAAA,EAAa5S,CAAA,GACxD,KAAKgzB,UAAA,EACP;UAAA;UACAhI,kBAAkBlsB,CAAA,EAAuBC,CAAA,EAAeQ,CAAA;YACtD,MAAMD,CAAA,GAAK,KAAKqqB,EAAA;YAEhBrqB,CAAA,CAAGgsB,WAAA,CAAYhsB,CAAA,CAAGizB,UAAA,EAAYzzB,CAAA,GAC9BQ,CAAA,CAAG4zB,eAAA,CAAgB5zB,CAAA,CAAG6zB,WAAA,EAAa,KAAKhB,WAAA,GACxC7yB,CAAA,CAAG8zB,oBAAA,CACC9zB,CAAA,CAAG6zB,WAAA,EAAa7zB,CAAA,CAAG+zB,iBAAA,EAAmB/zB,CAAA,CAAGizB,UAAA,EAAYzzB,CAAA,EACrD,IACJ,KAAKk0B,UAAA,IACL1zB,CAAA,CAAGg0B,QAAA,CAAS,GAAG,GAAGv0B,CAAA,EAAOQ,CAAA,GACzBD,CAAA,CAAGi0B,OAAA,CAAQ,GAAG,GAAGx0B,CAAA,EAAOQ,CAAA,CAC1B;UAAA;UACAqV,YACI9V,CAAA,EAAuBC,CAAA,EAAeQ,CAAA,EAAgBD,CAAA,EAAkBE,CAAA,EACxEO,CAAA;YACF,MAAMC,CAAA,GAAK,KAAK2pB,EAAA;YACX5pB,CAAA,KACHA,CAAA,GAAW,IAER,KAAK+xB,gBAAA,IACR,KAAK9G,iBAAA,CAAkBlsB,CAAA,EAASC,CAAA,EAAOQ,CAAA;YAEzC,MAAM6C,CAAA,GAAU,KAAK4sB,UAAA,CAAWxvB,CAAA,EAAUO,CAAA;cACpCyC,CAAA,GAASJ,CAAA,CAAQirB,QAAA,CAAStuB,CAAA,GAAQQ,CAAA;YAUxC,OARAS,CAAA,CAAGsrB,WAAA,CAAYtrB,CAAA,CAAGuyB,UAAA,EAAYzzB,CAAA,GAC9BkB,CAAA,CAAGozB,oBAAA,CACCpzB,CAAA,CAAGmzB,WAAA,EAAanzB,CAAA,CAAGqzB,iBAAA,EAAmBrzB,CAAA,CAAGuyB,UAAA,EAAYzzB,CAAA,EACrD,IAEJkB,CAAA,CAAGwzB,UAAA,CAAW,GAAG,GAAGz0B,CAAA,EAAOQ,CAAA,EAAQS,CAAA,CAAGotB,IAAA,EAAMhrB,CAAA,CAAQwQ,WAAA,EAAapQ,CAAA,GACjE,KAAKwwB,UAAA,IAEE5wB,CAAA,CAAQ6L,MAAA,CAAOzL,CAAA,EAAQlD,CAAA,CAChC;UAAA;UAEAm0B,mBAAA;YAEE,QAAO,CACT;UAAA;UACAC,iBAAA;YACE,MAAM50B,CAAA,GAAK,KAAK6qB,EAAA;YAEhB,OAAO,aADG7qB,CAAA,CAAG60B,YAAA,CAAa,KAAKhK,EAAA,CAAGiK,cAAA,IACZ90B,CAAA,CAAG+0B,QAAA,CAC3B;UAAA;UACAC,kBAAA;YACE,OAAO,KAAKnK,EAAA,CAAGgK,YAAA,CAAa,KAAKhK,EAAA,CAAGoK,kBAAA,CACtC;UAAA;UACAC,sBAAA;YACE,OAAO,KAAKrK,EAAA,CAAGgK,YAAA,CAAa,KAAKhK,EAAA,CAAGsK,mBAAA,CACtC;UAAA;UACA9I,oBAAoBrsB,CAAA,EAAwBC,CAAA;YAC1C,MAAMQ,CAAA,GAAK,KAAKoqB,EAAA;YAChBpqB,CAAA,CAAG20B,mBAAA,CAAoBp1B,CAAA,EAAgB,GAAGS,CAAA,CAAGyE,KAAA,GAAO,GAAO,IAAI,IAC/DzE,CAAA,CAAG40B,uBAAA,CAAwBr1B,CAAA,IACC,MAAxBC,CAAA,KACFQ,CAAA,CAAG20B,mBAAA,CAAoBn1B,CAAA,EAAoB,GAAGQ,CAAA,CAAGyE,KAAA,GAAO,GAAO,IAAI,KACnEzE,CAAA,CAAG40B,uBAAA,CAAwBp1B,CAAA,IAE7B,KAAKi0B,UAAA,EACP;UAAA;UACAjI,cACIjsB,CAAA,EACAC,CAAA;YAEF,MAAMQ,CAAA,GAAK,KAAKoqB,EAAA;cACVrqB,CAAA,GAAUC,CAAA,CAAGwrB,aAAA;YAMnB,OAHAxrB,CAAA,CAAG60B,YAAA,CAAa90B,CAAA,EAASR,CAAA,GACzBS,CAAA,CAAG60B,YAAA,CAAa90B,CAAA,EAASP,CAAA,GACzBQ,CAAA,CAAG80B,WAAA,CAAY/0B,CAAA,GACRA,CACT;UAAA;UACAqrB,cAAc7rB,CAAA,EAAsBC,CAAA;YAClC,MAAMQ,CAAA,GAAK,KAAKoqB,EAAA;cACVrqB,CAAA,GAASC,CAAA,CAAG+0B,YAAA,CAAav1B,CAAA;YAC/B,KAAKO,CAAA,EACH,MAAM,IAAI6D,KAAA,CAAM,0CAA0CpE,CAAA;YAK5D,IAFAQ,CAAA,CAAGoQ,YAAA,CAAarQ,CAAA,EAAQR,CAAA,GACxBS,CAAA,CAAGorB,aAAA,CAAcrrB,CAAA,IACwC,MAArDC,CAAA,CAAGg1B,kBAAA,CAAmBj1B,CAAA,EAAQC,CAAA,CAAGi1B,cAAA,GACnC,MAAM,IAAIrxB,KAAA,CAAM,6BAA6B5D,CAAA,CAAGk1B,gBAAA,CAAiBn1B,CAAA,sBAErER,CAAA;YAEE,OAAOQ,CACT;UAAA;UACAgrB,aAAaxrB,CAAA;YACX,KAAK6qB,EAAA,CAAGW,YAAA,CAAaxrB,CAAA,CACvB;UAAA;UACA6sB,qBAAqB7sB,CAAA,EAAuBC,CAAA,EAAkBQ,CAAA;YAC5D,MAAMD,CAAA,GAAK,KAAKqqB,EAAA;YAChBrqB,CAAA,CAAGo1B,aAAA,CAAcp1B,CAAA,CAAGu0B,QAAA,GAAW90B,CAAA,GAC/B,KAAKi0B,UAAA,IACL1zB,CAAA,CAAGgsB,WAAA,CAAYhsB,CAAA,CAAGizB,UAAA,EAAYzzB,CAAA,GAC9B,KAAKk0B,UAAA,IACL1zB,CAAA,CAAGosB,SAAA,CAAUnsB,CAAA,EAAeR,CAAA,GAC5B,KAAKi0B,UAAA,EACP;UAAA;UACA5I,KAAA;YACE,KAAKT,EAAA,CAAGgL,UAAA,CAAW,KAAKhL,EAAA,CAAGiL,cAAA,EAAgB,GAAG,IAC9C,KAAK5B,UAAA,EACP;UAAA;UACAA,WAAA;YACE,IAAIhzB,CAAA,CAAAE,GAAA,CAAI2qB,KAAA,EAAO;cACb,MAAM/rB,CAAA,GAAK,KAAK6qB,EAAA;gBACV5qB,CAAA,GAAQD,CAAA,CAAG+1B,QAAA;cACjB,IAAIt1B,CAAA,GAAQ;cACZ,QAAQR,CAAA;gBACN,KAAMD,CAAA,CAAWg2B,QAAA;kBACf;gBACF,KAAMh2B,CAAA,CAAei2B,YAAA;kBACnBx1B,CAAA,GAAQ;kBACR;gBACF,KAAMT,CAAA,CAAgBk2B,aAAA;kBACpBz1B,CAAA,GAAQ;kBACR;gBACF,KAAMT,CAAA,CAAoBm2B,iBAAA;kBACxB11B,CAAA,GAAQ;kBACR;gBACF,KAAMT,CAAA,CAAgCo2B,6BAAA;kBACpC31B,CAAA,GAAQ;kBACR;gBACF,KAAMT,CAAA,CAAgBq2B,aAAA;kBACpB51B,CAAA,GAAQ;kBACR;gBACF,KAAMT,CAAA,CAAqBs2B,kBAAA;kBACzB71B,CAAA,GAAQ;kBACR;gBACF;kBACEA,CAAA,GAAQ,wBAAwBR,CAAA,CAAMs2B,QAAA,CAAS;cAAA;cAEnD,MAAM,IAAIlyB,KAAA,CAAM5D,CAAA,C;;UAEpB;UACAiwB,cAAc1wB,CAAA;YACZ,KAAK6qB,EAAA,CAAG6F,aAAA,CAAc1wB,CAAA,CACxB;UAAA;UACAyrB,cAAczrB,CAAA;YACZ,KAAK6qB,EAAA,CAAGY,aAAA,CAAczrB,CAAA,CACxB;UAAA;UACAkwB,WAAWlwB,CAAA,EAA4BC,CAAA,EAAkBQ,CAAA;YACvD,IAAqB,MAAjB,KAAKkC,OAAA,EACP,OAAO,IAAIW,CAAA,CAAayqB,qBAAA,CAAsB,KAAKlD,EAAA,EAA8B5qB,CAAA;YAGnF,QAAQD,CAAA;cACN,KAAK;gBACH,OAAc,MAAVS,CAAA,IAAsC,KAAK+1B,wBAAA,GACtC,IAAIlzB,CAAA,CAAakrB,oBAAA,CAAqB,KAAK3D,EAAA,EAAI5qB,CAAA,IAE/C,IAAIqD,CAAA,CAAakrB,oBAAA,CACpB,KAAK3D,EAAA,EAAI5qB,CAAA,EAAU,KAAKw2B,yBAAA,CAA2BC,cAAA;cAE3D,KAAK;gBACH,MAAM,IAAIryB,KAAA,CAAM;cAClB,KAAK;gBACH,OAAO,IAAIf,CAAA,CAAamrB,gBAAA,CAAiB,KAAK5D,EAAA,EAAI5qB,CAAA;cACpD;gBACE,MAAM,IAAIoE,KAAA,CAAM,qBAAqBrE,CAAA;YAAA;UAE3C;UACAmW,oBAAA;YACE,MAAMnW,CAAA,GAAK,KAAK6qB,EAAA;YAChB,KAAK,IAAI5qB,CAAA,GAAO,GAAGA,CAAA,GAAO,KAAK02B,oBAAA,IAAwB12B,CAAA,EACrDD,CAAA,CAAG41B,aAAA,CAAc51B,CAAA,CAAG+0B,QAAA,GAAW90B,CAAA,GAC/BD,CAAA,CAAGwsB,WAAA,CAAYxsB,CAAA,CAAGyzB,UAAA,EAAY,KAElC;UAAA;UACApsB,QAAA;YACE,IAAI,KAAKuvB,QAAA,EACP;YAEF,MAAM52B,CAAA,GAAK,KAAK6qB,EAAA;YAChB7qB,CAAA,CAAGo0B,eAAA,CAAgBp0B,CAAA,CAAGq0B,WAAA,EAAa,OACnCr0B,CAAA,CAAG62B,iBAAA,CAAkB,KAAKxD,WAAA,GAC1BrzB,CAAA,CAAG82B,UAAA,CAAW92B,CAAA,CAAG+2B,YAAA,EAAc,OAC/B/2B,CAAA,CAAGg3B,YAAA,CAAa,KAAK7D,YAAA,GACrBnzB,CAAA,CAAG82B,UAAA,CAAW92B,CAAA,CAAGi3B,oBAAA,EAAsB,OACvCj3B,CAAA,CAAGk3B,MAAA,IACH,KAAKN,QAAA,IAAW,CAClB;UAAA;UAEQO,sBAAA;YAEN,OAAO,IAAIviB,YAAA,CAAa,EACrB,GAAK,GAAM,GAAK,GAAK,IACrB,IAAM,GAAK,GAAK,GAAK,GACtB,GAAM,GAAM,GAAK,GAAK,GACtB,IAAO,GAAK,GAAK,GAAK,GAE1B;UAAA;UACQwe,mBAAA;YACN,MAAMpzB,CAAA,GAAK,KAAK6qB,EAAA;cACV5qB,CAAA,GAASD,CAAA,CAAGo3B,YAAA;YAClB,KAAKn3B,CAAA,EACH,MAAM,IAAIoE,KAAA,CAAM;YAElB,MAAM5D,CAAA,GAAW,KAAK02B,qBAAA;YAItB,OAHAn3B,CAAA,CAAG82B,UAAA,CAAW92B,CAAA,CAAG+2B,YAAA,EAAc92B,CAAA,GAC/BD,CAAA,CAAGq3B,UAAA,CAAWr3B,CAAA,CAAG+2B,YAAA,EAAct2B,CAAA,EAAUT,CAAA,CAAGs3B,WAAA,GAC5C,KAAKpD,UAAA,IACEj0B,CACT;UAAA;UACQqzB,kBAAA;YACN,MAAMtzB,CAAA,GAAK,KAAK6qB,EAAA,CAAGyI,iBAAA;YACnB,KAAKtzB,CAAA,EACH,MAAM,IAAIqE,KAAA,CAAM;YAElB,OAAOrE,CACT;UAAA;UAEQuzB,qBAAA;YACN,MAAMvzB,CAAA,GAAK,KAAK6qB,EAAA;YAMhB,IAJA,KAAK0M,qCAAA,GAAwC,KAAKC,wCAAA,IAClD,KAAKhB,wBAAA,GAA2B,KAAKiB,kBAAA,IACrC,KAAKphB,0BAAA,GAA6B,KAAKqhB,oBAAA,IAElB,MAAjB,KAAK/0B,OAAA,KAAkB,KAAK8zB,yBAAA,KAA8B,KAAKD,wBAAA,EACjE,MAAM,IAAInyB,KAAA,CAAM;YAGlB,KAAKszB,gBAAA,IAAoB,KAAKnB,wBAAA,IAA4B,KAAKoB,iBAAA,IAG/D,KAAK3K,cAAA,GAAiBjtB,CAAA,CAAG60B,YAAA,CAAa70B,CAAA,CAAG63B,gBAAA,GACzC,KAAKlB,oBAAA,GAAuB32B,CAAA,CAAG60B,YAAA,CAAa70B,CAAA,CAAG83B,uBAAA,GAM3C,KAAKn1B,OAMX;UAAA;UACQuwB,cAAA;YACe,MAAjB,KAAKvwB,OAAA,IACP,KAAKo1B,yBAAA,GAA4B,KAAKlN,EAAA,CAAGmN,YAAA,CAAa,2BACtD,KAAKC,iCAAA,GAAoC,KAAKpN,EAAA,CAAGmN,YAAA,CAAa,uCAE9D,KAAKE,qBAAA,GAAwB,KAAKrN,EAAA,CAAGmN,YAAA,CAAa,sBAClD,KAAKvB,yBAAA,GAA4B,KAAK5L,EAAA,CAAGmN,YAAA,CAAa,0BAE1D;UAAA;UAEQR,yCAAA;YAGN,MAAMx3B,CAAA,GAAK,KAAK6qB,EAAA;cACV5qB,CAAA,GAAUD,CAAA,CAAGwzB,aAAA;YACnBxzB,CAAA,CAAGwsB,WAAA,CAAYxsB,CAAA,CAAGyzB,UAAA,EAAYxzB,CAAA;YAE9B,MAAMQ,CAAA,GAAkC,MAAjB,KAAKkC,OAAA,GAAiB3C,CAAA,CAAoCquB,OAAA,GAAUruB,CAAA,CAAGsuB,IAAA;YAC9FtuB,CAAA,CAAGi0B,UAAA,CAAWj0B,CAAA,CAAGyzB,UAAA,EAAY,GAAGhzB,CAAA,EAAgB,GAAG,GAAG,GAAGT,CAAA,CAAGsuB,IAAA,EAAMtuB,CAAA,CAAGkF,KAAA,EAAO;YAE5E,MAAM1E,CAAA,GAAcR,CAAA,CAAGszB,iBAAA;YACvBtzB,CAAA,CAAGo0B,eAAA,CAAgBp0B,CAAA,CAAGq0B,WAAA,EAAa7zB,CAAA,GAEnCR,CAAA,CAAGs0B,oBAAA,CAAqBt0B,CAAA,CAAGq0B,WAAA,EAAar0B,CAAA,CAAGu0B,iBAAA,EAAmBv0B,CAAA,CAAGyzB,UAAA,EAAYxzB,CAAA,EAAS;YAEtF,MAAMS,CAAA,GAAaV,CAAA,CAAGm4B,sBAAA,CAAuBn4B,CAAA,CAAGq0B,WAAA,MAAiBr0B,CAAA,CAAGo4B,oBAAA;YAKpE,OAJAp4B,CAAA,CAAGwsB,WAAA,CAAYxsB,CAAA,CAAGyzB,UAAA,EAAY,OAC9BzzB,CAAA,CAAGo0B,eAAA,CAAgBp0B,CAAA,CAAGq0B,WAAA,EAAa,OACnCr0B,CAAA,CAAG0wB,aAAA,CAAczwB,CAAA,GACjBD,CAAA,CAAG62B,iBAAA,CAAkBr2B,CAAA,GACdE,CACT;UAAA;UAEQ+2B,mBAAA;YACN,IAAqB,MAAjB,KAAK90B,OAAA;cACP,KAAK,KAAKo1B,yBAAA,EACR,QAAO;YAAA,OAGT,KAAK,KAAKG,qBAAA,EACR,QAAO;YAGX,OAAO,KAAKX,qCACd;UAAA;UAEQG,qBAAA;YACN,IAAqB,MAAjB,KAAK/0B,OAAA;cACP,KAAK,KAAKo1B,yBAAA,EACR,QAAO;YAAA,OAEJ;cACL,KAAK,KAAKG,qBAAA,EACR,QAAO;cAET,KAAK,KAAKrN,EAAA,CAAGmN,YAAA,CAAa,6BACxB,QAAO,C;;YAGX,OAAO,KAAKT,qCACd;UAAA;UAKQK,kBAAA;YAIN,MAAM53B,CAAA,GAAK,KAAK6qB,EAAA;YAEhB,IAAI5qB,CAAA,EACAQ,CAAA,EACAD,CAAA,EACAE,CAAA,EACAO,CAAA;YAEJ;cACEhB,CAAA,GAAUD,CAAA,CAAGwzB,aAAA,IACb/yB,CAAA,GAAcT,CAAA,CAAGszB,iBAAA,IACjBtzB,CAAA,CAAGwsB,WAAA,CAAYxsB,CAAA,CAAGyzB,UAAA,EAAYxzB,CAAA;cAG9B,MAAMiB,CAAA,GAAkC,MAAjB,KAAKyB,OAAA,GAAiB3C,CAAA,CAAoCquB,OAAA,GAAUruB,CAAA,CAAGsuB,IAAA;cAS9F,OARAtuB,CAAA,CAAGi0B,UAAA,CAAWj0B,CAAA,CAAGyzB,UAAA,EAAY,GAAGvyB,CAAA,EAAgB,GAAG,GAAG,GAAGlB,CAAA,CAAGsuB,IAAA,EAAMtuB,CAAA,CAAGkF,KAAA,EAAO,OAE5ElF,CAAA,CAAGo0B,eAAA,CAAgBp0B,CAAA,CAAGq0B,WAAA,EAAa5zB,CAAA,GACnCT,CAAA,CAAGs0B,oBAAA,CAAqBt0B,CAAA,CAAGq0B,WAAA,EAAar0B,CAAA,CAAGu0B,iBAAA,EAAmBv0B,CAAA,CAAGyzB,UAAA,EAAYxzB,CAAA,EAAS,IAEtFD,CAAA,CAAGyyB,MAAA,CAAOzyB,CAAA,CAAGqyB,KAAA,GAEb7xB,CAAA,GAAeR,CAAA,CAAGw1B,YAAA,CAAax1B,CAAA,CAAG8rB,aAAA,KAC7BtrB,CAAA,KAGLR,CAAA,CAAG6Q,YAAA,CAAarQ,CAAA,EAAc,kBAC9BR,CAAA,CAAG6rB,aAAA,CAAcrrB,CAAA,GAEjBE,CAAA,GAAiBV,CAAA,CAAGw1B,YAAA,CAAax1B,CAAA,CAAGgsB,eAAA,KAC/BtrB,CAAA,KAGLV,CAAA,CAAG6Q,YAAA,CAAanQ,CAAA,EAAgB,+DAChCV,CAAA,CAAG6rB,aAAA,CAAcnrB,CAAA,GAEjBO,CAAA,GAAUjB,CAAA,CAAGisB,aAAA,MACRhrB,CAAA,KAGLjB,CAAA,CAAGs1B,YAAA,CAAar0B,CAAA,EAAST,CAAA,GACzBR,CAAA,CAAGs1B,YAAA,CAAar0B,CAAA,EAASP,CAAA,GACzBV,CAAA,CAAGu1B,WAAA,CAAYt0B,CAAA,GACfjB,CAAA,CAAG+qB,UAAA,CAAW9pB,CAAA,GAEdjB,CAAA,CAAG61B,UAAA,CAAW71B,CAAA,CAAGq4B,MAAA,EAAQ,GAAG,IACrBr4B,CAAA,CAAG+1B,QAAA,OAAe/1B,CAAA,CAAGg2B,QAAA,G;;cAG5Bh2B,CAAA,CAAGkyB,OAAA,CAAQlyB,CAAA,CAAGqyB,KAAA,GAEVpxB,CAAA,IACFjB,CAAA,CAAGyrB,aAAA,CAAcxqB,CAAA,GAEfT,CAAA,IACFR,CAAA,CAAGwrB,YAAA,CAAahrB,CAAA,GAEdE,CAAA,IACFV,CAAA,CAAGwrB,YAAA,CAAa9qB,CAAA,GAEdD,CAAA,KACFT,CAAA,CAAGo0B,eAAA,CAAgBp0B,CAAA,CAAGq0B,WAAA,EAAa,OACnCr0B,CAAA,CAAG62B,iBAAA,CAAkBp2B,CAAA,IAEnBR,CAAA,KACFD,CAAA,CAAGwsB,WAAA,CAAYxsB,CAAA,CAAGyzB,UAAA,EAAY,OAC9BzzB,CAAA,CAAG0wB,aAAA,CAAczwB,CAAA,E;;UAGvB;UAEAq4B,WAAA;YACE,IAAqB,MAAjB,KAAK31B,OAAA,IAAiB,KAAKs1B,iCAAA,EAAmC;cAChE,MAAMj4B,CAAA,GAAM,KAAK6qB,EAAA;gBACX5qB,CAAA,GAAM,KAAKg4B,iCAAA;gBAEXx3B,CAAA,GAAQT,CAAA,CAAIu4B,WAAA;cAElB,OADAv4B,CAAA,CAAIw4B,UAAA,CAAWv4B,CAAA,CAAIw4B,gBAAA,EAAkBh4B,CAAA,GAC9BA,C;;YAGP,MAAM,IAAI4D,KAAA,CAAM,4CAEpB;UAAA;UAEAq0B,SAAA;YACE,IAAqB,MAAjB,KAAK/1B,OAAA,KAAiB,KAAKs1B,iCAAA,EAO7B,MAAM,IAAI5zB,KAAA,CAAM;YAPlB;cACE,MAAMrE,CAAA,GAAM,KAAK6qB,EAAA;gBACX5qB,CAAA,GAAM,KAAKg4B,iCAAA;cACjBj4B,CAAA,CAAI24B,QAAA,CAAS14B,CAAA,CAAIw4B,gBAAA,C;;UAMrB;UAEAG,uBAAuB54B,CAAA;YACrB,IAAIC,CAAA,IAAY;cAAOQ,CAAA,IAAW;YAClC,IAAqB,MAAjB,KAAKkC,OAAA,KAAiB,KAAKs1B,iCAAA,EAQ7B,MAAM,IAAI5zB,KAAA,CAAM;YARgD;cAChE,MAAM7D,CAAA,GAAM,KAAKqqB,EAAA;gBACXnqB,CAAA,GAAM,KAAKu3B,iCAAA;cAEjBh4B,CAAA,GAAYO,CAAA,CAAIq4B,iBAAA,CAAkB74B,CAAA,EAAOQ,CAAA,CAAIs4B,sBAAA,GAC7Cr4B,CAAA,GAAWD,CAAA,CAAIq0B,YAAA,CAAan0B,CAAA,CAAIq4B,gBAAA,C;;YAMlC,OAAO94B,CAAA,KAAcQ,CACvB;UAAA;UAEAu4B,eAAeh5B,CAAA;YACb,IAAIC,CAAA,GAAc;YAClB,IAAqB,MAAjB,KAAK0C,OAAA,EAMP,MAAM,IAAI0B,KAAA,CAAM;YANM;cACtB,MAAM5D,CAAA,GAAM,KAAKoqB,EAAA;cACjB5qB,CAAA,GAAcQ,CAAA,CAAIo4B,iBAAA,CAAkB74B,CAAA,EAAOS,CAAA,CAAIw4B,YAAA,GAC/Cx4B,CAAA,CAAIy4B,WAAA,CAAYl5B,CAAA,C;;YAMlB,OAAOC,CAAA,GAAc,GACvB;UAAA;UAEA,MAAAk5B,uBAA6Bn5B,CAAA;YAE3B,cADM,GAAA0D,CAAA,CAAAstB,WAAA,EAAY,MAAM,KAAK4H,sBAAA,CAAuB54B,CAAA,IAC7C,KAAKg5B,cAAA,CAAeh5B,CAAA,CAC7B;UAAA;UAEO,MAAAwwB,sBAAA;YACL,MAAMxwB,CAAA,GAAe,KAAKo5B,WAAA,CAAY,KAAKvO,EAAA;YAC3C,OAAO,KAAKwO,SAAA,CAAUr5B,CAAA,CACxB;UAAA;UAEQo5B,YAAYp5B,CAAA;YAClB,IAAIC,CAAA;YACJ,MAAMQ,CAAA,GAAMT,CAAA;cACNQ,CAAA,GAAQC,CAAA,CAAI64B,SAAA,CAAU74B,CAAA,CAAI84B,0BAAA,EAA4B;YAU5D,OATAv5B,CAAA,CAAGw5B,KAAA,IAEDv5B,CAAA,GADY,SAAVO,CAAA,GACc,OAAM,IAEN;cACd,MAAMR,CAAA,GAASS,CAAA,CAAIg5B,cAAA,CAAej5B,CAAA,EAAO,GAAG;cAC5C,OAAOR,CAAA,KAAWS,CAAA,CAAIi5B,gBAAA,IAAoB15B,CAAA,KAAWS,CAAA,CAAIk5B,mBAAmB;YAAA,GAGzE;cAACC,KAAA,EAAAp5B,CAAA;cAAOq5B,aAAA,EAAA55B;YAAA,CACjB;UAAA;UAEA,MAAAo5B,UAAgBr5B,CAAA;YACd,OAAO,IAAIsC,OAAA,CAAcrC,CAAA;cAClB,KAAK65B,aAAA,CAAc,MAAM95B,CAAA,CAAa65B,aAAA,IAAiB,MAAM55B,CAAA,GAAU;YAAA,EAEhF;UAAA;UAIA85B,UAAA;YAEE,MAAM/5B,CAAA,GAAQyK,CAAA,CAAqB,KAAKwoB,WAAA,CAAY9vB,GAAA,CAAInD,CAAA,IAAKA,CAAA,CAAEg6B,QAAA;YAC/D,KAAK,IAAI/5B,CAAA,GAAI,GAAGA,CAAA,IAAKD,CAAA,IAASC,CAAA,EAAG;cAC/B;gBAAMg6B,SAAA,EAACj6B;cAAA,IAAa,KAAKizB,WAAA,CAAYhzB,CAAA;cACrCD,CAAA,E;;YAEF,KAAKizB,WAAA,GAAc,KAAKA,WAAA,CAAY/lB,KAAA,CAAMlN,CAAA,GAAQ,EACpD;UAAA;UAEQ,MAAA85B,cAAoB95B,CAAA,EAAyBC,CAAA;YACnD,KAAKgzB,WAAA,CAAYjsB,IAAA,CAAK;cAACgzB,QAAA,EAAAh6B,CAAA;cAAUi6B,SAAA,EAAAh6B;YAAA,IAC7B,KAAKgzB,WAAA,CAAYnxB,MAAA,GAAS,aAKxB,GAAA4B,CAAA,CAAAstB,WAAA,EAAY,OAChB,KAAK+I,SAAA,IAE8B,MAA5B,KAAK9G,WAAA,CAAYnxB,MAAA,EAE5B;UAAA;QAAA,C;;;;;;;;QC7lBF,MAAAtB,CAAA,GAAAC,CAAA;QAIA,MAAMC,CAAA;UACJkC,YAAmB5C,CAAA,EAAqBC,CAAA;YAArB,KAAAi6B,EAAA,GAAAl6B,CAAA,EAAqB,KAAAm6B,IAAA,GAAAl6B,CAAmB;UAAA;QAAA;QAG7DA,CAAA,CAAAm6B,aAAA;UACEx3B,YAAoB5C,CAAA,EAAcC,CAAA,EAAyBQ,CAAA;YAAvC,KAAA45B,KAAA,GAAAr6B,CAAA,EAAuC,KAAAwqB,QAAA,GAAA/pB,CAAA,EACzD,KAAK2G,UAAA,CAAWnH,CAAA,CAClB;UAAA;UAEAmH,WAAWpH,CAAA;YACT,KAAKwqB,QAAA,CAASI,KAAA,CAAM,WAAW,4BAA4B;cACzD,MAAM3qB,CAAA,GAAa,KAAKo6B,KAAA,CAAMC,QAAA;cAC9B,IAAIr6B,CAAA,CAAW6B,MAAA,KAAW9B,CAAA,CAAI8B,MAAA,EAC5B,MAAM,IAAIuC,KAAA,CAAM;cAGlB,KAAKk2B,IAAA,GAAOv6B,CAAA,CAAImD,GAAA,CAAI,CAACnD,CAAA,EAAIS,CAAA,KAAM,IAAIC,CAAA,CAASV,CAAA,EAAIC,CAAA,CAAWQ,CAAA,KAC3D,KAAK+5B,KAAA,IAGL,KAAKC,QAAA,GAAW,IAChB,KAAKF,IAAA,CAAK1vB,OAAA,CAAQ,CAAC7K,CAAA,EAAIC,CAAA;gBACrB,IAAIQ,CAAA,IAAW;gBACf,KAAK,MAAMR,CAAA,IAASD,CAAA,CAAGm6B,IAAA,CAAKvQ,MAAA,EAC1B,KACK,KAAK8Q,OAAA,CAAQz6B,CAAA,MACsC,MAAjD,KAAKo6B,KAAA,CAAMM,eAAA,GAAkBvuB,OAAA,CAAQnM,CAAA,GAC1C;kBACAQ,CAAA,IAAW;kBACX;;gBAGAA,CAAA,IACF,KAAKg6B,QAAA,CAASzzB,IAAA,CAAK/G,CAAA,C;gBAErB;YAAA,EAEN;UAAA;UAEAu6B,MAAA;YACE,KAAKE,OAAA,GAAU,KAAKL,KAAA,CAAM7M,SAAA,GAAYrqB,GAAA,CAAInD,CAAA,IAAKA,CAAA,CAAEoU,MAAA,CACnD;UAAA;UAEA,MAAAwmB,QAAc56B,CAAA,EAAgCC,CAAA;YAC5C,OAAO,KAAKuqB,QAAA,CAASI,KAAA,CAAM,WAAW,yBAAyB;cAE7D,KAAK4P,KAAA;cAGL,MAAM/5B,CAAA,GAAmBT,CAAA,CAAestB,sBAAA;gBAGlC5sB,CAAA,GAAc,KAAK25B,KAAA,CAAMM,eAAA;cAC/B,IAAI16B,CAAA,CAAY6B,MAAA,KAAWpB,CAAA,CAAYoB,MAAA,EACrC,MAAM,IAAIuC,KAAA,CAAM,kFACZpE,CAAA,CAAY6B,MAAA,cAAoBpB,CAAA,CAAYoB,MAAA;cAGlD7B,CAAA,CAAY4K,OAAA,CAAQ,CAAC7K,CAAA,EAAOC,CAAA;gBAC1B,MAAMQ,CAAA,GAAQC,CAAA,CAAYT,CAAA;gBAC1B,KAAKy6B,OAAA,CAAQj6B,CAAA,IAAST,CAAK;cAAA;cAI7B,MAAMiB,CAAA,GAAqB,KAAKw5B,QAAA,CAASvtB,KAAA,CAAM;gBAGzChM,CAAA,GAAc,KAAKm5B,KAAA,CAAM7M,SAAA;gBACzBlqB,CAAA,GAAa,KAAK+2B,KAAA,CAAMC,QAAA;cAE9B,IAAI52B,CAAA,GAAO;cACX,OAAOA,CAAA,GAAOzC,CAAA,CAASa,MAAA,GAAQ;gBAC7B,MAAM9B,CAAA,GAAciB,CAAA,CAASyC,CAAA;kBACvBzD,CAAA,GAAS,KAAKs6B,IAAA,CAAKv6B,CAAA;kBAGnBU,CAAA,GAAYT,CAAA,CAAOk6B,IAAA,CAAKvQ,MAAA,CAAOzmB,GAAA,CAAInD,CAAA,IAAK,KAAK06B,OAAA,CAAQ16B,CAAA;gBAC3D,KAAsC,MAAlCU,CAAA,CAAU0L,OAAA,MAAQ,IACpB,MAAM,IAAI/H,KAAA,CAAM,kCAAkCpE,CAAA,CAAOk6B,IAAA;gBAI3D,MAAM1vB,CAAA,GAAe/J,CAAA;gBACrBF,CAAA,CAAAwH,MAAA,CAAOE,OAAA,CACH,YACA,aAAajI,CAAA,CAAOk6B,IAAA,CAAKn2B,IAAA,KACrByG,CAAA,CAAatH,GAAA,CAAI,CAACnD,CAAA,EAAGS,CAAA,KAAM,IAAIR,CAAA,CAAOk6B,IAAA,CAAKvQ,MAAA,CAAOnpB,CAAA,OAAQT,CAAA,CAAEgF,IAAA,IAAQhF,CAAA,CAAE6T,IAAA,CAAKzQ,IAAA,CAAK,SAASA,IAAA,CAAK;gBAEtG,MAAMiI,CAAA,SAAmB,KAAKmf,QAAA,CAASI,KAAA,CACnC,QAAQ3qB,CAAA,CAAOk6B,IAAA,CAAKn2B,IAAA,EAAM,YAAY/D,CAAA,CAAOi6B,EAAA,CAAGtM,IAAA,CAAKntB,CAAA,EAAkBgK,CAAA,EAAcxK,CAAA,CAAOi6B,EAAA,CAAGlxB,OAAA;gBAGnG,IAAIqC,CAAA,CAAWvJ,MAAA,KAAW7B,CAAA,CAAOk6B,IAAA,CAAK5S,OAAA,CAAQzlB,MAAA,EAC5C,MAAM,IAAIuC,KAAA,CAAM;gBAIlBgH,CAAA,CAAWR,OAAA,CAAQ,CAAC7K,CAAA,EAAQS,CAAA;kBAC1B,MAAMD,CAAA,GAAIP,CAAA,CAAOk6B,IAAA,CAAK5S,OAAA,CAAQ9mB,CAAA;kBAC9B,IAAI,KAAKi6B,OAAA,CAAQl6B,CAAA,GACf,MAAM,IAAI6D,KAAA,CAAM,WAAW7D,CAAA,2BAA4BP,CAAA,CAAOk6B,IAAA,CAAKn2B,IAAA;kBAErE,KAAK02B,OAAA,CAAQl6B,CAAA,IAAKR,CAAM;gBAAA;gBAI1B,MAAMsL,CAAA,GAAkB,IAAIqD,GAAA;gBAC5BtD,CAAA,CAAWR,OAAA,CAAQ,CAAC7K,CAAA,EAAQS,CAAA;kBAC1B,MAAMD,CAAA,GAAIP,CAAA,CAAOk6B,IAAA,CAAK5S,OAAA,CAAQ9mB,CAAA;kBAC9B,KAAK,MAAMT,CAAA,IAA8BkB,CAAA,CAAYV,CAAA,EAAGq6B,EAAA,EAAI;oBAC1D,MAAM56B,CAAA,GAAwBqD,CAAA,CAAWtD,CAAA;oBACzC,IAAIS,CAAA,IAAW;oBACf,KAAK,MAAMT,CAAA,IAAKC,CAAA,CAAsB2pB,MAAA,EACpC,KAAK,KAAK8Q,OAAA,CAAQ16B,CAAA,GAAI;sBACpBS,CAAA,IAAW;sBACX;;oBAGAA,CAAA,IACF6K,CAAA,CAAgByD,GAAA,CAAI/O,CAAA,C;;oBAI1BiB,CAAA,CAAS+F,IAAA,IAAQsE,CAAA,C;;cAGnB,MAAMb,CAAA,GAAmB;cACzB,KAAK,IAAIzK,CAAA,GAAI,GAAGA,CAAA,GAAI,KAAKq6B,KAAA,CAAMS,gBAAA,GAAmBh5B,MAAA,EAAQ9B,CAAA,IAAK;gBAC7D,MAAMC,CAAA,GAAc,KAAKo6B,KAAA,CAAMS,gBAAA,GAAmB96B,CAAA;kBAC5CS,CAAA,GAAe,KAAKi6B,OAAA,CAAQz6B,CAAA;gBAClC,SAAqB,MAAjBQ,CAAA,EACF,MAAM,IAAI4D,KAAA,CAAM,oBAAoBpE,CAAA;gBAElB,MAAhBA,CAAA,SACIQ,CAAA,CAAas6B,OAAA,KAGnBt6B,CAAA,CAAagjB,IAAA,EAEfhZ,CAAA,CAAOzD,IAAA,CAAKvG,CAAA,C;;cAId,OAFAD,CAAA,CAAAwH,MAAA,CAAOE,OAAA,CAAQ,YAAY,kCAC3BzH,CAAA,CAAiB4G,OAAA,IACVoD,CAAM;YAAA,EAEjB;UAAA;QAAA,C;;;;;;;;QCvJF,MAAAjK,CAAA,GAAAC,CAAA;UACAC,CAAA,GAAAD,CAAA;UACAQ,CAAA,GAAAR,CAAA;UACAS,CAAA,GAAAT,CAAA;UACA6C,CAAA,GAAA7C,CAAA;QAEA,IAAOiD,CAAA,GAAShD,CAAA,CAAA6C,WAAA,CAAYC,YAAA,CAAaC,GAAA;QAmE5BxD,CAAA,CAAA+6B,KAAA,GAAQ;UAInB5b,IAAA,EAAMA,CAACpf,CAAA,EAA2CC,CAAA,KAC9C,IAAIqL,CAAA,CAAUtL,CAAA,EAAYC,CAAA;QAAA;QAGhC,MAAMwK,CAAA;UACJ7H,YAAY5C,CAAA;YACV,KAAKi7B,KAAA,QAAQ,GACb,KAAKC,GAAA,GAAM,IACX,KAAK9mB,MAAA,QAAS,GACd,KAAKpP,IAAA,QAAO,GAERhF,CAAA,KACF,KAAKgF,IAAA,GAAO1B,CAAA,CAAA2b,SAAA,CAAUkc,wBAAA,CAAyBn7B,CAAA,CAAUgF,IAAA,CAAMo2B,UAAA,EAEnE;UAAA;UAGI,IAAAhc,KAAA;YACF,OAAO,KAAK6b,KACd;UAAA;UAEI,IAAAJ,GAAA;YACF,OAAO,KAAKK,GACd;UAAA;QAAA;QAKF,MAAM7vB,CAAA;UACJzI,YAAY5C,CAAA,EAAyCC,CAAA;YAC/CD,CAAA,YAAsBiB,CAAA,CAAA4C,IAAA,CAAKw3B,SAAA,IAC7B,KAAKr3B,IAAA,GAAOhE,CAAA,CAAWgE,IAAA,EACvB,KAAKs3B,MAAA,GAASt7B,CAAA,CAAWs7B,MAAA,EACzB,KAAK1d,UAAA,GAAa,IAAIpd,CAAA,CAAA2D,SAAA,CAAUnE,CAAA,CAAWoS,SAAA,KAClCpS,CAAA,YAAsB0D,CAAA,CAAO63B,IAAA,KACtC,KAAKv3B,IAAA,GAAO,QAAA/D,CAAA,GAAAA,CAAA,GAAQD,CAAA,CAAWgE,IAAA,IAC/B,KAAKs3B,MAAA,GAASt7B,CAAA,CAAWs7B,MAAA,IACzB,KAAK1d,UAAA,GAAa,IAAIpd,CAAA,CAAA2D,SAAA,CAAUb,CAAA,CAAA2b,SAAA,CAAUuc,6BAAA,CAA8Bx7B,CAAA,KAG1E,KAAK4pB,MAAA,GAAS,IACd,KAAKrC,OAAA,GAAU,IACf,KAAKkU,WAAA,IAAc,CACrB;UAAA;QAAA;QAUF,MAAMnwB,CAAA;UAWJ1I,YAAY5C,CAAA,EAAsCC,CAAA;YAChD,KAAKD,CAAA,EACH,MAAM,IAAI+hB,SAAA,CAAU;YAItB,KAAK2Z,UAAA,CAAW17B,CAAA,GAGhB,KAAK27B,cAAA,CAAe17B,CAAA,GAGpB,KAAK27B,cAAA,EACP;UAAA;UAEAjB,gBAAA;YACE,OAAO,KAAKkB,gBACd;UAAA;UAEAC,cAAA;YACE,OAAO,KAAKC,cACd;UAAA;UAEAjB,iBAAA;YACE,OAAO,KAAKkB,iBACd;UAAA;UAEAC,eAAA;YACE,OAAO,KAAKC,eACd;UAAA;UAEA1O,UAAA;YACE,OAAO,KAAK2O,QACd;UAAA;UAEA7B,SAAA;YACE,OAAO,KAAK8B,MACd;UAAA;UAEQV,WAAW17B,CAAA;YAEjB,IAAIA,CAAA,YAAiBiB,CAAA,CAAA4C,IAAA,CAAKw4B,UAAA,EACxB,KAAKC,wBAAA,CAAyBt8B,CAAA,OACzB;cAAA,MAAIA,CAAA,YAAiB0D,CAAA,CAAOs3B,KAAA,GAGjC,MAAM,IAAIjZ,SAAA,CAAU;cAFpB,KAAKwa,uBAAA,CAAwBv8B,CAAA,C;;UAIjC;UACQs8B,yBAAyBt8B,CAAA;YAC/B,MAAMC,CAAA,GAAc,IAAI2D,GAAA;YACxB,KAAKu4B,QAAA,GAAW,IAEhB,KAAKN,gBAAA,GAAmB,IACxB,KAAKE,cAAA,GAAiB,IAEtB,KAAKC,iBAAA,GAAoB,IACzB,KAAKE,eAAA,GAAkB,IAEvB,KAAKE,MAAA,GAAS;YAEd,MAAM37B,CAAA,GAAe,IAAImD,GAAA;YAGzB,KAAK5D,CAAA,CAAMw8B,KAAA,EACT,MAAM,IAAIn4B,KAAA,CAAM;YAElB,MAAM7D,CAAA,GAAkB;YACxB,KAAK,MAAMC,CAAA,IAAKT,CAAA,CAAMw8B,KAAA,EAAO;cAC3B,IAAIv8B,CAAA,CAAY6O,GAAA,CAAIrO,CAAA,CAAEuD,IAAA,GACpB,MAAM,IAAIK,KAAA,CAAM,0BAA0B5D,CAAA,CAAEuD,IAAA;cAE9C,MAAMhE,CAAA,GAAe,KAAKm8B,QAAA,CAASn1B,IAAA,CAAK,IAAIyD,CAAA,CAAMhK,CAAA,KAAM;cACxDR,CAAA,CAAY8D,GAAA,CAAItD,CAAA,CAAEuD,IAAA,EAAOhE,CAAA,GACzBQ,CAAA,CAAgBwG,IAAA,CAAKvG,CAAA,CAAEuD,IAAA,C;;YAIzB,KAAKhE,CAAA,CAAMy8B,WAAA,EACT,MAAM,IAAIp4B,KAAA,CAAM;YAElB,KAAK,MAAM5D,CAAA,IAAKT,CAAA,CAAMy8B,WAAA,EAAa;cACjC,IAAIz8B,CAAA,GAAQC,CAAA,CAAYuE,GAAA,CAAI/D,CAAA,CAAEuD,IAAA;cAC9B,SAAc,MAAVhE,CAAA,EAAqB;gBACvB,MAAMQ,CAAA,GAAQ,IAAIiK,CAAA;gBAClBjK,CAAA,CAAMwE,IAAA,GAAO;kBACX8I,KAAA,EAAO;oBAAC+F,IAAA,EAAMvQ,CAAA,CAAA2b,SAAA,CAAUyd,mBAAA,CAAoBj8B,CAAA,CAAEoT,IAAA;kBAAA;kBAC9CunB,UAAA,EAAY93B,CAAA,CAAA2b,SAAA,CAAUC,uBAAA,CAAwBze,CAAA,CAAEk8B,QAAA;gBAAA,GAElD38B,CAAA,GAAQ,KAAKm8B,QAAA,CAASn1B,IAAA,CAAKxG,CAAA,IAAS,GACpCP,CAAA,CAAY8D,GAAA,CAAItD,CAAA,CAAEuD,IAAA,EAAOhE,CAAA,C;;cAE3B,KAAKm8B,QAAA,CAASn8B,CAAA,EAAOi7B,KAAA,IAAS,GAC9B,KAAKkB,QAAA,CAASn8B,CAAA,EAAOoU,MAAA,GAASlT,CAAA,CAAA+E,MAAA,CAAOC,SAAA,CAAUzF,CAAA,C;;YAIjD,KAAK,IAAIT,CAAA,GAAI,GAAGA,CAAA,GAAI,KAAKm8B,QAAA,CAASr6B,MAAA,EAAQ9B,CAAA,IACnC,KAAKm8B,QAAA,CAASn8B,CAAA,EAAGoU,MAAA,KACpB,KAAKynB,gBAAA,CAAiB70B,IAAA,CAAKhH,CAAA,GAC3B,KAAK+7B,cAAA,CAAe/0B,IAAA,CAAKxG,CAAA,CAAgBR,CAAA;YAK7C,KAAKA,CAAA,CAAM8J,MAAA,EACT,MAAM,IAAIzF,KAAA,CAAM;YAElB,KAAK,MAAM5D,CAAA,IAAKT,CAAA,CAAM8J,MAAA,EAAQ;cAC5B,IAAI7J,CAAA,CAAY6O,GAAA,CAAIrO,CAAA,CAAEuD,IAAA,GACpB,MAAM,IAAIK,KAAA,CAAM,2BAA2B5D,CAAA,CAAEuD,IAAA;cAE/C,MAAMhE,CAAA,GAAe,KAAKm8B,QAAA,CAASn1B,IAAA,CAAK,IAAIyD,CAAA,CAAMhK,CAAA,KAAM;cACxDR,CAAA,CAAY8D,GAAA,CAAItD,CAAA,CAAEuD,IAAA,EAAOhE,CAAA,GACzB,KAAKg8B,iBAAA,CAAkBh1B,IAAA,CAAKhH,CAAA,GAC5B,KAAKk8B,eAAA,CAAgBl1B,IAAA,CAAKvG,CAAA,CAAEuD,IAAA,C;;YAI9B,KAAKhE,CAAA,CAAMm6B,IAAA,EACT,MAAM,IAAI91B,KAAA,CAAM;YAElB,KAAK,MAAMpE,CAAA,IAAaD,CAAA,CAAMm6B,IAAA,EAAM;cAClC,KAAKl6B,CAAA,CAAU+D,IAAA,EAEb,KAAK,IAAIhE,CAAA,GAAO,IAAIA,CAAA,IAAQ;gBAC1B,MAAMQ,CAAA,GAAO,WAAWP,CAAA,CAAUq7B,MAAA,IAAUt7B,CAAA;gBAC5C,KAAKS,CAAA,CAAaqO,GAAA,CAAItO,CAAA,GAAO;kBAC3BP,CAAA,CAAU+D,IAAA,GAAOxD,CAAA;kBACjB;;;cAKN,IAAIC,CAAA,CAAaqO,GAAA,CAAI7O,CAAA,CAAU+D,IAAA,GAC7B,MAAM,IAAIK,KAAA,CAAM,yBAAyBpE,CAAA,CAAU+D,IAAA;cAErD,MAAMhE,CAAA,GAAe,KAAKo8B,MAAA,CAAOp1B,IAAA,CAAK,IAAIqE,CAAA,CAAKpL,CAAA,KAAc;cAC7DQ,CAAA,CAAasD,GAAA,CAAI9D,CAAA,CAAU+D,IAAA,EAAMhE,CAAA,C;;YAInC,KAAK,IAAIS,CAAA,GAAI,GAAGA,CAAA,GAAI,KAAK27B,MAAA,CAAOt6B,MAAA,EAAQrB,CAAA,IAAK;cAC3C,MAAMD,CAAA,GAAO,KAAK47B,MAAA,CAAO37B,CAAA;gBACnBC,CAAA,GAAYV,CAAA,CAAMm6B,IAAA,CAAK15B,CAAA;cAC7B,KAAKC,CAAA,CAAUoJ,MAAA,EACb,MAAM,IAAIzF,KAAA,CAAM,4BAA4B3D,CAAA,CAAUsD,IAAA;cAExD,KAAK,MAAMhE,CAAA,IAAUU,CAAA,CAAUoJ,MAAA,EAAQ;gBACrC,IAAI7I,CAAA,GAAYhB,CAAA,CAAYuE,GAAA,CAAIxE,CAAA;gBAOhC,SANyB,MAAdiB,CAAA,KACTA,CAAA,GAAY,KAAKk7B,QAAA,CAASn1B,IAAA,CAAK,IAAIyD,CAAA,MAAW,GAC9CxK,CAAA,CAAY8D,GAAA,CAAI/D,CAAA,EAAQiB,CAAA,IAE1BT,CAAA,CAAK+mB,OAAA,CAAQvgB,IAAA,CAAK/F,CAAA,QAEqB,MAAnC,KAAKk7B,QAAA,CAASl7B,CAAA,EAAWg6B,KAAA,EAC3B,MAAM,IAAI52B,KAAA,CAAM,4CAA4CpD,CAAA;gBAM9D,IAJA,KAAKk7B,QAAA,CAASl7B,CAAA,EAAWg6B,KAAA,GAAQx6B,CAAA,EAIR,eAArBC,CAAA,CAAU46B,MAAA,EAAuB;kBACnC,KAAK56B,CAAA,CAAU0R,SAAA,IAA4C,MAA/B1R,CAAA,CAAU0R,SAAA,CAAUtQ,MAAA,KAAiBpB,CAAA,CAAU0R,SAAA,CAAU,GAAGnS,CAAA,EACtF,MAAM,IAAIoE,KAAA,CAAM;kBAElB,KAAK3D,CAAA,CAAUoJ,MAAA,IAAsC,MAA5BpJ,CAAA,CAAUoJ,MAAA,CAAOhI,MAAA,EACxC,MAAM,IAAIuC,KAAA,CAAM;kBAElB7D,CAAA,CAAK+mB,OAAA,CAAQ4I,GAAA,IACb3vB,CAAA,CAAKi7B,WAAA,IAAc,GAEnB,KAAKU,QAAA,CAASl7B,CAAA,EAAWg6B,KAAA,IAAS,GAClC,KAAKkB,QAAA,CAASl7B,CAAA,EAAWmT,MAAA,GAASlT,CAAA,CAAA+E,MAAA,CAAOC,SAAA,CAAUxF,CAAA,CAAU0R,SAAA,CAAU,GAAGnS,CAAA,C;;;;YAMhF,KAAK,IAAIQ,CAAA,GAAI,GAAGA,CAAA,GAAI,KAAK27B,MAAA,CAAOt6B,MAAA,EAAQrB,CAAA,IAAK;cAC3C,MAAMD,CAAA,GAAO,KAAK47B,MAAA,CAAO37B,CAAA;gBACnBC,CAAA,GAAYV,CAAA,CAAMm6B,IAAA,CAAK15B,CAAA;cAE7B,KAAKC,CAAA,CAAU87B,KAAA,EACb,MAAM,IAAIn4B,KAAA,CAAM,2BAA2B3D,CAAA,CAAUsD,IAAA;cAEvD,KAAK,MAAMhE,CAAA,IAASU,CAAA,CAAU87B,KAAA,EAAO;gBACnC,MAAMv7B,CAAA,GAAYhB,CAAA,CAAYuE,GAAA,CAAIxE,CAAA;gBAClC,SAAyB,MAAdiB,CAAA,EAA2B;kBAEpC,IAAc,OAAVjB,CAAA,KAA4C,MAA3BU,CAAA,CAAU87B,KAAA,CAAM16B,MAAA,IAA2C,MAA3BpB,CAAA,CAAU87B,KAAA,CAAM16B,MAAA,KAC5C,aAArBpB,CAAA,CAAU46B,MAAA,EACZ;kBAEF,MAAM,IAAIj3B,KAAA,CAAM,uBAAuBrE,CAAA,eAAoBU,CAAA,CAAUsD,IAAA,G;;gBAEvExD,CAAA,CAAKopB,MAAA,CAAO5iB,IAAA,CAAK/F,CAAA,GAEjB,KAAKk7B,QAAA,CAASl7B,CAAA,EAAWi6B,GAAA,CAAIl0B,IAAA,CAAKvG,CAAA,C;;;YAItC,QAAO,CACT;UAAA;UAEQ87B,wBAAwBv8B,CAAA;;YAC9B,MAAMU,CAAA,GAAc,IAAIkD,GAAA;YACxB,KAAKu4B,QAAA,GAAW,IAEhB,KAAKN,gBAAA,GAAmB,IACxB,KAAKE,cAAA,GAAiB,IAEtB,KAAKC,iBAAA,GAAoB,IACzB,KAAKE,eAAA,GAAkB,IAEvB,KAAKE,MAAA,GAAS;YAEd,MAAMn7B,CAAA,GAAe,IAAI2C,GAAA;cAGnB0H,CAAA,GAAkB;YACxB,KAAK,IAAIrK,CAAA,GAAI,GAAGA,CAAA,GAAIjB,CAAA,CAAM48B,YAAA,IAAgB37B,CAAA,IAAK;cAC7C,MAAMC,CAAA,GAAYlB,CAAA,CAAM4pB,MAAA,CAAO3oB,CAAA;cAC/B,IAAIP,CAAA,CAAYoO,GAAA,CAAI5N,CAAA,GAClB,MAAM,IAAImD,KAAA,CAAM,0BAA0BnD,CAAA;cAG5C,KAAK,IAAID,CAAA,GAAI,GAAGA,CAAA,GAAIjB,CAAA,CAAM68B,cAAA,IAAkB57B,CAAA,IAC1C,KAAqB,UAAjBhB,CAAA,GAAAD,CAAA,CAAM88B,QAAA,CAAS77B,CAAA,WAAE,MAAAhB,CAAA,YAAAA,CAAA,CAAE+D,IAAA,QAAW9C,CAAA,EAAW;gBAC3C,MAAMjB,CAAA,GAAQ,IAAIwK,CAAA;gBAElB,KAD2C,UAAzBjK,CAAA,GAAiB,UAAjBC,CAAA,GAAAT,CAAA,CAAM88B,QAAA,CAAS77B,CAAA,WAAE,MAAAR,CAAA,YAAAA,CAAA,CAAEuE,IAAA,YAAM,MAAAxE,CAAA,YAAAA,CAAA,CAAEu8B,SAAA,QAC3Br5B,CAAA,CAAOs5B,aAAA,CAAcC,WAAA,EACrC,MAAM,IAAI54B,KAAA,CAAM;gBAElB,MAAMgH,CAAA,GAAYrL,CAAA,CAAM88B,QAAA,CAAS77B,CAAA,EAAI+D,IAAA,GAAQmf,KAAA,CAAM,IAAIzgB,CAAA,CAAOw5B,kBAAA;kBACxD3xB,CAAA,GAAOjI,CAAA,CAAA2b,SAAA,CAAUC,uBAAA,CAAwB7T,CAAA,CAAU8xB,QAAA;kBACnD52B,CAAA,GAAQ8E,CAAA,CAAUyC,KAAA;kBAClBpC,CAAA,GAAO;gBACb,KAAK,IAAI1L,CAAA,GAAI,GAAGA,CAAA,GAAIuG,CAAA,CAAM62B,SAAA,IAAcp9B,CAAA,IACtC0L,CAAA,CAAK1E,IAAA,CAAK1D,CAAA,CAAAuC,QAAA,CAASE,YAAA,CAAaQ,CAAA,CAAM82B,GAAA,CAAIr9B,CAAA,EAAImkB,KAAA,GAASmZ,QAAA;gBAEzDr9B,CAAA,CAAM+E,IAAA,GAAO;kBAAC8I,KAAA,EAAO;oBAAC+F,IAAA,EAAAnI;kBAAA;kBAAO0vB,UAAA,EAAY7vB;gBAAA;gBACzC,MAAM/E,CAAA,GAAe,KAAK21B,QAAA,CAASn1B,IAAA,CAAK/G,CAAA,IAAS;gBACjDS,CAAA,CAAYqD,GAAA,CAAI7C,CAAA,EAAWsF,CAAA,GAC3B8E,CAAA,CAAgBtE,IAAA,CAAK9F,CAAA,C;;;YAK3B,KAAK,IAAIjB,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAMu9B,kBAAA,IAAsBt9B,CAAA,IAAK;cACnD,MAAMQ,CAAA,GAAcT,CAAA,CAAMytB,YAAA,CAAaxtB,CAAA;cACvC,IAAIO,CAAA,GAAQE,CAAA,CAAY8D,GAAA,CAAI/D,CAAA,CAAYuD,IAAA;cACxC,SAAc,MAAVxD,CAAA,EAAqB;gBACvB,MAAMR,CAAA,GAAQ,IAAIyK,CAAA;kBACZxK,CAAA,GAAOqD,CAAA,CAAA2b,SAAA,CAAUue,uBAAA,CAAwB/8B,CAAA;kBACzCQ,CAAA,GAAOqC,CAAA,CAAA2b,SAAA,CAAUC,uBAAA,CAAwBze,CAAA,CAAYk8B,QAAA;gBAC3D38B,CAAA,CAAMgF,IAAA,GAAO;kBAAC8I,KAAA,EAAO;oBAAC+F,IAAA,EAAA5T;kBAAA;kBAAOm7B,UAAA,EAAYn6B;gBAAA,GACzCT,CAAA,GAAQ,KAAK27B,QAAA,CAASn1B,IAAA,CAAKhH,CAAA,IAAS,GACpCU,CAAA,CAAYqD,GAAA,CAAItD,CAAA,CAAYuD,IAAA,IAASxD,CAAA,C;;cAEvC,KAAK27B,QAAA,CAAS37B,CAAA,EAAOy6B,KAAA,IAAS,GAC9B,KAAKkB,QAAA,CAAS37B,CAAA,EAAO4T,MAAA,GAASlT,CAAA,CAAA+E,MAAA,CAAOE,aAAA,CAAc1F,CAAA,C;;YAIrD,KAAK,IAAIT,CAAA,GAAI,GAAGA,CAAA,GAAI,KAAKm8B,QAAA,CAASr6B,MAAA,EAAQ9B,CAAA,IACnC,KAAKm8B,QAAA,CAASn8B,CAAA,EAAGoU,MAAA,KACpB,KAAKynB,gBAAA,CAAiB70B,IAAA,CAAKhH,CAAA,GAC3B,KAAK+7B,cAAA,CAAe/0B,IAAA,CAAKsE,CAAA,CAAgBtL,CAAA;YAK7C,KAAK,IAAIC,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAMy9B,aAAA,IAAiBx9B,CAAA,IAAK;cAC9C,MAAMQ,CAAA,GAAaT,CAAA,CAAMunB,OAAA,CAAQtnB,CAAA;cACjC,IAAIS,CAAA,CAAYoO,GAAA,CAAIrO,CAAA,GAClB,MAAM,IAAI4D,KAAA,CAAM,2BAA2B5D,CAAA;cAE7C,MAAMD,CAAA,GAAe,KAAK27B,QAAA,CAASn1B,IAAA,CAAK,IAAIyD,CAAA,MAAW;cACvD/J,CAAA,CAAYqD,GAAA,CAAItD,CAAA,EAAYD,CAAA,GAC5B,KAAKw7B,iBAAA,CAAkBh1B,IAAA,CAAKxG,CAAA,GAC5B,KAAK07B,eAAA,CAAgBl1B,IAAA,CAAKvG,CAAA,C;;YAI5B,KAAKT,CAAA,CAAM09B,KAAA,EACT,MAAM,IAAIr5B,KAAA,CAAM;YAElB,KAAK,IAAIpE,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAM29B,WAAA,IAAe19B,CAAA,IAAK;cAC5C,MAAMQ,CAAA,GAAYT,CAAA,CAAM09B,KAAA,CAAMz9B,CAAA;cAC9B,IAAIO,CAAA,GAAOC,CAAA,CAAWuD,IAAA;cACtB,KAAKxD,CAAA,EAEH,KAAK,IAAIR,CAAA,GAAO,GACdQ,CAAA,GAAO,WAAWC,CAAA,CAAW66B,MAAA,MAAYt7B,CAAA,IACpCiB,CAAA,CAAa6N,GAAA,CAAItO,CAAA,GAFJR,CAAA;cAStB,IAAIiB,CAAA,CAAa6N,GAAA,CAAItO,CAAA,GACnB,MAAM,IAAI6D,KAAA,CAAM,yBAAyB7D,CAAA;cAE3C,MAAME,CAAA,GAAe,KAAK07B,MAAA,CAAOp1B,IAAA,CAAK,IAAIqE,CAAA,CAAK5K,CAAA,EAAYD,CAAA,KAAS;cACpES,CAAA,CAAa8C,GAAA,CAAIvD,CAAA,EAAME,CAAA,C;;YAIzB,KAAK,IAAIT,CAAA,GAAI,GAAGA,CAAA,GAAI,KAAKm8B,MAAA,CAAOt6B,MAAA,EAAQ7B,CAAA,IAAK;cAC3C,MAAMQ,CAAA,GAAO,KAAK27B,MAAA,CAAOn8B,CAAA;gBACnBO,CAAA,GAAYR,CAAA,CAAM09B,KAAA,CAAMz9B,CAAA;cAC9B,IAAiB,QAAbO,CAAA,EACF,MAAM,IAAI6D,KAAA,CAAM,2BAA2BpE,CAAA;cAE7C,IAAmC,OAA/B,QAAAO,CAAA,QAAS,IAATA,CAAA,CAAWi9B,aAAA,KACb,MAAM,IAAIp5B,KAAA,CAAM,4BAA4B7D,CAAA,CAAUwD,IAAA;cAExD,KAAK,IAAIhE,CAAA,GAAI,GAAGA,CAAA,IAAI,QAAAQ,CAAA,QAAS,IAATA,CAAA,CAAWi9B,aAAA,KAAiBz9B,CAAA,IAAK;gBACnD,MAAMiB,CAAA,GAAS,QAAAT,CAAA,QAAS,IAATA,CAAA,CAAW+mB,OAAA,CAAQvnB,CAAA;gBAClC,IAAIsD,CAAA,GAAY5C,CAAA,CAAY8D,GAAA,CAAIvD,CAAA;gBAOhC,SANyB,MAAdqC,CAAA,KACTA,CAAA,GAAY,KAAK64B,QAAA,CAASn1B,IAAA,CAAK,IAAIyD,CAAA,MAAW,GAC9C/J,CAAA,CAAYqD,GAAA,CAAI9C,CAAA,EAAQqC,CAAA,IAE1B7C,CAAA,CAAK8mB,OAAA,CAAQvgB,IAAA,CAAK1D,CAAA,QAEqB,MAAnC,KAAK64B,QAAA,CAAS74B,CAAA,EAAW23B,KAAA,EAC3B,MAAM,IAAI52B,KAAA,CAAM,4CAA4Cf,CAAA;gBAM9D,IAJA,KAAK64B,QAAA,CAAS74B,CAAA,EAAW23B,KAAA,GAAQh7B,CAAA,EAIN,eAAvBO,CAAA,CAAU86B,MAAA,IAAyB;kBACrC,IAAqC,MAAjC96B,CAAA,CAAUo9B,gBAAA,OAA6Bp9B,CAAA,CAAUod,UAAA,CAAW,GAAI3d,CAAA,IAClE,MAAM,IAAIoE,KAAA,CAAM;kBAElB,IAAkC,MAA9B7D,CAAA,CAAUi9B,aAAA,IACZ,MAAM,IAAIp5B,KAAA,CAAM;kBAElB5D,CAAA,CAAK8mB,OAAA,CAAQ4I,GAAA,IACb1vB,CAAA,CAAKg7B,WAAA,IAAc,GAEnB,KAAKU,QAAA,CAAS74B,CAAA,EAAW23B,KAAA,IAAS,GAClC,KAAKkB,QAAA,CAAS74B,CAAA,EAAW8Q,MAAA,GAASlT,CAAA,CAAA+E,MAAA,CAAOE,aAAA,CAAc3F,CAAA,CAAUod,UAAA,CAAW,GAAI3d,CAAA,G;;;;YAMtF,KAAK,IAAIA,CAAA,GAAI,GAAGA,CAAA,GAAI,KAAKm8B,MAAA,CAAOt6B,MAAA,EAAQ7B,CAAA,IAAK;cAC3C,MAAMQ,CAAA,GAAO,KAAK27B,MAAA,CAAOn8B,CAAA;gBACnBO,CAAA,GAAYR,CAAA,CAAM09B,KAAA,CAAMz9B,CAAA;cAE9B,IAAiC,MAA7BO,CAAA,CAAUo8B,YAAA,IACZ,MAAM,IAAIv4B,KAAA,CAAM,2BAA2B7D,CAAA,CAAUwD,IAAA;cAEvD,KAAK,IAAIhE,CAAA,GAAI,GAAGA,CAAA,GAAIQ,CAAA,CAAUo8B,YAAA,IAAiB58B,CAAA,IAAK;gBAClD,MAAMiB,CAAA,GAAQT,CAAA,CAAUopB,MAAA,CAAO5pB,CAAA;kBACzBkB,CAAA,GAAYR,CAAA,CAAY8D,GAAA,CAAIvD,CAAA;gBAClC,SAAyB,MAAdC,CAAA,EACT,MAAM,IAAImD,KAAA,CAAM,uBAAuBpD,CAAA,eAAoBT,CAAA,CAAWwD,IAAA;gBAExEvD,CAAA,CAAKmpB,MAAA,CAAO5iB,IAAA,CAAK9F,CAAA,GAEjB,KAAKi7B,QAAA,CAASj7B,CAAA,EAAWg6B,GAAA,CAAIl0B,IAAA,CAAK/G,CAAA,C;;;UAGxC;UAEQ27B,eAAA;YAEN,MAAM57B,CAAA,GAAwB,IAAI2O,GAAA;YAClC,KAAKktB,gBAAA,CAAiBhxB,OAAA,CAAQ5K,CAAA;cACf,KAAKk8B,QAAA,CAASl8B,CAAA,EACtBi7B,GAAA,CAAIrwB,OAAA,CAAQ5K,CAAA;gBACfD,CAAA,CAAS+O,GAAA,CAAI9O,CAAA,CAAE;cAAA,EACf;YAAA;YAIJ,MAAMA,CAAA,GAAa+F,KAAA,CAAMoZ,IAAA,CAAKpf,CAAA;cACxBS,CAAA,GAAa,IAAIuF,KAAA,CAAc,KAAKo2B,MAAA,CAAOt6B,MAAA,EAAQud,IAAA,CAAK;YAE9D,OAAOpf,CAAA,CAAW6B,MAAA,GAAS,IAAG;cAC5B,MAAM9B,CAAA,GAAYC,CAAA,CAAWkwB,GAAA;cAEC,WAA1B1vB,CAAA,CAAWT,CAAA,IACbS,CAAA,CAAWT,CAAA,IAAa,WAGxBC,CAAA,CAAW+G,IAAA,CAAKhH,CAAA,GAChBS,CAAA,CAAWT,CAAA,IAAa,QAExB,KAAKo8B,MAAA,CAAOp8B,CAAA,EAAWunB,OAAA,CAAQ1c,OAAA,CAASrK,CAAA;gBACtC,MAAME,CAAA,GAAO,KAAKy7B,QAAA,CAAS37B,CAAA;gBAC3B,SAA2B,MAAhBE,CAAA,CAAK0T,MAAA,EACd,MAAM,IAAI/P,KAAA,CAAM;gBAElB,IAAI3D,CAAA,CAAKu6B,KAAA,KAAUj7B,CAAA,EACjB,MAAM,IAAIqE,KAAA,CAAM;gBAElB3D,CAAA,CAAKw6B,GAAA,CAAIrwB,OAAA,CAAS7K,CAAA;kBAEhB,IAAwC,WAApCS,CAAA,CAAWT,CAAA,GACb,MAAM,IAAIqE,KAAA,CAAM;kBAG2B,YAApC5D,CAAA,CAAWT,CAAA,KAClBC,CAAA,CAAW+G,IAAA,CAAKhH,CAAA,C;kBAElB;cAAA,G;;UAIV;UAEQ27B,eAAe37B,CAAA;YAErB,KAAK69B,sBAAA,IACL,KAAKC,qBAAA,IACL,KAAKC,uBAAA,IAED/9B,CAAA,IACFA,CAAA,CAAiB27B,cAAA,CAAe,OAIlC,KAAKqC,aAAA,EACP;UAAA;UAQAA,cAAA;YACE,IAAIh+B,CAAA,GAAS;YAMb,MAAMC,CAAA,GAAa,IAAI+F,KAAA,CAAc,KAAKo2B,MAAA,CAAOt6B,MAAA,EAAQ;YACzD,IAAIrB,CAAA,GAAgB;YAEpB,KAAK,IAAIT,CAAA,GAAI,GAAGA,CAAA,GAAI,KAAKo8B,MAAA,CAAOt6B,MAAA,EAAQ9B,CAAA,IAEtCC,CAAA,CAAWD,CAAA,IAAKS,CAAA,EACZ,KAAK27B,MAAA,CAAOp8B,CAAA,EAAGy7B,WAAA,IACbh7B,CAAA,KAAkBT,CAAA,KACpB,KAAKo8B,MAAA,CAAO37B,CAAA,IAAiB,KAAK27B,MAAA,CAAOp8B,CAAA,IAE3CS,CAAA,MAIA,KAAK27B,MAAA,CAAOp8B,CAAA,EAAGunB,OAAA,CAAQ1c,OAAA,CAAQ7K,CAAA;cAC7B,KAAKm8B,QAAA,CAASn8B,CAAA,EAAKi7B,KAAA,IAAS,CAAC;YAAA;YAMnC,KAAKmB,MAAA,CAAO3L,MAAA,CAAOhwB,CAAA,EAAe,KAAK27B,MAAA,CAAOt6B,MAAA,GAASrB,CAAA;YAGvD,KAAK,IAAIT,CAAA,GAAI,GAAGA,CAAA,GAAI,KAAKm8B,QAAA,CAASr6B,MAAA,EAAQ9B,CAAA,IAAK;cAC7C,MAAMS,CAAA,GAAc,KAAK07B,QAAA,CAASn8B,CAAA;cAAA,KACR,MAAtBS,CAAA,CAAYw6B,KAAA,KAA8C,MAAvBx6B,CAAA,CAAYw6B,KAAA,KAAuC,MAAvBx6B,CAAA,CAAYw6B,KAAA,KAC7Ex6B,CAAA,CAAYw6B,KAAA,GAAQh7B,CAAA,CAAWQ,CAAA,CAAYw6B,KAAA;cAG7C,KAAK,IAAIj7B,CAAA,GAAI,GAAGA,CAAA,GAAIS,CAAA,CAAYy6B,GAAA,CAAIp5B,MAAA,EAAQ9B,CAAA,IAAK;gBAC/C,MAAIS,CAAA,CAAYy6B,GAAA,CAAIl7B,CAAA,KAAM,IAGxB,MAAM,IAAIqE,KAAA,CAAM;gBAFhB5D,CAAA,CAAYy6B,GAAA,CAAIl7B,CAAA,IAAKC,CAAA,CAAWQ,CAAA,CAAYy6B,GAAA,CAAIl7B,CAAA,E;;;YAOtDA,CAAA,GAAS;YAET,KAAK,IAAIC,CAAA,GAAI,GAAGA,CAAA,GAAI,KAAKk8B,QAAA,CAASr6B,MAAA,EAAQ7B,CAAA,IAExC,KAA+B,MAA3B,KAAKk8B,QAAA,CAASl8B,CAAA,EAAGmf,IAAA,KAA+D,MAAhD,KAAK4c,iBAAA,CAAkB5vB,OAAA,CAAQnM,CAAA,GAAID,CAAA;cAMvE,IAAIA,CAAA,GAAS,GAAG;gBACd,IAAIS,CAAA,IAAO;gBAAA,KAGmB,MAA1B,KAAK07B,QAAA,CAASl8B,CAAA,EAAGmf,IAAA,KAAiD,MAA3B,KAAK+c,QAAA,CAASl8B,CAAA,EAAGmf,IAAA,IAC1D3e,CAAA,GAAM,KAAK27B,MAAA,CAAO,KAAKD,QAAA,CAASl8B,CAAA,EAAGmf,IAAA,EAAMmI,OAAA,CAAQnb,OAAA,CAAQnM,CAAA,GAAID,CAAA,IAChD,MAATS,CAAA,KACF,KAAK27B,MAAA,CAAO,KAAKD,QAAA,CAASl8B,CAAA,EAAGmf,IAAA,EAAMmI,OAAA,CAAQ9mB,CAAA,IAAOR,CAAA,MAIpDQ,CAAA,GAAM,KAAKo7B,gBAAA,CAAiBzvB,OAAA,CAAQnM,CAAA,GAAID,CAAA,IAC3B,MAATS,CAAA,KACF,KAAKo7B,gBAAA,CAAiBp7B,CAAA,IAAOR,CAAA,IAKjC,KAAKk8B,QAAA,CAASl8B,CAAA,EAAG46B,EAAA,CAAGhwB,OAAA,CAAQrK,CAAA;kBAC1BC,CAAA,GAAM,KAAK27B,MAAA,CAAO57B,CAAA,EAAMopB,MAAA,CAAOxd,OAAA,CAAQnM,CAAA,GAAID,CAAA,IAC9B,MAATS,CAAA,KACF,KAAK27B,MAAA,CAAO57B,CAAA,EAAMopB,MAAA,CAAOnpB,CAAA,IAAOR,CAAA,C;oBAGD,MAA/B,KAAKk8B,QAAA,CAASl8B,CAAA,EAAG46B,EAAA,CAAG/4B,MAAA,KAEtBrB,CAAA,GAAM,KAAKu7B,iBAAA,CAAkB5vB,OAAA,CAAQnM,CAAA,GAAID,CAAA,IAC5B,MAATS,CAAA,KACF,KAAKu7B,iBAAA,CAAkBv7B,CAAA,IAAOR,CAAA,E;;mBAjClCD,CAAA,IACA,KAAKm8B,QAAA,CAAS1L,MAAA,CAAOxwB,CAAA,EAAG,IACxBA,CAAA,EAoCN;UAAA;UAOQg+B,WAAWj+B,CAAA;YACjB,MAAMC,CAAA,GAAO,KAAKm8B,MAAA,CAAOp8B,CAAA;YACzB,IAAIC,CAAA,CAAKsnB,OAAA,CAAQzlB,MAAA,GAAS,GACxB,KAAK,IAAI9B,CAAA,GAAI,GAAGA,CAAA,GAAIC,CAAA,CAAKsnB,OAAA,CAAQzlB,MAAA,EAAQ9B,CAAA,IACvC,IAAI,KAAKm8B,QAAA,CAASl8B,CAAA,CAAKsnB,OAAA,CAAQvnB,CAAA,GAAI66B,EAAA,CAAG/4B,MAAA,GAAS,GAC7C,MAAM,IAAIuC,KAAA,CAAM;YAMtBpE,CAAA,CAAKw7B,WAAA,IAAc;YACnB,MAAMh7B,CAAA,GAAkBR,CAAA,CAAK2pB,MAAA,CAAO;cAC9BppB,CAAA,GAAmBP,CAAA,CAAKsnB,OAAA,CAAQ;cAChC7mB,CAAA,GAAuB,KAAKy7B,QAAA,CAAS37B,CAAA,EAAkBq6B,EAAA;YAG7D,KAAK,IAAIp6B,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK2pB,MAAA,CAAO9nB,MAAA,EAAQrB,CAAA,IAAK;cAC3C,MAAMD,CAAA,GAAW,KAAK27B,QAAA,CAASl8B,CAAA,CAAK2pB,MAAA,CAAOnpB,CAAA,GAAIo6B,EAAA,CAAGzuB,OAAA,CAAQpM,CAAA;cAE1D,KAAkB,MAAdQ,CAAA,EACF,MAAM,IAAI6D,KAAA,CAAM;cAElB,KAAK83B,QAAA,CAASl8B,CAAA,CAAK2pB,MAAA,CAAOnpB,CAAA,GAAIo6B,EAAA,CAAGpK,MAAA,CAAOjwB,CAAA,EAAU,E;;YAIpD,KAAK27B,QAAA,CAAS37B,CAAA,EAAkB06B,GAAA,GAAM;YAGtC,MAAMj6B,CAAA,GAAQ,KAAK+6B,iBAAA,CAAkB5vB,OAAA,CAAQ5L,CAAA;YAM7C,KALe,MAAXS,CAAA,KACF,KAAK+6B,iBAAA,CAAkB/6B,CAAA,IAASR,CAAA,GAI9BC,CAAA,IAAwBA,CAAA,CAAqBoB,MAAA,GAAS,GACxD,KAAK,MAAM9B,CAAA,IAAaU,CAAA,EAAsB;cAC5C,MAAMT,CAAA,GAAe,KAAKm8B,MAAA,CAAOp8B,CAAA,EAAW4pB,MAAA,CAAOxd,OAAA,CAAQ5L,CAAA;cAE3D,KAAsB,MAAlBP,CAAA,EACF,MAAM,IAAIoE,KAAA,CAAM;cAElB,KAAK+3B,MAAA,CAAOp8B,CAAA,EAAW4pB,MAAA,CAAO3pB,CAAA,IAAgBQ,CAAA,EAC9C,KAAK07B,QAAA,CAAS17B,CAAA,EAAiBo6B,EAAA,CAAG7zB,IAAA,CAAKhH,CAAA,C;;UAG7C;UAEA89B,sBAAA;YACE,IAAI99B,CAAA,GAAY;YAChB,KAAK,MAAMC,CAAA,IAAQ,KAAKm8B,MAAA,EAAQ;cAE9B,IAAoB,cAAhBn8B,CAAA,CAAKq7B,MAAA,EAAsB;gBAE7B,IAA2B,MAAvBr7B,CAAA,CAAK2pB,MAAA,CAAO9nB,MAAA,EACd,MAAM,IAAIuC,KAAA,CAAM;gBAElB,IAA4B,MAAxBpE,CAAA,CAAKsnB,OAAA,CAAQzlB,MAAA,IAAwC,MAAxB7B,CAAA,CAAKsnB,OAAA,CAAQzlB,MAAA,EAC5C,MAAM,IAAIuC,KAAA,CAAM;gBAGlB,IAA4B,MAAxBpE,CAAA,CAAKsnB,OAAA,CAAQzlB,MAAA,IAA8D,MAA9C,KAAKq6B,QAAA,CAASl8B,CAAA,CAAKsnB,OAAA,CAAQ,IAAI2T,GAAA,CAAIp5B,MAAA,EAClE,MAAM,IAAIuC,KAAA,CAAM;gBAElB,KAAK45B,UAAA,CAAWj+B,CAAA,C;;cAElBA,CAAA,E;;UAEJ;UAEA69B,uBAAA;YACE,IAAI79B,CAAA,GAAY;YAChB,KAAK,MAAMC,CAAA,IAAQ,KAAKm8B,MAAA,EAEF,eAAhBn8B,CAAA,CAAKq7B,MAAA,IACP,KAAK2C,UAAA,CAAWj+B,CAAA,GAElBA,CAAA,EAEJ;UAAA;UAEAk+B,aAAal+B,CAAA;YACX,QAAQA,CAAA,CAAEs7B,MAAA;cAER,KAAK;cACL,KAAK;cACL,KAAK;gBACH,QAAO;cACT;gBACE,QAAO;YAAA;UAEb;UAEAyC,wBAAA;YACE,KAAK,MAAM/9B,CAAA,IAAQ,KAAKo8B,MAAA,EACtB,IAAoB,WAAhBp8B,CAAA,CAAKs7B,MAAA,EAAmB;cAC1B,MAAMr7B,CAAA,GAAO,KAAKk8B,QAAA,CAASn8B,CAAA,CAAKunB,OAAA,CAAQ,IAAI2T,GAAA;cAC5C,IAAoB,MAAhBj7B,CAAA,CAAK6B,MAAA,IAAgB,KAAKo8B,YAAA,CAAa,KAAK9B,MAAA,CAAOn8B,CAAA,CAAK,MAAM;gBAChE,MAAMQ,CAAA,GAAQ,KAAK27B,MAAA,CAAOn8B,CAAA,CAAK;gBAC/B,IAAqB,WAAjBQ,CAAA,CAAM66B,MAAA,EACR,IAA4B,MAAxB76B,CAAA,CAAMmpB,MAAA,CAAO9nB,MAAA,EACf;kBACE9B,CAAA,CAAK4d,UAAA,CAAW7Z,GAAA,CACZ,qBAAqB,UACrB,CAACtD,CAAA,CAAMmd,UAAA,CAAWrZ,QAAA,CAAS,QAAQ9D,CAAA,CAAMmd,UAAA,CAAWrZ,QAAA,CAAS,Q;iBACjE,QAAOtE,CAAA;kBACPD,CAAA,CAAK4d,UAAA,CAAW7Z,GAAA,CAAI,qBAAqB,UAAU,CAACT,CAAA,CAAAmf,QAAA,EAAUnf,CAAA,CAAAof,QAAA,E;uBAE3D;kBAAA,MACHjiB,CAAA,CAAMmpB,MAAA,CAAO9nB,MAAA,IAAU,UAA+C,MAA1C,KAAKq6B,QAAA,CAAS17B,CAAA,CAAMmpB,MAAA,CAAO,IAAIxV,MAAA,SACjB,MAA1C,KAAK+nB,QAAA,CAAS17B,CAAA,CAAMmpB,MAAA,CAAO,IAAIxV,MAAA,GAMjC;kBALApU,CAAA,CAAK4d,UAAA,CAAW7Z,GAAA,CAAI,qBAAqB,UAAU,CACjD,KAAKo4B,QAAA,CAAS17B,CAAA,CAAMmpB,MAAA,CAAO,IAAIxV,MAAA,CAAQkQ,SAAA,CAAU,IAAI,KAAK6X,QAAA,CAAS17B,CAAA,CAAMmpB,MAAA,CAAO,IAAIxV,MAAA,CAAQkQ,SAAA,CAAU,I;;gBAO5GtkB,CAAA,CAAK4d,UAAA,CAAW7Z,GAAA,CAAI,cAAc,UAAWtD,CAAA,CAAY66B,MAAA,GACzD,KAAK2C,UAAA,CAAWh+B,CAAA,CAAK,G;;;UAI7B;QAAA;;;;;;;;QC/qBF,MAAMQ,CAAA,GAAiB;YACrByH,OAAA,EAAS;YACTi2B,IAAA,EAAM;YACNh2B,OAAA,EAAS;YACTkjB,KAAA,EAAO;YACP+S,KAAA,EAAO;UAAA;UAGH59B,CAAA,GAA+E;YACnF69B,IAAA,EAAU,IAtCZ;cACE9jB,IAAIva,CAAA,EAA4BC,CAAA,EAAkBQ,CAAA,GAElD;YAAA;YAoCA69B,OAAA,EAAa,IAlCf;cACE/jB,IAAIva,CAAA,EAA2BC,CAAA,EAAiBQ,CAAA;gBAE9C69B,OAAA,CAAQ/jB,GAAA,CAAI,GAAG,KAAKgkB,KAAA,CAAMv+B,CAAA,KAAaS,CAAA,GAAW,UAAaA,CAAA,GAAW,UAAa,KAAKR,CAAA,GAC9F;cAAA;cAEQs+B,MAAMv+B,CAAA;gBACZ,QAAQA,CAAA;kBACN,KAAK;oBACH,OAAO;kBACT,KAAK;oBACH,OAAO;kBACT,KAAK;oBACH,OAAO;kBACT,KAAK;oBACH,OAAO;kBACT,KAAK;oBACH,OAAO;kBACT;oBACE,MAAM,IAAIqE,KAAA,CAAM,yBAAyBrE,CAAA;gBAAA;cAE/C;YAAA;UAAA;UAeIU,CAAA,GAAwB;YAC5B89B,QAAA,EAAU;YACVC,eAAA,EAAiB;YACjBC,WAAA,GAAa;YACbC,iBAAA,GAAmB;UAAA;QAErB,IAAI19B,CAAA,GAC0D;UAAC,IAAMP;QAAA;QAMrE,SAASQ,EACLlB,CAAA,EAA8BC,CAAA,EAAeQ,CAAA,EAAsBD,CAAA;UACrE,SAAa,MAATP,CAAA,EAEF,OAkB6BS,CAAA,GAlBEV,CAAA,EAmB1B;YACLkI,OAAA,EAAShH,CAAA,CAAIgH,OAAA,CAAQ02B,IAAA,CAAK,MAAMl+B,CAAA;YAChCy9B,IAAA,EAAMj9B,CAAA,CAAIi9B,IAAA,CAAKS,IAAA,CAAK,MAAMl+B,CAAA;YAC1ByH,OAAA,EAASjH,CAAA,CAAIiH,OAAA,CAAQy2B,IAAA,CAAK,MAAMl+B,CAAA;YAChC2qB,KAAA,EAAOnqB,CAAA,CAAImqB,KAAA,CAAMuT,IAAA,CAAK,MAAMl+B,CAAA;YAC5B09B,KAAA,EAAOl9B,CAAA,CAAIk9B,KAAA,CAAMQ,IAAA,CAAK,MAAMl+B,CAAA;UAAA;UAvBvB,SAAa,MAATD,CAAA,EAET6C,CAAA,CAAYtD,CAAA,EAAyBC,CAAA,OAChC,IAAoB,mBAATQ,CAAA,SAA8B,MAATD,CAAA,EAErC8C,CAAA,CAAYtD,CAAA,EAAyBC,CAAA,OAChC,IAAoB,mBAATQ,CAAA,SAA8B,MAATD,CAAA,EAErC8C,CAAA,CAAYtD,CAAA,EAAyBS,CAAA,EAAM,GAAGR,CAAA,OACzC;YAAA,IAAoB,mBAATQ,CAAA,IAAqC,mBAATD,CAAA,EAI5C,MAAM,IAAIuhB,SAAA,CAAU;YAFpBze,CAAA,CAAYtD,CAAA,EAAyBS,CAAA,EAAM,GAAMR,CAAA,C;;UAMrD,IAAiCS,CAFjC;QAAA;QAeA,SAAS4C,EAAYtD,CAAA,EAA2BC,CAAA,EAAiBS,CAAA,EAAeQ,CAAA;UAC9E,MAAMoC,CAAA,GAASrC,CAAA,CAAkBC,CAAA,IAAY,OAAOD,CAAA,CAAkB;UAClER,CAAA,CAAeT,CAAA,IAAYS,CAAA,CAAe6C,CAAA,CAAOm7B,eAAA,MAIjDn7B,CAAA,CAAOo7B,WAAA,KACTz+B,CAAA,GAAU,GAAG,IAAI4+B,IAAA,GAAOC,WAAA,MAAiB7+B,CAAA,KAGvCqD,CAAA,CAAOq7B,iBAAA,EAIXn+B,CAAA,CAAoB8C,CAAA,CAAOk7B,QAAA,EAAUjkB,GAAA,CAAIva,CAAA,EAAUC,CAAA,EAASiB,CAAA,EAC9D;QAAA;QAAA,CAGA,UAAUlB,CAAA;UA2BR,SAAgBC,EAAMD,CAAA;YACpBiB,CAAA,GAAoB,CAAC,GACrBR,CAAA,CAAI,IAAIT,CAAA,IAAU,CAAC,EACrB;UAAA;UACA,SAAgBS,EAAIT,CAAA,EAAkBS,CAAA;YACpC,IAAiB,QAAbT,CAAA,EACFC,CAAA,CAAMQ,CAAA,OACD;cACL,MAAMR,CAAA,GAAiBgB,CAAA,CAAkBjB,CAAA,KAAaU,CAAA;cACtDO,CAAA,CAAkBjB,CAAA,IAAY;gBAC5Bw+B,QAAA,EAAU/9B,CAAA,CAAO+9B,QAAA,IAAYv+B,CAAA,CAAeu+B,QAAA;gBAC5CC,eAAA,EAAiBh+B,CAAA,CAAOg+B,eAAA,IAAmBx+B,CAAA,CAAew+B,eAAA;gBAC1DC,WAAA,OAAqC,MAAvBj+B,CAAA,CAAOi+B,WAAA,GAA6Bz+B,CAAA,CAAey+B,WAAA,GAAcj+B,CAAA,CAAOi+B,WAAA;gBACtFC,iBAAA,OAAiD,MAA7Bl+B,CAAA,CAAOk+B,iBAAA,GAAmC1+B,CAAA,CAAe0+B,iBAAA,GACfl+B,CAAA,CAAOk+B;cAAA,C;;UAK3E;UA3CgB3+B,CAAA,CAAAkI,OAAA,GAAhB,UAAwBjI,CAAA,EAAcQ,CAAA;YACpCT,CAAA,CAAI,WAAWC,CAAA,EAAMQ,CAAA,CACvB;UAAA,GAGgBT,CAAA,CAAAm+B,IAAA,GAAhB,UAAqBl+B,CAAA,EAAcQ,CAAA;YACjCT,CAAA,CAAI,QAAQC,CAAA,EAAMQ,CAAA,CACpB;UAAA,GAGgBT,CAAA,CAAAmI,OAAA,GAAhB,UAAwBlI,CAAA,EAAcQ,CAAA;YACpCT,CAAA,CAAI,WAAWC,CAAA,EAAMQ,CAAA,CACvB;UAAA,GAGgBT,CAAA,CAAAqrB,KAAA,GAAhB,UAAsBprB,CAAA,EAAcQ,CAAA;YAClCT,CAAA,CAAI,SAASC,CAAA,EAAMQ,CAAA,CACrB;UAAA,GAGgBT,CAAA,CAAAo+B,KAAA,GAAhB,UAAsBn+B,CAAA,EAAcQ,CAAA;YAClCT,CAAA,CAAI,SAASC,CAAA,EAAMQ,CAAA,CACrB;UAAA,GAEgBT,CAAA,CAAAw6B,KAAA,GAAKv6B,CAAA,EAILD,CAAA,CAAA+D,GAAA,GAAGtD,CAAA,EAiBHT,CAAA,CAAAiI,UAAA,GAAhB,UAA2BjI,CAAA;YACzB,MAAMC,CAAA,GAAwB,CAAC;YAC3BD,CAAA,CAAI++B,QAAA,KACN9+B,CAAA,CAAOw+B,eAAA,GAAkBz+B,CAAA,CAAI++B,QAAA,GAE/Bt+B,CAAA,CAAI,IAAIR,CAAA,CACV;UAAA,CACD;QAAA,CAvDD,CAAUiB,CAAA,KAAAA,CAAA,GAAG,MA0DAjB,CAAA,CAAA+H,MAAA,GAAiB9G,CAAA;QAkB9B,MAAMwC,CAAA;UACJd,YACW5C,CAAA,EAAyCC,CAAA,EAAqBQ,CAAA,EAC7DD,CAAA,EAAsDE,CAAA,EAA2BO,CAAA;YADlF,KAAA+9B,QAAA,GAAAh/B,CAAA,EAAyC,KAAAgE,IAAA,GAAA/D,CAAA,EAAqB,KAAAg/B,SAAA,GAAAx+B,CAAA,EAC7D,KAAAy+B,WAAA,GAAA1+B,CAAA,EAAsD,KAAA2+B,KAAA,GAAAz+B,CAAA,EAA2B,KAAA0+B,GAAA,GAAAn+B,CAAqB;UAAA;UAElH,MAAAo+B,IAAA;YACE,OAAO,KAAKH,WAAA,CAAY,KAC1B;UAAA;UAEA,MAAAI,WAAA;YACE,SAAiB,MAAb,KAAKF,GAAA,SAAoC,MAAf,KAAKD,KAAA,EACjC,MAAM,IAAI96B,KAAA,CAAM;YAGhB,OADA,KAAK+6B,GAAA,CAAI1G,QAAA,IACF,KAAK0G,GAAA,CAAIjG,sBAAA,CAAuB,KAAKgG,KAAA,CAEhD;UAAA;QAAA;QAGF,MAAM10B,CAAA;UACJ7H,YACW5C,CAAA,EAAyCC,CAAA,EAAqBQ,CAAA,EAA0BD,CAAA;YAAxF,KAAAw+B,QAAA,GAAAh/B,CAAA,EAAyC,KAAAgE,IAAA,GAAA/D,CAAA,EAAqB,KAAAg/B,SAAA,GAAAx+B,CAAA,EAA0B,KAAA8+B,OAAA,GAAA/+B,CAAkB;UAAA;QAAA;QAGvHP,CAAA,CAAAu/B,QAAA;UACE,OAAAC,OAAcz/B,CAAA;YACZ,YAAe,MAAXA,CAAA,GACK,IAAI,SAEN,IAAI,KAAKA,CAAA,CAAO0/B,eAAA,EAAiB1/B,CAAA,CAAO2/B,cAAA,EAAgB3/B,CAAA,CAAO4/B,2BAAA,CACxE;UAAA;UAEAh9B,YAAoB5C,CAAA,EAA0BC,CAAA,EAAyBQ,CAAA;YA+H/D,KAAAo/B,QAAA,IAAW,GASX,KAAAC,aAAA,GAAgB,GAvItB,KAAKD,QAAA,IAAW,GAChB,KAAKE,gBAAA,QAAuC,MAApB//B,CAAA,GAAgC,MAAQA,CAAA,EAChE,KAAKggC,eAAA,QAAqC,MAAnB//B,CAAA,GAA+B,KAAKA,CAAA,EAC3D,KAAKggC,4BAAA,QAA+D,MAAhCx/B,CAAA,GAA4C,MAAOA,CACzF;UAAA;UAGAy/B,MAAA;YACE,KAAKL,QAAA,IAAW,GAChB,KAAKM,aAAA,GAAgB,IACrB,KAAKC,UAAA,IAAa,GAAAngC,CAAA,CAAAogC,GAAA,KAClB,KAAKP,aAAA,GAAgB,CACvB;UAAA;UAGAQ,KAAA;YAEE,KADA,KAAKT,QAAA,IAAW,GACT,KAAKC,aAAA,GAAgB,KAAKK,aAAA,CAAcr+B,MAAA,EAAQ,KAAKg+B,aAAA,IAC1D,KAAKS,WAAA,CAAY,KAAKJ,aAAA,CAAc,KAAKL,aAAA,EAE7C;UAAA;UAMAlV,MAAS5qB,CAAA,EAAkCC,CAAA,EAAcQ,CAAA,EAA4BD,CAAA;YAEnF,MAAME,CAAA,GAAQ,KAAKm/B,QAAA,GAAW,KAAKW,KAAA,CAAMxgC,CAAA,EAAUC,CAAA,EAAMO,CAAA,SAAO;YAChE,IAAIS,CAAA,IAAY;YAEhB,MAAMC,CAAA,GAAMT,CAAA;YAGZ,IAAIS,CAAA,IAA2C,qBAA5BA,CAAA,CAAmBu/B,IAAA,EAEpC,OADAx/B,CAAA,IAAY,GACL,IAAIqB,OAAA,CAAW,CAACtC,CAAA,EAASC,CAAA;cAC7BiB,CAAA,CACIu/B,IAAA,CACG,MAAMxgC,CAAA;gBACAS,CAAA,WACIA,CAAA,CAAM2+B,GAAA,KAEdr/B,CAAA,CAAQC,CAAA,CAAM;cAAA,GAEhB,MAAMD,CAAA;gBACAU,CAAA,WACIA,CAAA,CAAM2+B,GAAA,KAEdp/B,CAAA,CAAOD,CAAA,CAAO;cAAA,EACd;YAAA;YAGd,KAAKiB,CAAA,IAAaP,CAAA,EAAO;cACvB,MAAMV,CAAA,GAAWU,CAAA,CAAM2+B,GAAA;cACvB,IAAIr/B,CAAA,IAAqC,qBAAlBA,CAAA,CAASygC,IAAA,EAC9B,OAAO,IAAIn+B,OAAA,CAAW,CAACrC,CAAA,EAASQ,CAAA;gBAC9BT,CAAA,CAAWygC,IAAA,CACP;kBACExgC,CAAA,CAAQiB,CAAA,CAAI;gBAAA,GAEblB,CAAA;kBACCS,CAAA,CAAOT,CAAA,CAAO;gBAAA,EACd;cAAA,E;;YAIZ,OAAOkB,CACT;UAAA;UAGAs/B,MAAMxgC,CAAA,EAAkCS,CAAA,EAAcD,CAAA;YACpD,KAAK,KAAKq/B,QAAA,EACR,MAAM,IAAIx7B,KAAA,CAAM;YAElB,SAAY,MAAR7D,CAAA,EAAmB;cACrB,MAAMA,CAAA,IAAY,GAAAP,CAAA,CAAAogC,GAAA;cAElB,OADA,KAAK7G,KAAA,CAAMh5B,CAAA,GACJ,IAAIkD,CAAA,CAAM1D,CAAA,EAAUS,CAAA,EAAMD,CAAA,EAAWR,CAAA,IAAK,KAAK0gC,OAAA,CAAQ1gC,CAAA,E;;YACzD;cACL,MAAMC,CAAA,GAAoBO,CAAA,CAAI83B,UAAA;cAC9B,OAAO,IAAI50B,CAAA,CAAM1D,CAAA,EAAUS,CAAA,EAAM,GAAG,MAAMT,CAAA,IAAK,KAAKq/B,GAAA,CAAIr/B,CAAA,GAAIC,CAAA,EAAOO,CAAA,C;;UAEvE;UAGQ,MAAA6+B,IAAUr/B,CAAA;YAChB,MAAMC,CAAA,SAAwBD,CAAA,CAAMs/B,UAAA;YAChC,KAAKa,aAAA,CAAcr+B,MAAA,GAAS,KAAKi+B,gBAAA,KACnC,KAAKI,aAAA,CAAcn5B,IAAA,CAAK,IAAIyD,CAAA,CAAYzK,CAAA,CAAMg/B,QAAA,EAAUh/B,CAAA,CAAMgE,IAAA,EAAMhE,CAAA,CAAMi/B,SAAA,EAAWh/B,CAAA,IACrF,KAAKu5B,KAAA,CAAMv5B,CAAA,EAEf;UAAA;UAEQygC,QAAQ1gC,CAAA;YACd,MAAMS,CAAA,IAAkB,GAAAR,CAAA,CAAAogC,GAAA;YACpB,KAAKF,aAAA,CAAcr+B,MAAA,GAAS,KAAKi+B,gBAAA,KACnC,KAAKI,aAAA,CAAcn5B,IAAA,CAAK,IAAIyD,CAAA,CAAYzK,CAAA,CAAMg/B,QAAA,EAAUh/B,CAAA,CAAMgE,IAAA,EAAMhE,CAAA,CAAMi/B,SAAA,EAAWx+B,CAAA,IACrF,KAAK+4B,KAAA,CAAM/4B,CAAA,EAEf;UAAA;UAEQ8/B,YAAYvgC,CAAA;YAClBC,CAAA,CAAA+H,MAAA,CAAOE,OAAA,CACH,YAAYlI,CAAA,CAAMg/B,QAAA,IAClB,IAAIh/B,CAAA,CAAMu/B,OAAA,GAAUv/B,CAAA,CAAMi/B,SAAA,EAAW0B,OAAA,CAAQ,kBAAkB3gC,CAAA,CAAMgE,IAAA,QAAYhE,CAAA,CAAMu/B,OAAA,CAAQoB,OAAA,CAAQ,KAC7G;UAAA;UAEQnH,MAAMx5B,CAAA;YACZ,IAAI,KAAKmgC,aAAA,CAAcr+B,MAAA,GAAS,KAAKg+B,aAAA,IAAiB,KAAKE,eAAA,IACvDhgC,CAAA,GAAc,KAAKogC,UAAA,IAAc,KAAKH,4BAAA,EAA8B;cAGtE,KAAK,MAAMjgC,CAAA,GAAkB,KAAK8/B,aAAA,EAAe,KAAKA,aAAA,GAAgB9/B,CAAA,GAAkB,KAAKggC,eAAA,IACxF,KAAKF,aAAA,GAAgB,KAAKK,aAAA,CAAcr+B,MAAA,EACxC,KAAKg+B,aAAA,IACR,KAAKS,WAAA,CAAY,KAAKJ,aAAA,CAAc,KAAKL,aAAA;cAG3C,KAAKM,UAAA,IAAa,GAAAngC,CAAA,CAAAogC,GAAA,G;;UAEtB;UAEI,IAAAO,QAAA;YACF,OAAO,KAAKf,QACd;UAAA;QAAA,GAgBW5/B,CAAA,CAAAogC,GAAA,GAA8B,sBAAhBQ,WAAA,IAA+BA,WAAA,CAAYR,GAAA,GAAO,MAAMQ,WAAA,CAAYR,GAAA,KAAQxB,IAAA,CAAKwB,G;;;;;;;;QC3b5G,MAAA7/B,CAAA,GAAAC,CAAA;UAEAC,CAAA,GAAAD,CAAA;UAEAQ,CAAA,GAAAR,CAAA;UACAS,CAAA,GAAAT,CAAA;UACA6C,CAAA,GAAA7C,CAAA;QAEA,IAAOiD,CAAA,GAASzC,CAAA,CAAAsC,WAAA,CAAYC,YAAA,CAAaC,GAAA;QAEzCxD,CAAA,CAAA6gC,KAAA;UAEEl+B,YAAA,GAAe;UAEfm+B,KAAK/gC,CAAA,EAAiBC,CAAA,EAAsCQ,CAAA;YAC1D,KAAKA,CAAA,EAEH;cAEE,YADA,KAAKugC,kBAAA,CAAmBhhC,CAAA,EAAKC,CAAA,C;aAE7B,QAAOD,CAAA;cACP,SAAoB,MAAhBS,CAAA,EACF,MAAMT,C;;YAKZ,KAAKihC,iBAAA,CAAkBjhC,CAAA,EAAKC,CAAA,CAC9B;UAAA;UAEQ+gC,mBAAmBhhC,CAAA,EAAiBC,CAAA;YAC1C,MAAMQ,CAAA,GAAaS,CAAA,CAAA2C,IAAA,CAAKq9B,UAAA,CAAW/xB,MAAA,CAAOnP,CAAA;YAE1C,IADkBsD,CAAA,CAAAuC,QAAA,CAASE,YAAA,CAAatF,CAAA,CAAW0gC,SAAA,IACnC,GACd,MAAM,IAAI98B,KAAA,CAAM;YAGlB,KAAK+8B,OAAA,GACD3gC,CAAA,CAAW4gC,WAAA,CAAYl+B,GAAA,CAAInD,CAAA,KAAK;cAAEshC,MAAA,EAAQthC,CAAA,CAAEshC,MAAA;cAAkB3+B,OAAA,EAASW,CAAA,CAAAuC,QAAA,CAASE,YAAA,CAAa/F,CAAA,CAAE2C,OAAA;YAAA,KAEnG,KAAK4+B,MAAA,GAAS7gC,CAAA,CAAAs6B,KAAA,CAAM5b,IAAA,CAAK3e,CAAA,CAAW45B,KAAA,EAAQp6B,CAAA,CAC9C;UAAA;UAEQghC,kBAAkBjhC,CAAA,EAAiBC,CAAA;YACzC,MAAMQ,CAAA,GAAK,IAAID,CAAA,CAAAghC,WAAA,CAAYC,UAAA,CAAWzhC,CAAA;cAChCiB,CAAA,GAAWyC,CAAA,CAAOg+B,gBAAA,CAAiBC,yBAAA,CAA0BlhC,CAAA,EAAImhC,KAAA;YAEvE,IADkBt+B,CAAA,CAAAuC,QAAA,CAASE,YAAA,CAAa9E,CAAA,CAASkgC,SAAA,MACjC,GACd,MAAM,IAAI98B,KAAA,CAAM;YAElB,KAAK+8B,OAAA,GAAU;YACf,KAAK,IAAIphC,CAAA,GAAI,GAAGA,CAAA,GAAIiB,CAAA,CAAS4gC,iBAAA,IAAqB7hC,CAAA,IAAK;cACrD,MAAMC,CAAA,GAAUgB,CAAA,CAASogC,WAAA,CAAYrhC,CAAA;cACrC,KAAKohC,OAAA,CAAQp6B,IAAA,CAAK;gBAACs6B,MAAA,EAAQ,QAAArhC,CAAA,QAAO,IAAPA,CAAA,CAASqhC,MAAA;gBAAoB3+B,OAAA,EAASW,CAAA,CAAAuC,QAAA,CAASE,YAAA,CAAa9F,CAAA,CAAQ0C,OAAA;cAAA,E;;YAGjG,KAAK4+B,MAAA,GAAS7gC,CAAA,CAAAs6B,KAAA,CAAM5b,IAAA,CAAKne,CAAA,CAASo5B,KAAA,IAAUp6B,CAAA,CAC9C;UAAA;UAGI,IAAAo6B,MAAA;YACF,OAAO,KAAKkH,MACd;UAAA;UAGI,IAAAO,OAAA;YACF,OAAO,KAAKV,OACd;UAAA;QAAA,C;;;;;;;mECvDWnhC,CAAA,CAAA4iB,YAAA,GACT,CAAC,WAAW,WAAW,SAAS,SAAS,QAAQ,UAAU,UAAU,UAC5D5iB,CAAA,CAAA8hC,SAAA,GAAwC,CAAC,SAAS,SAAS,QAAQ,UAAU,UAAU,UACvF9hC,CAAA,CAAA+hC,WAAA,GAA0C,CAAC,WAAW,U;;;;;QC8BnE,SAASvhC,EAAcT,CAAA,EAAiBC,CAAA;UACtC,IAAIA,CAAA,CAASgiC,QAAA,CAAS,MAAM;YAE1B,MAAMxhC,CAAA,GAAaiB,MAAA,CAAOwgC,QAAA,CAASjiC,CAAA,CAASkiC,SAAA,CAAU,GAAGliC,CAAA,CAAS6B,MAAA,GAAS,IAAI;YAC/E,QAAQsgC,KAAA,CAAM3hC,CAAA,KAAeA,CAAA,IAAcT,C;;UACtC,IAAmC,MAA/BC,CAAA,CAAS+P,KAAA,CAAM,KAAKlO,MAAA,EAAc;YAE3C,MAAMrB,CAAA,GAAOR,CAAA,CAAS+P,KAAA,CAAM;cACtBxP,CAAA,GAAakB,MAAA,CAAOwgC,QAAA,CAASzhC,CAAA,CAAK,IAAI;cACtCC,CAAA,GAAWgB,MAAA,CAAOwgC,QAAA,CAASzhC,CAAA,CAAK,IAAI;YAC1C,QAAQ2hC,KAAA,CAAM5hC,CAAA,MAAgB4hC,KAAA,CAAM1hC,CAAA,KAAaF,CAAA,IAAcR,CAAA,IAAWA,CAAA,IAAWU,C;;UAGrF,OAAOgB,MAAA,CAAOwgC,QAAA,CAASjiC,CAAA,EAAU,QAAQD,CAE7C;QAAA;;;wCAvCAC,CAAA,CAAA0tB,eAAA,aAAgC3tB,CAAA,EAAkBC,CAAA,EAA0BO,CAAA;UAC1E,KAAK,MAAME,CAAA,IAAQF,CAAA,EAAO;YACxB,MAAMA,CAAA,GAASE,CAAA,CAAK;cACdO,CAAA,GAASP,CAAA,CAAK;cACdQ,CAAA,GAAkBR,CAAA,CAAK;cACvB4C,CAAA,GAAS5C,CAAA,CAAK;cACdgD,CAAA,GAAShD,CAAA,CAAK;YAEpB,IAAIV,CAAA,CAAKs7B,MAAA,KAAW96B,CAAA,EAClB,KAAK,MAAMR,CAAA,IAASC,CAAA,EAElB,KAAID,CAAA,CAAMshC,MAAA,KAAWrgC,CAAA,IAA4B,cAAjBjB,CAAA,CAAMshC,MAAA,IAAmC,OAAXrgC,CAAA,KACxDR,CAAA,CAAcT,CAAA,CAAM2C,OAAA,EAASzB,CAAA,GAC/B,OAAO;cAAC2sB,MAAA,EAAAvqB,CAAA;cAAQwqB,MAAA,EAAApqB;YAAA,C;;UAO1B,MAAM,IAAIqe,SAAA,CAAU,4BAA4B/hB,CAAA,CAAKs7B,MAAA,kBACjDr7B,CAAA,CAAOkD,GAAA,CAAInD,CAAA,IAAO,GAAGA,CAAA,CAAIshC,MAAA,IAAU,cAActhC,CAAA,CAAI2C,OAAA,IAAWS,IAAA,CAAK,QAC3E;QAAA,C;;;;;;;;QC3CA,MAAA5C,CAAA,GAAAC,CAAA;QAKA,IAAiBC,CAAA,EAAYO,CAAA;QAAZP,CAAA,GAAAT,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,KAAc,UAAAvD,CAAA;UACxC,IAAYC,CAAA;UAAA,CAAZ,UAAYD,CAAA;YACVA,CAAA,CAAAA,CAAA,CAAAqiC,SAAA,qBACAriC,CAAA,CAAAA,CAAA,CAAAkF,KAAA,iBACAlF,CAAA,CAAAA,CAAA,CAAAmF,GAAA,eACAnF,CAAA,CAAAA,CAAA,CAAAoF,MAAA,kBACApF,CAAA,CAAAA,CAAA,CAAAqF,MAAA,kBACArF,CAAA,CAAAA,CAAA,CAAA0F,KAAA,iBACA1F,CAAA,CAAAA,CAAA,CAAAsF,MAAA,kBACAtF,CAAA,CAAAA,CAAA,CAAAuF,IAAA,gBACAvF,CAAA,CAAAA,CAAA,CAAAwF,OAAA,mBACAxF,CAAA,CAAAA,CAAA,CAAAyF,OAAA,mBACAzF,CAAA,CAAAA,CAAA,CAAA2F,MAAA,mBACA3F,CAAA,CAAAA,CAAA,CAAAsiC,aAAA,0BACAtiC,CAAA,CAAAA,CAAA,CAAAuiC,cAAA,yBACD;UAAA,CAdD,CAAYtiC,CAAA,GAAAD,CAAA,CAAAiF,aAAA,KAAAjF,CAAA,CAAAiF,aAAA,GAAa,IAe1B;QAAA,CAhByC,EAAbhE,CAAA,GAAAP,CAAA,CAAA8C,YAAA,KAAA9C,CAAA,CAAA8C,YAAA,GAAY,KAACC,GAAA,KAAAxC,CAAA,CAAAwC,GAAA,GAAG,MAqB7C,UAAiBzD,CAAA;UAAA,CAAY,UAAAA,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,IAAYC,CAAA;cAAA,CAAZ,UAAYD,CAAA;gBAAoBA,CAAA,CAAAA,CAAA,CAAAwiC,OAAA,mBAAaxiC,CAAA,CAAAA,CAAA,CAAAyiC,KAAA,iBAAWziC,CAAA,CAAAA,CAAA,CAAA0iC,KAAA,eAAU;cAAA,CAAlE,CAAYziC,CAAA,GAAAD,CAAA,CAAA2iC,kBAAA,KAAA3iC,CAAA,CAAA2iC,kBAAA,GAAkB,IAC/B;YAAA,CAFyC,CAAA3iC,CAAA,CAAAyD,GAAA,KAAAzD,CAAA,CAAAyD,GAAA,GAAG,IAE5C;UAAA,CAF4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IAExC;QAAA,CAFD,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MAO5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAA,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,IAAYC,CAAA;cAAA,CAAZ,UAAYD,CAAA;gBACVA,CAAA,CAAAA,CAAA,CAAAqiC,SAAA,qBACAriC,CAAA,CAAAA,CAAA,CAAAkF,KAAA,iBACAlF,CAAA,CAAAA,CAAA,CAAA4iC,KAAA,iBACA5iC,CAAA,CAAAA,CAAA,CAAA6iC,IAAA,gBACA7iC,CAAA,CAAAA,CAAA,CAAA8iC,MAAA,kBACA9iC,CAAA,CAAAA,CAAA,CAAA+iC,KAAA,iBACA/iC,CAAA,CAAAA,CAAA,CAAAgjC,KAAA,iBACAhjC,CAAA,CAAAA,CAAA,CAAAijC,KAAA,iBACAjjC,CAAA,CAAAA,CAAA,CAAAoF,MAAA,kBACApF,CAAA,CAAAA,CAAA,CAAAkjC,IAAA,gBACAljC,CAAA,CAAAA,CAAA,CAAAmjC,OAAA,oBACAnjC,CAAA,CAAAA,CAAA,CAAAojC,MAAA,mBACApjC,CAAA,CAAAA,CAAA,CAAAqjC,MAAA,mBACArjC,CAAA,CAAAA,CAAA,CAAAsjC,MAAA,mBACAtjC,CAAA,CAAAA,CAAA,CAAAujC,SAAA,sBACAvjC,CAAA,CAAAA,CAAA,CAAAwjC,UAAA,uBACAxjC,CAAA,CAAAA,CAAA,CAAAyjC,QAAA,qBACAzjC,CAAA,CAAAA,CAAA,CAAA0jC,YAAA,yBACA1jC,CAAA,CAAAA,CAAA,CAAA2jC,cAAA,2BACA3jC,CAAA,CAAAA,CAAA,CAAA4jC,UAAA,uBACA5jC,CAAA,CAAAA,CAAA,CAAA6jC,cAAA,yBACD;cAAA,CAtBD,CAAY5jC,CAAA,GAAAD,CAAA,CAAA8jC,cAAA,KAAA9jC,CAAA,CAAA8jC,cAAA,GAAc,IAuB3B;YAAA,CAxByC,CAAA9jC,CAAA,CAAAyD,GAAA,KAAAzD,CAAA,CAAAyD,GAAA,GAAG,IAwB5C;UAAA,CAxB4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IAwBxC;QAAA,CAxBD,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MA6B5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAA,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,IAAYC,CAAA;cAAA,CAAZ,UAAYD,CAAA;gBAAUA,CAAA,CAAAA,CAAA,CAAA+jC,SAAA,qBAAe/jC,CAAA,CAAAA,CAAA,CAAAgkC,KAAA,eAAU;cAAA,CAA/C,CAAY/jC,CAAA,GAAAD,CAAA,CAAAikC,QAAA,KAAAjkC,CAAA,CAAAikC,QAAA,GAAQ,IACrB;YAAA,CAFyC,CAAAjkC,CAAA,CAAAyD,GAAA,KAAAzD,CAAA,CAAAyD,GAAA,GAAG,IAE5C;UAAA,CAF4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IAExC;QAAA,CAFD,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MAO5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAA,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,IAAYC,CAAA;cAAA,CAAZ,UAAYD,CAAA;gBAAeA,CAAA,CAAAA,CAAA,CAAAkkC,IAAA,gBAAUlkC,CAAA,CAAAA,CAAA,CAAAi9B,WAAA,uBAAiBj9B,CAAA,CAAAA,CAAA,CAAAmkC,aAAA,yBAAmBnkC,CAAA,CAAAA,CAAA,CAAAokC,QAAA,kBAAa;cAAA,CAAtF,CAAYnkC,CAAA,GAAAD,CAAA,CAAAg9B,aAAA,KAAAh9B,CAAA,CAAAg9B,aAAA,GAAa,IAC1B;YAAA,CAFyC,CAAAh9B,CAAA,CAAAyD,GAAA,KAAAzD,CAAA,CAAAyD,GAAA,GAAG,IAE5C;UAAA,CAF4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IAExC;QAAA,CAFD,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MAO5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAC,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,MAAaQ,CAAA;gBAAbmC,YAAA;kBACE,KAAAyhC,EAAA,GAAkC,MAElC,KAAAC,MAAA,GAAS,CAqGX;gBAAA;gBA/FEC,OAAOvkC,CAAA,EAAWC,CAAA;kBAGhB,OAFA,KAAKqkC,MAAA,GAAStkC,CAAA,EACd,KAAKqkC,EAAA,GAAKpkC,CAAA,EACH,IACT;gBAAA;gBAOA,OAAAukC,eAAsBxkC,CAAA,EAA4BC,CAAA;kBAChD,QAAQA,CAAA,IAAO,IAAIQ,CAAA,IAAS8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CAClF;gBAAA;gBAOA,OAAA0kC,2BAAkC1kC,CAAA,EAA4BC,CAAA;kBAE5D,OADAD,CAAA,CAAG2kC,WAAA,CAAY3kC,CAAA,CAAGmsB,QAAA,KAAa3rB,CAAA,CAAAghC,WAAA,CAAYoD,kBAAA,IACnC3kC,CAAA,IAAO,IAAIQ,CAAA,IAAS8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CAClF;gBAAA;gBAOAq9B,IAAIp9B,CAAA,EAAeQ,CAAA;kBACjB,IAAID,CAAA,GAAS,KAAK6jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO9jC,CAAA,IAAUC,CAAA,IAAO,IAAIT,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIqhC,SAAA,IACpCP,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKV,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAS9jC,CAAA,IAAkB,IAARP,CAAA,GAAY,KAAKokC,EAAA,IAC3F,IAClB;gBAAA;gBAKAjH,UAAA;kBACE,IAAIp9B,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAKA,OAAAklC,WAAkBllC,CAAA;kBAChBA,CAAA,CAAQmlC,WAAA,CAAY,EACtB;gBAAA;gBAMA,OAAAC,OAAcplC,CAAA,EAA8BC,CAAA;kBAC1CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAW,EACvC;gBAAA;gBAOA,OAAAqlC,gBAAuBtlC,CAAA,EAA8BC,CAAA;kBACnDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQwlC,SAAA,CAAUvlC,CAAA,CAAKQ,CAAA;kBAEzB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAAC,eAAsB1lC,CAAA,EAA8BC,CAAA;kBAClDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAA0lC,SAAgB3lC,CAAA;kBAEd,OADaA,CAAA,CAAQ4lC,SAAA,EAEvB;gBAAA;gBAEA,OAAAC,YAAmB7lC,CAAA,EAA8BC,CAAA;kBAG/C,OAFAQ,CAAA,CAAMykC,UAAA,CAAWllC,CAAA,GACjBS,CAAA,CAAM2kC,MAAA,CAAOplC,CAAA,EAASC,CAAA,GACfQ,CAAA,CAAMklC,QAAA,CAAS3lC,CAAA,CACxB;gBAAA;cAAA;cAvGWC,CAAA,CAAA6lC,KAAA,GAAKrlC,CAyGnB;YAAA,CA1GyC,CAAAR,CAAA,CAAAwD,GAAA,KAAAxD,CAAA,CAAAwD,GAAA,GAAG,IA0G5C;UAAA,CA1G4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IA0GxC;QAAA,CA1GD,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MA8G5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAC,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,MAAaQ,CAAA;gBAAbmC,YAAA;kBACE,KAAAyhC,EAAA,GAAkC,MAElC,KAAAC,MAAA,GAAS,CA6FX;gBAAA;gBAvFEC,OAAOvkC,CAAA,EAAWC,CAAA;kBAGhB,OAFA,KAAKqkC,MAAA,GAAStkC,CAAA,EACd,KAAKqkC,EAAA,GAAKpkC,CAAA,EACH,IACT;gBAAA;gBAOA,OAAA8lC,mBAA0B/lC,CAAA,EAA4BC,CAAA;kBACpD,QAAQA,CAAA,IAAO,IAAIQ,CAAA,IAAa8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACtF;gBAAA;gBAOA,OAAAgmC,+BAAsChmC,CAAA,EAA4BC,CAAA;kBAEhE,OADAD,CAAA,CAAG2kC,WAAA,CAAY3kC,CAAA,CAAGmsB,QAAA,KAAa3rB,CAAA,CAAAghC,WAAA,CAAYoD,kBAAA,IACnC3kC,CAAA,IAAO,IAAIQ,CAAA,IAAa8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACtF;gBAAA;gBAMAmkB,MAAMlkB,CAAA;kBACJ,IAAIQ,CAAA,GAAS,KAAK4jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO7jC,CAAA,IAAUR,CAAA,IAAO,IAAID,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIwiC,cAAA,IACpC1B,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKT,MAAA,GAAS7jC,CAAA,GAAS,KAAK4jC,EAAA,IAC5D,IAClB;gBAAA;gBAQA6B,WAAWlmC,CAAA;kBACT,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBAKA,OAAAomC,eAAsBpmC,CAAA;kBACpBA,CAAA,CAAQmlC,WAAA,CAAY,EACtB;gBAAA;gBAMA,OAAAkB,SAAgBrmC,CAAA,EAA8BC,CAAA;kBAC5CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAa,EACzC;gBAAA;gBAMA,OAAAqmC,cAAqBtmC,CAAA,EAA8BC,CAAA;kBACjDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAkB,EAC9C;gBAAA;gBAMA,OAAAsmC,aAAoBvmC,CAAA;kBAElB,OADaA,CAAA,CAAQ4lC,SAAA,EAEvB;gBAAA;gBAEA,OAAAY,gBACIxmC,CAAA,EAA8BC,CAAA,EAC9BO,CAAA;kBAIF,OAHAC,CAAA,CAAU2lC,cAAA,CAAepmC,CAAA,GACzBS,CAAA,CAAU4lC,QAAA,CAASrmC,CAAA,EAASC,CAAA,GAC5BQ,CAAA,CAAU6lC,aAAA,CAActmC,CAAA,EAASQ,CAAA,GAC1BC,CAAA,CAAU8lC,YAAA,CAAavmC,CAAA,CAChC;gBAAA;cAAA;cA/FWC,CAAA,CAAA6kC,SAAA,GAASrkC,CAiGvB;YAAA,CAlGyC,CAAAR,CAAA,CAAAwD,GAAA,KAAAxD,CAAA,CAAAwD,GAAA,GAAG,IAkG5C;UAAA,CAlG4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IAkGxC;QAAA,CAlGD,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MAsG5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAC,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,MAAaQ,CAAA;gBAAbmC,YAAA;kBACE,KAAAyhC,EAAA,GAAkC,MAElC,KAAAC,MAAA,GAAS,CA4GX;gBAAA;gBAtGEC,OAAOvkC,CAAA,EAAWC,CAAA;kBAGhB,OAFA,KAAKqkC,MAAA,GAAStkC,CAAA,EACd,KAAKqkC,EAAA,GAAKpkC,CAAA,EACH,IACT;gBAAA;gBAOA,OAAAwmC,wBAA+BzmC,CAAA,EAA4BC,CAAA;kBACzD,QAAQA,CAAA,IAAO,IAAIQ,CAAA,IAAkB8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CAC3F;gBAAA;gBAOA,OAAA0mC,oCAA2C1mC,CAAA,EAA4BC,CAAA;kBAErE,OADAD,CAAA,CAAG2kC,WAAA,CAAY3kC,CAAA,CAAGmsB,QAAA,KAAa3rB,CAAA,CAAAghC,WAAA,CAAYoD,kBAAA,IACnC3kC,CAAA,IAAO,IAAIQ,CAAA,IAAkB8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CAC3F;gBAAA;gBAKA2mC,QAAA;kBACE,IAAI1mC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAkB,KAAKokC,EAAA,CAAIuC,QAAA,CAAS,KAAKtC,MAAA,GAASrkC,CAAA,IACzCD,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIk/B,kBAAA,CAAmBH,OAClE;gBAAA;gBAKAlF,SAAA;kBACE,IAAIt9B,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIwC,SAAA,CAAU,KAAKvC,MAAA,GAAStkC,CAAA,IAAU,KAAKqkC,EAAA,CAAIyC,UAAA,CAAW,GAAG,EACpF;gBAAA;gBAQAC,SAAS/mC,CAAA;kBACP,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBAKA,OAAAgnC,oBAA2BhnC,CAAA;kBACzBA,CAAA,CAAQmlC,WAAA,CAAY,EACtB;gBAAA;gBAMA,OAAA8B,WAAkBhnC,CAAA,EAA8BQ,CAAA;kBAC9CR,CAAA,CAAQinC,YAAA,CAAa,GAAGzmC,CAAA,EAAST,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIk/B,kBAAA,CAAmBH,OAAA,CACnF;gBAAA;gBAMA,OAAA2E,YAAmBnnC,CAAA,EAA8BC,CAAA;kBAC/CD,CAAA,CAAQonC,aAAA,CAAc,GAAGnnC,CAAA,EAAUD,CAAA,CAAQ8mC,UAAA,CAAW,GAAG,GAC3D;gBAAA;gBAMA,OAAAO,YAAmBrnC,CAAA,EAA8BC,CAAA;kBAC/CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAgB,EAC5C;gBAAA;gBAMA,OAAAqnC,kBAAyBtnC,CAAA;kBAEvB,OADaA,CAAA,CAAQ4lC,SAAA,EAEvB;gBAAA;gBAEA,OAAA2B,qBACIvnC,CAAA,EAA8BC,CAAA,EAC9BO,CAAA,EAA4BE,CAAA;kBAK9B,OAJAD,CAAA,CAAeumC,mBAAA,CAAoBhnC,CAAA,GACnCS,CAAA,CAAewmC,UAAA,CAAWjnC,CAAA,EAASC,CAAA,GACnCQ,CAAA,CAAe0mC,WAAA,CAAYnnC,CAAA,EAASQ,CAAA,GACpCC,CAAA,CAAe4mC,WAAA,CAAYrnC,CAAA,EAASU,CAAA,GAC7BD,CAAA,CAAe6mC,iBAAA,CAAkBtnC,CAAA,CAC1C;gBAAA;cAAA;cA9GWC,CAAA,CAAAgmC,cAAA,GAAcxlC,CAgH5B;YAAA,CAjHyC,CAAAR,CAAA,CAAAwD,GAAA,KAAAxD,CAAA,CAAAwD,GAAA,GAAG,IAiH5C;UAAA,CAjH4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IAiHxC;QAAA,CAjHD,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MAqH5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAC,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,MAAaQ,CAAA;gBAAbmC,YAAA;kBACE,KAAAyhC,EAAA,GAAkC,MAElC,KAAAC,MAAA,GAAS,CA4FX;gBAAA;gBAtFEC,OAAOvkC,CAAA,EAAWC,CAAA;kBAGhB,OAFA,KAAKqkC,MAAA,GAAStkC,CAAA,EACd,KAAKqkC,EAAA,GAAKpkC,CAAA,EACH,IACT;gBAAA;gBAOA,OAAAunC,4BAAmCxnC,CAAA,EAA4BC,CAAA;kBAC7D,QAAQA,CAAA,IAAO,IAAIQ,CAAA,IAAsB8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CAC/F;gBAAA;gBAOA,OAAAynC,wCAA+CznC,CAAA,EAA4BC,CAAA;kBAGzE,OADAD,CAAA,CAAG2kC,WAAA,CAAY3kC,CAAA,CAAGmsB,QAAA,KAAa3rB,CAAA,CAAAghC,WAAA,CAAYoD,kBAAA,IACnC3kC,CAAA,IAAO,IAAIQ,CAAA,IAAsB8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CAC/F;gBAAA;gBAKAm9B,SAAA;kBACE,IAAIl9B,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAkB,KAAKokC,EAAA,CAAII,SAAA,CAAU,KAAKH,MAAA,GAASrkC,CAAA,IAC1CD,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIqgC,cAAA,CAAezB,SAC9D;gBAAA;gBAMAv0B,MAAM7N,CAAA;kBACJ,IAAIQ,CAAA,GAAS,KAAK4jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO7jC,CAAA,IAAUR,CAAA,IAAO,IAAID,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIqiC,KAAA,IACpCvB,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKT,MAAA,GAAS7jC,CAAA,GAAS,KAAK4jC,EAAA,IAC5D,IAClB;gBAAA;gBAKA,OAAAqD,wBAA+B1nC,CAAA;kBAC7BA,CAAA,CAAQmlC,WAAA,CAAY,EACtB;gBAAA;gBAMA,OAAAwC,YAAmB1nC,CAAA,EAA8BQ,CAAA;kBAC/CR,CAAA,CAAQ2nC,aAAA,CAAc,GAAGnnC,CAAA,EAAUT,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIqgC,cAAA,CAAezB,SAAA,CACjF;gBAAA;gBAMA,OAAAwF,SAAgB7nC,CAAA,EAA8BC,CAAA;kBAC5CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAa,EACzC;gBAAA;gBAMA,OAAA6nC,sBAA6B9nC,CAAA;kBAE3B,OADaA,CAAA,CAAQ4lC,SAAA,EAEvB;gBAAA;gBAEA,OAAAmC,yBACI/nC,CAAA,EAA8BC,CAAA,EAC9BO,CAAA;kBAIF,OAHAC,CAAA,CAAmBinC,uBAAA,CAAwB1nC,CAAA,GAC3CS,CAAA,CAAmBknC,WAAA,CAAY3nC,CAAA,EAASC,CAAA,GACxCQ,CAAA,CAAmBonC,QAAA,CAAS7nC,CAAA,EAASQ,CAAA,GAC9BC,CAAA,CAAmBqnC,qBAAA,CAAsB9nC,CAAA,CAClD;gBAAA;cAAA;cA9FWC,CAAA,CAAAi9B,kBAAA,GAAkBz8B,CAgGhC;YAAA,CAjGyC,CAAAR,CAAA,CAAAwD,GAAA,KAAAxD,CAAA,CAAAwD,GAAA,GAAG,IAiG5C;UAAA,CAjG4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IAiGxC;QAAA,CAjGD,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MAqG5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAC,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,MAAaQ,CAAA;gBAAbmC,YAAA;kBACE,KAAAyhC,EAAA,GAAkC,MAElC,KAAAC,MAAA,GAAS,CA2FX;gBAAA;gBArFEC,OAAOvkC,CAAA,EAAWC,CAAA;kBAGhB,OAFA,KAAKqkC,MAAA,GAAStkC,CAAA,EACd,KAAKqkC,EAAA,GAAKpkC,CAAA,EACH,IACT;gBAAA;gBAOA,OAAA+nC,iBAAwBhoC,CAAA,EAA4BC,CAAA;kBAClD,QAAQA,CAAA,IAAO,IAAIQ,CAAA,IAAW8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACpF;gBAAA;gBAOA,OAAAioC,6BAAoCjoC,CAAA,EAA4BC,CAAA;kBAE9D,OADAD,CAAA,CAAG2kC,WAAA,CAAY3kC,CAAA,CAAGmsB,QAAA,KAAa3rB,CAAA,CAAAghC,WAAA,CAAYoD,kBAAA,IACnC3kC,CAAA,IAAO,IAAIQ,CAAA,IAAW8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACpF;gBAAA;gBAKAkoC,QAAA;kBACE,IAAIjoC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAkB,KAAKokC,EAAA,CAAII,SAAA,CAAU,KAAKH,MAAA,GAASrkC,CAAA,IAC1CD,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIqgC,cAAA,CAAezB,SAC9D;gBAAA;gBAMAtF,UAAU98B,CAAA;kBACR,IAAIQ,CAAA,GAAS,KAAK4jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO7jC,CAAA,IAAUR,CAAA,IAAO,IAAID,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAI0kC,QAAA,IACpC5D,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKT,MAAA,GAAS7jC,CAAA,GAAS,KAAK4jC,EAAA,IAC5D,IAClB;gBAAA;gBAKA,OAAA+D,aAAoBpoC,CAAA;kBAClBA,CAAA,CAAQmlC,WAAA,CAAY,EACtB;gBAAA;gBAMA,OAAAkD,WAAkBpoC,CAAA,EAA8BQ,CAAA;kBAC9CR,CAAA,CAAQ2nC,aAAA,CAAc,GAAGnnC,CAAA,EAAST,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIqgC,cAAA,CAAezB,SAAA,CAChF;gBAAA;gBAMA,OAAAiG,aAAoBtoC,CAAA,EAA8BC,CAAA;kBAChDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAiB,EAC7C;gBAAA;gBAMA,OAAAsoC,WAAkBvoC,CAAA;kBAEhB,OADaA,CAAA,CAAQ4lC,SAAA,EAEvB;gBAAA;gBAEA,OAAA4C,cACIxoC,CAAA,EAA8BC,CAAA,EAC9BO,CAAA;kBAIF,OAHAC,CAAA,CAAQ2nC,YAAA,CAAapoC,CAAA,GACrBS,CAAA,CAAQ4nC,UAAA,CAAWroC,CAAA,EAASC,CAAA,GAC5BQ,CAAA,CAAQ6nC,YAAA,CAAatoC,CAAA,EAASQ,CAAA,GACvBC,CAAA,CAAQ8nC,UAAA,CAAWvoC,CAAA,CAC5B;gBAAA;cAAA;cA7FWC,CAAA,CAAAwoC,OAAA,GAAOhoC,CA+FrB;YAAA,CAhGyC,CAAAR,CAAA,CAAAwD,GAAA,KAAAxD,CAAA,CAAAwD,GAAA,GAAG,IAgG5C;UAAA,CAhG4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IAgGxC;QAAA,CAhGD,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MAoG5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAC,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,MAAaQ,CAAA;gBAAbmC,YAAA;kBACE,KAAAyhC,EAAA,GAAkC,MAElC,KAAAC,MAAA,GAAS,CAuEX;gBAAA;gBAjEEC,OAAOvkC,CAAA,EAAWC,CAAA;kBAGhB,OAFA,KAAKqkC,MAAA,GAAStkC,CAAA,EACd,KAAKqkC,EAAA,GAAKpkC,CAAA,EACH,IACT;gBAAA;gBAOA,OAAAyoC,sBAA6B1oC,CAAA,EAA4BC,CAAA;kBACvD,QAAQA,CAAA,IAAO,IAAIQ,CAAA,IAAgB8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACzF;gBAAA;gBAOA,OAAA2oC,kCAAyC3oC,CAAA,EAA4BC,CAAA;kBAEnE,OADAD,CAAA,CAAG2kC,WAAA,CAAY3kC,CAAA,CAAGmsB,QAAA,KAAa3rB,CAAA,CAAAghC,WAAA,CAAYoD,kBAAA,IACnC3kC,CAAA,IAAO,IAAIQ,CAAA,IAAgB8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACzF;gBAAA;gBAMAm9B,SAASl9B,CAAA;kBACP,IAAIQ,CAAA,GAAS,KAAK4jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO7jC,CAAA,IAAUR,CAAA,IAAO,IAAID,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAI0kC,QAAA,IACpC5D,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKT,MAAA,GAAS7jC,CAAA,GAAS,KAAK4jC,EAAA,IAC5D,IAClB;gBAAA;gBAKA,OAAAuE,kBAAyB5oC,CAAA;kBACvBA,CAAA,CAAQmlC,WAAA,CAAY,EACtB;gBAAA;gBAMA,OAAAwC,YAAmB3nC,CAAA,EAA8BC,CAAA;kBAC/CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAgB,EAC5C;gBAAA;gBAMA,OAAA4oC,gBAAuB7oC,CAAA;kBAErB,OADaA,CAAA,CAAQ4lC,SAAA,EAEvB;gBAAA;gBAEA,OAAAkD,mBAA0B9oC,CAAA,EAA8BC,CAAA;kBAGtD,OAFAQ,CAAA,CAAamoC,iBAAA,CAAkB5oC,CAAA,GAC/BS,CAAA,CAAaknC,WAAA,CAAY3nC,CAAA,EAASC,CAAA,GAC3BQ,CAAA,CAAaooC,eAAA,CAAgB7oC,CAAA,CACtC;gBAAA;cAAA;cAzEWC,CAAA,CAAA8oC,YAAA,GAAYtoC,CA2E1B;YAAA,CA5EyC,CAAAR,CAAA,CAAAwD,GAAA,KAAAxD,CAAA,CAAAwD,GAAA,GAAG,IA4E5C;UAAA,CA5E4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IA4ExC;QAAA,CA5ED,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MAgF5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAA,CAAA;YAAA,CAAaA,CAAA,CAAAyD,GAAA,KAAAzD,CAAA,CAAAyD,GAAA,GAAG,KAC9BulC,OAAA,GAAb;cAAApmC,YAAA;gBACE,KAAAyhC,EAAA,GAAkC,MAElC,KAAAC,MAAA,GAAS,CAiDX;cAAA;cA3CEC,OAAOvkC,CAAA,EAAWC,CAAA;gBAGhB,OAFA,KAAKqkC,MAAA,GAAStkC,CAAA,EACd,KAAKqkC,EAAA,GAAKpkC,CAAA,EACH,IACT;cAAA;cAKAgpC,UAAA;gBACE,OAAO,KAAK5E,EAAA,CAAI6E,UAAA,CAAW,KAAK5E,MAAA,CAClC;cAAA;cAKA6E,YAAA;gBACE,OAAO,KAAK9E,EAAA,CAAII,SAAA,CAAU,KAAKH,MAAA,GAAS,EAC1C;cAAA;cAKA8E,YAAA;gBACE,OAAO,KAAK/E,EAAA,CAAII,SAAA,CAAU,KAAKH,MAAA,GAAS,EAC1C;cAAA;cASA,OAAA+E,cACIrpC,CAAA,EAA8BC,CAAA,EAAoBQ,CAAA,EAClDD,CAAA;gBAKF,OAJAR,CAAA,CAAQspC,IAAA,CAAK,GAAG,KAChBtpC,CAAA,CAAQupC,UAAA,CAAW/oC,CAAA,GACnBR,CAAA,CAAQupC,UAAA,CAAW9oC,CAAA,GACnBT,CAAA,CAAQupC,UAAA,CAAWtpC,CAAA,GACZD,CAAA,CAAQwpC,MAAA,EACjB;cAAA;YAAA,CAEH;UAAA,CAtD4B,CAAAxpC,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IAsDxC;QAAA,CAtDD,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MA0D5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAC,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,MAAaQ,CAAA;gBAAbmC,YAAA;kBACE,KAAAyhC,EAAA,GAAkC,MAElC,KAAAC,MAAA,GAAS,CAgJX;gBAAA;gBA1IEC,OAAOvkC,CAAA,EAAWC,CAAA;kBAGhB,OAFA,KAAKqkC,MAAA,GAAStkC,CAAA,EACd,KAAKqkC,EAAA,GAAKpkC,CAAA,EACH,IACT;gBAAA;gBAOA,OAAAwpC,kBAAyBzpC,CAAA,EAA4BC,CAAA;kBACnD,QAAQA,CAAA,IAAO,IAAIQ,CAAA,IAAY8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACrF;gBAAA;gBAOA,OAAA0pC,8BAAqC1pC,CAAA,EAA4BC,CAAA;kBAE/D,OADAD,CAAA,CAAG2kC,WAAA,CAAY3kC,CAAA,CAAGmsB,QAAA,KAAa3rB,CAAA,CAAAghC,WAAA,CAAYoD,kBAAA,IACnC3kC,CAAA,IAAO,IAAIQ,CAAA,IAAY8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACrF;gBAAA;gBAKAipC,UAAA;kBACE,IAAIjpC,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAI6E,UAAA,CAAW,KAAK5E,MAAA,GAAStkC,CAAA,IAAU,CAC9D;gBAAA;gBAOA2pC,WAAW1pC,CAAA,EAAeQ,CAAA;kBACxB,IAAID,CAAA,GAAS,KAAK6jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO9jC,CAAA,IAAUC,CAAA,IAAO,IAAIT,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIulC,OAAA,IACpCzE,MAAA,CAAO,KAAKF,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAS9jC,CAAA,IAAkB,KAARP,CAAA,EAAY,KAAKokC,EAAA,IACvE,IAClB;gBAAA;gBAKAuF,iBAAA;kBACE,IAAI5pC,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAOA6pC,YAAY5pC,CAAA,EAAeQ,CAAA;kBACzB,IAAID,CAAA,GAAS,KAAK6jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO9jC,CAAA,IAAUC,CAAA,IAAO,IAAIT,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIulC,OAAA,IACpCzE,MAAA,CAAO,KAAKF,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAS9jC,CAAA,IAAkB,KAARP,CAAA,EAAY,KAAKokC,EAAA,IACvE,IAClB;gBAAA;gBAKAyF,kBAAA;kBACE,IAAI9pC,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAKA,OAAA+pC,cAAqB/pC,CAAA;kBACnBA,CAAA,CAAQmlC,WAAA,CAAY,EACtB;gBAAA;gBAMA,OAAA6E,aAAoBhqC,CAAA,EAA8BC,CAAA;kBAChDD,CAAA,CAAQ4nC,aAAA,CAAc,GAAG3nC,CAAA,EAAW,EACtC;gBAAA;gBAMA,OAAAgqC,cAAqBjqC,CAAA,EAA8BC,CAAA;kBACjDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAkB,EAC9C;gBAAA;gBAMA,OAAAiqC,sBAA6BlqC,CAAA,EAA8BC,CAAA;kBACzDD,CAAA,CAAQulC,WAAA,CAAY,IAAItlC,CAAA,EAAU,EACpC;gBAAA;gBAMA,OAAAkqC,eAAsBnqC,CAAA,EAA8BC,CAAA;kBAClDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAmB,EAC/C;gBAAA;gBAMA,OAAAmqC,uBAA8BpqC,CAAA,EAA8BC,CAAA;kBAC1DD,CAAA,CAAQulC,WAAA,CAAY,IAAItlC,CAAA,EAAU,EACpC;gBAAA;gBAMA,OAAAoqC,YAAmBrqC,CAAA;kBAEjB,OADaA,CAAA,CAAQ4lC,SAAA,EAEvB;gBAAA;gBAEA,OAAA0E,eACItqC,CAAA,EAA8BC,CAAA,EAAmBO,CAAA,EACjDE,CAAA;kBAKF,OAJAD,CAAA,CAASspC,aAAA,CAAc/pC,CAAA,GACvBS,CAAA,CAASupC,YAAA,CAAahqC,CAAA,EAASC,CAAA,GAC/BQ,CAAA,CAASwpC,aAAA,CAAcjqC,CAAA,EAASQ,CAAA,GAChCC,CAAA,CAAS0pC,cAAA,CAAenqC,CAAA,EAASU,CAAA,GAC1BD,CAAA,CAAS4pC,WAAA,CAAYrqC,CAAA,CAC9B;gBAAA;cAAA;cAlJWC,CAAA,CAAAsqC,QAAA,GAAQ9pC,CAoJtB;YAAA,CArJyC,CAAAR,CAAA,CAAAwD,GAAA,KAAAxD,CAAA,CAAAwD,GAAA,GAAG,IAqJ5C;UAAA,CArJ4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IAqJxC;QAAA,CArJD,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MAyJ5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAC,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,MAAaQ,CAAA;gBAAbmC,YAAA;kBACE,KAAAyhC,EAAA,GAAkC,MAElC,KAAAC,MAAA,GAAS,CAodX;gBAAA;gBA9cEC,OAAOvkC,CAAA,EAAWC,CAAA;kBAGhB,OAFA,KAAKqkC,MAAA,GAAStkC,CAAA,EACd,KAAKqkC,EAAA,GAAKpkC,CAAA,EACH,IACT;gBAAA;gBAOA,OAAAuqC,cAAqBxqC,CAAA,EAA4BC,CAAA;kBAC/C,QAAQA,CAAA,IAAO,IAAIQ,CAAA,IAAQ8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACjF;gBAAA;gBAOA,OAAAyqC,0BAAiCzqC,CAAA,EAA4BC,CAAA;kBAE3D,OADAD,CAAA,CAAG2kC,WAAA,CAAY3kC,CAAA,CAAGmsB,QAAA,KAAa3rB,CAAA,CAAAghC,WAAA,CAAYoD,kBAAA,IACnC3kC,CAAA,IAAO,IAAIQ,CAAA,IAAQ8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACjF;gBAAA;gBAQAgE,KAAKhE,CAAA;kBACH,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBAQA0qC,UAAU1qC,CAAA;kBACR,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBAQAshC,OAAOthC,CAAA;kBACL,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBAKA2qC,aAAA;kBACE,IAAI3qC,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAII,SAAA,CAAU,KAAKH,MAAA,GAAStkC,CAAA,IAAU,CAC7D;gBAAA;gBAKA4qC,MAAA;kBACE,IAAI5qC,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAI6E,UAAA,CAAW,KAAK5E,MAAA,GAAStkC,CAAA,IAAU,CAC9D;gBAAA;gBAQAs7B,OAAOt7B,CAAA;kBACL,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBAKAgF,KAAA;kBACE,IAAI/E,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAkB,KAAKokC,EAAA,CAAII,SAAA,CAAU,KAAKH,MAAA,GAASrkC,CAAA,IAC1CD,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIwgC,QAAA,CAASF,SACxD;gBAAA;gBAQA8G,sBAAsB7qC,CAAA;kBACpB,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBASA4pB,OAAO5pB,CAAA,EAAeC,CAAA;kBACpB,IAAIQ,CAAA,GAAS,KAAK4jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO7jC,CAAA,GAAS,KAAK4jC,EAAA,CAAI8B,QAAA,CAAS,KAAK9B,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAS7jC,CAAA,IAAkB,IAART,CAAA,EAAWC,CAAA,IAAoB,IAC7G;gBAAA;gBAKA28B,aAAA;kBACE,IAAI58B,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBASAunB,QAAQvnB,CAAA,EAAeC,CAAA;kBACrB,IAAIQ,CAAA,GAAS,KAAK4jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO7jC,CAAA,GAAS,KAAK4jC,EAAA,CAAI8B,QAAA,CAAS,KAAK9B,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAS7jC,CAAA,IAAkB,IAART,CAAA,EAAWC,CAAA,IAAoB,IAC7G;gBAAA;gBAKAw9B,cAAA;kBACE,IAAIz9B,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAOA4d,WAAW3d,CAAA,EAAeQ,CAAA;kBAExB,IAAID,CAAA,GAAS,KAAK6jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO9jC,CAAA,IAAUC,CAAA,IAAO,IAAIT,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIU,SAAA,IACpCogC,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKV,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAS9jC,CAAA,IAAkB,IAARP,CAAA,GAAY,KAAKokC,EAAA,IAC3F,IAClB;gBAAA;gBAKAzG,iBAAA;kBACE,IAAI59B,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAMA8qC,eAAe9qC,CAAA;kBACb,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAII,SAAA,CAAU,KAAKJ,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAASrkC,CAAA,IAAkB,IAARD,CAAA,IAAa,CAC5F;gBAAA;gBAKA+qC,qBAAA;kBACE,IAAI/qC,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAKAgrC,oBAAA;kBACE,IAAIhrC,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GACH,IAAI2mB,UAAA,CACA,KAAK0d,EAAA,CAAI4G,KAAA,GAAQrc,MAAA,EAAQ,KAAKyV,EAAA,CAAI4G,KAAA,GAAQpc,UAAA,GAAa,KAAKwV,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAStkC,CAAA,GACvF,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,KACxC,IACN;gBAAA;gBASAkrC,eAAelrC,CAAA,EAAeC,CAAA;kBAC5B,IAAIQ,CAAA,GAAS,KAAK4jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO7jC,CAAA,GAAS,KAAK4jC,EAAA,CAAI8B,QAAA,CAAS,KAAK9B,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAS7jC,CAAA,IAAkB,IAART,CAAA,EAAWC,CAAA,IAAoB,IAC7G;gBAAA;gBAKAkrC,qBAAA;kBACE,IAAInrC,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAKA,OAAAorC,UAAiBprC,CAAA;kBACfA,CAAA,CAAQmlC,WAAA,CAAY,GACtB;gBAAA;gBAMA,OAAAkG,QAAerrC,CAAA,EAA8BC,CAAA;kBAC3CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAY,EACxC;gBAAA;gBAMA,OAAAqrC,aAAoBtrC,CAAA,EAA8BC,CAAA;kBAChDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAiB,EAC7C;gBAAA;gBAMA,OAAAsrC,UAAiBvrC,CAAA,EAA8BC,CAAA;kBAC7CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAc,EAC1C;gBAAA;gBAMA,OAAAurC,gBAAuBxrC,CAAA,EAA8BC,CAAA;kBACnDD,CAAA,CAAQ4nC,aAAA,CAAc,GAAG3nC,CAAA,EAAc,EACzC;gBAAA;gBAMA,OAAAwrC,SAAgBzrC,CAAA,EAA8BC,CAAA;kBAC5CD,CAAA,CAAQ4nC,aAAA,CAAc,GAAG3nC,CAAA,EAAO,EAClC;gBAAA;gBAMA,OAAAyrC,UAAiB1rC,CAAA,EAA8BC,CAAA;kBAC7CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAc,EAC1C;gBAAA;gBAMA,OAAA0rC,QAAe1rC,CAAA,EAA8BQ,CAAA;kBAC3CR,CAAA,CAAQ2nC,aAAA,CAAc,GAAGnnC,CAAA,EAAMT,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIwgC,QAAA,CAASF,SAAA,CACvE;gBAAA;gBAMA,OAAA6H,yBAAgC5rC,CAAA,EAA8BC,CAAA;kBAC5DD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAA6B,EACzD;gBAAA;gBAMA,OAAA4rC,UAAiB7rC,CAAA,EAA8BC,CAAA;kBAC7CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAc,EAC1C;gBAAA;gBAOA,OAAA6rC,mBAA0B9rC,CAAA,EAA8BC,CAAA;kBACtDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQwlC,SAAA,CAAUvlC,CAAA,CAAKQ,CAAA;kBAEzB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAAsG,kBAAyB/rC,CAAA,EAA8BC,CAAA;kBACrDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAA+rC,WAAkBhsC,CAAA,EAA8BC,CAAA;kBAC9CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAe,EAC3C;gBAAA;gBAOA,OAAAgsC,oBAA2BjsC,CAAA,EAA8BC,CAAA;kBACvDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQwlC,SAAA,CAAUvlC,CAAA,CAAKQ,CAAA;kBAEzB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAAyG,mBAA0BlsC,CAAA,EAA8BC,CAAA;kBACtDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAAksC,cAAqBnsC,CAAA,EAA8BC,CAAA;kBACjDD,CAAA,CAAQqlC,cAAA,CAAe,IAAIplC,CAAA,EAAkB,EAC/C;gBAAA;gBAOA,OAAAmsC,uBAA8BpsC,CAAA,EAA8BC,CAAA;kBAC1DD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQwlC,SAAA,CAAUvlC,CAAA,CAAKQ,CAAA;kBAEzB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAA4G,sBAA6BrsC,CAAA,EAA8BC,CAAA;kBACzDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAAqsC,kBAAyBtsC,CAAA,EAA8BC,CAAA;kBACrDD,CAAA,CAAQqlC,cAAA,CAAe,IAAIplC,CAAA,EAAsB,EACnD;gBAAA;gBAOA,OAAAssC,2BAAkCvsC,CAAA,EAA8BC,CAAA;kBAC9DD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQwsC,QAAA,CAASvsC,CAAA,CAAKQ,CAAA;kBAExB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAAgH,0BAAiCzsC,CAAA,EAA8BC,CAAA;kBAC7DD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAAysC,kBAAyB1sC,CAAA,EAA8BC,CAAA;kBACrDD,CAAA,CAAQqlC,cAAA,CAAe,IAAIplC,CAAA,EAAsB,EACnD;gBAAA;gBAOA,OAAA0sC,2BAAkC3sC,CAAA,EAA8BC,CAAA;kBAC9DD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQwlC,SAAA,CAAUvlC,CAAA,CAAKQ,CAAA;kBAEzB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAAmH,0BAAiC5sC,CAAA,EAA8BC,CAAA;kBAC7DD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAA4sC,QAAe7sC,CAAA;kBAEb,OADaA,CAAA,CAAQ4lC,SAAA,EAEvB;gBAAA;gBAEA,OAAAkH,WACI9sC,CAAA,EAA8BC,CAAA,EAAgCO,CAAA,EAC9DE,CAAA,EAAkCO,CAAA,EAAsBC,CAAA,EAAeoC,CAAA,EACvEI,CAAA,EAA6C+G,CAAA,EAC7CY,CAAA,EAAkCC,CAAA,EAAmCC,CAAA,EACrEhF,CAAA,EAA0CmF,CAAA;kBAe5C,OAdAjL,CAAA,CAAK2qC,SAAA,CAAUprC,CAAA,GACfS,CAAA,CAAK4qC,OAAA,CAAQrrC,CAAA,EAASC,CAAA,GACtBQ,CAAA,CAAK6qC,YAAA,CAAatrC,CAAA,EAASQ,CAAA,GAC3BC,CAAA,CAAK8qC,SAAA,CAAUvrC,CAAA,EAASU,CAAA,GACxBD,CAAA,CAAK+qC,eAAA,CAAgBxrC,CAAA,EAASiB,CAAA,GAC9BR,CAAA,CAAKgrC,QAAA,CAASzrC,CAAA,EAASkB,CAAA,GACvBT,CAAA,CAAKirC,SAAA,CAAU1rC,CAAA,EAASsD,CAAA,GACxB7C,CAAA,CAAKkrC,OAAA,CAAQ3rC,CAAA,EAAS0D,CAAA,GACtBjD,CAAA,CAAKmrC,wBAAA,CAAyB5rC,CAAA,EAASyK,CAAA,GACvChK,CAAA,CAAKorC,SAAA,CAAU7rC,CAAA,EAASqL,CAAA,GACxB5K,CAAA,CAAKurC,UAAA,CAAWhsC,CAAA,EAASsL,CAAA,GACzB7K,CAAA,CAAK0rC,aAAA,CAAcnsC,CAAA,EAASuL,CAAA,GAC5B9K,CAAA,CAAK6rC,iBAAA,CAAkBtsC,CAAA,EAASuG,CAAA,GAChC9F,CAAA,CAAKisC,iBAAA,CAAkB1sC,CAAA,EAAS0L,CAAA,GACzBjL,CAAA,CAAKosC,OAAA,CAAQ7sC,CAAA,CACtB;gBAAA;cAAA;cAtdWC,CAAA,CAAAs7B,IAAA,GAAI96B,CAwdlB;YAAA,CAzdyC,CAAAR,CAAA,CAAAwD,GAAA,KAAAxD,CAAA,CAAAwD,GAAA,GAAG,IAyd5C;UAAA,CAzd4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IAydxC;QAAA,CAzdD,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MA6d5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAC,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,MAAaQ,CAAA;gBAAbmC,YAAA;kBACE,KAAAyhC,EAAA,GAAkC,MAElC,KAAAC,MAAA,GAAS,CAiHX;gBAAA;gBA3GEC,OAAOvkC,CAAA,EAAWC,CAAA;kBAGhB,OAFA,KAAKqkC,MAAA,GAAStkC,CAAA,EACd,KAAKqkC,EAAA,GAAKpkC,CAAA,EACH,IACT;gBAAA;gBAOA,OAAA8sC,mBAA0B/sC,CAAA,EAA4BC,CAAA;kBACpD,QAAQA,CAAA,IAAO,IAAIQ,CAAA,IAAa8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACtF;gBAAA;gBAOA,OAAAgtC,+BAAsChtC,CAAA,EAA4BC,CAAA;kBAEhE,OADAD,CAAA,CAAG2kC,WAAA,CAAY3kC,CAAA,CAAGmsB,QAAA,KAAa3rB,CAAA,CAAAghC,WAAA,CAAYoD,kBAAA,IACnC3kC,CAAA,IAAO,IAAIQ,CAAA,IAAa8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACtF;gBAAA;gBAQAgE,KAAKhE,CAAA;kBACH,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBAQA0qC,UAAU1qC,CAAA;kBACR,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBAMAgF,KAAK/E,CAAA;kBACH,IAAIQ,CAAA,GAAS,KAAK4jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO7jC,CAAA,IAAUR,CAAA,IAAO,IAAID,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAI0kC,QAAA,IACpC5D,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKT,MAAA,GAAS7jC,CAAA,GAAS,KAAK4jC,EAAA,IAC5D,IAClB;gBAAA;gBAKA,OAAA4I,eAAsBjtC,CAAA;kBACpBA,CAAA,CAAQmlC,WAAA,CAAY,EACtB;gBAAA;gBAMA,OAAAkG,QAAerrC,CAAA,EAA8BC,CAAA;kBAC3CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAY,EACxC;gBAAA;gBAMA,OAAAqrC,aAAoBtrC,CAAA,EAA8BC,CAAA;kBAChDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAiB,EAC7C;gBAAA;gBAMA,OAAA0rC,QAAe3rC,CAAA,EAA8BC,CAAA;kBAC3CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAY,EACxC;gBAAA;gBAMA,OAAAitC,aAAoBltC,CAAA;kBAElB,OADaA,CAAA,CAAQ4lC,SAAA,EAEvB;gBAAA;gBAEA,OAAAuH,gBACIntC,CAAA,EAA8BC,CAAA,EAAgCO,CAAA,EAC9DE,CAAA;kBAKF,OAJAD,CAAA,CAAUwsC,cAAA,CAAejtC,CAAA,GACzBS,CAAA,CAAU4qC,OAAA,CAAQrrC,CAAA,EAASC,CAAA,GAC3BQ,CAAA,CAAU6qC,YAAA,CAAatrC,CAAA,EAASQ,CAAA,GAChCC,CAAA,CAAUkrC,OAAA,CAAQ3rC,CAAA,EAASU,CAAA,GACpBD,CAAA,CAAUysC,YAAA,CAAaltC,CAAA,CAChC;gBAAA;cAAA;cAnHWC,CAAA,CAAAmtC,SAAA,GAAS3sC,CAqHvB;YAAA,CAtHyC,CAAAR,CAAA,CAAAwD,GAAA,KAAAxD,CAAA,CAAAwD,GAAA,GAAG,IAsH5C;UAAA,CAtH4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IAsHxC;QAAA,CAtHD,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MA0H5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAC,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,MAAaQ,CAAA;gBAAbmC,YAAA;kBACE,KAAAyhC,EAAA,GAAkC,MAElC,KAAAC,MAAA,GAAS,CA6GX;gBAAA;gBAvGEC,OAAOvkC,CAAA,EAAWC,CAAA;kBAGhB,OAFA,KAAKqkC,MAAA,GAAStkC,CAAA,EACd,KAAKqkC,EAAA,GAAKpkC,CAAA,EACH,IACT;gBAAA;gBAOA,OAAAotC,kBAAyBrtC,CAAA,EAA4BC,CAAA;kBACnD,QAAQA,CAAA,IAAO,IAAIQ,CAAA,IAAY8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACrF;gBAAA;gBAOA,OAAAstC,8BAAqCttC,CAAA,EAA4BC,CAAA;kBAE/D,OADAD,CAAA,CAAG2kC,WAAA,CAAY3kC,CAAA,CAAGmsB,QAAA,KAAa3rB,CAAA,CAAAghC,WAAA,CAAYoD,kBAAA,IACnC3kC,CAAA,IAAO,IAAIQ,CAAA,IAAY8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACrF;gBAAA;gBAQAkmC,WAAWlmC,CAAA;kBACT,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBAKA+8B,UAAA;kBACE,IAAI98B,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAkB,KAAKokC,EAAA,CAAIkJ,SAAA,CAAU,KAAKjJ,MAAA,GAASrkC,CAAA,IAC1CD,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIu5B,aAAA,CAAckH,IAC7D;gBAAA;gBAMA/f,MAAmCnkB,CAAA;kBACjC,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAImJ,OAAA,CAAQxtC,CAAA,EAAK,KAAKskC,MAAA,GAASrkC,CAAA,IAAU,IAChE;gBAAA;gBAKA,OAAAwtC,cAAqBztC,CAAA;kBACnBA,CAAA,CAAQmlC,WAAA,CAAY,EACtB;gBAAA;gBAMA,OAAAmB,cAAqBtmC,CAAA,EAA8BC,CAAA;kBACjDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAkB,EAC9C;gBAAA;gBAMA,OAAAqoC,aAAoBroC,CAAA,EAA8BQ,CAAA;kBAChDR,CAAA,CAAQinC,YAAA,CAAa,GAAGzmC,CAAA,EAAWT,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIu5B,aAAA,CAAckH,IAAA,CAChF;gBAAA;gBAMA,OAAAmC,SAAgBrmC,CAAA,EAA8BC,CAAA;kBAC5CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAa,EACzC;gBAAA;gBAMA,OAAAytC,YAAmB1tC,CAAA;kBAEjB,OADaA,CAAA,CAAQ4lC,SAAA,EAEvB;gBAAA;gBAEA,OAAA+H,eACI3tC,CAAA,EAA8BC,CAAA,EAC9BO,CAAA,EAAuDE,CAAA;kBAKzD,OAJAD,CAAA,CAASgtC,aAAA,CAAcztC,CAAA,GACvBS,CAAA,CAAS6lC,aAAA,CAActmC,CAAA,EAASC,CAAA,GAChCQ,CAAA,CAAS6nC,YAAA,CAAatoC,CAAA,EAASQ,CAAA,GAC/BC,CAAA,CAAS4lC,QAAA,CAASrmC,CAAA,EAASU,CAAA,GACpBD,CAAA,CAASitC,WAAA,CAAY1tC,CAAA,CAC9B;gBAAA;cAAA;cA/GWC,CAAA,CAAAkoC,QAAA,GAAQ1nC,CAiHtB;YAAA,CAlHyC,CAAAR,CAAA,CAAAwD,GAAA,KAAAxD,CAAA,CAAAwD,GAAA,GAAG,IAkH5C;UAAA,CAlH4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IAkHxC;QAAA,CAlHD,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MAsH5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAA,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,MAAaC,CAAA;gBAAb2C,YAAA;kBACE,KAAAyhC,EAAA,GAAkC,MAElC,KAAAC,MAAA,GAAS,CAyFX;gBAAA;gBAnFEC,OAAOvkC,CAAA,EAAWC,CAAA;kBAGhB,OAFA,KAAKqkC,MAAA,GAAStkC,CAAA,EACd,KAAKqkC,EAAA,GAAKpkC,CAAA,EACH,IACT;gBAAA;gBAOA,OAAA2tC,uBAA8B5tC,CAAA,EAA4BS,CAAA;kBACxD,QAAQA,CAAA,IAAO,IAAIR,CAAA,IAAiBskC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CAC1F;gBAAA;gBAOA,OAAA6tC,mCAA0C7tC,CAAA,EAA4BS,CAAA;kBAEpE,OADAT,CAAA,CAAG2kC,WAAA,CAAY3kC,CAAA,CAAGmsB,QAAA,KAAa3rB,CAAA,CAAAghC,WAAA,CAAYoD,kBAAA,IACnCnkC,CAAA,IAAO,IAAIR,CAAA,IAAiBskC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CAC1F;gBAAA;gBAQAshC,OAAOthC,CAAA;kBACL,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBAKA2C,QAAA;kBACE,IAAI3C,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIwC,SAAA,CAAU,KAAKvC,MAAA,GAAStkC,CAAA,IAAU,KAAKqkC,EAAA,CAAIyC,UAAA,CAAW,GAAG,EACpF;gBAAA;gBAKA,OAAAgH,mBAA0B9tC,CAAA;kBACxBA,CAAA,CAAQmlC,WAAA,CAAY,EACtB;gBAAA;gBAMA,OAAAoG,UAAiBvrC,CAAA,EAA8BC,CAAA;kBAC7CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAc,EAC1C;gBAAA;gBAMA,OAAA8tC,WAAkB/tC,CAAA,EAA8BC,CAAA;kBAC9CD,CAAA,CAAQonC,aAAA,CAAc,GAAGnnC,CAAA,EAASD,CAAA,CAAQ8mC,UAAA,CAAW,GAAG,GAC1D;gBAAA;gBAMA,OAAAkH,iBAAwBhuC,CAAA;kBAEtB,OADaA,CAAA,CAAQ4lC,SAAA,EAEvB;gBAAA;gBAEA,OAAAqI,oBACIjuC,CAAA,EAA8BS,CAAA,EAAkCD,CAAA;kBAIlE,OAHAP,CAAA,CAAc6tC,kBAAA,CAAmB9tC,CAAA,GACjCC,CAAA,CAAcsrC,SAAA,CAAUvrC,CAAA,EAASS,CAAA,GACjCR,CAAA,CAAc8tC,UAAA,CAAW/tC,CAAA,EAASQ,CAAA,GAC3BP,CAAA,CAAc+tC,gBAAA,CAAiBhuC,CAAA,CACxC;gBAAA;cAAA;cA3FWA,CAAA,CAAAkuC,aAAA,GAAajuC,CA6F3B;YAAA,CA9FyC,CAAAD,CAAA,CAAAyD,GAAA,KAAAzD,CAAA,CAAAyD,GAAA,GAAG,IA8F5C;UAAA,CA9F4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IA8FxC;QAAA,CA9FD,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MAkG5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAC,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,MAAaQ,CAAA;gBAAbmC,YAAA;kBACE,KAAAyhC,EAAA,GAAkC,MAElC,KAAAC,MAAA,GAAS,CA6QX;gBAAA;gBAvQEC,OAAOvkC,CAAA,EAAWC,CAAA;kBAGhB,OAFA,KAAKqkC,MAAA,GAAStkC,CAAA,EACd,KAAKqkC,EAAA,GAAKpkC,CAAA,EACH,IACT;gBAAA;gBAOA,OAAAkuC,gBAAuBnuC,CAAA,EAA4BC,CAAA;kBACjD,QAAQA,CAAA,IAAO,IAAIQ,CAAA,IAAU8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACnF;gBAAA;gBAOA,OAAAouC,4BAAmCpuC,CAAA,EAA4BC,CAAA;kBAE7D,OADAD,CAAA,CAAG2kC,WAAA,CAAY3kC,CAAA,CAAGmsB,QAAA,KAAa3rB,CAAA,CAAAghC,WAAA,CAAYoD,kBAAA,IACnC3kC,CAAA,IAAO,IAAIQ,CAAA,IAAU8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACnF;gBAAA;gBAQAgE,KAAKhE,CAAA;kBACH,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBAQA0qC,UAAU1qC,CAAA;kBACR,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBAMA6T,KAAK7T,CAAA;kBACH,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAIwC,SAAA,CAAU,KAAKxC,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAASrkC,CAAA,IAAkB,IAARD,CAAA,IAC7D,KAAKqkC,EAAA,CAAIyC,UAAA,CAAW,GAAG,EACzC;gBAAA;gBAKAuH,WAAA;kBACE,IAAIruC,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAKA28B,SAAA;kBACE,IAAI18B,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAkB,KAAKokC,EAAA,CAAII,SAAA,CAAU,KAAKH,MAAA,GAASrkC,CAAA,IAC1CD,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIqgC,cAAA,CAAezB,SAC9D;gBAAA;gBAMAiM,QAAQtuC,CAAA;kBACN,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAIkJ,SAAA,CAAU,KAAKlJ,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAASrkC,CAAA,IAAUD,CAAA,IAAS,CACxF;gBAAA;gBAKAuuC,cAAA;kBACE,IAAIvuC,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAKAwuC,aAAA;kBACE,IAAIxuC,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GACH,IAAIyP,UAAA,CACA,KAAK40B,EAAA,CAAI4G,KAAA,GAAQrc,MAAA,EAAQ,KAAKyV,EAAA,CAAI4G,KAAA,GAAQpc,UAAA,GAAa,KAAKwV,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAStkC,CAAA,GACvF,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,KACxC,IACN;gBAAA;gBASAyuC,WAAWzuC,CAAA,EAAeC,CAAA;kBACxB,IAAIQ,CAAA,GAAS,KAAK4jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO7jC,CAAA,GAAS,KAAK4jC,EAAA,CAAI8B,QAAA,CAAS,KAAK9B,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAS7jC,CAAA,IAAkB,IAART,CAAA,EAAWC,CAAA,IAAoB,IAC7G;gBAAA;gBAKAyuC,iBAAA;kBACE,IAAI1uC,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAKA,OAAA2uC,YAAmB3uC,CAAA;kBACjBA,CAAA,CAAQmlC,WAAA,CAAY,EACtB;gBAAA;gBAMA,OAAAkG,QAAerrC,CAAA,EAA8BC,CAAA;kBAC3CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAY,EACxC;gBAAA;gBAMA,OAAAqrC,aAAoBtrC,CAAA,EAA8BC,CAAA;kBAChDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAiB,EAC7C;gBAAA;gBAMA,OAAA2uC,QAAe5uC,CAAA,EAA8BC,CAAA;kBAC3CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAY,EACxC;gBAAA;gBAOA,OAAA4uC,iBAAwB7uC,CAAA,EAA8BC,CAAA;kBACpDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQ8uC,QAAA,CAAS7uC,CAAA,CAAKQ,CAAA;kBAExB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAAsJ,gBAAuB/uC,CAAA,EAA8BC,CAAA;kBACnDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAA+uC,YAAmB/uC,CAAA,EAA8BQ,CAAA;kBAC/CR,CAAA,CAAQ2nC,aAAA,CAAc,GAAGnnC,CAAA,EAAUT,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIqgC,cAAA,CAAezB,SAAA,CACjF;gBAAA;gBAMA,OAAA4M,WAAkBjvC,CAAA,EAA8BC,CAAA;kBAC9CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAe,EAC3C;gBAAA;gBAOA,OAAAivC,oBAA2BlvC,CAAA,EAA8BC,CAAA;kBACvDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQmvC,OAAA,CAAQlvC,CAAA,CAAKQ,CAAA;kBAEvB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAA2J,mBAA0BpvC,CAAA,EAA8BC,CAAA;kBACtDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAAovC,cAAqBrvC,CAAA,EAA8BC,CAAA;kBACjDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAkB,EAC9C;gBAAA;gBAOA,OAAAqvC,uBAA8BtvC,CAAA,EAA8BC,CAAA;kBAC1DD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQwlC,SAAA,CAAUvlC,CAAA,CAAKQ,CAAA;kBAEzB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAA8J,sBAA6BvvC,CAAA,EAA8BC,CAAA;kBACzDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAAuvC,UAAiBxvC,CAAA;kBAEf,OADaA,CAAA,CAAQ4lC,SAAA,EAEvB;gBAAA;gBAEA,OAAA6J,aACIzvC,CAAA,EAA8BC,CAAA,EAAgCO,CAAA,EAC9DE,CAAA,EAAgCO,CAAA,EAChCC,CAAA,EAAmCoC,CAAA;kBAQrC,OAPA7C,CAAA,CAAOkuC,WAAA,CAAY3uC,CAAA,GACnBS,CAAA,CAAO4qC,OAAA,CAAQrrC,CAAA,EAASC,CAAA,GACxBQ,CAAA,CAAO6qC,YAAA,CAAatrC,CAAA,EAASQ,CAAA,GAC7BC,CAAA,CAAOmuC,OAAA,CAAQ5uC,CAAA,EAASU,CAAA,GACxBD,CAAA,CAAOuuC,WAAA,CAAYhvC,CAAA,EAASiB,CAAA,GAC5BR,CAAA,CAAOwuC,UAAA,CAAWjvC,CAAA,EAASkB,CAAA,GAC3BT,CAAA,CAAO4uC,aAAA,CAAcrvC,CAAA,EAASsD,CAAA,GACvB7C,CAAA,CAAO+uC,SAAA,CAAUxvC,CAAA,CAC1B;gBAAA;cAAA;cA/QWC,CAAA,CAAAgG,MAAA,GAAMxF,CAiRpB;YAAA,CAlRyC,CAAAR,CAAA,CAAAwD,GAAA,KAAAxD,CAAA,CAAAwD,GAAA,GAAG,IAkR5C;UAAA,CAlR4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IAkRxC;QAAA,CAlRD,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MAsR5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAC,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,MAAaQ,CAAA;gBAAbmC,YAAA;kBACE,KAAAyhC,EAAA,GAAkC,MAElC,KAAAC,MAAA,GAAS,CA6IX;gBAAA;gBAvIEC,OAAOvkC,CAAA,EAAWC,CAAA;kBAGhB,OAFA,KAAKqkC,MAAA,GAAStkC,CAAA,EACd,KAAKqkC,EAAA,GAAKpkC,CAAA,EACH,IACT;gBAAA;gBAOA,OAAAyvC,sBAA6B1vC,CAAA,EAA4BC,CAAA;kBACvD,QAAQA,CAAA,IAAO,IAAIQ,CAAA,IAAgB8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACzF;gBAAA;gBAOA,OAAA2vC,kCAAyC3vC,CAAA,EAA4BC,CAAA;kBAEnE,OADAD,CAAA,CAAG2kC,WAAA,CAAY3kC,CAAA,CAAGmsB,QAAA,KAAa3rB,CAAA,CAAAghC,WAAA,CAAYoD,kBAAA,IACnC3kC,CAAA,IAAO,IAAIQ,CAAA,IAAgB8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACzF;gBAAA;gBAMA4vC,OAAO3vC,CAAA;kBACL,IAAIQ,CAAA,GAAS,KAAK4jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO7jC,CAAA,IAAUR,CAAA,IAAO,IAAID,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIwC,MAAA,IACpCs+B,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKT,MAAA,GAAS7jC,CAAA,GAAS,KAAK4jC,EAAA,IAC5D,IAClB;gBAAA;gBAMAwL,QAAQ5vC,CAAA;kBACN,IAAIQ,CAAA,GAAS,KAAK4jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO7jC,CAAA,IAAUR,CAAA,IAAO,IAAID,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIwC,MAAA,IACpCs+B,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKT,MAAA,GAAS7jC,CAAA,GAAS,KAAK4jC,EAAA,IAC5D,IAClB;gBAAA;gBAMAxwB,KAAK7T,CAAA;kBACH,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAIwC,SAAA,CAAU,KAAKxC,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAASrkC,CAAA,IAAkB,IAARD,CAAA,IAC7D,KAAKqkC,EAAA,CAAIyC,UAAA,CAAW,GAAG,EACzC;gBAAA;gBAKAuH,WAAA;kBACE,IAAIruC,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAKA,OAAA8vC,kBAAyB9vC,CAAA;kBACvBA,CAAA,CAAQmlC,WAAA,CAAY,EACtB;gBAAA;gBAMA,OAAA4K,UAAiB/vC,CAAA,EAA8BC,CAAA;kBAC7CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAc,EAC1C;gBAAA;gBAMA,OAAA+vC,WAAkBhwC,CAAA,EAA8BC,CAAA;kBAC9CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAe,EAC3C;gBAAA;gBAMA,OAAA2uC,QAAe5uC,CAAA,EAA8BC,CAAA;kBAC3CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAY,EACxC;gBAAA;gBAOA,OAAA4uC,iBAAwB7uC,CAAA,EAA8BC,CAAA;kBACpDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQ8uC,QAAA,CAAS7uC,CAAA,CAAKQ,CAAA;kBAExB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAAsJ,gBAAuB/uC,CAAA,EAA8BC,CAAA;kBACnDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAAgwC,gBAAuBjwC,CAAA;kBAErB,OADaA,CAAA,CAAQ4lC,SAAA,EAEvB;gBAAA;gBAEA,OAAAsK,mBACIlwC,CAAA,EAA8BC,CAAA,EAAkCO,CAAA,EAChEE,CAAA;kBAKF,OAJAD,CAAA,CAAaqvC,iBAAA,CAAkB9vC,CAAA,GAC/BS,CAAA,CAAasvC,SAAA,CAAU/vC,CAAA,EAASC,CAAA,GAChCQ,CAAA,CAAauvC,UAAA,CAAWhwC,CAAA,EAASQ,CAAA,GACjCC,CAAA,CAAamuC,OAAA,CAAQ5uC,CAAA,EAASU,CAAA,GACvBD,CAAA,CAAawvC,eAAA,CAAgBjwC,CAAA,CACtC;gBAAA;cAAA;cA/IWC,CAAA,CAAAkwC,YAAA,GAAY1vC,CAiJ1B;YAAA,CAlJyC,CAAAR,CAAA,CAAAwD,GAAA,KAAAxD,CAAA,CAAAwD,GAAA,GAAG,IAkJ5C;UAAA,CAlJ4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IAkJxC;QAAA,CAlJD,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MAsJ5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAC,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,MAAaQ,CAAA;gBAAbmC,YAAA;kBACE,KAAAyhC,EAAA,GAAkC,MAElC,KAAAC,MAAA,GAAS,CAidX;gBAAA;gBA3cEC,OAAOvkC,CAAA,EAAWC,CAAA;kBAGhB,OAFA,KAAKqkC,MAAA,GAAStkC,CAAA,EACd,KAAKqkC,EAAA,GAAKpkC,CAAA,EACH,IACT;gBAAA;gBAOA,OAAAmwC,mBAA0BpwC,CAAA,EAA4BC,CAAA;kBACpD,QAAQA,CAAA,IAAO,IAAIQ,CAAA,IAAa8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACtF;gBAAA;gBAOA,OAAAqwC,+BAAsCrwC,CAAA,EAA4BC,CAAA;kBAEhE,OADAD,CAAA,CAAG2kC,WAAA,CAAY3kC,CAAA,CAAGmsB,QAAA,KAAa3rB,CAAA,CAAAghC,WAAA,CAAYoD,kBAAA,IACnC3kC,CAAA,IAAO,IAAIQ,CAAA,IAAa8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACtF;gBAAA;gBAQAgE,KAAKhE,CAAA;kBACH,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBAQA0qC,UAAU1qC,CAAA;kBACR,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBAKAgF,KAAA;kBACE,IAAI/E,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAkB,KAAKokC,EAAA,CAAII,SAAA,CAAU,KAAKH,MAAA,GAASrkC,CAAA,IAC1CD,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIwB,aAAA,CAAco9B,SAC7D;gBAAA;gBAKA97B,EAAA;kBACE,IAAIvG,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIiM,WAAA,CAAY,KAAKhM,MAAA,GAAStkC,CAAA,IAAU,CAC/D;gBAAA;gBAKAiB,EAAA;kBACE,IAAIjB,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIwC,SAAA,CAAU,KAAKvC,MAAA,GAAStkC,CAAA,IAAU,KAAKqkC,EAAA,CAAIyC,UAAA,CAAW,GAAG,EACpF;gBAAA;gBAQAxjC,EAAEtD,CAAA;kBACA,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBAMAC,EAAEA,CAAA;kBACA,IAAIQ,CAAA,GAAS,KAAK4jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO7jC,CAAA,IAAUR,CAAA,IAAO,IAAID,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIwC,MAAA,IACpCs+B,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKT,MAAA,GAAS7jC,CAAA,GAAS,KAAK4jC,EAAA,IAC5D,IAClB;gBAAA;gBAMA79B,EAAEvG,CAAA;kBACA,IAAIQ,CAAA,GAAS,KAAK4jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO7jC,CAAA,IAAUR,CAAA,IAAO,IAAID,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIu3B,KAAA,IACpCuJ,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKT,MAAA,GAAS7jC,CAAA,GAAS,KAAK4jC,EAAA,IAC5D,IAClB;gBAAA;gBAMA59B,OAAOzG,CAAA;kBACL,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAIiM,WAAA,CAAY,KAAKjM,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAASrkC,CAAA,IAAkB,IAARD,CAAA,IAAa,CAC9F;gBAAA;gBAKAuwC,aAAA;kBACE,IAAIvwC,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAKA8G,YAAA;kBACE,IAAI9G,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GACH,IAAI4U,YAAA,CACA,KAAKyvB,EAAA,CAAI4G,KAAA,GAAQrc,MAAA,EAAQ,KAAKyV,EAAA,CAAI4G,KAAA,GAAQpc,UAAA,GAAa,KAAKwV,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAStkC,CAAA,GACvF,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,KACxC,IACN;gBAAA;gBAMA0G,KAAK1G,CAAA;kBACH,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAIwC,SAAA,CAAU,KAAKxC,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAASrkC,CAAA,IAAkB,IAARD,CAAA,IAC7D,KAAKqkC,EAAA,CAAIyC,UAAA,CAAW,GAAG,EACzC;gBAAA;gBAKA//B,WAAA;kBACE,IAAI/G,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBASA2G,QAAQ3G,CAAA,EAAeC,CAAA;kBACrB,IAAIQ,CAAA,GAAS,KAAK4jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO7jC,CAAA,GAAS,KAAK4jC,EAAA,CAAI8B,QAAA,CAAS,KAAK9B,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAS7jC,CAAA,IAAkB,IAART,CAAA,EAAWC,CAAA,IAAoB,IAC7G;gBAAA;gBAKAgH,cAAA;kBACE,IAAIjH,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAOA4G,QAAQ3G,CAAA,EAAeQ,CAAA;kBACrB,IAAID,CAAA,GAAS,KAAK6jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO9jC,CAAA,IAAUC,CAAA,IAAO,IAAIT,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIwC,MAAA,IACpCs+B,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKV,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAS9jC,CAAA,IAAkB,IAARP,CAAA,GAAY,KAAKokC,EAAA,IAC3F,IAClB;gBAAA;gBAKAn9B,cAAA;kBACE,IAAIlH,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAOA6G,OAAO5G,CAAA,EAAeQ,CAAA;kBACpB,IAAID,CAAA,GAAS,KAAK6jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO9jC,CAAA,IAAUC,CAAA,IAAO,IAAIT,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIu3B,KAAA,IACpCuJ,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKV,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAS9jC,CAAA,IAAkB,IAARP,CAAA,GAAY,KAAKokC,EAAA,IAC3F,IAClB;gBAAA;gBAKAmM,aAAA;kBACE,IAAIxwC,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAKA,OAAAywC,eAAsBzwC,CAAA;kBACpBA,CAAA,CAAQmlC,WAAA,CAAY,GACtB;gBAAA;gBAMA,OAAAkG,QAAerrC,CAAA,EAA8BC,CAAA;kBAC3CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAY,EACxC;gBAAA;gBAMA,OAAAqrC,aAAoBtrC,CAAA,EAA8BC,CAAA;kBAChDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAiB,EAC7C;gBAAA;gBAMA,OAAA0rC,QAAe1rC,CAAA,EAA8BQ,CAAA;kBAC3CR,CAAA,CAAQ2nC,aAAA,CAAc,GAAGnnC,CAAA,EAAMT,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIwB,aAAA,CAAco9B,SAAA,CAC5E;gBAAA;gBAMA,OAAAqO,KAAY1wC,CAAA,EAA8BC,CAAA;kBACxCD,CAAA,CAAQ2wC,eAAA,CAAgB,GAAG1wC,CAAA,EAAG,EAChC;gBAAA;gBAMA,OAAA2wC,KAAY5wC,CAAA,EAA8BC,CAAA;kBACxCD,CAAA,CAAQonC,aAAA,CAAc,GAAGnnC,CAAA,EAAGD,CAAA,CAAQ8mC,UAAA,CAAW,GAAG,GACpD;gBAAA;gBAMA,OAAA+J,KAAY7wC,CAAA,EAA8BC,CAAA;kBACxCD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAS,EACrC;gBAAA;gBAMA,OAAA6wC,KAAY9wC,CAAA,EAA8BC,CAAA;kBACxCD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAS,EACrC;gBAAA;gBAMA,OAAA8wC,KAAY/wC,CAAA,EAA8BC,CAAA;kBACxCD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAS,EACrC;gBAAA;gBAMA,OAAA+wC,UAAiBhxC,CAAA,EAA8BC,CAAA;kBAC7CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAc,EAC1C;gBAAA;gBAOA,OAAAgxC,mBAA0BjxC,CAAA,EAA8BC,CAAA;kBACtDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQkxC,UAAA,CAAWjxC,CAAA,CAAKQ,CAAA;kBAE1B,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAA0L,kBAAyBnxC,CAAA,EAA8BC,CAAA;kBACrDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAAmxC,QAAepxC,CAAA,EAA8BC,CAAA;kBAC3CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAY,EACxC;gBAAA;gBAOA,OAAAoxC,iBAAwBrxC,CAAA,EAA8BC,CAAA;kBACpDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQ8uC,QAAA,CAAS7uC,CAAA,CAAKQ,CAAA;kBAExB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAA6L,gBAAuBtxC,CAAA,EAA8BC,CAAA;kBACnDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAAsxC,WAAkBvxC,CAAA,EAA8BC,CAAA;kBAC9CD,CAAA,CAAQqlC,cAAA,CAAe,IAAIplC,CAAA,EAAe,EAC5C;gBAAA;gBAOA,OAAAuxC,oBAA2BxxC,CAAA,EAA8BC,CAAA;kBACvDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQwlC,SAAA,CAAUvlC,CAAA,CAAKQ,CAAA;kBAEzB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAAgM,mBAA0BzxC,CAAA,EAA8BC,CAAA;kBACtDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAAyxC,WAAkB1xC,CAAA,EAA8BC,CAAA;kBAC9CD,CAAA,CAAQqlC,cAAA,CAAe,IAAIplC,CAAA,EAAe,EAC5C;gBAAA;gBAOA,OAAA0xC,oBAA2B3xC,CAAA,EAA8BC,CAAA;kBACvDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQwlC,SAAA,CAAUvlC,CAAA,CAAKQ,CAAA;kBAEzB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAAmM,mBAA0B5xC,CAAA,EAA8BC,CAAA;kBACtDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAA4xC,UAAiB7xC,CAAA,EAA8BC,CAAA;kBAC7CD,CAAA,CAAQqlC,cAAA,CAAe,IAAIplC,CAAA,EAAc,EAC3C;gBAAA;gBAOA,OAAA6xC,mBAA0B9xC,CAAA,EAA8BC,CAAA;kBACtDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQwlC,SAAA,CAAUvlC,CAAA,CAAKQ,CAAA;kBAEzB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAAsM,kBAAyB/xC,CAAA,EAA8BC,CAAA;kBACrDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAA+xC,aAAoBhyC,CAAA;kBAElB,OADaA,CAAA,CAAQ4lC,SAAA,EAEvB;gBAAA;gBAEA,OAAAqM,gBACIjyC,CAAA,EAA8BC,CAAA,EAAgCO,CAAA,EAC9DE,CAAA,EAAkDO,CAAA,EAAWC,CAAA,EAAqBoC,CAAA,EAClFI,CAAA,EAA6B+G,CAAA,EAA6BY,CAAA,EAC1DC,CAAA,EAAgCC,CAAA,EAAmChF,CAAA,EACnEmF,CAAA;kBAeF,OAdAjL,CAAA,CAAUgwC,cAAA,CAAezwC,CAAA,GACzBS,CAAA,CAAU4qC,OAAA,CAAQrrC,CAAA,EAASC,CAAA,GAC3BQ,CAAA,CAAU6qC,YAAA,CAAatrC,CAAA,EAASQ,CAAA,GAChCC,CAAA,CAAUkrC,OAAA,CAAQ3rC,CAAA,EAASU,CAAA,GAC3BD,CAAA,CAAUiwC,IAAA,CAAK1wC,CAAA,EAASiB,CAAA,GACxBR,CAAA,CAAUmwC,IAAA,CAAK5wC,CAAA,EAASkB,CAAA,GACxBT,CAAA,CAAUowC,IAAA,CAAK7wC,CAAA,EAASsD,CAAA,GACxB7C,CAAA,CAAUqwC,IAAA,CAAK9wC,CAAA,EAAS0D,CAAA,GACxBjD,CAAA,CAAUswC,IAAA,CAAK/wC,CAAA,EAASyK,CAAA,GACxBhK,CAAA,CAAUuwC,SAAA,CAAUhxC,CAAA,EAASqL,CAAA,GAC7B5K,CAAA,CAAU2wC,OAAA,CAAQpxC,CAAA,EAASsL,CAAA,GAC3B7K,CAAA,CAAU8wC,UAAA,CAAWvxC,CAAA,EAASuL,CAAA,GAC9B9K,CAAA,CAAUixC,UAAA,CAAW1xC,CAAA,EAASuG,CAAA,GAC9B9F,CAAA,CAAUoxC,SAAA,CAAU7xC,CAAA,EAAS0L,CAAA,GACtBjL,CAAA,CAAUuxC,YAAA,CAAahyC,CAAA,CAChC;gBAAA;cAAA;cAndWC,CAAA,CAAAkE,SAAA,GAAS1D,CAqdvB;YAAA,CAtdyC,CAAAR,CAAA,CAAAwD,GAAA,KAAAxD,CAAA,CAAAwD,GAAA,GAAG,IAsd5C;UAAA,CAtd4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IAsdxC;QAAA,CAtdD,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MA0d5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAC,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,MAAaQ,CAAA;gBAAbmC,YAAA;kBACE,KAAAyhC,EAAA,GAAkC,MAElC,KAAAC,MAAA,GAAS,CAwaX;gBAAA;gBAlaEC,OAAOvkC,CAAA,EAAWC,CAAA;kBAGhB,OAFA,KAAKqkC,MAAA,GAAStkC,CAAA,EACd,KAAKqkC,EAAA,GAAKpkC,CAAA,EACH,IACT;gBAAA;gBAOA,OAAAiyC,eAAsBlyC,CAAA,EAA4BC,CAAA;kBAChD,QAAQA,CAAA,IAAO,IAAIQ,CAAA,IAAS8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CAClF;gBAAA;gBAOA,OAAAmyC,2BAAkCnyC,CAAA,EAA4BC,CAAA;kBAE5D,OADAD,CAAA,CAAG2kC,WAAA,CAAY3kC,CAAA,CAAGmsB,QAAA,KAAa3rB,CAAA,CAAAghC,WAAA,CAAYoD,kBAAA,IACnC3kC,CAAA,IAAO,IAAIQ,CAAA,IAAS8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CAClF;gBAAA;gBAOAytB,aAAaxtB,CAAA,EAAeQ,CAAA;kBAC1B,IAAID,CAAA,GAAS,KAAK6jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO9jC,CAAA,IAAUC,CAAA,IAAO,IAAIT,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIwC,MAAA,IACpCs+B,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKV,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAS9jC,CAAA,IAAkB,IAARP,CAAA,GAAY,KAAKokC,EAAA,IAC3F,IAClB;gBAAA;gBAKA9G,mBAAA;kBACE,IAAIv9B,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAOA88B,SAAS78B,CAAA,EAAeQ,CAAA;kBACtB,IAAID,CAAA,GAAS,KAAK6jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO9jC,CAAA,IAAUC,CAAA,IAAO,IAAIT,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAI2pC,SAAA,IACpC7I,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKV,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAS9jC,CAAA,IAAkB,IAARP,CAAA,GAAY,KAAKokC,EAAA,IAC3F,IAClB;gBAAA;gBAKAxH,eAAA;kBACE,IAAI78B,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAOA09B,MAAMz9B,CAAA,EAAeQ,CAAA;kBACnB,IAAID,CAAA,GAAS,KAAK6jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO9jC,CAAA,IAAUC,CAAA,IAAO,IAAIT,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAI83B,IAAA,IACpCgJ,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKV,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAS9jC,CAAA,IAAkB,IAARP,CAAA,GAAY,KAAKokC,EAAA,IAC3F,IAClB;gBAAA;gBAKA1G,YAAA;kBACE,IAAI39B,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAKAoyC,aAAA;kBACE,IAAIpyC,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAI6E,UAAA,CAAW,KAAK5E,MAAA,GAAStkC,CAAA,IAAU,CAC9D;gBAAA;gBAOAqyC,UAAUpyC,CAAA,EAAeQ,CAAA;kBACvB,IAAID,CAAA,GAAS,KAAK6jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO9jC,CAAA,IAAUC,CAAA,IAAO,IAAIT,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAI8mC,QAAA,IACpChG,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKV,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAS9jC,CAAA,IAAkB,IAARP,CAAA,GAAY,KAAKokC,EAAA,IAC3F,IAClB;gBAAA;gBAKAiO,gBAAA;kBACE,IAAItyC,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBASA4pB,OAAO5pB,CAAA,EAAeC,CAAA;kBACpB,IAAIQ,CAAA,GAAS,KAAK4jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO7jC,CAAA,GAAS,KAAK4jC,EAAA,CAAI8B,QAAA,CAAS,KAAK9B,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAS7jC,CAAA,IAAkB,IAART,CAAA,EAAWC,CAAA,IAAoB,IAC7G;gBAAA;gBAKA28B,aAAA;kBACE,IAAI58B,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBASAunB,QAAQvnB,CAAA,EAAeC,CAAA;kBACrB,IAAIQ,CAAA,GAAS,KAAK4jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO7jC,CAAA,GAAS,KAAK4jC,EAAA,CAAI8B,QAAA,CAAS,KAAK9B,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAS7jC,CAAA,IAAkB,IAART,CAAA,EAAWC,CAAA,IAAoB,IAC7G;gBAAA;gBAKAw9B,cAAA;kBACE,IAAIz9B,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAOAuyC,mBAAmBtyC,CAAA,EAAeQ,CAAA;kBAEhC,IAAID,CAAA,GAAS,KAAK6jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO9jC,CAAA,IAAUC,CAAA,IAAO,IAAIT,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAI0sC,YAAA,IACpC5L,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKV,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAS9jC,CAAA,IAAkB,IAARP,CAAA,GAAY,KAAKokC,EAAA,IAC3F,IAClB;gBAAA;gBAKAmO,yBAAA;kBACE,IAAIxyC,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAKA,OAAAyyC,WAAkBzyC,CAAA;kBAChBA,CAAA,CAAQmlC,WAAA,CAAY,EACtB;gBAAA;gBAMA,OAAAuN,gBAAuB1yC,CAAA,EAA8BC,CAAA;kBACnDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAoB,EAChD;gBAAA;gBAOA,OAAA0yC,yBAAgC3yC,CAAA,EAA8BC,CAAA;kBAC5DD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQwlC,SAAA,CAAUvlC,CAAA,CAAKQ,CAAA;kBAEzB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAAmN,wBAA+B5yC,CAAA,EAA8BC,CAAA;kBAC3DD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAA4yC,YAAmB7yC,CAAA,EAA8BC,CAAA;kBAC/CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAgB,EAC5C;gBAAA;gBAOA,OAAA6yC,qBAA4B9yC,CAAA,EAA8BC,CAAA;kBACxDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQwlC,SAAA,CAAUvlC,CAAA,CAAKQ,CAAA;kBAEzB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAAsN,oBAA2B/yC,CAAA,EAA8BC,CAAA;kBACvDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAA+yC,SAAgBhzC,CAAA,EAA8BC,CAAA;kBAC5CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAa,EACzC;gBAAA;gBAOA,OAAAgzC,kBAAyBjzC,CAAA,EAA8BC,CAAA;kBACrDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQwlC,SAAA,CAAUvlC,CAAA,CAAKQ,CAAA;kBAEzB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAAyN,iBAAwBlzC,CAAA,EAA8BC,CAAA;kBACpDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAAkzC,gBAAuBnzC,CAAA,EAA8BC,CAAA;kBACnDD,CAAA,CAAQ4nC,aAAA,CAAc,GAAG3nC,CAAA,EAAc,EACzC;gBAAA;gBAMA,OAAAmzC,aAAoBpzC,CAAA,EAA8BC,CAAA;kBAChDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAiB,EAC7C;gBAAA;gBAOA,OAAAozC,sBAA6BrzC,CAAA,EAA8BC,CAAA;kBACzDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQwlC,SAAA,CAAUvlC,CAAA,CAAKQ,CAAA;kBAEzB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAA6N,qBAA4BtzC,CAAA,EAA8BC,CAAA;kBACxDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAA4rC,UAAiB7rC,CAAA,EAA8BC,CAAA;kBAC7CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAc,EAC1C;gBAAA;gBAOA,OAAA6rC,mBAA0B9rC,CAAA,EAA8BC,CAAA;kBACtDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQwlC,SAAA,CAAUvlC,CAAA,CAAKQ,CAAA;kBAEzB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAAsG,kBAAyB/rC,CAAA,EAA8BC,CAAA;kBACrDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAA+rC,WAAkBhsC,CAAA,EAA8BC,CAAA;kBAC9CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAe,EAC3C;gBAAA;gBAOA,OAAAgsC,oBAA2BjsC,CAAA,EAA8BC,CAAA;kBACvDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQwlC,SAAA,CAAUvlC,CAAA,CAAKQ,CAAA;kBAEzB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAAyG,mBAA0BlsC,CAAA,EAA8BC,CAAA;kBACtDD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAAszC,sBAA6BvzC,CAAA,EAA8BC,CAAA;kBACzDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAA0B,EACtD;gBAAA;gBAOA,OAAAuzC,+BAAsCxzC,CAAA,EAA8BC,CAAA;kBAElED,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQwlC,SAAA,CAAUvlC,CAAA,CAAKQ,CAAA;kBAEzB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAAgO,8BAAqCzzC,CAAA,EAA8BC,CAAA;kBACjED,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAAyzC,SAAgB1zC,CAAA;kBAEd,OADaA,CAAA,CAAQ4lC,SAAA,EAEvB;gBAAA;gBAEA,OAAA+N,YACI3zC,CAAA,EAA8BC,CAAA,EAAwCO,CAAA,EACtEE,CAAA,EAAiCO,CAAA,EAAsBC,CAAA,EACvDoC,CAAA,EAAkCI,CAAA,EAClC+G,CAAA;kBAUF,OATAhK,CAAA,CAAMgyC,UAAA,CAAWzyC,CAAA,GACjBS,CAAA,CAAMiyC,eAAA,CAAgB1yC,CAAA,EAASC,CAAA,GAC/BQ,CAAA,CAAMoyC,WAAA,CAAY7yC,CAAA,EAASQ,CAAA,GAC3BC,CAAA,CAAMuyC,QAAA,CAAShzC,CAAA,EAASU,CAAA,GACxBD,CAAA,CAAM0yC,eAAA,CAAgBnzC,CAAA,EAASiB,CAAA,GAC/BR,CAAA,CAAM2yC,YAAA,CAAapzC,CAAA,EAASkB,CAAA,GAC5BT,CAAA,CAAMorC,SAAA,CAAU7rC,CAAA,EAASsD,CAAA,GACzB7C,CAAA,CAAMurC,UAAA,CAAWhsC,CAAA,EAAS0D,CAAA,GAC1BjD,CAAA,CAAM8yC,qBAAA,CAAsBvzC,CAAA,EAASyK,CAAA,GAC9BhK,CAAA,CAAMizC,QAAA,CAAS1zC,CAAA,CACxB;gBAAA;cAAA;cA1aWC,CAAA,CAAA+6B,KAAA,GAAKv6B,CA4anB;YAAA,CA7ayC,CAAAR,CAAA,CAAAwD,GAAA,KAAAxD,CAAA,CAAAwD,GAAA,GAAG,IA6a5C;UAAA,CA7a4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IA6axC;QAAA,CA7aD,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MAib5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAC,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,MAAaQ,CAAA;gBAAbmC,YAAA;kBACE,KAAAyhC,EAAA,GAAkC,MAElC,KAAAC,MAAA,GAAS,CAoQX;gBAAA;gBA9PEC,OAAOvkC,CAAA,EAAWC,CAAA;kBAGhB,OAFA,KAAKqkC,MAAA,GAAStkC,CAAA,EACd,KAAKqkC,EAAA,GAAKpkC,CAAA,EACH,IACT;gBAAA;gBAOA,OAAA2zC,eAAsB5zC,CAAA,EAA4BC,CAAA;kBAChD,QAAQA,CAAA,IAAO,IAAIQ,CAAA,IAAS8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CAClF;gBAAA;gBAOA,OAAA6zC,2BAAkC7zC,CAAA,EAA4BC,CAAA;kBAE5D,OADAD,CAAA,CAAG2kC,WAAA,CAAY3kC,CAAA,CAAGmsB,QAAA,KAAa3rB,CAAA,CAAAghC,WAAA,CAAYoD,kBAAA,IACnC3kC,CAAA,IAAO,IAAIQ,CAAA,IAAS8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CAClF;gBAAA;gBAKAmhC,UAAA;kBACE,IAAInhC,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIwC,SAAA,CAAU,KAAKvC,MAAA,GAAStkC,CAAA,IAAU,KAAKqkC,EAAA,CAAIyC,UAAA,CAAW,GAAG,EACpF;gBAAA;gBAOAzF,YAAYphC,CAAA,EAAeQ,CAAA;kBAEzB,IAAID,CAAA,GAAS,KAAK6jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO9jC,CAAA,IAAUC,CAAA,IAAO,IAAIT,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIyqC,aAAA,IACpC3J,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKV,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAS9jC,CAAA,IAAkB,IAARP,CAAA,GAAY,KAAKokC,EAAA,IAC3F,IAClB;gBAAA;gBAKAxC,kBAAA;kBACE,IAAI7hC,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAQA8zC,aAAa9zC,CAAA;kBACX,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBAQA+zC,gBAAgB/zC,CAAA;kBACd,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBAQAshC,OAAOthC,CAAA;kBACL,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBAKAg0C,aAAA;kBACE,IAAIh0C,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIwC,SAAA,CAAU,KAAKvC,MAAA,GAAStkC,CAAA,IAAU,KAAKqkC,EAAA,CAAIyC,UAAA,CAAW,GAAG,EACpF;gBAAA;gBAQA4D,UAAU1qC,CAAA;kBACR,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBAMAq6B,MAAMp6B,CAAA;kBACJ,IAAIQ,CAAA,GAAS,KAAK4jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO7jC,CAAA,IAAUR,CAAA,IAAO,IAAID,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIu3B,KAAA,IACpCuJ,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKT,MAAA,GAAS7jC,CAAA,GAAS,KAAK4jC,EAAA,IAC5D,IAClB;gBAAA;gBAQA4P,eAAej0C,CAAA;kBACb,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBAKA,OAAAk0C,WAAkBl0C,CAAA;kBAChBA,CAAA,CAAQmlC,WAAA,CAAY,EACtB;gBAAA;gBAMA,OAAAgP,aAAoBn0C,CAAA,EAA8BC,CAAA;kBAChDD,CAAA,CAAQonC,aAAA,CAAc,GAAGnnC,CAAA,EAAWD,CAAA,CAAQ8mC,UAAA,CAAW,GAAG,GAC5D;gBAAA;gBAMA,OAAAsN,eAAsBp0C,CAAA,EAA8BC,CAAA;kBAClDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAmB,EAC/C;gBAAA;gBAOA,OAAAo0C,wBAA+Br0C,CAAA,EAA8BC,CAAA;kBAC3DD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQwlC,SAAA,CAAUvlC,CAAA,CAAKQ,CAAA;kBAEzB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAA6O,uBAA8Bt0C,CAAA,EAA8BC,CAAA;kBAC1DD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAAs0C,gBAAuBv0C,CAAA,EAA8BC,CAAA;kBACnDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAoB,EAChD;gBAAA;gBAMA,OAAAu0C,mBAA0Bx0C,CAAA,EAA8BC,CAAA;kBACtDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAuB,EACnD;gBAAA;gBAMA,OAAAsrC,UAAiBvrC,CAAA,EAA8BC,CAAA;kBAC7CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAc,EAC1C;gBAAA;gBAMA,OAAAw0C,gBAAuBz0C,CAAA,EAA8BC,CAAA;kBACnDD,CAAA,CAAQonC,aAAA,CAAc,GAAGnnC,CAAA,EAAcD,CAAA,CAAQ8mC,UAAA,CAAW,GAAG,GAC/D;gBAAA;gBAMA,OAAAwE,aAAoBtrC,CAAA,EAA8BC,CAAA;kBAChDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAiB,EAC7C;gBAAA;gBAMA,OAAAy0C,SAAgB10C,CAAA,EAA8BC,CAAA;kBAC5CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAa,EACzC;gBAAA;gBAMA,OAAA00C,kBAAyB30C,CAAA,EAA8BC,CAAA;kBACrDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAsB,EAClD;gBAAA;gBAMA,OAAA20C,SAAgB50C,CAAA;kBAEd,OADaA,CAAA,CAAQ4lC,SAAA,EAEvB;gBAAA;gBAEA,OAAAiP,YACI70C,CAAA,EAA8BC,CAAA,EAA6BO,CAAA,EAC3DE,CAAA,EAAwCO,CAAA,EACxCC,CAAA,EAAkCoC,CAAA,EAAgCI,CAAA,EAClE+G,CAAA,EAAiCY,CAAA;kBAWnC,OAVA5K,CAAA,CAAMyzC,UAAA,CAAWl0C,CAAA,GACjBS,CAAA,CAAM0zC,YAAA,CAAan0C,CAAA,EAASC,CAAA,GAC5BQ,CAAA,CAAM2zC,cAAA,CAAep0C,CAAA,EAASQ,CAAA,GAC9BC,CAAA,CAAM8zC,eAAA,CAAgBv0C,CAAA,EAASU,CAAA,GAC/BD,CAAA,CAAM+zC,kBAAA,CAAmBx0C,CAAA,EAASiB,CAAA,GAClCR,CAAA,CAAM8qC,SAAA,CAAUvrC,CAAA,EAASkB,CAAA,GACzBT,CAAA,CAAMg0C,eAAA,CAAgBz0C,CAAA,EAASsD,CAAA,GAC/B7C,CAAA,CAAM6qC,YAAA,CAAatrC,CAAA,EAAS0D,CAAA,GAC5BjD,CAAA,CAAMi0C,QAAA,CAAS10C,CAAA,EAASyK,CAAA,GACxBhK,CAAA,CAAMk0C,iBAAA,CAAkB30C,CAAA,EAASqL,CAAA,GAC1B5K,CAAA,CAAMm0C,QAAA,CAAS50C,CAAA,CACxB;gBAAA;cAAA;cAtQWC,CAAA,CAAA6gC,KAAA,GAAKrgC,CAwQnB;YAAA,CAzQyC,CAAAR,CAAA,CAAAwD,GAAA,KAAAxD,CAAA,CAAAwD,GAAA,GAAG,IAyQ5C;UAAA,CAzQ4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IAyQxC;QAAA,CAzQD,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MA6Q5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAA,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,MAAaC,CAAA;gBAAb2C,YAAA;kBACE,KAAAyhC,EAAA,GAAkC,MAElC,KAAAC,MAAA,GAAS,CAiKX;gBAAA;gBA3JEC,OAAOvkC,CAAA,EAAWC,CAAA;kBAGhB,OAFA,KAAKqkC,MAAA,GAAStkC,CAAA,EACd,KAAKqkC,EAAA,GAAKpkC,CAAA,EACH,IACT;gBAAA;gBAOA,OAAA60C,2BAAkC90C,CAAA,EAA4BS,CAAA;kBAC5D,QAAQA,CAAA,IAAO,IAAIR,CAAA,IAAqBskC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CAC9F;gBAAA;gBAOA,OAAA+0C,uCAA8C/0C,CAAA,EAA4BS,CAAA;kBAGxE,OADAT,CAAA,CAAG2kC,WAAA,CAAY3kC,CAAA,CAAGmsB,QAAA,KAAa3rB,CAAA,CAAAghC,WAAA,CAAYoD,kBAAA,IACnCnkC,CAAA,IAAO,IAAIR,CAAA,IAAqBskC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CAC9F;gBAAA;gBAMAg1C,YAAYh1C,CAAA;kBACV,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI6E,UAAA,CAAW,KAAK7E,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAASrkC,CAAA,IAAkB,IAARD,CAAA,IAAa,CAC7F;gBAAA;gBAKAi1C,kBAAA;kBACE,IAAIj1C,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAKAk1C,iBAAA;kBACE,IAAIl1C,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GACH,IAAIwP,WAAA,CACA,KAAK60B,EAAA,CAAI4G,KAAA,GAAQrc,MAAA,EAAQ,KAAKyV,EAAA,CAAI4G,KAAA,GAAQpc,UAAA,GAAa,KAAKwV,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAStkC,CAAA,GACvF,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,KACxC,IACN;gBAAA;gBAMAm1C,gBAAgBn1C,CAAA;kBACd,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI+Q,UAAA,CAAW,KAAK/Q,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAASrkC,CAAA,IAAkB,IAARD,CAAA,IAC9D,KAAKqkC,EAAA,CAAIyC,UAAA,CAAW,GAAG,EACzC;gBAAA;gBAKAuO,sBAAA;kBACE,IAAIr1C,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAKA,OAAAs1C,uBAA8Bt1C,CAAA;kBAC5BA,CAAA,CAAQmlC,WAAA,CAAY,EACtB;gBAAA;gBAMA,OAAAoQ,eAAsBv1C,CAAA,EAA8BC,CAAA;kBAClDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAmB,EAC/C;gBAAA;gBAOA,OAAAu1C,wBAA+Bx1C,CAAA,EAA8BC,CAAA;kBAC3DD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQwsC,QAAA,CAASvsC,CAAA,CAAKQ,CAAA;kBAExB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAAgQ,uBAA8Bz1C,CAAA,EAA8BC,CAAA;kBAC1DD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAAy1C,mBAA0B11C,CAAA,EAA8BC,CAAA;kBACtDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAuB,EACnD;gBAAA;gBAOA,OAAA01C,4BAAmC31C,CAAA,EAA8BC,CAAA;kBAC/DD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQ8uC,QAAA,CAAS7uC,CAAA,CAAKQ,CAAA;kBAExB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAAmQ,2BAAkC51C,CAAA,EAA8BC,CAAA;kBAC9DD,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAA41C,qBAA4B71C,CAAA;kBAE1B,OADaA,CAAA,CAAQ4lC,SAAA,EAEvB;gBAAA;gBAEA,OAAAkQ,wBACI91C,CAAA,EAA8BS,CAAA,EAC9BD,CAAA;kBAIF,OAHAP,CAAA,CAAkBq1C,sBAAA,CAAuBt1C,CAAA,GACzCC,CAAA,CAAkBs1C,cAAA,CAAev1C,CAAA,EAASS,CAAA,GAC1CR,CAAA,CAAkBy1C,kBAAA,CAAmB11C,CAAA,EAASQ,CAAA,GACvCP,CAAA,CAAkB41C,oBAAA,CAAqB71C,CAAA,CAChD;gBAAA;cAAA;cAnKWA,CAAA,CAAA+1C,iBAAA,GAAiB91C,CAqK/B;YAAA,CAtKyC,CAAAD,CAAA,CAAAyD,GAAA,KAAAzD,CAAA,CAAAyD,GAAA,GAAG,IAsK5C;UAAA,CAtK4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IAsKxC;QAAA,CAtKD,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MA0K5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAC,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,MAAaQ,CAAA;gBAAbmC,YAAA;kBACE,KAAAyhC,EAAA,GAAkC,MAElC,KAAAC,MAAA,GAAS,CA+FX;gBAAA;gBAzFEC,OAAOvkC,CAAA,EAAWC,CAAA;kBAGhB,OAFA,KAAKqkC,MAAA,GAAStkC,CAAA,EACd,KAAKqkC,EAAA,GAAKpkC,CAAA,EACH,IACT;gBAAA;gBAOA,OAAA+1C,8BAAqCh2C,CAAA,EAA4BC,CAAA;kBAC/D,QAAQA,CAAA,IAAO,IAAIQ,CAAA,IAAwB8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACjG;gBAAA;gBAOA,OAAAi2C,0CAAiDj2C,CAAA,EAA4BC,CAAA;kBAG3E,OADAD,CAAA,CAAG2kC,WAAA,CAAY3kC,CAAA,CAAGmsB,QAAA,KAAa3rB,CAAA,CAAAghC,WAAA,CAAYoD,kBAAA,IACnC3kC,CAAA,IAAO,IAAIQ,CAAA,IAAwB8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACjG;gBAAA;gBAQAk2C,QAAQl2C,CAAA;kBACN,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBAMAm2C,aAAal2C,CAAA;kBACX,IAAIQ,CAAA,GAAS,KAAK4jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO7jC,CAAA,IAAUR,CAAA,IAAO,IAAID,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAI2yC,YAAA,IACpC7R,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKT,MAAA,GAAS7jC,CAAA,GAAS,KAAK4jC,EAAA,IAC5D,IAClB;gBAAA;gBAKA,OAAAgS,0BAAiCr2C,CAAA;kBAC/BA,CAAA,CAAQmlC,WAAA,CAAY,EACtB;gBAAA;gBAMA,OAAAmR,WAAkBt2C,CAAA,EAA8BC,CAAA;kBAC9CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAe,EAC3C;gBAAA;gBAMA,OAAAs2C,gBAAuBv2C,CAAA,EAA8BC,CAAA;kBACnDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAoB,EAChD;gBAAA;gBAMA,OAAAu2C,wBAA+Bx2C,CAAA;kBAC7B,IAAIC,CAAA,GAASD,CAAA,CAAQ4lC,SAAA;kBAErB,OADA5lC,CAAA,CAAQy2C,aAAA,CAAcx2C,CAAA,EAAQ,IACvBA,CACT;gBAAA;gBAEA,OAAAy2C,2BACI12C,CAAA,EAA8BC,CAAA,EAC9BO,CAAA;kBAIF,OAHAC,CAAA,CAAqB41C,yBAAA,CAA0Br2C,CAAA,GAC/CS,CAAA,CAAqB61C,UAAA,CAAWt2C,CAAA,EAASC,CAAA,GACzCQ,CAAA,CAAqB81C,eAAA,CAAgBv2C,CAAA,EAASQ,CAAA,GACvCC,CAAA,CAAqB+1C,uBAAA,CAAwBx2C,CAAA,CACtD;gBAAA;cAAA;cAjGWC,CAAA,CAAA02C,oBAAA,GAAoBl2C,CAmGlC;YAAA,CApGyC,CAAAR,CAAA,CAAAwD,GAAA,KAAAxD,CAAA,CAAAwD,GAAA,GAAG,IAoG5C;UAAA,CApG4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IAoGxC;QAAA,CApGD,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MAwG5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAC,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,MAAaQ,CAAA;gBAAbmC,YAAA;kBACE,KAAAyhC,EAAA,GAAkC,MAElC,KAAAC,MAAA,GAAS,CA6HX;gBAAA;gBAvHEC,OAAOvkC,CAAA,EAAWC,CAAA;kBAGhB,OAFA,KAAKqkC,MAAA,GAAStkC,CAAA,EACd,KAAKqkC,EAAA,GAAKpkC,CAAA,EACH,IACT;gBAAA;gBAOA,OAAA22C,sBAA6B52C,CAAA,EAA4BC,CAAA;kBACvD,QAAQA,CAAA,IAAO,IAAIQ,CAAA,IAAgB8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACzF;gBAAA;gBAOA,OAAA62C,kCAAyC72C,CAAA,EAA4BC,CAAA;kBAEnE,OADAD,CAAA,CAAG2kC,WAAA,CAAY3kC,CAAA,CAAGmsB,QAAA,KAAa3rB,CAAA,CAAAghC,WAAA,CAAYoD,kBAAA,IACnC3kC,CAAA,IAAO,IAAIQ,CAAA,IAAgB8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CACzF;gBAAA;gBAMA82C,QAAQ72C,CAAA;kBACN,IAAIQ,CAAA,GAAS,KAAK4jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO7jC,CAAA,IAAUR,CAAA,IAAO,IAAID,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIsyC,iBAAA,IACpCxR,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKT,MAAA,GAAS7jC,CAAA,GAAS,KAAK4jC,EAAA,IAC5D,IAClB;gBAAA;gBAOA0S,sBAAsB92C,CAAA,EAAeQ,CAAA;kBAEnC,IAAID,CAAA,GAAS,KAAK6jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO9jC,CAAA,IAAUC,CAAA,IAAO,IAAIT,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIkzC,oBAAA,IACpCpS,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKV,EAAA,CAAIW,QAAA,CAAS,KAAKV,MAAA,GAAS9jC,CAAA,IAAkB,IAARP,CAAA,GAAY,KAAKokC,EAAA,IAC3F,IAClB;gBAAA;gBAKA2S,4BAAA;kBACE,IAAIh3C,CAAA,GAAS,KAAKqkC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOtkC,CAAA,GAAS,KAAKqkC,EAAA,CAAIY,YAAA,CAAa,KAAKX,MAAA,GAAStkC,CAAA,IAAU,CAChE;gBAAA;gBAKA,OAAAi3C,kBAAyBj3C,CAAA;kBACvBA,CAAA,CAAQmlC,WAAA,CAAY,EACtB;gBAAA;gBAMA,OAAA+R,WAAkBl3C,CAAA,EAA8BC,CAAA;kBAC9CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAe,EAC3C;gBAAA;gBAMA,OAAAk3C,yBAAgCn3C,CAAA,EAA8BC,CAAA;kBAC5DD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAA6B,EACzD;gBAAA;gBAOA,OAAAm3C,kCAAyCp3C,CAAA,EAA8BC,CAAA;kBAErED,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ;kBACpC,KAAK,IAAIrB,CAAA,GAAIR,CAAA,CAAK6B,MAAA,GAAS,GAAGrB,CAAA,IAAK,GAAGA,CAAA,IACpCT,CAAA,CAAQwlC,SAAA,CAAUvlC,CAAA,CAAKQ,CAAA;kBAEzB,OAAOT,CAAA,CAAQylC,SAAA,EACjB;gBAAA;gBAMA,OAAA4R,iCAAwCr3C,CAAA,EAA8BC,CAAA;kBACpED,CAAA,CAAQulC,WAAA,CAAY,GAAGtlC,CAAA,EAAU,EACnC;gBAAA;gBAMA,OAAAq3C,gBAAuBt3C,CAAA;kBAErB,OADaA,CAAA,CAAQ4lC,SAAA,EAEvB;gBAAA;gBAEA,OAAA2R,mBACIv3C,CAAA,EAA8BC,CAAA,EAC9BO,CAAA;kBAIF,OAHAC,CAAA,CAAaw2C,iBAAA,CAAkBj3C,CAAA,GAC/BS,CAAA,CAAay2C,UAAA,CAAWl3C,CAAA,EAASC,CAAA,GACjCQ,CAAA,CAAa02C,wBAAA,CAAyBn3C,CAAA,EAASQ,CAAA,GACxCC,CAAA,CAAa62C,eAAA,CAAgBt3C,CAAA,CACtC;gBAAA;cAAA;cA/HWC,CAAA,CAAAm2C,YAAA,GAAY31C,CAiI1B;YAAA,CAlIyC,CAAAR,CAAA,CAAAwD,GAAA,KAAAxD,CAAA,CAAAwD,GAAA,GAAG,IAkI5C;UAAA,CAlI4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IAkIxC;QAAA,CAlID,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,MAsI5B,UAAiBvD,CAAA;UAAA,CAAY,UAAAC,CAAA;YAAA,CAAa,UAAAA,CAAA;cACxC,MAAaQ,CAAA;gBAAbmC,YAAA;kBACE,KAAAyhC,EAAA,GAAkC,MAElC,KAAAC,MAAA,GAAS,CAyIX;gBAAA;gBAnIEC,OAAOvkC,CAAA,EAAWC,CAAA;kBAGhB,OAFA,KAAKqkC,MAAA,GAAStkC,CAAA,EACd,KAAKqkC,EAAA,GAAKpkC,CAAA,EACH,IACT;gBAAA;gBAOA,OAAA0hC,0BAAiC3hC,CAAA,EAA4BC,CAAA;kBAC3D,QAAQA,CAAA,IAAO,IAAIQ,CAAA,IAAoB8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CAC7F;gBAAA;gBAOA,OAAAw3C,sCAA6Cx3C,CAAA,EAA4BC,CAAA;kBAEvE,OADAD,CAAA,CAAG2kC,WAAA,CAAY3kC,CAAA,CAAGmsB,QAAA,KAAa3rB,CAAA,CAAAghC,WAAA,CAAYoD,kBAAA,IACnC3kC,CAAA,IAAO,IAAIQ,CAAA,IAAoB8jC,MAAA,CAAOvkC,CAAA,CAAGykC,SAAA,CAAUzkC,CAAA,CAAGmsB,QAAA,MAAcnsB,CAAA,CAAGmsB,QAAA,IAAYnsB,CAAA,CAC7F;gBAAA;gBAMA,OAAAy3C,oBAA2Bz3C,CAAA;kBACzB,OAAOA,CAAA,CAAG03C,gBAAA,CAAiB,OAC7B;gBAAA;gBAQAC,WAAW33C,CAAA;kBACT,IAAIC,CAAA,GAAS,KAAKokC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAOrkC,CAAA,GAAS,KAAKokC,EAAA,CAAI8B,QAAA,CAAS,KAAK7B,MAAA,GAASrkC,CAAA,EAAQD,CAAA,IAAoB,IAC9E;gBAAA;gBAMA4hC,MAAM3hC,CAAA;kBACJ,IAAIQ,CAAA,GAAS,KAAK4jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO7jC,CAAA,IAAUR,CAAA,IAAO,IAAID,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAIq9B,KAAA,IACpCyD,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKT,MAAA,GAAS7jC,CAAA,GAAS,KAAK4jC,EAAA,IAC5D,IAClB;gBAAA;gBAMA8R,aAAal2C,CAAA;kBACX,IAAIQ,CAAA,GAAS,KAAK4jC,EAAA,CAAIQ,QAAA,CAAS,KAAKP,MAAA,EAAQ;kBAC5C,OAAO7jC,CAAA,IAAUR,CAAA,IAAO,IAAID,CAAA,CAAYwD,YAAA,CAAaC,GAAA,CAAI2yC,YAAA,IACpC7R,MAAA,CAAO,KAAKF,EAAA,CAAIU,UAAA,CAAW,KAAKT,MAAA,GAAS7jC,CAAA,GAAS,KAAK4jC,EAAA,IAC5D,IAClB;gBAAA;gBAKA,OAAAuT,sBAA6B53C,CAAA;kBAC3BA,CAAA,CAAQmlC,WAAA,CAAY,EACtB;gBAAA;gBAMA,OAAA0S,cAAqB73C,CAAA,EAA8BC,CAAA;kBACjDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAkB,EAC9C;gBAAA;gBAMA,OAAA63C,SAAgB93C,CAAA,EAA8BC,CAAA;kBAC5CD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAa,EACzC;gBAAA;gBAMA,OAAAs2C,gBAAuBv2C,CAAA,EAA8BC,CAAA;kBACnDD,CAAA,CAAQqlC,cAAA,CAAe,GAAGplC,CAAA,EAAoB,EAChD;gBAAA;gBAMA,OAAA83C,oBAA2B/3C,CAAA;kBAEzB,OADaA,CAAA,CAAQ4lC,SAAA,EAEvB;gBAAA;gBAMA,OAAAoS,6BAAoCh4C,CAAA,EAA8BC,CAAA;kBAChED,CAAA,CAAQk3B,MAAA,CAAOj3B,CAAA,EAAQ,OACzB;gBAAA;gBAMA,OAAAg4C,yCAAgDj4C,CAAA,EAA8BC,CAAA;kBAC5ED,CAAA,CAAQk3B,MAAA,CAAOj3B,CAAA,EAAQ,SAAQ,EACjC;gBAAA;gBAEA,OAAAi4C,uBACIl4C,CAAA,EAA8BC,CAAA,EAAsCO,CAAA,EACpEE,CAAA;kBAKF,OAJAD,CAAA,CAAiBm3C,qBAAA,CAAsB53C,CAAA,GACvCS,CAAA,CAAiBo3C,aAAA,CAAc73C,CAAA,EAASC,CAAA,GACxCQ,CAAA,CAAiBq3C,QAAA,CAAS93C,CAAA,EAASQ,CAAA,GACnCC,CAAA,CAAiB81C,eAAA,CAAgBv2C,CAAA,EAASU,CAAA,GACnCD,CAAA,CAAiBs3C,mBAAA,CAAoB/3C,CAAA,CAC9C;gBAAA;cAAA;cA3IWC,CAAA,CAAAyhC,gBAAA,GAAgBjhC,CA6I9B;YAAA,CA9IyC,CAAAR,CAAA,CAAAwD,GAAA,KAAAxD,CAAA,CAAAwD,GAAA,GAAG,IA8I5C;UAAA,CA9I4B,CAAAzD,CAAA,CAAAwD,YAAA,KAAAxD,CAAA,CAAAwD,YAAA,GAAY,IA8IxC;QAAA,CA9ID,CAAiBvD,CAAA,CAAAsD,WAAA,KAAAtD,CAAA,CAAAsD,WAAA,GAAW,I;;;;;;;;QC5oH5B,MAAA/C,CAAA,GAAAC,CAAA;UAGAC,CAAA,GAAAD,CAAA;QAEAR,CAAA,CAAAe,oBAAA;UACE4B,YAAoB5C,CAAA;YAAA,KAAAiT,OAAA,GAAAjT,CAAA,EAClB,KAAK4K,UAAA,GAAa,KAAKqI,OAAA,CAAQrI,UAAA,EAC/B,KAAKutC,WAAA,GAAc,KAAKllC,OAAA,CAAQklC,WAClC;UAAA;UAEA,MAAA9wC,QAAA,GAAgC;UAGhC,MAAA8M,IACInU,CAAA,EAAiCC,CAAA,EACjCQ,CAAA;YACF,MAAMQ,CAAA,GAAW,IAAI2C,GAAA;YACrB,KAAK,MAAM3D,CAAA,IAAQD,CAAA,EACjB,IAAI6C,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAOC,CAAA,GAAO;cAC3C,MAAMQ,CAAA,GAAOT,CAAA,CAAMC,CAAA;cACnBgB,CAAA,CAAS8C,GAAA,CACL9D,CAAA,EACA,IAAIS,CAAA,CAAAuF,MAAA,CACAxF,CAAA,CAAKoT,IAAA,EAAMpT,CAAA,CAAKuE,IAAA,OAA+B,QAAW,GAC1DvE,CAAA,CAAKgjB,IAAA,E;;YAGjB,MAAMviB,CAAA,SAAkB,KAAK+R,OAAA,CAAQkB,GAAA,CAAIlT,CAAA;cACnCqC,CAAA,GAAoC,CAAC;YAI3C,OAHApC,CAAA,CAAU2J,OAAA,CAAQ,CAAC7K,CAAA,EAAQC,CAAA;cACzBqD,CAAA,CAAOrD,CAAA,IAAQ,IAAIO,CAAA,CAAAyF,MAAA,CAAOjG,CAAA,CAAOgF,IAAA,EAAMhF,CAAA,CAAOyjB,IAAA,EAAMzjB,CAAA,CAAO6T,IAAA,CAAK;YAAA,IAE3DvQ,CACT;UAAA;UACA80C,eAAA;YACE,KAAKnlC,OAAA,CAAQmlC,cAAA,EACf;UAAA;UACAC,aAAA;YACE,KAAKplC,OAAA,CAAQolC,YAAA,EACf;UAAA;QAAA,C;;;;;;;;QCxCF,MAAA73C,CAAA,GAAAC,CAAA;UACAC,CAAA,GAAAD,CAAA;UAEAQ,CAAA,GAAAR,CAAA;UACAS,CAAA,GAAAT,CAAA;UAEA6C,CAAA,GAAA7C,CAAA;UACAiD,CAAA,GAAAjD,CAAA;QAiBAR,CAAA,CAAAa,OAAA;UACE8B,YAAY5C,CAAA,GAAyB,CAAC;YACpC,KAAKs4C,YAAA,IAAe,GACpB,KAAKC,WAAA,GAAcv4C,CAAA,CAAOu4C,WAAA,EAC1B,KAAK/tB,QAAA,GAAWlnB,CAAA,CAAAk8B,QAAA,CAASC,MAAA,CAAOz/B,CAAA,CAAOwqB,QAAA,GACvC,KAAKxhB,OAAA,GAAU;cAACwhB,QAAA,EAAU,KAAKA,QAAA;cAAUguB,eAAA,EAAiB;cAAIC,cAAA,EAAgB;YAAA,CAChF;UAAA;UAEI,IAAA7tC,WAAA;YACF,OAAO,KAAK8tC,MAAA,CAAOre,KAAA,CAAMyB,aAAA,EAC3B;UAAA;UACI,IAAAqc,YAAA;YACF,OAAO,KAAKO,MAAA,CAAOre,KAAA,CAAM4B,cAAA,EAC3B;UAAA;UAEAmc,eAAA;YACE,KAAK5tB,QAAA,CAAS0V,KAAA,EAChB;UAAA;UAEAmY,aAAA;YACE,KAAK7tB,QAAA,CAAS8V,IAAA,EAChB;UAAA;UAKA,MAAAv/B,UAAgBf,CAAA,EAAoCC,CAAA,EAAqBQ,CAAA;YAAA,MACjE,KAAK+pB,QAAA,CAASI,KAAA,CAAM,WAAW,qBAAqB;cAExD,MAAM1pB,CAAA,UAAgB,GAAAD,CAAA,CAAAuG,cAAA,EAAe,KAAK+wC,WAAA;cAI1C,IAHA,KAAKI,cAAA,GAAiBz3C,CAAA,CAAQL,oBAAA,CAAqB,KAAKmI,OAAA,GAExD,KAAK0vC,MAAA,GAAS,IAAIh1C,CAAA,CAAAo9B,KAAA,IACC,mBAAR9gC,CAAA,EAAkB;gBAC3B,MAAMC,CAAA,GAAcD,CAAA,CAAIiiC,QAAA,CAAS;gBACjC,IAAuB,sBAAZ2W,OAAA,IAA2BA,OAAA,CAAQn2C,QAAA,IAAYm2C,OAAA,CAAQn2C,QAAA,CAAS03B,IAAA,EAAM;kBAE/E,MAAM15B,CAAA,UAAY,GAAAC,CAAA,CAAAm4C,SAAA,EAAUr4C,CAAA,CAAAs4C,QAAA,CAAV,CAAoB94C,CAAA;kBACtC,KAAKoH,UAAA,CAAW3G,CAAA,EAAKR,CAAA,C;uBAChB;kBAEL,MAAMQ,CAAA,SAAiBs4C,KAAA,CAAM/4C,CAAA;oBACvBQ,CAAA,SAAYC,CAAA,CAASu4C,WAAA;kBAC3B,KAAK5xC,UAAA,CAAW,IAAIqI,UAAA,CAAWjP,CAAA,GAAMP,CAAA,C;;qBAElC,IAAKsP,WAAA,CAAY0pC,MAAA,CAAOj5C,CAAA,GAM7B,KAAKoH,UAAA,CAAWpH,CAAA,OANmB;gBAEnC,MAAMQ,CAAA,GAAM,IAAIiP,UAAA,CAAWzP,CAAA,EAAKC,CAAA,IAAc,GAAGQ,CAAA,IAAUT,CAAA,CAAI8uB,UAAA;gBAC/D,KAAK1nB,UAAA,CAAW5G,CAAA,C;;cAMtB;UAAA;UAEQ4G,WAAWpH,CAAA,EAA4BC,CAAA;YAC7C,IAAI,KAAKq4C,YAAA,EACP,MAAM,IAAIj0C,KAAA,CAAM;YAGlB,KAAKmmB,QAAA,CAASI,KAAA,CAAM,WAAW,sBAAsB;cAEnD,MAAMnqB,CAAA,GACF,KAAKk4C,cAAA,CAAehd,cAAA,GAAiB,KAAKgd,cAAA,QAAsC;cACpF,KAAKD,MAAA,CAAO3X,IAAA,CAAK/gC,CAAA,EAAgBS,CAAA,EAAkBR,CAAA,GAG/C,KAAK04C,cAAA,CAAeprB,kBAAA,IACtB,KAAKorB,cAAA,CAAeprB,kBAAA,CAAmB,KAAKmrB,MAAA,CAAOre,KAAA,GAGrD,KAAK6e,aAAA,CAAc,KAAKR,MAAA,CAAOre,KAAA,GAG/B,KAAK8e,cAAA,GAAiB,IAAIj4C,CAAA,CAAAk5B,aAAA,CAAc,KAAKse,MAAA,CAAOre,KAAA,EAAO,KAAKE,IAAA,EAAM,KAAK/P,QAAA,CAAS;YAAA,IAGtF,KAAK8tB,YAAA,IAAe,CACtB;UAAA;UAEA,MAAAnkC,IAAUnU,CAAA;YACR,KAAK,KAAKs4C,YAAA,EACR,MAAM,IAAIj0C,KAAA,CAAM;YAGlB,OAAO,KAAKmmB,QAAA,CAASI,KAAA,CAAM,WAAW,eAAe;cACnD,MAAM3qB,CAAA,GAAe,KAAKm5C,0BAAA,CAA2Bp5C,CAAA;gBAE/CS,CAAA,SAAsB,KAAK04C,cAAA,CAAeve,OAAA,CAAQ,KAAK+d,cAAA,EAAgB14C,CAAA;cAE7E,OAAO,KAAKo5C,YAAA,CAAa54C,CAAA,CAAc;YAAA,EAE3C;UAAA;UAEQ24C,2BAA2Bp5C,CAAA;YACjC,MAAMC,CAAA,GAAkB,KAAKy4C,MAAA,CAAOre,KAAA,CAAMyB,aAAA;YAI1C,IAAI91B,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA;cAChB,IAAIA,CAAA,CAAO8B,MAAA,KAAW7B,CAAA,CAAgB6B,MAAA,EACpC,MAAM,IAAIuC,KAAA,CAAM,0CAA0CpE,CAAA,CAAgB6B,MAAA,YAAkB9B,CAAA,CAAO8B,MAAA;YAAA,OAKlG;cACH,IAAI9B,CAAA,CAAOoE,IAAA,KAASnE,CAAA,CAAgB6B,MAAA,EAClC,MAAM,IAAIuC,KAAA,CAAM,sCAAsCpE,CAAA,CAAgB6B,MAAA,YAAkB9B,CAAA,CAAOoE,IAAA;cAGjG,MAAM3D,CAAA,GAAe,IAAIuF,KAAA,CAAchG,CAAA,CAAOoE,IAAA;cAC9C,IAAI5D,CAAA,GAAoB;cACxB,KAAK,IAAIE,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAgB6B,MAAA,IAAUpB,CAAA,EAAG;gBAC/C,MAAMO,CAAA,GAASjB,CAAA,CAAOwE,GAAA,CAAIvE,CAAA,CAAgBS,CAAA;gBAC1C,KAAKO,CAAA,EACH,MAAM,IAAIoD,KAAA,CAAM,8BAA8BL,IAAA;gBAEhDvD,CAAA,CAAaD,CAAA,MAAuBS,C;;cAGtCjB,CAAA,GAASS,C;;YAKX,IAAK,KAAKuI,OAAA,CAAQwvC,eAAA,IAA2D,MAAxC,KAAKxvC,OAAA,CAAQwvC,eAAA,CAAgB12C,MAAA,IAAiB,KAAKkH,OAAA,CAAQyvC,cAAA,IACrD,MAAvC,KAAKzvC,OAAA,CAAQyvC,cAAA,CAAe32C,MAAA,EAqB9B,KAAKw3C,uBAAA,CAAwB,KAAKtwC,OAAA,CAAQyvC,cAAA,EAAgBz4C,CAAA,GAAQ,QArBtB;cAC5C,MAAMC,CAAA,GAAoB,KAAKy4C,MAAA,CAAOre,KAAA,CAAMM,eAAA;gBACtCl6B,CAAA,GAAc,KAAKi4C,MAAA,CAAOre,KAAA,CAAM7M,SAAA;gBAEhChtB,CAAA,GAAiB,IAAIwF,KAAA,CAAyB/F,CAAA,CAAkB6B,MAAA;cAEtE,KAAK,IAAIpB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAkB6B,MAAA,IAAUpB,CAAA,EAAG;gBACjD,MAAMO,CAAA,GAAaR,CAAA,CAAYR,CAAA,CAAkBS,CAAA;gBACjDF,CAAA,CAAeE,CAAA,IAAKO,CAAA,CAAW+D,IAAA,CAAM8I,KAAA,CAAM+F,IAAA,EAI3C,KAAK7K,OAAA,CAAQwvC,eAAA,CAAiBxxC,IAAA,CAAK/F,CAAA,CAAW+D,IAAA,CAAMo2B,UAAA,GACpD,KAAKpyB,OAAA,CAAQyvC,cAAA,CAAgBzxC,IAAA,CAAKhH,CAAA,CAAOU,CAAA,EAAGmT,IAAA,C;;cAG9C,KAAKylC,uBAAA,CAAwB94C,CAAA,EAAgBR,CAAA,GAAQ,E;;YAWvD,OAFA,KAAKu5C,wBAAA,CAAyB,KAAKvwC,OAAA,CAAQwvC,eAAA,EAAkBx4C,CAAA,GAEtDA,CACT;UAAA;UAEQu5C,yBAAyBv5C,CAAA,EAAoCC,CAAA;YACnE,KAAK,IAAIQ,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAY6B,MAAA,EAAQrB,CAAA,IAAK;cAC3C,MAAMD,CAAA,GAAeR,CAAA,CAAgBS,CAAA;gBAC/BC,CAAA,GAAaT,CAAA,CAAYQ,CAAA,EAAGuE,IAAA;cAClC,IAAIxE,CAAA,KAAiBE,CAAA,EACnB,MAAM,IAAI2D,KAAA,CAAM,gBAAgB5D,CAAA,kCAAmCD,CAAA,aAAyBE,CAAA,G;;UAGlG;UAEQ44C,wBACJt5C,CAAA,EAA0CC,CAAA,EAAuBQ,CAAA;YACnE,KAAK,IAAID,CAAA,GAAI,GAAGA,CAAA,GAAIP,CAAA,CAAY6B,MAAA,EAAQtB,CAAA,IAAK;cAC3C,MAAME,CAAA,GAAeV,CAAA,CAAeQ,CAAA;gBAC9BS,CAAA,GAAahB,CAAA,CAAYO,CAAA,EAAGqT,IAAA;cAClC,KAAK,KAAK2lC,iBAAA,CAAkB94C,CAAA,EAAcO,CAAA,EAAYR,CAAA,GACpD,MAAM,IAAI4D,KAAA,CAAM,gBAAgB7D,CAAA,oCAAqCE,CAAA,CAAa0C,IAAA,CAAK,mBACnFnC,CAAA,CAAWmC,IAAA,CAAK,Q;;UAG1B;UAEQo2C,kBAAkBx5C,CAAA,EAAiCC,CAAA,EAA+BQ,CAAA;YAExF,IAAIT,CAAA,CAAa8B,MAAA,KAAW7B,CAAA,CAAW6B,MAAA,EACrC,QAAO;YAGT,KAAK,IAAItB,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAa8B,MAAA,IAAUtB,CAAA,EACzC,IAAIR,CAAA,CAAaQ,CAAA,MAAOP,CAAA,CAAWO,CAAA,OAAQC,CAAA,IAAwC,MAApBT,CAAA,CAAaQ,CAAA,IAE1E,QAAO;YAIX,QAAO,CACT;UAAA;UAEQ64C,aAAar5C,CAAA;YACnB,MAAMC,CAAA,GAAmB,KAAKy4C,MAAA,CAAOre,KAAA,CAAM4B,cAAA;YAC3C,IAAIj8B,CAAA,CAAc8B,MAAA,KAAW7B,CAAA,CAAiB6B,MAAA,EAC5C,MAAM,IAAIuC,KAAA,CAAM;YAGlB,MAAM5D,CAAA,GAAS,IAAImD,GAAA;YACnB,KAAK,IAAIpD,CAAA,GAAI,GAAGA,CAAA,GAAIP,CAAA,CAAiB6B,MAAA,IAAUtB,CAAA,EAC7CC,CAAA,CAAOsD,GAAA,CAAI9D,CAAA,CAAiBO,CAAA,GAAIR,CAAA,CAAcQ,CAAA;YAGhD,OAAOC,CACT;UAAA;UAEQy4C,cAAcl5C,CAAA;YACpB,MAAMC,CAAA,GAAQD,CAAA,CAAMs6B,QAAA;YACpB,KAAKC,IAAA,GAAO,IAAIv0B,KAAA,CAAM/F,CAAA,CAAM6B,MAAA;YAE5B,KAAK,IAAIrB,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAM6B,MAAA,EAAQrB,CAAA,IAChC,KAAK85B,IAAA,CAAK95B,CAAA,IAAK,KAAKk4C,cAAA,CAAep2C,OAAA,CAAQtC,CAAA,CAAMQ,CAAA,GAAI,KAAKi4C,MAAA,CAAO5W,MAAA,EAAQ9hC,CAAA,CAE7E;UAAA;QAAA,C;;;;;;;;;;;;;QCjPF,MAAAU,CAAA,GAAAD,CAAA;UACAQ,CAAA,GAAAT,CAAA,CAAAC,CAAA;UAEAS,CAAA,GAAAT,CAAA;UACA6C,CAAA,GAAA7C,CAAA;UACAiD,CAAA,GAAAjD,CAAA;QAEA,IAAOgK,CAAA,GAASvJ,CAAA,CAAAqC,WAAA,CAAYC,YAAA,CAAaC,GAAA;QAkCzC,MAAa4H,CAAA;UAIP,IAAAoY,KAAA;YACF,SAAmB,MAAf,KAAKg2B,KAAA,EAAqB;cAC5B,MAAMz5C,CAAA,GAAO,KAAK05C,YAAA,CAAc,KAAKllC,MAAA;cACrC,IAAIxU,CAAA,CAAK8B,MAAA,KAAW,KAAKsC,IAAA,EACvB,MAAM,IAAIC,KAAA,CAAM;cAElB,KAAKo1C,KAAA,GAAQz5C,C;;YAEf,OAAO,KAAKy5C,KACd;UAAA;UAKI,IAAAhL,WAAA;YACF,IAAkB,aAAd,KAAKzpC,IAAA,EACP,MAAM,IAAI+c,SAAA,CAAU;YAGtB,OAAO,KAAK0B,IACd;UAAA;UAMI,IAAAY,YAAA;YACF,QAAQ,KAAKrf,IAAA;cACX,KAAK;cACL,KAAK;cACL,KAAK;cACL,KAAK;cACL,KAAK;cACL,KAAK;cACL,KAAK;gBACH,OAAO,KAAKye,IAAA;cAEd;gBACE,MAAM,IAAI1B,SAAA,CAAU;YAAA;UAE1B;UAKI,IAAAuC,UAAA;YACF,QAAQ,KAAKtf,IAAA;cACX,KAAK;cACL,KAAK;gBACH,OAAO,KAAKye,IAAA;cAEd;gBACE,MAAM,IAAI1B,SAAA,CAAU;YAAA;UAE1B;UAMI,IAAApN,WAAA;YACF,IAAkB,aAAd,KAAK3P,IAAA,EACP,OAAO,KAAKye,IAAA;YAEd,MAAM,IAAI1B,SAAA,CAAU,qCACtB;UAAA;UAKAvd,IAAIxE,CAAA;YACF,OAAO,KAAKyjB,IAAA,CAAK/f,CAAA,CAAAwI,SAAA,CAAU8F,eAAA,CAAgBhS,CAAA,EAAS,KAAK+N,OAAA,EAC3D;UAAA;UAKAhK,IAAI/D,CAAA,EAA4BC,CAAA;YAC9B,KAAKwjB,IAAA,CAAK/f,CAAA,CAAAwI,SAAA,CAAU8F,eAAA,CAAgBhS,CAAA,EAAS,KAAK+N,OAAA,KAAY9N,CAChE;UAAA;UAKA,MAAA86B,QAAA;YAIE,YAHmB,MAAf,KAAK0e,KAAA,KACP,KAAKA,KAAA,SAAc,KAAKE,iBAAA,CAAmB,KAAKnlC,MAAA,IAE3C,KAAKilC,KACd;UAAA;UAWI,IAAA1rC,QAAA;YAIF,OAHK,KAAK6rC,QAAA,KACR,KAAKA,QAAA,GAAWl2C,CAAA,CAAAwI,SAAA,CAAUqJ,cAAA,CAAe,KAAK1B,IAAA,IAEzC,KAAK+lC,QACd;UAAA;UAEAh3C,YAIoB5C,CAAA,EAIAC,CAAA,EAA+BQ,CAAA,EACvCD,CAAA,EAA+CS,CAAA,EAIvCC,CAAA,GAAeR,CAAA,CAAAm5C,IAAA,CAAKpa,MAAA;YATpB,KAAA5rB,IAAA,GAAA7T,CAAA,EAIA,KAAAgF,IAAA,GAAA/E,CAAA,EAA+B,KAAAy5C,YAAA,GAAAj5C,CAAA,EACvC,KAAAk5C,iBAAA,GAAAn5C,CAAA,EAA+C,KAAAi5C,KAAA,GAAAx4C,CAAA,EAIvC,KAAAuT,MAAA,GAAAtT,CAAA,EAClB,KAAKkD,IAAA,GAAOV,CAAA,CAAAwI,SAAA,CAAU4tC,uBAAA,CAAwB95C,CAAA;YAC9C,MAAMsD,CAAA,GAAO,KAAKc,IAAA;cACZqG,CAAA,QAA0B,MAAjBhK,CAAA,SAAoD,MAAtBD,CAAA,SAA6C,MAAVS,CAAA;YAEhF,SAAc,MAAVA,CAAA,IACEA,CAAA,CAAMa,MAAA,KAAWwB,CAAA,EACnB,MAAM,IAAIy2C,UAAA,CAAW;YAIzB,IAAa,aAAT95C,CAAA,EAAmB;cACrB,WAAc,MAAVgB,CAAA,IAAyB+E,KAAA,CAAM+oB,OAAA,CAAQ9tB,CAAA,KAAWA,CAAA,CAAMglB,KAAA,CAAMjmB,CAAA,IAAkB,mBAANA,CAAA,IAC5E,MAAM,IAAI+hB,SAAA,CAAU;cAGlBtX,CAAA,KACF,KAAKgvC,KAAA,GAAQ,IAAIzzC,KAAA,CAAc1C,CAAA,E;mBAE5B;cACL,SAAc,MAAVrC,CAAA,EAAqB;gBACvB,MAAMjB,CAAA,GAAcuL,CAAA,CAAoBtL,CAAA;gBACxC,MAAMgB,CAAA,YAAiBjB,CAAA,GACrB,MAAM,IAAI+hB,SAAA,CAAU,wBAAwB/hB,CAAA,CAAYgE,IAAA,G;;cAI5D,IAAIyG,CAAA,EAAO;gBACT,MAAMzK,CAAA,GAAM,IAAIuP,WAAA,CAAYjM,CAAA,GA2JpC,UAAgBtD,CAAA;kBACd,QAAQA,CAAA;oBACN,KAAK;oBACL,KAAK;oBACL,KAAK;sBACH,OAAO;oBACT,KAAK;oBACL,KAAK;sBACH,OAAO;oBACT,KAAK;oBACL,KAAK;oBACL,KAAK;sBACH,OAAO;oBACT,KAAK;sBACH,OAAO;oBACT;sBACE,MAAM,IAAIqE,KAAA,CAAM,qCAAqCrE,CAAA;kBAAA;gBAE3D,CA7K2C,CAAOC,CAAA;gBAC1C,KAAKw5C,KAAA,GAoMb,UAAoBz5C,CAAA,EAAyBC,CAAA;kBAC3C,OAAO,KAAKsL,CAAA,CAAoBtL,CAAA,GAAOD,CAAA,CACzC;gBAAA,CAtMqB,CAAWA,CAAA,EAAKC,CAAA,C;;;UAGnC;UAMA,OAAAiG,UAAiBlG,CAAA;YACf,KAAKA,CAAA,EACH,MAAM,IAAIqE,KAAA,CAAM;YAElB,MAAMpE,CAAA,GAAOyD,CAAA,CAAAub,SAAA,CAAUC,uBAAA,CAAwBlf,CAAA,CAAY28B,QAAA;cACrDl8B,CAAA,GAAOiD,CAAA,CAAAub,SAAA,CAAUyd,mBAAA,CAAoB18B,CAAA,CAAY6T,IAAA;cAEjDrT,CAAA,GAAQ,IAAI6K,CAAA,CAAO5K,CAAA,EAAMR,CAAA;YAE/B,IAAa,aAATA,CAAA,EAGFD,CAAA,CAAYyuC,UAAA,CAAY5jC,OAAA,CAAQ,CAAC7K,CAAA,EAAKC,CAAA;cACpCO,CAAA,CAAMijB,IAAA,CAAKxjB,CAAA,KAAK,GAAAyD,CAAA,CAAA0C,gBAAA,EAAiBpG,CAAA,CAAI;YAAA,QAGlC,IACHA,CAAA,CAAYsuC,OAAA,IAAqD,mBAAnCtuC,CAAA,CAAYsuC,OAAA,CAAQxf,UAAA,IAClD9uB,CAAA,CAAYsuC,OAAA,CAAQxf,UAAA,GAAa,GAAG;cAItC,MAAM7uB,CAAA,GAAWO,CAAA,CAAMijB,IAAA;gBACjBhjB,CAAA,GACF,IAAIu5C,QAAA,CAASh6C,CAAA,CAAYsuC,OAAA,CAAQ1f,MAAA,EAAQ5uB,CAAA,CAAYsuC,OAAA,CAAQzf,UAAA,EAAY7uB,CAAA,CAAYsuC,OAAA,CAAQxf,UAAA;gBAC3FpuB,CAAA,GAAc4K,CAAA,CAAYtL,CAAA,CAAY28B,QAAA;gBACtC17B,CAAA,GAASjB,CAAA,CAAYsuC,OAAA,CAAQxf,UAAA,GAAapuB,CAAA;cAEhD,IAAIV,CAAA,CAAYsuC,OAAA,CAAQxf,UAAA,GAAapuB,CAAA,IAAgB,GACnD,MAAM,IAAI2D,KAAA,CAAM;cAElB,IAAIpE,CAAA,CAAS6B,MAAA,KAAWb,CAAA,EACtB,MAAM,IAAIoD,KAAA,CAAM;cAGlB,KAAK,IAAI7D,CAAA,GAAI,GAAGA,CAAA,GAAIS,CAAA,EAAQT,CAAA,IAAK;gBAC/B,MAAMS,CAAA,GAAIyK,CAAA,CAAUjL,CAAA,EAAYT,CAAA,CAAY28B,QAAA,EAAWn8B,CAAA,GAAIE,CAAA;gBAC3DT,CAAA,CAASO,CAAA,IAAKS,C;;mBAEX;cAEL,IAAIhB,CAAA;cACJ,QAAQD,CAAA,CAAY28B,QAAA;gBAClB,KAAKr5B,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASh1C,KAAA;kBAC7BjF,CAAA,GAAQD,CAAA,CAAYskB,SAAA;kBACpB;gBACF,KAAKhhB,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASlX,KAAA;gBAC/B,KAAK1/B,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASnX,KAAA;gBAC/B,KAAKz/B,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASpX,MAAA;gBAC/B,KAAKx/B,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASrX,IAAA;gBAC/B,KAAKv/B,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAStX,KAAA;gBAC/B,KAAKt/B,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAShX,IAAA;kBAC7BjjC,CAAA,GAAQD,CAAA,CAAYm6C,SAAA;kBACpB;gBACF,KAAK72C,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASjX,KAAA;kBAC7BhjC,CAAA,GAAQD,CAAA,CAAYo6C,SAAA;kBACpB;gBACF,KAAK92C,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAS9W,MAAA;kBAC7BnjC,CAAA,GAAQD,CAAA,CAAYq6C,UAAA;kBACpB;gBACF,KAAK/2C,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAS7W,MAAA;gBAC/B,KAAK//B,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAS5W,MAAA;kBAC7BrjC,CAAA,GAAQD,CAAA,CAAYs6C,UAAA;kBACpB;gBACF;kBAEE,MAAM,IAAIj2C,KAAA,CAAM;cAAA;cAGpB,IAAI,QAAApE,CAAA,EACF,MAAM,IAAIoE,KAAA,CAAM;cAGlB,MAAM5D,CAAA,GAAOD,CAAA,CAAMijB,IAAA;cACnB,IAAIhjB,CAAA,CAAKqB,MAAA,KAAW7B,CAAA,CAAM6B,MAAA,EACxB,MAAM,IAAIuC,KAAA,CAAM;cAGlB,KAAK,IAAI7D,CAAA,GAAI,GAAGA,CAAA,GAAIP,CAAA,CAAM6B,MAAA,EAAQtB,CAAA,IAAK;gBACrC,MAAME,CAAA,GAAUT,CAAA,CAAMO,CAAA;gBAClBS,CAAA,CAAAs5C,OAAA,CAAKz0C,MAAA,CAAOpF,CAAA,IACdD,CAAA,CAAKD,CAAA,IAAK+F,CAAA,CAAa7F,CAAA,EAASV,CAAA,CAAY28B,QAAA,IAE5Cl8B,CAAA,CAAKD,CAAA,IAAKE,C;;;YAKhB,OAAOF,CACT;UAAA;UASA,OAAAg6C,SAAgBx6C,CAAA,EAA2CC,CAAA,EAAyBQ,CAAA;YAClF,OAAO,IAAI4K,CAAA,CAAOpL,CAAA,EAAMQ,CAAA,OAAM,QAAW,GAAWT,CAAA,CACtD;UAAA;UAEA,OAAAmG,cAAqBnG,CAAA;YACnB,KAAKA,CAAA,EACH,MAAM,IAAIqE,KAAA,CAAM;YAElB,MAAMpE,CAAA,GAAOyD,CAAA,CAAAub,SAAA,CAAUue,uBAAA,CAAwBx9B,CAAA;cACzCS,CAAA,GAAOiD,CAAA,CAAAub,SAAA,CAAUC,uBAAA,CAAwBlf,CAAA,CAAU28B,QAAA;cAEnDn8B,CAAA,GAAQ,IAAI6K,CAAA,CAAOpL,CAAA,EAAMQ,CAAA;YAE/B,IAAa,aAATA,CAAA,EAGF,KAAK,IAAIR,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAU0uC,gBAAA,IAAoBzuC,CAAA,IAChDO,CAAA,CAAMijB,IAAA,CAAKxjB,CAAA,IAAKD,CAAA,CAAUyuC,UAAA,CAAWxuC,CAAA,OAGlC,IACHD,CAAA,CAAUwuC,YAAA,MAAuD,mBAA9BxuC,CAAA,CAAUuuC,aAAA,MAAgCvuC,CAAA,CAAUuuC,aAAA,KAAkB,GAAG;cAI9G,MAAMtuC,CAAA,GAAWO,CAAA,CAAMijB,IAAA;gBACjBhjB,CAAA,GAAa,IAAIu5C,QAAA,CACnBh6C,CAAA,CAAUwuC,YAAA,GAAgB5f,MAAA,EAAQ5uB,CAAA,CAAUwuC,YAAA,GAAgB3f,UAAA,EAAY7uB,CAAA,CAAUuuC,aAAA;gBAChF7tC,CAAA,GAAc4K,CAAA,CAAYtL,CAAA,CAAU28B,QAAA;gBACpC17B,CAAA,GAASjB,CAAA,CAAUuuC,aAAA,KAAkB7tC,CAAA;cAE3C,IAAIV,CAAA,CAAUuuC,aAAA,KAAkB7tC,CAAA,IAAgB,GAC9C,MAAM,IAAI2D,KAAA,CAAM;cAElB,IAAIpE,CAAA,CAAS6B,MAAA,KAAWb,CAAA,EACtB,MAAM,IAAIoD,KAAA,CAAM;cAGlB,KAAK,IAAI7D,CAAA,GAAI,GAAGA,CAAA,GAAIS,CAAA,EAAQT,CAAA,IAAK;gBAC/B,MAAMS,CAAA,GAAIyK,CAAA,CAAUjL,CAAA,EAAYT,CAAA,CAAU28B,QAAA,IAAYn8B,CAAA,GAAIE,CAAA;gBAC1DT,CAAA,CAASO,CAAA,IAAKS,C;;;YAGlB,OAAOT,CACT;UAAA;QAAA;QAuBF,SAAS8K,EAAYtL,CAAA;UACnB,QAAQA,CAAA;YACN,KAAKsD,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAStX,KAAA;YAC/B,KAAKt/B,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASrX,IAAA;YAC/B,KAAKv/B,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAShX,IAAA;cAC7B,OAAO;YACT,KAAK5/B,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASpX,MAAA;YAC/B,KAAKx/B,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASnX,KAAA;cAC7B,OAAO;YACT,KAAKz/B,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASh1C,KAAA;YAC/B,KAAK5B,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASlX,KAAA;YAC/B,KAAK1/B,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAS7W,MAAA;cAC7B,OAAO;YACT,KAAK//B,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASjX,KAAA;YAC/B,KAAK3/B,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAS9W,MAAA;YAC/B,KAAK9/B,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAS5W,MAAA;cAC7B,OAAO;YACT;cACE,MAAM,IAAIj/B,KAAA,CAAM,qCAAqCf,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASl6C,CAAA;UAAA;QAErF;QAMA,SAASuL,EAAoBvL,CAAA;UAC3B,QAAQA,CAAA;YACN,KAAK;YACL,KAAK;cACH,OAAOyP,UAAA;YACT,KAAK;cACH,OAAOmhB,SAAA;YACT,KAAK;cACH,OAAOD,UAAA;YACT,KAAK;cACH,OAAOE,WAAA;YACT,KAAK;cACH,OAAOlK,UAAA;YACT,KAAK;cACH,OAAOnX,WAAA;YACT,KAAK;cACH,OAAOirC,aAAA;YACT,KAAK;cACH,OAAO7lC,YAAA;YACT,KAAK;cACH,OAAOkc,YAAA;YACT;cAEE,MAAM,IAAIzsB,KAAA,CAAM;UAAA;QAEtB;QAGA,SAASkC,EAAavG,CAAA,EAASC,CAAA;UAE7B,IAAIA,CAAA,KAASqD,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASjX,KAAA,IAAShjC,CAAA,KAASwK,CAAA,CAAOq5B,cAAA,CAAeb,KAAA;YAC7E,IAAIjjC,CAAA,CAAE06C,kBAAA,CAAmB,eAAe16C,CAAA,CAAE26C,QAAA,EAAU,aAClD,MAAM,IAAI54B,SAAA,CAAU;UAAA,OAEjB;YAAA,IACH9hB,CAAA,KAASqD,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAS7W,MAAA,IAAUpjC,CAAA,KAASwK,CAAA,CAAOq5B,cAAA,CAAeT,MAAA,IAC5EpjC,CAAA,KAASqD,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAS5W,MAAA,IAAUrjC,CAAA,KAASwK,CAAA,CAAOq5B,cAAA,CAAeR,MAAA,EAK9E,MAAM,IAAIvhB,SAAA,CAAU,oBAAoBze,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASj6C,CAAA;YAJlE,IAAID,CAAA,CAAE06C,kBAAA,CAAmB,eAAe16C,CAAA,CAAE26C,QAAA,CAAS,IACjD,MAAM,IAAI54B,SAAA,CAAU,0B;;UAMxB,OAAO/hB,CAAA,CAAE46C,QAAA,EACX;QAAA;QAGA,SAASlvC,EAAU1L,CAAA,EAAgBC,CAAA,EAAuDQ,CAAA;UACxF,QAAQR,CAAA;YACN,KAAKqD,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAShX,IAAA;YAC/B,KAAK5/B,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAStX,KAAA;cAC7B,OAAO5iC,CAAA,CAAK66C,QAAA,CAASp6C,CAAA;YACvB,KAAK6C,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASrX,IAAA;cAC7B,OAAO7iC,CAAA,CAAK86C,OAAA,CAAQr6C,CAAA;YACtB,KAAK6C,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASpX,MAAA;cAC7B,OAAO9iC,CAAA,CAAK+6C,SAAA,CAAUt6C,CAAA,GAAY;YACpC,KAAK6C,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASnX,KAAA;cAC7B,OAAO/iC,CAAA,CAAKg7C,QAAA,CAASv6C,CAAA,GAAY;YACnC,KAAK6C,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASh1C,KAAA;cAC7B,OAAOlF,CAAA,CAAKi7C,UAAA,CAAWx6C,CAAA,GAAY;YACrC,KAAK6C,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASlX,KAAA;cAC7B,OAAOhjC,CAAA,CAAKk7C,QAAA,CAASz6C,CAAA,GAAY;YACnC,KAAK6C,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAS7W,MAAA;cAC7B,OAAOrjC,CAAA,CAAKm7C,SAAA,CAAU16C,CAAA,GAAY;YACpC,KAAK6C,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASjX,KAAA;cAC7B,OAAO18B,CAAA,CACHtF,CAAA,CAAAs5C,OAAA,CAAKa,QAAA,CAASp7C,CAAA,CAAKm7C,SAAA,CAAU16C,CAAA,GAAY,IAAOT,CAAA,CAAKm7C,SAAA,CAAU16C,CAAA,GAAa,IAAG,KAAO,IAAQR,CAAA;YACpG,KAAKqD,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAS9W,MAAA;cAC7B,OAAOpjC,CAAA,CAAKq7C,UAAA,CAAW56C,CAAA,GAAY;YACrC,KAAK6C,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAS5W,MAAA;cAC7B,OAAO/8B,CAAA,CACHtF,CAAA,CAAAs5C,OAAA,CAAKa,QAAA,CAASp7C,CAAA,CAAKm7C,SAAA,CAAU16C,CAAA,GAAY,IAAOT,CAAA,CAAKm7C,SAAA,CAAU16C,CAAA,GAAa,IAAG,KAAO,IAAOR,CAAA;YACnG;cACE,MAAM,IAAIoE,KAAA,CAAM,sCAAsCf,CAAA,CAAAO,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASj6C,CAAA;UAAA;QAEtF;QA7aAA,CAAA,CAAAgG,MAAA,GAAAoF,C;;;;;;;;;;;;;QCzCA,MAAA3K,CAAA,GAAAD,CAAA;UACAQ,CAAA,GAAAT,CAAA,CAAAC,CAAA;UAIAS,CAAA,GAAAT,CAAA;UACA6C,CAAA,GAAA7C,CAAA;QAMAR,CAAA,CAAAq7C,gBAAA,aAAiCt7C,CAAA,KAAqBC,CAAA;UACpD,KAAKD,CAAA,IAAUA,CAAA,CAAO8B,MAAA,KAAW7B,CAAA,CAAmB6B,MAAA,EAClD,QAAO;UAET,KAAK,IAAIrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAO8B,MAAA,EAAQrB,CAAA,IACjC,KAAKT,CAAA,CAAOS,CAAA,EAAGoT,IAAA,IAAQ7T,CAAA,CAAOS,CAAA,EAAGoT,IAAA,CAAK/R,MAAA,KAAW7B,CAAA,CAAmBQ,CAAA,GAClE,QAAO;UAGX,QAAO,CACT;QAAA,GAGAR,CAAA,CAAA+uB,MAAA,aAAuBhvB,CAAA,EAAeC,CAAA;UACpC,KAAKD,CAAA,EACH,MAAM,IAAIqE,KAAA,CAAqB,mBAARpE,CAAA,GAAmBA,CAAA,GAAMA,CAAA,GAEpD;QAAA,GAEAA,CAAA,CAAAsK,SAAA;UAOE,OAAAC,YACIxK,CAAA,EAEAC,CAAA;YAEF,IAAID,CAAA,CAAG8B,MAAA,KAAW7B,CAAA,CAAG6B,MAAA,EACnB,QAAO;YAET,KAAK,IAAIrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAG8B,MAAA,EAAQrB,CAAA,IAC7B,IAAIT,CAAA,CAAGS,CAAA,MAAOR,CAAA,CAAGQ,CAAA,GACf,QAAO;YAGX,QAAO,CACT;UAAA;QAAA;QAGF,MAAaiD,CAAA;UAOX,OAAA63C,sBAA6Bv7C,CAAA,EAA0BC,CAAA;YAYrD,OAAO,CAPqB,MAAjBD,CAAA,CAAM8B,MAAA,GAAgB,CAAC,GAAG9B,CAAA,CAAM,MAAMA,CAAA,EAKrB,MAAjBC,CAAA,CAAM6B,MAAA,GAAgB,CAAC7B,CAAA,CAAM,IAAI,KAAKA,CAAA,CAGnD;UAAA;UASA,OAAAu7C,uBAA8Bx7C,CAAA,EAAuBC,CAAA,EAAeQ,CAAA;YAEpD,MAAVR,CAAA,IAEFD,CAAA,CAAYywB,MAAA,CAAOzwB,CAAA,CAAY8B,MAAA,GAAS,GAAG,IAG/B,MAAVrB,CAAA,IACFT,CAAA,CAAYmwB,GAAA,EAEhB;UAAA;UAQA,OAAAsrB,gBAAuBz7C,CAAA,EAAqBC,CAAA;YAC1C,OAAQD,CAAA,CAAE,OAAOC,CAAA,CAAE,UAAM,IAAY,CAACD,CAAA,CAAE,IAAIC,CAAA,CAAE,GAChD;UAAA;QAAA;QAjDFA,CAAA,CAAAy7C,UAAA,GAAAh4C,CAAA;QAoDA,MAAa+G,CAAA;UAQX,OAAAuU,UAAiBhf,CAAA,EAA0BC,CAAA,EAA0BQ,CAAA,IAAW;YAC9E,MAAMD,CAAA,GAAQR,CAAA,CAAM8B,MAAA;cACdpB,CAAA,GAAQT,CAAA,CAAM6B,MAAA;YACpB,IAAc,MAAVtB,CAAA,EACF,OAAOP,CAAA;YAET,IAAc,MAAVS,CAAA,EACF,OAAOV,CAAA;YAET,MAAMiB,CAAA,GAAQe,IAAA,CAAKwnB,GAAA,CAAIxpB,CAAA,CAAM8B,MAAA,EAAQ7B,CAAA,CAAM6B,MAAA;cACrCZ,CAAA,GAAQ,IAAI8E,KAAA,CAAc/E,CAAA;YAGhC,IAAIR,CAAA,EAAU;cACZ,IAAID,CAAA,GAAQ,KAAKE,CAAA,GAAQ,GACvB;cAEF,MAAMD,CAAA,GACFiD,CAAA,CAAW+3C,eAAA,CAAgB,CAACz7C,CAAA,CAAMQ,CAAA,GAAQ,IAAIR,CAAA,CAAMQ,CAAA,GAAQ,KAAK,CAACP,CAAA,CAAMS,CAAA,GAAQ,IAAIT,CAAA,CAAMS,CAAA,GAAQ;cACtG,SAAqB,MAAjBD,CAAA,EACF;cAAA,CAEDS,CAAA,CAAMD,CAAA,GAAQ,IAAIC,CAAA,CAAMD,CAAA,GAAQ,MAAMR,C;;YAGzC,KAAK,IAAI6C,CAAA,GAAI7C,CAAA,GAAW,IAAI,GAAG6C,CAAA,IAAKrC,CAAA,EAAOqC,CAAA,IAAK;cAC9C,MAAM7C,CAAA,GAAOD,CAAA,GAAQ8C,CAAA,GAAI,IAAI,IAAItD,CAAA,CAAMQ,CAAA,GAAQ8C,CAAA;gBACzCI,CAAA,GAAOhD,CAAA,GAAQ4C,CAAA,GAAI,IAAI,IAAIrD,CAAA,CAAMS,CAAA,GAAQ4C,CAAA;cAE/C,IAAI7C,CAAA,KAASiD,CAAA,IAAQjD,CAAA,GAAO,KAAKiD,CAAA,GAAO,GACtC;cAEFxC,CAAA,CAAMD,CAAA,GAAQqC,CAAA,IAAKtB,IAAA,CAAKwnB,GAAA,CAAI/oB,CAAA,EAAMiD,CAAA,C;;YAGpC,OAAOxC,CACT;UAAA;UAQA,OAAA0pC,MAAa5qC,CAAA,EAAuCC,CAAA;YAIlD,MAAMQ,CAAA,GAAkB,IAAIuF,KAAA,CAAM/F,CAAA,CAAc6B,MAAA;YAEhD,OADA2I,CAAA,CAAckxC,SAAA,CAAU37C,CAAA,EAAoBC,CAAA,EAAeQ,CAAA,GACpDA,CACT;UAAA;UASA,OAAAk7C,UAAiB37C,CAAA,EAAuCC,CAAA,EAAkCQ,CAAA;YAIxF,MAAMD,CAAA,GAAYR,CAAA,CAAmB8B,MAAA,GAAS7B,CAAA,CAAc6B,MAAA;YAC5D,KAAK,IAAIpB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAc6B,MAAA,EAAQpB,CAAA,IACxCD,CAAA,CAAgBC,CAAA,IAAKV,CAAA,CAAmBQ,CAAA,GAAYE,CAAA,IAAKT,CAAA,CAAcS,CAAA,CAE3E;UAAA;UAUA,OAAAk7C,KACI57C,CAAA,EAAWC,CAAA,EAAWQ,CAAA,EAA+DD,CAAA,EACrFE,CAAA;YACF,MAAMO,CAAA,GAAcwJ,CAAA,CAAcuU,SAAA,CAAUhf,CAAA,CAAE6T,IAAA,EAAM5T,CAAA,CAAE4T,IAAA;YAEtD,IAAI5S,CAAA,EAAa;cACf,IAAIT,CAAA,KAAY+K,CAAA,CAAUwT,QAAA,CAAS9d,CAAA,EAAajB,CAAA,CAAE6T,IAAA,GAEhD;cAGF,MAAM3S,CAAA,GAAOqK,CAAA,CAAUnH,IAAA,CAAKnD,CAAA;gBACtByC,CAAA,GAAIlD,CAAA,GAAUR,CAAA,GAAI,IAAIsD,CAAA,CAAA2C,MAAA,CAAOhF,CAAA,EAAaP,CAAA,IAAcV,CAAA,CAAEgF,IAAA;cAGhE,IAA2B,MAAvB/D,CAAA,CAAYa,MAAA,EACd4B,CAAA,CAAEK,GAAA,CAAI,IAAItD,CAAA,CAAGT,CAAA,CAAEwE,GAAA,CAAI,KAAevE,CAAA,CAAEuE,GAAA,CAAI,WAIrC;gBACH,MAAMhE,CAAA,GAAgB,IAAIwF,KAAA,CAAc/E,CAAA,CAAYa,MAAA;kBAC9CpB,CAAA,GAAmB,IAAIsF,KAAA,CAAMhG,CAAA,CAAE6T,IAAA,CAAK/R,MAAA;kBACpCwB,CAAA,GAAmB,IAAI0C,KAAA,CAAM/F,CAAA,CAAE4T,IAAA,CAAK/R,MAAA;gBAC1C,IAYIuJ,CAAA;kBAZAC,CAAA,GAAsB;kBACtBC,CAAA,GAAsB;kBACtBhF,CAAA,IAAY;kBACZmF,CAAA,IAAY;gBACM,MAAlB1L,CAAA,CAAE6T,IAAA,CAAK/R,MAAA,KACTwJ,CAAA,GAAOtL,CAAA,CAAEwE,GAAA,CAAI,KACb+B,CAAA,IAAY,IAEQ,MAAlBtG,CAAA,CAAE4T,IAAA,CAAK/R,MAAA,KACTyJ,CAAA,GAAOtL,CAAA,CAAEuE,GAAA,CAAI,KACbkH,CAAA,IAAY;gBAGd,KAAK,IAAIlF,CAAA,GAAI,GAAGA,CAAA,GAAItF,CAAA,EAAMsF,CAAA,IAAK;kBAE7B6E,CAAA,GAAO7E,CAAA;kBACP,KAAK,IAAIxG,CAAA,GAAIiB,CAAA,CAAYa,MAAA,GAAS,GAAG9B,CAAA,IAAK,GAAGA,CAAA,IAC3CQ,CAAA,CAAcR,CAAA,IAAKqL,CAAA,GAAOpK,CAAA,CAAYjB,CAAA,GACtCqL,CAAA,GAAOrJ,IAAA,CAAKoX,KAAA,CAAM/N,CAAA,GAAOpK,CAAA,CAAYjB,CAAA;kBAGlCuG,CAAA,KAEHkE,CAAA,CAAckxC,SAAA,CAAUn7C,CAAA,EAAeR,CAAA,CAAE6T,IAAA,EAAMnT,CAAA,GAC/C4K,CAAA,GAAOtL,CAAA,CAAEwE,GAAA,CAAI9D,CAAA,IAEVgL,CAAA,KACHjB,CAAA,CAAckxC,SAAA,CAAUn7C,CAAA,EAAeP,CAAA,CAAE4T,IAAA,EAAMvQ,CAAA,GAC/CiI,CAAA,GAAOtL,CAAA,CAAEuE,GAAA,CAAIlB,CAAA,IAGfI,CAAA,CAAEK,GAAA,CAAIvD,CAAA,EAAeC,CAAA,CAAG6K,CAAA,EAAMC,CAAA,E;;;cAIlC,OAAO7H,C;;UAIX;UAOA,OAAAm4C,iBAAwB77C,CAAA,EAA0BC,CAAA;YAEhD,MAAMQ,CAAA,GAAYT,CAAA,CAAM8B,MAAA;cAClBtB,CAAA,GAAYP,CAAA,CAAW6B,MAAA;YAC7B,IAAIrB,CAAA,GAAYD,CAAA,EACd,QAAO;YAET,KAAK,IAAIE,CAAA,GAAI,GAAGA,CAAA,IAAKD,CAAA,EAAWC,CAAA,IAC9B,IAA6B,MAAzBV,CAAA,CAAMS,CAAA,GAAYC,CAAA,KAAYV,CAAA,CAAMS,CAAA,GAAYC,CAAA,MAAOT,CAAA,CAAWO,CAAA,GAAYE,CAAA,GAChF,QAAO;YAGX,QAAO,CACT;UAAA;UASA,OAAA+K,iBAAwBzL,CAAA,EAA+BC,CAAA;YACrD,MAAMQ,CAAA,GAAST,CAAA,CAAW8B,MAAA;cACpBtB,CAAA,GAAiB;YACvB,KAAK,IAAIE,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,EAAQC,CAAA,IAAK;cAC/B,MAAMO,CAAA,GAAMR,CAAA,GAAS,IAAIC,CAAA;gBACnBQ,CAAA,GAAIlB,CAAA,CAAWiB,CAAA,KAAQ;cAAA,CACnBhB,CAAA,CAAYA,CAAA,CAAY6B,MAAA,GAAS,IAAIpB,CAAA,KAAM,KAC7C,KAAW,MAANQ,CAAA,IACXV,CAAA,CAAKs7C,OAAA,CAAQ76C,CAAA,C;;YAGjB,OAAOT,CACT;UAAA;QAAA;QA9LFP,CAAA,CAAAuL,aAAA,GAAAf,CAAA,EAmMAxK,CAAA,CAAA87C,eAAA,aACI/7C,CAAA,EAAoCC,CAAA,EAAoCQ,CAAA,EAAqBD,CAAA,EAC7FE,CAAA;UACF,IAAIF,CAAA,GAAc,KAAKA,CAAA,IAAeP,CAAA,CAAO6B,MAAA,EAC3C,MAAM,IAAIuC,KAAA,CAAM;UAElB,IAAI5D,CAAA,GAAc,KAAKA,CAAA,IAAeT,CAAA,CAAO8B,MAAA,EAC3C,MAAM,IAAIuC,KAAA,CAAM;UAElB,IAAI7D,CAAA,GAAcE,CAAA,GAAYT,CAAA,CAAO6B,MAAA,EACnC,MAAM,IAAIuC,KAAA,CAAM;UAElB,IAAI5D,CAAA,GAAcC,CAAA,GAAYV,CAAA,CAAO8B,MAAA,EACnC,MAAM,IAAIuC,KAAA,CAAM;UAGlB,KAAK,IAAIpD,CAAA,GAAS,GAAGA,CAAA,GAASP,CAAA,EAAWO,CAAA,IACvCjB,CAAA,CAAOS,CAAA,GAAcQ,CAAA,IAAUhB,CAAA,CAAOO,CAAA,GAAcS,CAAA,CAExD;QAAA,GAEAhB,CAAA,CAAAsjB,QAAA;UAIE,OAAAC,qBACIxjB,CAAA,EAA8BC,CAAA,EAAoBQ,CAAA,EAA+BD,CAAA,EACjFE,CAAA;YACF,IAAyB,MAArBV,CAAA,CAAU8B,MAAA,IAAsC,MAAtBrB,CAAA,CAAWqB,MAAA,EACvC,MAAM,IAAIuC,KAAA,CAAM;YAGlB,IAAIpD,CAAA,EACAC,CAAA,EACAoC,CAAA;YAEArD,CAAA,IACFgB,CAAA,GAAIjB,CAAA,CAAU,IACdkB,CAAA,GAAIlB,CAAA,CAAU,OAEdiB,CAAA,GAAIjB,CAAA,CAAU,IACdkB,CAAA,GAAIlB,CAAA,CAAU;YAGhB,IAAI0D,CAAA,IAAQ;YAUZ,IARIlD,CAAA,IACF8C,CAAA,GAAI7C,CAAA,CAAW,IACfiD,CAAA,GAAO,MAEPJ,CAAA,GAAI7C,CAAA,CAAW,IACfiD,CAAA,GAAO,IAGLjD,CAAA,CAAWiD,CAAA,MAAUxC,CAAA,EACvB,MAAM,IAAImD,KAAA,CAAM;YAGlB,IAAIpD,CAAA,IAAK,KAAKqC,CAAA,IAAK,KAAKpC,CAAA,IAAK,GAC3B,MAAM,IAAImD,KAAA,CAAM;YAGlB,IAAI3D,CAAA,KAAc+J,CAAA,CAAcoxC,gBAAA,CAAiBn7C,CAAA,EAAW,CAACO,CAAA,EAAGqC,CAAA,IAC9D,MAAM,IAAIe,KAAA,CAAM;YAGlB,OAAO,CAACpD,CAAA,EAAGqC,CAAA,EAAGpC,CAAA,CAChB;UAAA;QAAA;QAGF,MAAamK,CAAA;UACX,OAAA6T,wBAA+Blf,CAAA;YAE7B,QAAQA,CAAA;cACN,KAAKkB,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASrX,IAAA;gBAC7B,OAAO;cACT,KAAK3hC,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAStX,KAAA;gBAC7B,OAAO;cACT,KAAK1hC,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAShX,IAAA;gBAC7B,OAAO;cACT,KAAKhiC,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASnX,KAAA;gBAC7B,OAAO;cACT,KAAK7hC,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASpX,MAAA;gBAC7B,OAAO;cACT,KAAK5hC,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASlX,KAAA;gBAC7B,OAAO;cACT,KAAK9hC,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAS7W,MAAA;gBAC7B,OAAO;cACT,KAAKniC,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASh1C,KAAA;gBAC7B,OAAO;cACT,KAAKhE,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAS9W,MAAA;gBAC7B,OAAO;cACT,KAAKliC,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAS90C,MAAA;gBAC7B,OAAO;cAIT,KAAKlE,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASjX,KAAA;gBAC7B,OAAO;cACT,KAAK/hC,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAS5W,MAAA;gBAC7B,OAAO;cAET;gBACE,MAAM,IAAIj/B,KAAA,CAAM,0BAA0BnD,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASl6C,CAAA;YAAA;UAE1E;UAEA,OAAAg8C,2BAAkCh8C,CAAA;YAChC,QAAQA,CAAA;cACN,KAAK;gBACH,OAAOkB,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASrX,IAAA;cACnC,KAAK;gBACH,OAAO3hC,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAStX,KAAA;cACnC,KAAK;gBACH,OAAO1hC,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAShX,IAAA;cACnC,KAAK;gBACH,OAAOhiC,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASnX,KAAA;cACnC,KAAK;gBACH,OAAO7hC,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASpX,MAAA;cACnC,KAAK;gBACH,OAAO5hC,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASlX,KAAA;cACnC,KAAK;gBACH,OAAO9hC,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAS7W,MAAA;cACnC,KAAK;gBACH,OAAOniC,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASh1C,KAAA;cACnC,KAAK;gBACH,OAAOhE,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAS9W,MAAA;cACnC,KAAK;gBACH,OAAOliC,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAS90C,MAAA;cACnC,KAAK;gBACH,OAAOlE,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAASjX,KAAA;cACnC,KAAK;gBACH,OAAO/hC,CAAA,CAAA2C,IAAA,CAAKo2C,WAAA,CAAYC,QAAA,CAAS5W,MAAA;cAEnC;gBACE,MAAM,IAAIj/B,KAAA,CAAM,0BAA0BrE,CAAA;YAAA;UAEhD;UAEA,OAAA08B,oBAA2B18B,CAAA;YAEzB,OAAOA,CAAA,CAAKmD,GAAA,CAAInD,CAAA,IAAKiB,CAAA,CAAAs5C,OAAA,CAAKz0C,MAAA,CAAO9F,CAAA,IAAKA,CAAA,CAAE46C,QAAA,KAAa56C,CAAA,CACvD;UAAA;UAEA,OAAAm7B,yBAAgCn7B,CAAA;YAC9B,OAAO;cACLo7B,UAAA,EAAY/vB,CAAA,CAAU6T,uBAAA,CAAwBlf,CAAA,CAAUm9B,QAAA;cACxDrvB,KAAA,EAAO;gBAAC+F,IAAA,EAAMxI,CAAA,CAAUqxB,mBAAA,CAAoB18B,CAAA,CAAU8N,KAAA,CAAOuvB,GAAA,CAAKl6B,GAAA,CAAInD,CAAA,IAAKA,CAAA,CAAEs9B,QAAA;cAAA;YAAA,CAEjF;UAAA;UAEA,OAAAE,wBAA+Bx9B,CAAA;YAC7B,MAAMC,CAAA,GAAO;YACb,KAAK,IAAIQ,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOquC,UAAA,IAAc5tC,CAAA,IACvCR,CAAA,CAAK+G,IAAA,CAAKsE,CAAA,CAASvF,YAAA,CAAa/F,CAAA,CAAO6T,IAAA,CAAKpT,CAAA;YAE9C,OAAOR,CACT;UAAA;UAEA,OAAAu7B,8BAAqCx7B,CAAA;YACnC,MAAMC,CAAA,GAAa;YACnB,KAAK,IAAIQ,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAK49B,gBAAA,IAAoBn9B,CAAA,IAC3CR,CAAA,CAAW+G,IAAA,CAAKhH,CAAA,CAAK4d,UAAA,CAAWnd,CAAA;YAElC,OAAOR,CACT;UAAA;QAAA;QA/FFA,CAAA,CAAAgf,SAAA,GAAA5T,CAAA;QAkGA,MAAaC,CAAA;UAIX,OAAAvF,aAAoB/F,CAAA,EAAiCC,CAAA;YACnD,OAAIgB,CAAA,CAAAs5C,OAAA,CAAKz0C,MAAA,CAAO9F,CAAA,IACPA,CAAA,CAAE46C,QAAA,KACA56C,CAAA,YAAaU,CAAA,CAAA8gC,WAAA,CAAYya,IAAA,GAC3Bh7C,CAAA,CAAAs5C,OAAA,CAAK2B,SAAA,CAAU;cAACC,GAAA,EAAKn8C,CAAA,CAAEm8C,GAAA;cAAKC,IAAA,EAAMp8C,CAAA,CAAEo8C,IAAA;cAAMC,QAAA,EAAU,QAAAp8C,CAAA,IAAAA;YAAA,GAAoB26C,QAAA,KAE1E56C,CACT;UAAA;UACA,OAAA8F,OAAc9F,CAAA;YACZ,OAAOiB,CAAA,CAAAs5C,OAAA,CAAKz0C,MAAA,CAAO9F,CAAA,KAAMA,CAAA,YAAaU,CAAA,CAAA8gC,WAAA,CAAYya,IACpD;UAAA;QAAA;QAdFh8C,CAAA,CAAA4F,QAAA,GAAAyF,CAAA;QAiBA,MAAaC,CAAA;UACX,OAAAnH,KAAYpE,CAAA;YACV,OAAOuL,CAAA,CAAU+wC,yBAAA,CAA0Bt8C,CAAA,EAAM,GAAGA,CAAA,CAAK8B,MAAA,CAC3D;UAAA;UAGA,OAAAolB,kBAAyBlnB,CAAA,EAAyBC,CAAA;YAChD,IAAIA,CAAA,GAAO,KAAKA,CAAA,GAAOD,CAAA,CAAK8B,MAAA,EAC1B,MAAM,IAAIuC,KAAA,CAAM,wBAAwBpE,CAAA,wCAA4CD,CAAA,CAAK8B,MAAA;YAE3F,OAAOyJ,CAAA,CAAU+wC,yBAAA,CAA0Bt8C,CAAA,EAAMC,CAAA,EAAMD,CAAA,CAAK8B,MAAA,CAC9D;UAAA;UAGA,OAAAmlB,gBAAuBjnB,CAAA,EAAyBC,CAAA;YAC9C,IAAIA,CAAA,GAAO,KAAKA,CAAA,GAAOD,CAAA,CAAK8B,MAAA,EAC1B,MAAM,IAAIuC,KAAA,CAAM,wBAAwBpE,CAAA,sCAA0CD,CAAA,CAAK8B,MAAA;YAEzF,OAAOyJ,CAAA,CAAU+wC,yBAAA,CAA0Bt8C,CAAA,EAAM,GAAGC,CAAA,CACtD;UAAA;UAEA,OAAAq8C,0BAAiCt8C,CAAA,EAAyBC,CAAA,EAAeQ,CAAA;YACvE,IAAID,CAAA,GAAO;YACX,KAAK,IAAIE,CAAA,GAAIT,CAAA,EAAOS,CAAA,GAAID,CAAA,EAAKC,CAAA,IAAK;cAGhC,IAAIV,CAAA,CAAKU,CAAA,KAAM,GACb,MAAM,IAAI2D,KAAA,CAEN;cAEN7D,CAAA,IAAQR,CAAA,CAAKU,CAAA,C;;YAEf,OAAOF,CACT;UAAA;UAEA,OAAA+U,eAAsBvV,CAAA;YACpB,MAAMC,CAAA,GAAOD,CAAA,CAAK8B,MAAA;YAClB,IAAa,MAAT7B,CAAA,EACF,OAAO;YACF,IAAa,MAATA,CAAA,EACT,OAAO,CAAC;YAEV,MAAMQ,CAAA,GAAU,IAAIuF,KAAA,CAAM/F,CAAA;YAC1BQ,CAAA,CAAQR,CAAA,GAAO,KAAK,GACpBQ,CAAA,CAAQR,CAAA,GAAO,KAAKD,CAAA,CAAKC,CAAA,GAAO;YAChC,KAAK,IAAIO,CAAA,GAAIP,CAAA,GAAO,GAAGO,CAAA,IAAK,KAAKA,CAAA,EAC/BC,CAAA,CAAQD,CAAA,IAAKC,CAAA,CAAQD,CAAA,GAAI,KAAKR,CAAA,CAAKQ,CAAA,GAAI;YAEzC,OAAOC,CACT;UAAA;UAEA,OAAA0c,UAAiBnd,CAAA;YAEf,OADaA,CAAA,CAAKkN,KAAA,GACNW,OAAA,EACd;UAAA;UAEA,OAAAmE,gBAAuBhS,CAAA,EAA4BC,CAAA,EAA4BQ,CAAA;YAAA,KAChE,MAATA,CAAA,KACFA,CAAA,GAAOT,CAAA,CAAQ8B,MAAA;YAEjB,IAAItB,CAAA,GAAS;YACb,KAAK,IAAIE,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,IAAQC,CAAA,EAC1BF,CAAA,IAAUP,CAAA,CAAQS,CAAA,IAAKV,CAAA,CAAQU,CAAA;YAEjC,OAAOF,CACT;UAAA;UAEA,OAAAuR,gBAAuB/R,CAAA,EAAgBC,CAAA;YACrC,MAAMQ,CAAA,GAAOR,CAAA,CAAQ6B,MAAA;YACrB,IAAa,MAATrB,CAAA,EACF,OAAO;YACF,IAAa,MAATA,CAAA,EACT,OAAO,CAACT,CAAA,GAASC,CAAA,CAAQ;YAE3B,MAAMO,CAAA,GAAoB,IAAIwF,KAAA,CAAM/F,CAAA,CAAQ6B,MAAA;YAC5C,KAAK,IAAIrB,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQsB,MAAA,GAAS,KAAKrB,CAAA,EACxCD,CAAA,CAAQC,CAAA,IAAKuB,IAAA,CAAKoX,KAAA,CAAMpZ,CAAA,GAASC,CAAA,CAAQQ,CAAA,IACzCT,CAAA,IAAUQ,CAAA,CAAQC,CAAA,IAAKR,CAAA,CAAQQ,CAAA;YAGjC,OADAD,CAAA,CAAQA,CAAA,CAAQsB,MAAA,GAAS,KAAK9B,CAAA,EACvBQ,CACT;UAAA;UAKA,OAAAoiB,cAAqB5iB,CAAA,EAAcC,CAAA;YACjC,IAAID,CAAA,IAAQC,CAAA,IAAcD,CAAA,IAAQC,CAAA,EAChC,MAAM,IAAIoE,KAAA,CAAM;YAElB,OAAOrE,CAAA,GAAO,IAAIA,CAAA,GAAOC,CAAA,GAAaD,CACxC;UAAA;UAEA,OAAA6lB,cAAqB7lB,CAAA,EAAyBC,CAAA;YAC5C,OAAOD,CAAA,CAAKmD,GAAA,CAAInD,CAAA,IAAK,KAAK4iB,aAAA,CAAc5iB,CAAA,EAAGC,CAAA,EAC7C;UAAA;UAUA,OAAAs8C,eAAsBv8C,CAAA,EAAiBC,CAAA,EAAyBQ,CAAA;YAC9D,IAAoB,MAAhBR,CAAA,CAAK6B,MAAA,IAAiC,MAAjB9B,CAAA,CAAM8B,MAAA,EAC7B,MAAM,IAAIuC,KAAA,CAAM;YAElB,SAA0B,MAAtB5D,CAAA,EACFA,CAAA,GAAoBR,CAAA,CAAK6B,MAAA,MAEzB,IAAIrB,CAAA,IAAqB,KAAKA,CAAA,GAAoBR,CAAA,CAAK6B,MAAA,EACrD,MAAM,IAAIuC,KAAA,CAAM;YAIpB,KAAK,IAAI7D,CAAA,GAAIC,CAAA,GAAoB,GAAGD,CAAA,IAAK,MACvCR,CAAA,CAAMQ,CAAA,OACFR,CAAA,CAAMQ,CAAA,IAAKP,CAAA,CAAKO,CAAA,OAFwBA,CAAA,EAK5CR,CAAA,CAAMQ,CAAA,IAAK,CAEf;UAAA;UAcA,OAAAslB,sBAA6B9lB,CAAA,EAAiCC,CAAA;YAE5D,IAA0B,MAAtBA,CAAA,CAAW6B,MAAA,EAAc;cAC3B,IAA4B,MAAxB9B,CAAA,CAAa8B,MAAA,IAAiD,MAAjCyJ,CAAA,CAAUnH,IAAA,CAAKpE,CAAA,GAC9C,OAAO;cAEP,MAAM,IAAIqE,KAAA,CAAM,oC;;YAIpB,MAAM5D,CAAA,GAAQR,CAAA,CAAW6B,MAAA;cACnBtB,CAAA,GAAe,IAAIwF,KAAA,CAAcvF,CAAA;YACvC,IAAIC,CAAA,IAAoB;cACpBO,CAAA,GAAgB;YACpB,KAAK,IAAIC,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,EAAOS,CAAA,IAAK;cAC9B,IAAIjB,CAAA,CAAWiB,CAAA,KAAM,GACnB,MAAM,IAAImD,KAAA,CAAM;cAElB,KAAuB,MAAnBpE,CAAA,CAAWiB,CAAA,GAAW;gBACxB,KAA0B,MAAtBR,CAAA,EACF,MAAM,IAAI2D,KAAA,CAAM;gBAElB3D,CAAA,GAAmBQ,C;qBACd;gBACL,IAAsB,MAAlBjB,CAAA,CAAWiB,CAAA,GAAU;kBACvB,IAAIA,CAAA,IAAKlB,CAAA,CAAa8B,MAAA,EACpB,MAAM,IAAIuC,KAAA,CAAM;kBAElB7D,CAAA,CAAaU,CAAA,IAAKlB,CAAA,CAAakB,CAAA,C;uBAE/BV,CAAA,CAAaU,CAAA,IAAKjB,CAAA,CAAWiB,CAAA;gBAE/BD,CAAA,IAAiBT,CAAA,CAAaU,CAAA,C;;;YAIlC,MAAMA,CAAA,GAAgBqK,CAAA,CAAUnH,IAAA,CAAKpE,CAAA;YACrC,KAA0B,MAAtBU,CAAA,EAAyB;cAC3B,IAAIQ,CAAA,GAAgBD,CAAA,IAAkB,GACpC,MAAM,IAAIoD,KAAA,CAAM,6EACZrE,CAAA,oBAAgCC,CAAA;cAEtCO,CAAA,CAAaE,CAAA,IAAoBQ,CAAA,GAAgBD,C;mBAIjD,IAAIA,CAAA,KAAkBC,CAAA,EACpB,MAAM,IAAImD,KAAA,CAAM;YAGpB,OAAO7D,CACT;UAAA;UAQA,OAAA0nB,gBAAuBloB,CAAA,EAAsBC,CAAA;YAC3C,OAAIA,CAAA,GACKA,CAAA,CAAKkD,GAAA,CAAKlD,CAAA,IAAMD,CAAA,CAAEC,CAAA,KAElBD,CAAA,CAAEkN,KAAA,GAAQW,OAAA,EAErB;UAAA;UAOA,OAAA2W,SAAgBxkB,CAAA,EAAyBC,CAAA;YACvC,MAAMQ,CAAA,GAAOT,CAAA,CAAK8B,MAAA;YAClB,OAAO9B,CAAA,CAAKmD,GAAA,CAAI,CAACnD,CAAA,EAAGQ,CAAA,KAAMR,CAAA,GAAIC,CAAA,CAAIO,CAAA,IAAKP,CAAA,CAAIO,CAAA,GAAIC,CAAA,EACjD;UAAA;UAOA,OAAAse,SAAgB/e,CAAA,EAA2BC,CAAA;YACzC,OAAID,CAAA,CAAO8B,MAAA,KAAW7B,CAAA,CAAO6B,MAAA,IAGtB9B,CAAA,CAAOimB,KAAA,CAAM,CAACjmB,CAAA,EAAGS,CAAA,KAAMT,CAAA,KAAMC,CAAA,CAAOQ,CAAA,EAC7C;UAAA;UAMA,OAAAq5C,wBAA+B95C,CAAA;YAC7B,IAAIA,CAAA,CAAK8B,MAAA,GAAS,GAChB,MAAM,IAAIigB,SAAA,CAAU;YAEtB,IAAI9hB,CAAA,GAAO;YACX,KAAK,MAAMQ,CAAA,IAAKT,CAAA,EAAM;cACpB,KAAK0B,MAAA,CAAOC,SAAA,CAAUlB,CAAA,GACpB,MAAM,IAAIshB,SAAA,CAAU,kBAAkBthB,CAAA;cAExC,IAAIA,CAAA,GAAI,KAAKA,CAAA,GAAI,YACf,MAAM,IAAIshB,SAAA,CAAU,yBAAyBthB,CAAA;cAE/CR,CAAA,IAAQQ,C;;YAEV,OAAOR,CACT;UAAA;UAOA,OAAAiiB,aAAoBliB,CAAA,EAAyBC,CAAA;YACvCA,CAAA,GAAO,MACTA,CAAA,IAAQD,CAAA,CAAK8B,MAAA;YAEf,MAAMrB,CAAA,GAAQT,CAAA,CAAKwlB,MAAA,CAAO,CAACxlB,CAAA,EAAGC,CAAA,KAAMD,CAAA,GAAIC,CAAA,EAAG;cACrCO,CAAA,GAAQR,CAAA,CAAKkN,KAAA,CAAMjN,CAAA,EAAMulB,MAAA,CAAO,CAACxlB,CAAA,EAAGC,CAAA,KAAMD,CAAA,GAAIC,CAAA,EAAG;YAGvD,OAFmB,CAACQ,CAAA,GAAQD,CAAA,EAAOA,CAAA,CAGrC;UAAA;UAOA,OAAAoN,aAAoB5N,CAAA,EAAyBC,CAAA;YAC3C,MAAMQ,CAAA,GAAa,IAAIuF,KAAA;YAGvB/F,CAAA,GAAOsL,CAAA,CAAUsa,aAAA,CAAc5lB,CAAA,EAAMD,CAAA,CAAK8B,MAAA;YAE1C,KAAK,IAAItB,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK8B,MAAA,EAAQtB,CAAA,IAAK;cACpC,MAAME,CAAA,GAAgBT,CAAA,CAAKmM,OAAA,CAAQ5L,CAAA,KAAM;cACzC,IAAIE,CAAA,IAA6B,MAAZV,CAAA,CAAKQ,CAAA,GACxB,MAAM,IAAI6D,KAAA,CAAM;cAAA,CAGG,MAAhBpE,CAAA,CAAK6B,MAAA,IAAgB9B,CAAA,CAAKQ,CAAA,IAAK,KAAOP,CAAA,CAAK6B,MAAA,GAAS,MAAMpB,CAAA,KAC7DD,CAAA,CAAWuG,IAAA,CAAKhH,CAAA,CAAKQ,CAAA,E;;YAIzB,OAAOC,CACT;UAAA;UAOA,OAAAkpB,eAAsB3pB,CAAA,EAAyBC,CAAA;YAC7C,MAAMQ,CAAA,GAAa,IAAIuF,KAAA,CAAchG,CAAA,CAAK8B,MAAA,GAAS7B,CAAA,CAAK6B,MAAA;YAGxDrB,CAAA,CAAW4e,IAAA,CAAK;YAGhB,KAAK,IAAIrf,CAAA,GAAI,GAAGA,CAAA,GAAIC,CAAA,CAAK6B,MAAA,EAAQ9B,CAAA,IAAK;cACpC,MAAMQ,CAAA,GAAO+K,CAAA,CAAUqX,aAAA,CAAc3iB,CAAA,CAAKD,CAAA,GAAIS,CAAA,CAAWqB,MAAA;cACzD,IAAItB,CAAA,IAAQC,CAAA,CAAWqB,MAAA,EACrB,MAAM,IAAIuC,KAAA,CAAM;cAElB,IAAyB,MAArB5D,CAAA,CAAWD,CAAA,GACb,MAAM,IAAI6D,KAAA,CAAM;cAGlB5D,CAAA,CAAWD,CAAA,IAAQ,C;;YAIrB,IAAIA,CAAA,GAAoB;YACxB,KAAK,IAAIP,CAAA,GAAI,GAAGA,CAAA,GAAIQ,CAAA,CAAWqB,MAAA,EAAQ7B,CAAA,IACf,MAAlBQ,CAAA,CAAWR,CAAA,MACbQ,CAAA,CAAWR,CAAA,IAAKD,CAAA,CAAKQ,CAAA;YAMzB,IAAIA,CAAA,KAAsBR,CAAA,CAAK8B,MAAA,EAC7B,MAAM,IAAIuC,KAAA,CAAM;YAGlB,OAAO5D,CACT;UAAA;QAAA;QAzUFR,CAAA,CAAAiM,SAAA,GAAAX,CAAA,EA6UAtL,CAAA,CAAAu8C,QAAA;UAEE,OAAAC,IACIz8C,CAAA,EAAoCC,CAAA,EAAoCQ,CAAA,EAAqBD,CAAA,EAC7FE,CAAA;YACF,IAAIF,CAAA,GAAc,KAAKA,CAAA,IAAeP,CAAA,CAAO6B,MAAA,EAC3C,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAI5D,CAAA,GAAc,KAAKA,CAAA,IAAeT,CAAA,CAAO8B,MAAA,EAC3C,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAI7D,CAAA,GAAcE,CAAA,GAAYT,CAAA,CAAO6B,MAAA,EACnC,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAI5D,CAAA,GAAcC,CAAA,GAAYV,CAAA,CAAO8B,MAAA,EACnC,MAAM,IAAIuC,KAAA,CAAM;YAGlB,KAAK,IAAIpD,CAAA,GAAS,GAAGA,CAAA,GAASP,CAAA,EAAWO,CAAA,IACvCjB,CAAA,CAAOS,CAAA,GAAcQ,CAAA,KAAWe,IAAA,CAAKmZ,GAAA,CAAIlb,CAAA,CAAOO,CAAA,GAAcS,CAAA,GAAS,EAE3E;UAAA;UAGA,OAAAy7C,KACI18C,CAAA,EAAoCC,CAAA,EAAoCQ,CAAA,EAAqBD,CAAA,EAC7FE,CAAA,EAAmBO,CAAA;YACrB,IAAIT,CAAA,GAAc,KAAKA,CAAA,IAAeP,CAAA,CAAO6B,MAAA,EAC3C,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAI5D,CAAA,GAAc,KAAKA,CAAA,IAAeT,CAAA,CAAO8B,MAAA,EAC3C,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAI7D,CAAA,GAAcE,CAAA,GAAYT,CAAA,CAAO6B,MAAA,EACnC,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAI5D,CAAA,GAAcC,CAAA,GAAYV,CAAA,CAAO8B,MAAA,EACnC,MAAM,IAAIuC,KAAA,CAAM;YAGlB,KAAK,IAAInD,CAAA,GAAS,GAAGA,CAAA,GAASR,CAAA,EAAWQ,CAAA,IACvClB,CAAA,CAAOS,CAAA,GAAcS,CAAA,KAAYD,CAAA,GAAQhB,CAAA,CAAOO,CAAA,GAAcU,CAAA,CAElE;UAAA;UAGA,OAAAy7C,KACI38C,CAAA,EAAoCC,CAAA,EAAoCQ,CAAA,EAAqBD,CAAA,EAC7FE,CAAA,EAAmBO,CAAA;YACrB,IAAIT,CAAA,GAAc,KAAKA,CAAA,IAAeP,CAAA,CAAO6B,MAAA,EAC3C,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAI5D,CAAA,GAAc,KAAKA,CAAA,IAAeT,CAAA,CAAO8B,MAAA,EAC3C,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAI7D,CAAA,GAAcE,CAAA,GAAYT,CAAA,CAAO6B,MAAA,EACnC,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAI5D,CAAA,GAAcC,CAAA,GAAYV,CAAA,CAAO8B,MAAA,EACnC,MAAM,IAAIuC,KAAA,CAAM;YAGlB,KAAK,IAAInD,CAAA,GAAS,GAAGA,CAAA,GAASR,CAAA,EAAWQ,CAAA,IACvClB,CAAA,CAAOS,CAAA,GAAcS,CAAA,IAAUc,IAAA,CAAKmZ,GAAA,CAAIlb,CAAA,CAAOO,CAAA,GAAcU,CAAA,GAASD,CAAA,CAE1E;UAAA;UAGA,OAAA6R,IACI9S,CAAA,EAAoCC,CAAA,EAAoCQ,CAAA,EAAqBD,CAAA,EAC7FE,CAAA;YACF,IAAIF,CAAA,GAAc,KAAKA,CAAA,IAAeP,CAAA,CAAO6B,MAAA,EAC3C,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAI5D,CAAA,GAAc,KAAKA,CAAA,IAAeT,CAAA,CAAO8B,MAAA,EAC3C,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAI7D,CAAA,GAAcE,CAAA,GAAYT,CAAA,CAAO6B,MAAA,EACnC,MAAM,IAAIuC,KAAA,CAAM;YAElB,IAAI5D,CAAA,GAAcC,CAAA,GAAYV,CAAA,CAAO8B,MAAA,EACnC,MAAM,IAAIuC,KAAA,CAAM;YAGlB,KAAK,IAAIpD,CAAA,GAAS,GAAGA,CAAA,GAASP,CAAA,EAAWO,CAAA,IACvCjB,CAAA,CAAOS,CAAA,GAAcQ,CAAA,IAAWhB,CAAA,CAAOO,CAAA,GAAcS,CAAA,IAAUjB,CAAA,CAAOS,CAAA,GAAcQ,CAAA,CAExF;UAAA;QAAA;QAGF,MAAasF,CAAA;UAOX,OAAAohB,WAAkB3nB,CAAA,EAAyBC,CAAA,EAAcQ,CAAA,EAAiBD,CAAA;YAExE,IAAqB,MAAjBC,CAAA,CAAMqB,MAAA,EAAc;cACtB,KAAKtB,CAAA,EACH,MAAM,IAAI6D,KAAA,CAAM;cAElBkC,CAAA,CAAUq2C,cAAA,CAAe58C,CAAA,CAAKC,CAAA,GAAOO,CAAA,EAAYC,CAAA,C;;YAGnD,MAAMC,CAAA,GAAqB;cACrBO,CAAA,GAAU,CAAC;YACjB,KAAK,IAAIT,CAAA,GAAI,GAAGA,CAAA,GAAIC,CAAA,CAAMqB,MAAA,IAAUtB,CAAA,EAAG;cAC3B,MAANA,CAAA,IACFS,CAAA,CAAQ+F,IAAA,CAAK/F,CAAA,CAAQT,CAAA,GAAI,KAAKC,CAAA,CAAMD,CAAA,GAAI;cAE1C,MAAMU,CAAA,GAAQlB,CAAA,CAAKkN,KAAA;cACnBhM,CAAA,CAAMjB,CAAA,IAAQQ,CAAA,CAAMD,CAAA,GACpBE,CAAA,CAAOsG,IAAA,CAAK9F,CAAA,C;;YAEd,OAAO,CAACR,CAAA,EAAQO,CAAA,CAClB;UAAA;UAEA,OAAA27C,eAAsB58C,CAAA,EAA8BC,CAAA,EAAoBQ,CAAA;YAEtE,IAAIT,CAAA,GAAuBC,CAAA,IAAe,GACxC,MAAM,IAAIoE,KAAA,CAAM;YAElB,KAAK,IAAI7D,CAAA,GAAI,GAAGA,CAAA,GAAIP,CAAA,IAAcO,CAAA,EAChCC,CAAA,CAAMuG,IAAA,CAAKhH,CAAA,GAAuBC,CAAA,CAEtC;UAAA;QAAA;QArCFA,CAAA,CAAAynB,SAAA,GAAAnhB,CAAA;QAwCA,MAAamF,CAAA;UAUX,OAAAmxC,WACI78C,CAAA,EAAWC,CAAA,EAAgBQ,CAAA,EAAmBD,CAAA,EAC9CE,CAAA;YACF,MAAMO,CAAA,GAAOjB,CAAA,CAAE6T,IAAA,CAAK3G,KAAA,CAAM;YAEN,MAAhBjN,CAAA,CAAK6B,MAAA,IACPb,CAAA,CAAK4J,OAAA,CAAQ,CAAC7K,CAAA,EAAGS,CAAA,KAAQR,CAAA,CAAK+G,IAAA,CAAKvG,CAAA;YAGrC,MAAMS,CAAA,GAAawK,CAAA,CAAWoxC,eAAA,CAAgB77C,CAAA,EAAMhB,CAAA,GAAM;cAGpDyD,CAAA,GAAO6H,CAAA,CAAUnH,IAAA,CAAKlD,CAAA;cACtBmK,CAAA,GAAI,IAAI/H,CAAA,CAAA2C,MAAA,CAAO/E,CAAA,EAAYlB,CAAA,CAAEgF,IAAA;cAC7BsG,CAAA,GAAUC,CAAA,CAAUgK,cAAA,CAAerU,CAAA;cACnCqF,CAAA,GAAegF,CAAA,CAAUgK,cAAA,CAAetU,CAAA;cACxCuF,CAAA,GAAW,IAAIR,KAAA,CAAM/E,CAAA,CAAKa,MAAA;YAChC,KAAK,IAAIrB,CAAA,GAAI,GAAGA,CAAA,GAAIiD,CAAA,EAAMjD,CAAA,IAAK;cAC7B,MAAMS,CAAA,GAAUqK,CAAA,CAAUwG,eAAA,CAAgBtR,CAAA,EAAG6K,CAAA;cAE7Cb,CAAA,CAAckxC,SAAA,CAAUz6C,CAAA,EAASD,CAAA,EAAMuF,CAAA,GACvC6E,CAAA,CAAEtH,GAAA,CACE7C,CAAA,EACAwK,CAAA,CAAWqxC,gBAAA,CACP/8C,CAAA,CAAE2U,UAAA,EAAY1U,CAAA,EAAMgB,CAAA,EAAM,GAAGsK,CAAA,CAAUyG,eAAA,CAAgBxL,CAAA,EAAUD,CAAA,GAAe/F,CAAA,EAAKE,CAAA,E;;YAG/F,OAAID,CAAA,GACK4K,CAAA,GAGA,IAAI/H,CAAA,CAAA2C,MAAA,CACPyF,CAAA,CAAWoxC,eAAA,CAAgB77C,CAAA,EAAMhB,CAAA,EAAMQ,CAAA,GAAW4K,CAAA,CAAErG,IAAA,OAAM,QAAW,GAAWqG,CAAA,CAAEoY,IAAA,EAAMpY,CAAA,CAAEmJ,MAAA,CAElG;UAAA;UAaA,OAAAuoC,iBACI/8C,CAAA,EAA0BC,CAAA,EAAgBQ,CAAA,EAAgBD,CAAA,EAAoBE,CAAA,EAC9EO,CAAA,EAA4BC,CAAA;YAC9B,IAAIoC,CAAA,GAAM;YACV,IAAI9C,CAAA,IAAcP,CAAA,CAAK6B,MAAA,EACrB,OAAOb,CAAA,CAAIjB,CAAA,CAAMU,CAAA;YAEnB,MAAMgD,CAAA,GAAOzD,CAAA,CAAKO,CAAA;cACZiK,CAAA,GAAO/G,CAAA,IAAQjD,CAAA,CAAKqB,MAAA,GAAS,IAAIyJ,CAAA,CAAUnH,IAAA,CAAK3D,CAAA,CAAKyM,KAAA,CAAMxJ,CAAA,GAAO;YACxE,KAAK,IAAI2H,CAAA,GAAI,GAAGA,CAAA,GAAI5K,CAAA,CAAKiD,CAAA,GAAO2H,CAAA,IAC9B/H,CAAA,GAAY,MAAN+H,CAAA,GAAUK,CAAA,CAAWqxC,gBAAA,CAAiB/8C,CAAA,EAAOC,CAAA,EAAMQ,CAAA,EAAMD,CAAA,GAAa,GAAGE,CAAA,EAAKO,CAAA,EAAKC,CAAA,IACzEA,CAAA,CAAIoC,CAAA,EAAKoI,CAAA,CAAWqxC,gBAAA,CAAiB/8C,CAAA,EAAOC,CAAA,EAAMQ,CAAA,EAAMD,CAAA,GAAa,GAAGE,CAAA,EAAKO,CAAA,EAAKC,CAAA,IAClGR,CAAA,IAAO+J,CAAA;YAET,OAAOnH,CACT;UAAA;UASA,OAAAw5C,gBAAuB98C,CAAA,EAAyBC,CAAA,EAAyBQ,CAAA;YACvE,MAAMD,CAAA,GAAaR,CAAA,CAAKkN,KAAA;YACxB,KAAK,IAAIlN,CAAA,GAAI,GAAGA,CAAA,GAAIC,CAAA,CAAK6B,MAAA,EAAQ9B,CAAA,IAE7BQ,CAAA,CAAWP,CAAA,CAAKD,CAAA,KADdS,CAAA,GACoB,IAEA;YAG1B,OAAOD,CAAA,CAAW0P,MAAA,CAAOlQ,CAAA,IAAe,MAARA,CAAA,CAClC;UAAA;QAAA;QA3FFC,CAAA,CAAA+8C,UAAA,GAAAtxC,CAAA;QA8FA,MAAalF,CAAA;UAUX,OAAA6e,qBACIrlB,CAAA,EAA2BC,CAAA,EAA8BQ,CAAA,EAAuBD,CAAA,EAChFE,CAAA,EAAqBO,CAAA;YACvB,KAAKjB,CAAA,IAAoBS,CAAA,CAAYqB,MAAA,KAAW7B,CAAA,CAAU6B,MAAA,GAAS,GACjE,MAAM,IAAIuC,KAAA,CAAM;YAGlB,IAAIrE,CAAA,EAEF,KAAK,IAAIA,CAAA,GAAM,GAAGA,CAAA,GAAMC,CAAA,CAAU6B,MAAA,GAAS,GAAG9B,CAAA,IACxCA,CAAA,IAAOS,CAAA,CAAYqB,MAAA,GACrBrB,CAAA,CAAYuG,IAAA,CAAK/G,CAAA,CAAUD,CAAA,GAAM,MAEjCS,CAAA,CAAYT,CAAA,IAAOC,CAAA,CAAUD,CAAA,GAAM;YAMzC,KAAK,IAAIA,CAAA,GAAM,GAAGA,CAAA,GAAMS,CAAA,CAAYqB,MAAA,EAAQ9B,CAAA,IAC1C,IAAIA,CAAA,GAAMQ,CAAA,CAAQsB,MAAA;cAChB,IAAItB,CAAA,CAAQR,CAAA,IAAO,GACjB,MAAM,IAAIqE,KAAA,CAAM;YAAA,OAGlB7D,CAAA,CAAQwG,IAAA,CAAK;YAKjB,KAAK,IAAIhH,CAAA,GAAM,GAAGA,CAAA,GAAMS,CAAA,CAAYqB,MAAA,EAAQ9B,CAAA,IAC1C,IAAIA,CAAA,GAAMU,CAAA,CAAUoB,MAAA;cAClB,IAAIpB,CAAA,CAAUV,CAAA,IAAO,GACnB,MAAM,IAAIqE,KAAA,CAAM;YAAA,OAGlB3D,CAAA,CAAUsG,IAAA,CAAK;YAKnB,KAAK,IAAIhH,CAAA,GAAM,GAAGA,CAAA,GAA2B,IAArBS,CAAA,CAAYqB,MAAA,EAAY9B,CAAA,IAC9C,IAAIA,CAAA,GAAMiB,CAAA,CAAKa,MAAA;cACb,IAAIb,CAAA,CAAKjB,CAAA,IAAO,GACd,MAAM,IAAIqE,KAAA,CAAM;YAAA,OAGlBpD,CAAA,CAAK+F,IAAA,CAAK;YAKd,KAAK,IAAIhH,CAAA,GAAM,GAAGA,CAAA,GAAMS,CAAA,CAAYqB,MAAA,EAAQ9B,CAAA,IAAO;cACjD,IAAIS,CAAA,CAAYT,CAAA,KAAQ,GACtB,MAAM,IAAIqE,KAAA,CAAM;cAGlB,IAAIpD,CAAA,CAAKjB,CAAA,KAAQS,CAAA,CAAYT,CAAA,KAAQiB,CAAA,CAAKjB,CAAA,GAAMS,CAAA,CAAYqB,MAAA,KAAWrB,CAAA,CAAYT,CAAA,GACjF,MAAM,IAAIqE,KAAA,CAAM,qC;;UAGtB;UAGA,OAAAsd,yBACI3hB,CAAA,EAA8BC,CAAA,EAA4BQ,CAAA,EAC1DD,CAAA,EAAgCE,CAAA,EAAgBO,CAAA;YAClD,IAAKA,CAAA,EAAL;cAIA,IAAIP,CAAA,CAAKoB,MAAA,KAAW,KAAK9B,CAAA,CAAU8B,MAAA,GAAS,IAC1C,MAAM,IAAIuC,KAAA,CAAM;cAGlB,IAAIpE,CAAA,CAAQ6B,MAAA,KAAY9B,CAAA,CAAU8B,MAAA,GAAS,GACzC,MAAM,IAAIuC,KAAA,CAAM;cAGlB,IAAI7D,CAAA,CAAYsB,MAAA,KAAY9B,CAAA,CAAU8B,MAAA,GAAS,GAC7C,MAAM,IAAIuC,KAAA,CAAM;cAGlB,KAAK,IAAInD,CAAA,GAAM,GAAGA,CAAA,GAAMlB,CAAA,CAAU8B,MAAA,GAAS,GAAGZ,CAAA,IAC5CsF,CAAA,CAAay2C,uBAAA,CACTj9C,CAAA,CAAUkB,CAAA,GAAM,IAAIjB,CAAA,CAAQiB,CAAA,GAAMT,CAAA,CAAUS,CAAA,GAAMV,CAAA,CAAYU,CAAA,GAAMR,CAAA,EAAMQ,CAAA,EAAKA,CAAA,GAAMlB,CAAA,CAAU8B,MAAA,GAAS,GACxGb,CAAA,C;;UAER;UAaA,OAAAqkB,uBACItlB,CAAA,EAA2BC,CAAA,EAA8BQ,CAAA,EAAmBD,CAAA,EAC5EE,CAAA,EAAuBO,CAAA,EAAgBC,CAAA;YACzC,IAAIjB,CAAA,CAAU6B,MAAA,IAAU,GACtB,MAAM,IAAIuC,KAAA,CAAM;YAIlB,MAAMf,CAAA,GAAa,CAACrD,CAAA,CAAU,IAAIA,CAAA,CAAU;YAI5C,OAFAuG,CAAA,CAAa02C,kBAAA,CACTl9C,CAAA,EAAkBC,CAAA,EAAWqD,CAAA,EAAY7C,CAAA,EAASD,CAAA,EAAWE,CAAA,EAAaO,CAAA,EAAMC,CAAA,GAC7EoC,CACT;UAAA;UAYA,OAAA65C,uBACIn9C,CAAA,EAA8BC,CAAA,EAA+BQ,CAAA,EAAmBD,CAAA,EAChFE,CAAA,EAAuBO,CAAA,EAAgBC,CAAA;YACzC,IAAIlB,CAAA,CAAU8B,MAAA,IAAU,KAAK7B,CAAA,CAAW6B,MAAA,IAAU,GAChD,MAAM,IAAIuC,KAAA,CAAM;YAIlB,MAAMf,CAAA,GAAa,CAACtD,CAAA,CAAU,IAAIC,CAAA,CAAW;YAG7C,OADAuG,CAAA,CAAa02C,kBAAA,EAAmB,GAAOl9C,CAAA,EAAWsD,CAAA,EAAY7C,CAAA,EAASD,CAAA,EAAWE,CAAA,EAAaO,CAAA,EAAMC,CAAA,GAC9FoC,CACT;UAAA;UAKQ,OAAA45C,mBACJl9C,CAAA,EAA2BC,CAAA,EAA8BQ,CAAA,EAAsBD,CAAA,EAC/EE,CAAA,EAA8BO,CAAA,EAAgCC,CAAA,EAAgBoC,CAAA;YAChF,IAAItD,CAAA,EACF,KAAK,IAAIA,CAAA,GAAM,GAAGA,CAAA,GAAMC,CAAA,CAAU6B,MAAA,GAAS,GAAG9B,CAAA,IAC5CS,CAAA,CAAWuG,IAAA,CAAK,QAGlB,KAAK,IAAIhH,CAAA,GAAM,GAAGA,CAAA,GAAMC,CAAA,CAAU6B,MAAA,GAAS,GAAG9B,CAAA,IAC5CS,CAAA,CAAWuG,IAAA,CAAKR,CAAA,CAAay2C,uBAAA,CACzBh9C,CAAA,CAAUD,CAAA,GAAM,IAAIQ,CAAA,CAAQR,CAAA,GAAMU,CAAA,CAAUV,CAAA,GAAMiB,CAAA,CAAYjB,CAAA,GAAMkB,CAAA,EAAMlB,CAAA,EAAKA,CAAA,GAAMC,CAAA,CAAU6B,MAAA,GAAS,GACxGwB,CAAA,EAGV;UAAA;UAIQ,OAAA25C,wBACJj9C,CAAA,EAAgBC,CAAA,EAAgBQ,CAAA,EAAkBD,CAAA,EAAgBE,CAAA,EAAgBO,CAAA,EAClFC,CAAA,EAAsBoC,CAAA;YACxB,MAAMI,CAAA,GAAUjD,CAAA,IAAYD,CAAA,GAAS,KAAK;YAC1C,KAAI8C,CAAA,IAAuB,aAAZA,CAAA,EAsBb,OAAOtB,IAAA,CAAKoX,KAAA,EAAQpZ,CAAA,GAASU,CAAA,CAAKO,CAAA,IAAgBP,CAAA,CAAKQ,CAAA,IAAgBwC,CAAA,IAAWzD,CAAA,GAAU;YArB5F,QAAQqD,CAAA;cACN,KAAK;gBAGH,OAFA5C,CAAA,CAAKO,CAAA,IAAgB,GACrBP,CAAA,CAAKQ,CAAA,IAAgB,GACdc,IAAA,CAAKoX,KAAA,EAAQpZ,CAAA,GAAS0D,CAAA,IAAWzD,CAAA,GAAU;cACpD,KAAK;cACL,KAAK;gBACH,IAAiB,MAAbQ,CAAA,EACF,MAAM,IAAI4D,KAAA,CAAM;gBACX;kBACL,MACM5D,CAAA,KADoBT,CAAA,GAASC,CAAA,GAAS,KAAKA,CAAA,GACX,KAAKA,CAAA,GAASO,CAAA,GAASR,CAAA;kBAI7D,OAHAU,CAAA,CAAKO,CAAA,IACY,iBAAZqC,CAAA,GAA4BtB,IAAA,CAAKoX,KAAA,EAAO3Y,CAAA,GAAY,KAAK,KAAKuB,IAAA,CAAKoX,KAAA,CAAM3Y,CAAA,GAAY,IAC1FC,CAAA,CAAKQ,CAAA,IAAgBT,CAAA,GAAYC,CAAA,CAAKO,CAAA,GAC/Be,IAAA,CAAKoX,KAAA,EAAQpZ,CAAA,GAASS,CAAA,GAAYD,CAAA,IAAUP,CAAA,GAAU,E;;cAEjE;gBACE,MAAM,IAAIoE,KAAA,CAAM;YAAA;UAKxB;QAAA;QAvMFpE,CAAA,CAAAyhB,YAAA,GAAAlb,CAAA,EA0MavG,CAAA,CAAAwiB,QAAA,IAAY,sBACZxiB,CAAA,CAAAyiB,QAAA,GAAW,sBAExBziB,CAAA,CAAAmG,gBAAA,aAAiCpG,CAAA;UAC/B,OAAO,IAAIo9C,WAAA,GAAcjuC,MAAA,CAAOnP,CAAA,CAClC;QAAA,C;;;;;;;gCChuCaC,CAAA,CAAA0C,OAAA,GAAU,Q;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QCHvB,MAAAW,CAAA,GAAA7C,CAAA;UAGAiD,CAAA,GAAAxC,CAAA,CAAAT,CAAA;UACAgK,CAAA,GAAAhK,CAAA;UAEM4K,CAAA,GAAUgyC,CAAA,OAAiB/5C,CAAA,CAAAlC,GAAA,CAAIC,IAAA,CAAKG,KAAA,IAA6B,sBAAbuwB,QAAA;QAC1D,IAAIzmB,CAAA;UAQAC,CAAA;UACAhF,CAAA;UARAmF,CAAA,IAAe;UACflF,CAAA,IAAc;UACdoF,CAAA,IAAU;QAOd,MAAMC,CAAA,GAAiF;UACjFE,CAAA,GAAuF;UACvFC,CAAA,GAA+E;UAC/EC,CAAA,GAAyD;UACzDE,CAAA,GAA8D;UAC9DE,CAAA,GAAuD;UAEvDqK,CAAA,GAAe4mC,CAAA;YACnB,IAAI5xC,CAAA,KAAiBlF,CAAA,IAAeoF,CAAA,KAAYN,CAAA,EAC9C,MAAM,IAAIjH,KAAA,CAAM,mB;;UAIdsS,CAAA,GAAwB3W,CAAA;YAC5B,QAAQA,CAAA,CAAGyjB,IAAA,CAAKze,IAAA;cACd,KAAK;gBACH0G,CAAA,IAAe,GACX1L,CAAA,CAAGyjB,IAAA,CAAK85B,GAAA,IACV3xC,CAAA,IAAU,GACVL,CAAA,CAAkB,GAAGvL,CAAA,CAAGyjB,IAAA,CAAK85B,GAAA,MAE7B/2C,CAAA,IAAc,GACd+E,CAAA,CAAkB;gBAEpB;cACF,KAAK;gBACCvL,CAAA,CAAGyjB,IAAA,CAAK85B,GAAA,GACVh3C,CAAA,CAAiB,GAAGvG,CAAA,CAAGyjB,IAAA,CAAK85B,GAAA,IAE5Bh3C,CAAA,CAAiB;gBAEnB;cACF,KAAK;gBACCvG,CAAA,CAAGyjB,IAAA,CAAK85B,GAAA,GACV1xC,CAAA,CAA+B2xC,KAAA,GAAS,GAAGx9C,CAAA,CAAGyjB,IAAA,CAAK85B,GAAA,IAEnD1xC,CAAA,CAA+B2xC,KAAA,GAAS,GAAGx9C,CAAA,CAAGyjB,IAAA,CAAKg6B,GAAA;gBAErD;cACF,KAAK;gBACCz9C,CAAA,CAAGyjB,IAAA,CAAK85B,GAAA,GACVxxC,CAAA,CAA+ByxC,KAAA,GAAS,GAAGx9C,CAAA,CAAGyjB,IAAA,CAAK85B,GAAA,IAEnDxxC,CAAA,CAA+ByxC,KAAA,GAAS,GAAGx9C,CAAA,CAAGyjB,IAAA,CAAKg6B,GAAA;gBAErD;cACF,KAAK;gBACCz9C,CAAA,CAAGyjB,IAAA,CAAK85B,GAAA,GACVvxC,CAAA,CAAuBwxC,KAAA,GAAS,GAAGx9C,CAAA,CAAGyjB,IAAA,CAAK85B,GAAA,IAE3CvxC,CAAA,CAAuBwxC,KAAA,GAAS,GAAGx9C,CAAA,CAAGyjB,IAAA,CAAKg6B,GAAA;gBAE7C;cACF,KAAK;gBACCz9C,CAAA,CAAGyjB,IAAA,CAAK85B,GAAA,GACVtxC,CAAA,CAAwBuxC,KAAA,GAAS,GAAGx9C,CAAA,CAAGyjB,IAAA,CAAK85B,GAAA,IAE5CtxC,CAAA,CAAwBuxC,KAAA,GAAS;gBAEnC;cACF,KAAK;gBACCx9C,CAAA,CAAGyjB,IAAA,CAAK85B,GAAA,GACVpxC,CAAA,CAAaqxC,KAAA,GAAS,GAAGx9C,CAAA,CAAGyjB,IAAA,CAAK85B,GAAA,IAEjCpxC,CAAA,CAAaqxC,KAAA,GAAS,GAAGx9C,CAAA,CAAGyjB,IAAA,CAAKg6B,GAAA;gBAEnC;cACF,KAAK;gBACCz9C,CAAA,CAAGyjB,IAAA,CAAK85B,GAAA,GACVlxC,CAAA,CAAsBmxC,KAAA,GAAS,GAAGx9C,CAAA,CAAGyjB,IAAA,CAAK85B,GAAA,IAE1ClxC,CAAA,CAAsBmxC,KAAA,GAAS;YAAA;;UAOjC5mC,CAAA,GAAgC,sBAAbmb,QAAA,GAAyE,UAA7CvxB,CAAA,GAAQ,SAARuxB,QAAA,SAAQ,MAARA,QAAA,QAAQ,IAARA,QAAA,CAAU2rB,aAAA,UAAmC,MAAAl9C,CAAA,YAAAA,CAAA,CAAEm9C,GAAA,QAAM;QAE7F19C,CAAA,CAAAmC,6BAAA,GAAgC;UAC3C,IAAsCiJ,CAAA,IAAW;YAC/C,IAAI7E,CAAA,EACF;YAEF,IAAIkF,CAAA,EACF,MAAM,IAAIrH,KAAA,CAAM;YAElB,IAAIuH,CAAA,EACF,MAAM,IAAIvH,KAAA,CAAM;YAYlB,OATAqH,CAAA,IAAe,QAGY,MAAvBpI,CAAA,CAAAlC,GAAA,CAAIC,IAAA,CAAKu8C,SAAA,IACPhnC,CAAA,IAA4C,MAA/BA,CAAA,CAAUxK,OAAA,CAAQ,aACjC9I,CAAA,CAAAlC,GAAA,CAAIC,IAAA,CAAKu8C,SAAA,GAAYhnC,CAAA,CAAUinC,MAAA,CAAO,IAAIjnC,CAAA,CAAYknC,WAAA,CAAY,OAAO,KAItE,IAAIx7C,OAAA,CAAc,CAACtC,CAAA,EAASC,CAAA;cACjC,QAAAqL,CAAA,IAAAA,CAAA,CAAayyC,SAAA,IAEbzyC,CAAA,GAAc7K,CAAA,OAAAu9C,CAAA,IACd1yC,CAAA,CAAY2yC,SAAA,GAAYtnC,CAAA,EACxBpL,CAAA,GAAoB,CAACvL,CAAA,EAASC,CAAA;cAC9B,MAAMO,CAAA,GAA0B;gBAACwE,IAAA,EAAM;gBAAak5C,EAAA,EAAK56C,CAAA,CAAAlC,GAAA,CAAIC;cAAA;cAC7DiK,CAAA,CAAY6yC,WAAA,CAAY39C,CAAA,CAAQ;YAAA,E;;UAIlC,QAAO,GAAAiK,CAAA,CAAA2zC,qBAAA,EAAsB96C,CAAA,CAAAlC,GAAA,CAAIC,IAAA,C;WAIxBpB,CAAA,CAAAo+C,iBAAA,GAAoB,MAAMr+C,CAAA;UACrC,IAAsCqL,CAAA,IAEpC,OADAqL,CAAA,IACO,IAAIpU,OAAA,CAAc,CAACrC,CAAA,EAASQ,CAAA;YACjC8F,CAAA,GAAmB,CAACtG,CAAA,EAASQ,CAAA;YAC7B,MAAMD,CAAA,GAA0B;cAACwE,IAAA,EAAM;cAAYk5C,EAAA,EAAKl+C;YAAA;YACxDsL,CAAA,CAAa6yC,WAAA,CAAY39C,CAAA,CAAQ;UAAA;UAAA,MAG7BkD,CAAA,CAAK46C,WAAA,CAAYt+C,CAAA,C;WAIdC,CAAA,CAAAs+C,qBAAA,GAAwB,MAAMv+C,CAAA,IACHqL,CAAA,MACpCqL,CAAA,IACO,IAAIpU,OAAA,CAA+B,CAACrC,CAAA,EAASQ,CAAA;UAClDoL,CAAA,CAA+B7E,IAAA,CAAK,CAAC/G,CAAA,EAASQ,CAAA;UAC9C,MAAMD,CAAA,GAA0B;YAACwE,IAAA,EAAM;YAAmBk5C,EAAA,EAAK;cAACtc,KAAA,EAAA5hC;YAAA;UAAA;UAChEsL,CAAA,CAAa6yC,WAAA,CAAY39C,CAAA,EAAS,CAACR,CAAA,CAAM4uB,MAAA,EAAQ;QAAA,MAG5ClrB,CAAA,CAAK66C,qBAAA,CAAsBv+C,CAAA,GAIzBC,CAAA,CAAAu+C,qBAAA,GAAwB,OAAMx+C,CAAA,EAAkCC,CAAA,KAEjCoL,CAAA,MACpCqL,CAAA,IACO,IAAIpU,OAAA,CAAqC,CAAC7B,CAAA,EAASD,CAAA;UACxDuL,CAAA,CAA+B/E,IAAA,CAAK,CAACvG,CAAA,EAASD,CAAA;UAC9C,MAAME,CAAA,GAA0B;YAACsE,IAAA,EAAM;YAAmBk5C,EAAA,EAAK;cAACO,SAAA,EAAAz+C,CAAA;cAAW0+C,OAAA,EAAAz+C;YAAA;UAAA;UAC3EqL,CAAA,CAAa6yC,WAAA,CAAYz9C,CAAA,CAAQ;QAAA,MAG5BgD,CAAA,CAAK86C,qBAAA,CAAsBx+C,CAAA,EAAWC,CAAA,GAIxCA,CAAA,CAAA0+C,aAAA,GACT,OAAM3+C,CAAA,EAAmBC,CAAA,KACWoL,CAAA,MACpCqL,CAAA,IACO,IAAIpU,OAAA,CAAqC,CAAC7B,CAAA,EAASD,CAAA;UACxDwL,CAAA,CAAuBhF,IAAA,CAAK,CAACvG,CAAA,EAASD,CAAA;UACtC,MAAME,CAAA,GAA0B;YAACsE,IAAA,EAAM;YAAUk5C,EAAA,EAAK;cAACtc,KAAA,EAAA5hC,CAAA;cAAO0+C,OAAA,EAAAz+C;YAAA;UAAA;UAC9DqL,CAAA,CAAa6yC,WAAA,CAAYz9C,CAAA,EAAS,CAACV,CAAA,CAAM4uB,MAAA,EAAQ;QAAA,MAG5ClrB,CAAA,CAAKi7C,aAAA,CAAc3+C,CAAA,EAAOC,CAAA,GAIxBA,CAAA,CAAA2+C,cAAA,GAAiB,MAAM5+C,CAAA;UAClC,IAAsCqL,CAAA,IAEpC,OADAqL,CAAA,IACO,IAAIpU,OAAA,CAAc,CAACrC,CAAA,EAASQ,CAAA;YACjCwL,CAAA,CAAwBjF,IAAA,CAAK,CAAC/G,CAAA,EAASQ,CAAA;YACvC,MAAMD,CAAA,GAA0B;cAACwE,IAAA,EAAM;cAAWk5C,EAAA,EAAKl+C;YAAA;YACvDsL,CAAA,CAAa6yC,WAAA,CAAY39C,CAAA,CAAQ;UAAA;UAGnCkD,CAAA,CAAKk7C,cAAA,CAAe5+C,CAAA,C;WAIXC,CAAA,CAAAkU,GAAA,GAAM,OACfnU,CAAA,EAAmBC,CAAA,EAAwBQ,CAAA,EAA8BD,CAAA,EACzEE,CAAA,KACoC2K,CAAA,MACpCqL,CAAA,IACO,IAAIpU,OAAA,CAA8B,CAACrB,CAAA,EAASC,CAAA;UACjDiL,CAAA,CAAanF,IAAA,CAAK,CAAC/F,CAAA,EAASC,CAAA;UAC5B,MAAMoC,CAAA,GAA0B;YAAC0B,IAAA,EAAM;YAAOk5C,EAAA,EAAK;cAACW,SAAA,EAAA7+C,CAAA;cAAW8+C,YAAA,EAAA7+C,CAAA;cAAc2pB,MAAA,EAAAnpB,CAAA;cAAQs+C,aAAA,EAAAv+C,CAAA;cAAek+C,OAAA,EAAAh+C;YAAA;UAAA;UACpG4K,CAAA,CAAa6yC,WAAA,CAAY76C,CAAA,EAASI,CAAA,CAAKs7C,0BAAA,CAA2Bv+C,CAAA,EAAQ;QAAA,MAGrEiD,CAAA,CAAKyQ,GAAA,CAAInU,CAAA,EAAWC,CAAA,EAAcQ,CAAA,EAAQD,CAAA,EAAeE,CAAA,GAIvDT,CAAA,CAAAo4C,YAAA,GAAe,MAAMr4C,CAAA;UAChC,IAAsCqL,CAAA,IAEpC,OADAqL,CAAA,IACO,IAAIpU,OAAA,CAAc,CAACrC,CAAA,EAASQ,CAAA;YACjC4L,CAAA,CAAsBrF,IAAA,CAAK,CAAC/G,CAAA,EAASQ,CAAA;YACrC,MAAMD,CAAA,GAA0B;cAACwE,IAAA,EAAM;cAAiBk5C,EAAA,EAAKl+C;YAAA;YAC7DsL,CAAA,CAAa6yC,WAAA,CAAY39C,CAAA,CAAQ;UAAA;UAGnCkD,CAAA,CAAK20C,YAAA,CAAar4C,CAAA,C;;;;;;;;;QC9NtB,MAAAQ,CAAA,GAAAC,CAAA;UACAC,CAAA,GAAAD,CAAA;QAEaR,CAAA,CAAAg/C,aAAA,GAAiBj/C,CAAA;UAC5B,MAAMC,CAAA,IAAO,GAAAO,CAAA,CAAA0+C,WAAA;UACb,IAAIz+C,CAAA,GAAmB;UACvB,MAAMQ,CAAA,GAAmB;YAEnBC,CAAA,GAA0ClB,CAAA,IAAW,CAAC;UAE5D;YACE,SAAkC,OAA9B,QAAAA,CAAA,QAAO,IAAPA,CAAA,CAASm/C,gBAAA,GACXj+C,CAAA,CAAWi+C,gBAAA,GAAmB,OACzB,IACiC,mBAA7Bn/C,CAAA,CAAQm/C,gBAAA,KAAkCz9C,MAAA,CAAOC,SAAA,CAAU3B,CAAA,CAAQm/C,gBAAA,KAC1En/C,CAAA,CAAQm/C,gBAAA,GAAmB,KAAKn/C,CAAA,CAAQm/C,gBAAA,GAAmB,GAC7D,MAAM,IAAI96C,KAAA,CAAM,qCAAqCrE,CAAA,CAAQm/C,gBAAA;YAG/D,SAAmC,OAA/B,QAAAn/C,CAAA,QAAO,IAAPA,CAAA,CAASo/C,iBAAA,GACXl+C,CAAA,CAAWk+C,iBAAA,GAAoB,OAC1B,IAAyC,mBAA9Bp/C,CAAA,CAAQo/C,iBAAA,KAAmC19C,MAAA,CAAOC,SAAA,CAAU3B,CAAA,CAAQo/C,iBAAA,GACpF,MAAM,IAAI/6C,KAAA,CAAM,qCAAqCrE,CAAA,CAAQo/C,iBAAA;YAAA,KAGpC,OAAvB,QAAAp/C,CAAA,QAAO,IAAPA,CAAA,CAAS+9C,SAAA,MACX78C,CAAA,CAAW68C,SAAA,IAAY;YAGzB,IAAIv9C,CAAA,GAAgB;YAsBpB,YArBqB,OAAjB,QAAAR,CAAA,QAAO,IAAPA,CAAA,CAASq/C,GAAA,MACX7+C,CAAA,IAAgB,GAAAE,CAAA,CAAA4+C,eAAA,EAAgBt/C,CAAA,CAAQq/C,GAAA,EAAKp+C,CAAA,IAG/CR,CAAA,GAAmBR,CAAA,CAAKs/C,oBAAA,CACpBr+C,CAAA,CAAWi+C,gBAAA,EAAmBj+C,CAAA,CAAWk+C,iBAAA,IAAsBl+C,CAAA,CAAW68C,SAAA,EAAYv9C,CAAA,GACjE,MAArBC,CAAA,KACF,GAAAC,CAAA,CAAA8+C,cAAA,EAAe,mCAGM,OAAnB,QAAAx/C,CAAA,QAAO,IAAPA,CAAA,CAASy/C,KAAA,MACX,GAAA/+C,CAAA,CAAAg/C,mBAAA,EAAoB1/C,CAAA,CAAQy/C,KAAA,EAAO,IAAI,IAAIE,OAAA,IAAoC,CAAC3/C,CAAA,EAAKQ,CAAA;cACnF,MAAMU,CAAA,IAAgB,GAAAR,CAAA,CAAA4+C,eAAA,EAAgBt/C,CAAA,EAAKiB,CAAA;gBACrCqC,CAAA,IAAkB,GAAA5C,CAAA,CAAA4+C,eAAA,EAAgB9+C,CAAA,EAAOS,CAAA;cAEsC,MAAjFhB,CAAA,CAAK2/C,qBAAA,CAAsBn/C,CAAA,EAAkBS,CAAA,EAAeoC,CAAA,MAC9D,GAAA5C,CAAA,CAAA8+C,cAAA,EAAe,iCAAiCx/C,CAAA,MAASQ,CAAA,I;gBAKxD,CAACC,CAAA,EAAkBQ,CAAA,C;WAC1B,QAAOjB,CAAA;YAKP,MAJyB,MAArBS,CAAA,IACFR,CAAA,CAAK4/C,qBAAA,CAAsBp/C,CAAA,GAE7BQ,CAAA,CAAO4J,OAAA,CAAQ7K,CAAA,IAASC,CAAA,CAAK6/C,KAAA,CAAM9/C,CAAA,IAC7BA,C;;;;;;;;;;QC3DV,MAAAQ,CAAA,GAAAC,CAAA;UACAC,CAAA,GAAAD,CAAA;UACAQ,CAAA,GAAAR,CAAA;UAGAS,CAAA,GAAAT,CAAA;QAEA,IAAI6C,CAAA;QAEJrD,CAAA,CAAAoC,oCAAA;UAME,MAAAk8C,sBAA4Bv+C,CAAA;YAG1B,MAAMC,CAAA,SAAiB84C,KAAA,CAAM/4C,CAAA;YAC7B,IAAwB,QAApBC,CAAA,CAAS8/C,MAAA,EACX,MAAM,IAAI17C,KAAA,CAAM,yBAAyBrE,CAAA;YAE3C,MAAMS,CAAA,SAAoBR,CAAA,CAAS+4C,WAAA;YACnC,QAAO,GAAA93C,CAAA,CAAAq9C,qBAAA,EAAsB,IAAI9uC,UAAA,CAAWhP,CAAA,EAC9C;UAAA;UAEA,MAAAM,UAAgBf,CAAA,EAAiCC,CAAA;YAM/C,IALKqD,CAAA,YACG,GAAApC,CAAA,CAAAm9C,iBAAA,EAAkB39C,CAAA,CAAAU,GAAA,GACxBkC,CAAA,IAAqB,IAGK,mBAAjBtD,CAAA;cACT,IAAuB,sBAAZ44C,OAAA,IAA2BA,OAAA,CAAQn2C,QAAA,IAAYm2C,OAAA,CAAQn2C,QAAA,CAAS03B,IAAA,EAAM;gBAE/E,MAAM15B,CAAA,UAAc,GAAAQ,CAAA,CAAA43C,SAAA,EAAUr4C,CAAA,CAAAs4C,QAAA,CAAV,CAAoB94C,CAAA;gBAAA,CACvC,KAAK6+C,SAAA,EAAW,KAAKj0C,UAAA,EAAY,KAAKutC,WAAA,WAAqB,GAAAj3C,CAAA,CAAAy9C,aAAA,EAAcl+C,CAAA,EAAOR,CAAA,C;qBAC5E;gBAGL,MAAMQ,CAAA,SAAyC,KAAK89C,qBAAA,CAAsBv+C,CAAA;gBAAA,CAEzE,KAAK6+C,SAAA,EAAW,KAAKj0C,UAAA,EAAY,KAAKutC,WAAA,WAAqB,GAAAj3C,CAAA,CAAAs9C,qBAAA,EAAsB/9C,CAAA,EAAWR,CAAA,C;;oBAG9F,KAAK4+C,SAAA,EAAW,KAAKj0C,UAAA,EAAY,KAAKutC,WAAA,WAAqB,GAAAj3C,CAAA,CAAAy9C,aAAA,EAAc3+C,CAAA,EAAcC,CAAA,CAE5F;UAAA;UAEA,MAAAoH,QAAA;YACE,QAAO,GAAAnG,CAAA,CAAA09C,cAAA,EAAe,KAAKC,SAAA,CAC7B;UAAA;UAEA,MAAA1qC,IAAUnU,CAAA,EAAiCC,CAAA,EAAqCQ,CAAA;YAE9E,MAAMD,CAAA,GAAuB;cACvBS,CAAA,GAAyB;YAC/B4B,MAAA,CAAOm9C,OAAA,CAAQhgD,CAAA,EAAO6K,OAAA,CAAQ7K,CAAA;cAC5B,MAAMC,CAAA,GAAOD,CAAA,CAAI;gBACXS,CAAA,GAAST,CAAA,CAAI;gBACbU,CAAA,GAAQ,KAAKkK,UAAA,CAAWwB,OAAA,CAAQnM,CAAA;cACtC,KAAe,MAAXS,CAAA,EACF,MAAM,IAAI2D,KAAA,CAAM,kBAAkBpE,CAAA;cAEpCO,CAAA,CAAWwG,IAAA,CAAKvG,CAAA,GAChBQ,CAAA,CAAa+F,IAAA,CAAKtG,CAAA,CAAM;YAAA;YAG1B,MAAM4C,CAAA,GAA0B;YAChCT,MAAA,CAAOm9C,OAAA,CAAQ//C,CAAA,EAAS4K,OAAA,CAAQ7K,CAAA;cAC9B,MAAMC,CAAA,GAAOD,CAAA,CAAI;gBAEXS,CAAA,GAAQ,KAAK03C,WAAA,CAAY/rC,OAAA,CAAQnM,CAAA;cACvC,KAAe,MAAXQ,CAAA,EACF,MAAM,IAAI4D,KAAA,CAAM,mBAAmBpE,CAAA;cAErCqD,CAAA,CAAc0D,IAAA,CAAKvG,CAAA,CAAM;YAAA;YAG3B,MAAMiD,CAAA,UACI,GAAAxC,CAAA,CAAAiT,GAAA,EAAI,KAAK0qC,SAAA,EAAW59C,CAAA,EAAcT,CAAA,CAAW2C,GAAA,CAAInD,CAAA,IAAK,CAACA,CAAA,CAAEgF,IAAA,EAAMhF,CAAA,CAAE6T,IAAA,EAAM7T,CAAA,CAAEyjB,IAAA,IAAQngB,CAAA,EAAe7C,CAAA;cAEpGgK,CAAA,GAAoC,CAAC;YAC3C,KAAK,IAAIzK,CAAA,GAAI,GAAGA,CAAA,GAAI0D,CAAA,CAAQ5B,MAAA,EAAQ9B,CAAA,IAClCyK,CAAA,CAAO,KAAK0tC,WAAA,CAAY70C,CAAA,CAActD,CAAA,MAAO,IAAIU,CAAA,CAAAuF,MAAA,CAAOvC,CAAA,CAAQ1D,CAAA,EAAG,IAAI0D,CAAA,CAAQ1D,CAAA,EAAG,IAAI0D,CAAA,CAAQ1D,CAAA,EAAG;YAEnG,OAAOyK,CACT;UAAA;UAEA2tC,eAAA,GAEA;UAEAC,aAAA;YAAA,CACO,GAAAn3C,CAAA,CAAAm3C,YAAA,EAAa,KAAKwG,SAAA,CACzB;UAAA;QAAA,C;;;;;;;;QC7FF,MAAAr+C,CAAA,GAAAC,CAAA;UACAC,CAAA,GAAAD,CAAA;QAmGaR,CAAA,CAAAggD,iBAAA,GAAqBjgD,CAAA;;UAChC,MAAMsD,CAAA,IAAO,GAAA9C,CAAA,CAAA0+C,WAAA;UACb,IAAIx7C,CAAA,GAAuB;UAC3B,MAAM+G,CAAA,GAAmB;YAEnBY,CAAA,GAAkDrL,CAAA,IAAW,CAAC;UA5EzC,CAACA,CAAA;YACvBA,CAAA,CAAQy/C,KAAA,KACXz/C,CAAA,CAAQy/C,KAAA,GAAQ,CAAC,IAEdz/C,CAAA,CAAQy/C,KAAA,CAAMxsC,OAAA,KACjBjT,CAAA,CAAQy/C,KAAA,CAAMxsC,OAAA,GAAU,CAAC;YAE3B,MAAMhT,CAAA,GAAUD,CAAA,CAAQy/C,KAAA,CAAMxsC,OAAA;YACzBhT,CAAA,CAAQigD,4BAAA,KAEXjgD,CAAA,CAAQigD,4BAAA,GAA+B,MAIrClgD,CAAA,CAAQmgD,kBAAA,IACRngD,CAAA,CAAQmgD,kBAAA,CAAmBn5B,IAAA,CAAKhnB,CAAA,IAAkD,cAA7B,mBAAPA,CAAA,GAAkBA,CAAA,GAAKA,CAAA,CAAGgE,IAAA,OAC1EhE,CAAA,CAAQogD,gBAAA,IAAmB,E;aA6DR/0C,CAAA;UAErB;YACE,MAAMrL,CAAA,GA1GuB,CAACA,CAAA;gBAChC,QAAQA,CAAA;kBACN,KAAK;oBACH,OAAO;kBACT,KAAK;oBACH,OAAO;kBACT,KAAK;oBACH,OAAO;kBACT,KAAK;oBACH,OAAO;kBACT;oBACE,MAAM,IAAIqE,KAAA,CAAM,yCAAyCrE,CAAA;gBAAA;iBA+FkC,UAArCC,CAAA,GAAAoL,CAAA,CAAeg1C,sBAAA,UAAsB,MAAApgD,CAAA,GAAAA,CAAA,GAAI;cAC3FqL,CAAA,GA5Fe,CAACtL,CAAA;gBACxB,QAAQA,CAAA;kBACN,KAAK;oBACH,OAAO;kBACT,KAAK;oBACH,OAAO;kBACT;oBACE,MAAM,IAAIqE,KAAA,CAAM,+BAA+BrE,CAAA;gBAAA;iBAqFkB,UAA5BS,CAAA,GAAA4K,CAAA,CAAei1C,aAAA,UAAa,MAAA7/C,CAAA,GAAAA,CAAA,GAAI;cACjE8K,CAAA,GAC8B,mBAAzBF,CAAA,CAAek1C,KAAA,IAAqB,GAAA7/C,CAAA,CAAA4+C,eAAA,EAAgBj0C,CAAA,CAAek1C,KAAA,EAAO91C,CAAA,IAAU;cAEzFlE,CAAA,GAAkD,UAA/BtF,CAAA,GAAAoK,CAAA,CAAe8zC,gBAAA,UAAgB,MAAAl+C,CAAA,GAAAA,CAAA,GAAI;YAC5D,KAAKS,MAAA,CAAOC,SAAA,CAAU4E,CAAA,KAAqBA,CAAA,GAAmB,KAAKA,CAAA,GAAmB,GACpF,MAAM,IAAIlC,KAAA,CAAM,qCAAqCkC,CAAA;YAGvD,MAAMmF,CAAA,GAAoD,UAAhCxK,CAAA,GAAAmK,CAAA,CAAe+zC,iBAAA,UAAiB,MAAAl+C,CAAA,GAAAA,CAAA,GAAI;YAC9D,KAAKQ,MAAA,CAAOC,SAAA,CAAU+J,CAAA,KAAsBA,CAAA,GAAoB,KAAKA,CAAA,GAAoB,GACvF,MAAM,IAAIrH,KAAA,CAAM,qCAAqCqH,CAAA;YAGvD,MAAMlF,CAAA,GAAgF,mBAA1C6E,CAAA,CAAem1C,sBAAA,IACvD,GAAA9/C,CAAA,CAAA4+C,eAAA,EAAgBj0C,CAAA,CAAem1C,sBAAA,EAAwB/1C,CAAA,IACvD;YAyBJ,OAvBA/G,CAAA,GAAuBJ,CAAA,CAAKm9C,wBAAA,CACxBzgD,CAAA,IAA0BqL,CAAA,CAAeq1C,iBAAA,IAAqBr1C,CAAA,CAAe+0C,gBAAA,EAAkB90C,CAAA,IAC7FD,CAAA,CAAes1C,eAAA,EAAiB,GAAGp1C,CAAA,EAAiBhF,CAAA,EAAkBmF,CAAA,EACxElF,CAAA,GACyB,MAAzB9C,CAAA,KACF,GAAAhD,CAAA,CAAA8+C,cAAA,EAAe,kCAGbn0C,CAAA,CAAe80C,kBAAA,IAtFnB,EAACngD,CAAA,EAA8BC,CAAA,EAC9BQ,CAAA;cACC,KAAK,MAAMQ,CAAA,IAAMhB,CAAA,EAAoB;gBACnC,IAAIA,CAAA,GAAuB,mBAAPgB,CAAA,GAAkBA,CAAA,GAAKA,CAAA,CAAG+C,IAAA;gBAG9C,QAAQ/D,CAAA;kBACN,KAAK;oBACHA,CAAA,GAAS;oBACT;kBACF,KAAK;oBAEH,IADAA,CAAA,GAAS,SACS,mBAAPgB,CAAA,EAAiB;sBAC1B,MAAMhB,CAAA,GAAegB,CAAA;sBACrB,IAAI,QAAAhB,CAAA,QAAY,IAAZA,CAAA,CAAc2gD,UAAA,EAAY;wBAC5B,MAAM3/C,CAAA,IAAgB,GAAAP,CAAA,CAAA4+C,eAAA,EAAgB,cAAc7+C,CAAA;0BAC9CS,CAAA,IAAkB,GAAAR,CAAA,CAAA4+C,eAAA,EAAgBr/C,CAAA,CAAa2gD,UAAA,EAAYngD,CAAA;wBAE7D,OADA,GAAAD,CAAA,CAAA0+C,WAAA,IAAc2B,yBAAA,CAA0B7gD,CAAA,EAAsBiB,CAAA,EAAeC,CAAA,MAE/E,GAAAR,CAAA,CAAA8+C,cAAA,EAAe,oDAAoDv/C,CAAA,CAAa2gD,UAAA,I;;sBAGpF,IAAI,QAAA3gD,CAAA,QAAY,IAAZA,CAAA,CAAc6gD,eAAA,EAAiB;wBACjC,MAAM7/C,CAAA,IAAgB,GAAAP,CAAA,CAAA4+C,eAAA,EAAgB,mBAAmB7+C,CAAA;0BACnDS,CAAA,IAAkB,GAAAR,CAAA,CAAA4+C,eAAA,EAAgBr/C,CAAA,CAAa6gD,eAAA,EAAiBrgD,CAAA;wBAElE,OADA,GAAAD,CAAA,CAAA0+C,WAAA,IAAc2B,yBAAA,CAA0B7gD,CAAA,EAAsBiB,CAAA,EAAeC,CAAA,MAE/E,GAAAR,CAAA,CAAA8+C,cAAA,EACI,yDAAyDv/C,CAAA,CAAa6gD,eAAA,I;;;oBAIhF;kBACF,KAAK;oBACH7gD,CAAA,GAAS;oBACT;kBACF,KAAK;kBACL,KAAK;oBACH;kBACF;oBACE,MAAM,IAAIoE,KAAA,CAAM,qCAAqCpE,CAAA;gBAAA;gBAGzD,MAAMiB,CAAA,IAAmB,GAAAR,CAAA,CAAA4+C,eAAA,EAAgBr/C,CAAA,EAAQQ,CAAA;gBACyC,OAAtF,GAAAD,CAAA,CAAA0+C,WAAA,IAAc6B,2BAAA,CAA4B/gD,CAAA,EAAsBkB,CAAA,MAClE,GAAAR,CAAA,CAAA8+C,cAAA,EAAe,oCAAoCv/C,CAAA,I;;eA0CjCyD,CAAA,EAAsB2H,CAAA,CAAe80C,kBAAA,EAAoB11C,CAAA,QAGpD,MAAzBY,CAAA,CAAeo0C,KAAA,KACjB,GAAA/+C,CAAA,CAAAg/C,mBAAA,EAAoBr0C,CAAA,CAAeo0C,KAAA,EAAO,IAAI,IAAIE,OAAA,IAAoC,CAAC3/C,CAAA,EAAKC,CAAA;cAC1F,MAAMQ,CAAA,IAAgB,GAAAC,CAAA,CAAA4+C,eAAA,EAAgBt/C,CAAA,EAAKyK,CAAA;gBACrCjK,CAAA,IAAkB,GAAAE,CAAA,CAAA4+C,eAAA,EAAgBr/C,CAAA,EAAOwK,CAAA;cAE8C,MAAzFnH,CAAA,CAAKu9C,yBAAA,CAA0Bn9C,CAAA,EAAsBjD,CAAA,EAAeD,CAAA,MACtE,GAAAE,CAAA,CAAA8+C,cAAA,EAAe,qCAAqCx/C,CAAA,MAASC,CAAA,I;gBAK5D,CAACyD,CAAA,EAAsB+G,CAAA,C;WAC9B,QAAOzK,CAAA;YAKP,MAJ6B,MAAzB0D,CAAA,IACFJ,CAAA,CAAK09C,yBAAA,CAA0Bt9C,CAAA,GAEjC+G,CAAA,CAAOI,OAAA,CAAQ7K,CAAA,IAASsD,CAAA,CAAKw8C,KAAA,CAAM9/C,CAAA,IAC7BA,C;;;;;;;;;0KCjIGC,CAAA,CAAA+7C,0BAAA,GAA8Bh8C,CAAA;UACzC,QAAQA,CAAA;YACN,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YAET;cACE,MAAM,IAAIqE,KAAA,CAAM,0BAA0BrE,CAAA;UAAA;WAOnCC,CAAA,CAAAghD,0BAAA,GAA8BjhD,CAAA;UACzC,QAAQA,CAAA;YACN,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YAET;cACE,MAAM,IAAIqE,KAAA,CAAM,0BAA0BrE,CAAA;UAAA;WAQnCC,CAAA,CAAAihD,oBAAA,GAAwBlhD,CAAA,IACpB,MAAC,GAAW,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,QAAG,GAAW,GAAG,GAAG,GAAG,GAAG,QAAG,QAAW,QAAW,GAAWA,CAAA,GAKhGC,CAAA,CAAAkhD,iCAAA,GAAqCnhD,CAAA;UAG5C,QAAQA,CAAA;YACN,KAAK;YAQL,KAAK;cACH,OAAO6wB,WAAA;YAPT,KAAK;cACH,OAAOjc,YAAA;YACT,KAAK;YAUL,KAAK;cACH,OAAOnF,UAAA;YATT,KAAK;cACH,OAAOmhB,SAAA;YAGT,KAAK;cACH,OAAOD,UAAA;YACT,KAAK;cACH,OAAOhK,UAAA;YAGT,KAAK;cACH,OAAOmK,YAAA;YACT,KAAK;cACH,OAAOthB,WAAA;YACT,KAAK;cACH,OAAOirC,aAAA;YACT,KAAK;cACH,OAAO2G,cAAA;YACT;cACE,MAAM,IAAI/8C,KAAA,CAAM,qBAAqBrE,CAAA;UAAA;WAOlCC,CAAA,CAAAohD,oBAAA,GAAwBrhD,CAAA;UACnC,QAAQA,CAAA;YACN,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT,KAAK;cACH,OAAO;YACT;cACE,MAAM,IAAIqE,KAAA,CAAM,8BAA8BrE,CAAA;UAAA;;;;;;;;;QC7JpD,MAAAQ,CAAA,GAAAC,CAAA;UACAC,CAAA,GAAAD,CAAA;UACAQ,CAAA,GAAAR,CAAA;UACAS,CAAA,GAAAT,CAAA;UACA6C,CAAA,GAAA7C,CAAA;QAsCaR,CAAA,CAAAq+C,WAAA,GAAc,MAAMt+C,CAAA;UAXjB,IAACC,CAAA,EAAoBQ,CAAA;UAApBR,CAAA,GAaPD,CAAA,CAAIqB,IAAA,CAAKI,UAAA,EAbkBhB,CAAA,IAaL,GAAAQ,CAAA,CAAAogD,oBAAA,EAAqBrhD,CAAA,CAAI++B,QAAA,GAXrC,OADA,GAAA79B,CAAA,CAAAg+C,WAAA,IAAcoC,QAAA,CAASrhD,CAAA,EAAYQ,CAAA,MAEnD,GAAA6C,CAAA,CAAAk8C,cAAA,EAAe,gCAYgB;QAAA;QAcnC,MAAM97C,CAAA,GAAiB,IAAIE,GAAA;QAMd3D,CAAA,CAAAs+C,qBAAA,GAAyBv+C,CAAA;UACpC,MAAMC,CAAA,IAAO,GAAAiB,CAAA,CAAAg+C,WAAA;YACPz+C,CAAA,GAAkBR,CAAA,CAAKshD,OAAA,CAAQvhD,CAAA,CAAM8uB,UAAA;UAC3C,IAAwB,MAApBruB,CAAA,EACF,MAAM,IAAI4D,KAAA,CAAM,+DAA+DrE,CAAA,CAAM8uB,UAAA;UAGvF,OADA7uB,CAAA,CAAKuhD,MAAA,CAAOz9C,GAAA,CAAI/D,CAAA,EAAOS,CAAA,GAChB,CAACA,CAAA,EAAiBT,CAAA,CAAM8uB,UAAA,CAAW;QAAA,GAS/B7uB,CAAA,CAAAu+C,qBAAA,GACT,CAACx+C,CAAA,EAAkCC,CAAA;UACjC,MAAMQ,CAAA,IAAO,GAAAS,CAAA,CAAAg+C,WAAA;UAEb,IAAI1+C,CAAA,GAAgB;YAChBS,CAAA,GAAuB;YACvBwJ,CAAA,GAAmB;UACvB,MAAMY,CAAA,GAAwB;YACxBC,CAAA,GAAyB;UAE/B;YAAA,CACGrK,CAAA,EAAsBwJ,CAAA,KAAU,GAAA/J,CAAA,CAAAu/C,iBAAA,EAAkBhgD,CAAA,GAEnDO,CAAA,GAAgBC,CAAA,CAAKghD,iBAAA,CAAkBzhD,CAAA,CAAU,IAAIA,CAAA,CAAU,IAAIiB,CAAA,GAC7C,MAAlBT,CAAA,KACF,GAAA8C,CAAA,CAAAk8C,cAAA,EAAe;YAGjB,OAAOj0C,CAAA,EAAYhF,CAAA,IAzFQ,CAACvG,CAAA;gBAClC,MAAMC,CAAA,IAAO,GAAAiB,CAAA,CAAAg+C,WAAA;kBACPz+C,CAAA,GAAQR,CAAA,CAAKyhD,SAAA;gBACnB;kBACE,MAAMjhD,CAAA,GAAaR,CAAA,CAAK0hD,UAAA,CAAW;kBAKnC,OAHkB,MADA1hD,CAAA,CAAK2hD,uBAAA,CAAwB5hD,CAAA,EAAeS,CAAA,EAAYA,CAAA,GAAa,OAErF,GAAA6C,CAAA,CAAAk8C,cAAA,EAAe,0CAEV,CAACv/C,CAAA,CAAK4hD,MAAA,CAAOphD,CAAA,GAAa,IAAIR,CAAA,CAAK4hD,MAAA,CAAOphD,CAAA,GAAa,IAAI,G;;kBAElER,CAAA,CAAK6hD,YAAA,CAAarhD,CAAA,C;;iBA8E+CD,CAAA;cAEvDkL,CAAA,GAAa;cACblF,CAAA,GAAc;YACpB,KAAK,IAAIxG,CAAA,GAAI,GAAGA,CAAA,GAAIuL,CAAA,EAAYvL,CAAA,IAAK;cACnC,MAAMC,CAAA,GAAOQ,CAAA,CAAKshD,gBAAA,CAAiBvhD,CAAA,EAAeR,CAAA;cACrC,MAATC,CAAA,KACF,GAAAqD,CAAA,CAAAk8C,cAAA,EAAe,6BAEjBn0C,CAAA,CAAsBrE,IAAA,CAAK/G,CAAA,GAC3ByL,CAAA,CAAW1E,IAAA,CAAKvG,CAAA,CAAKuhD,YAAA,CAAa/hD,CAAA,E;;YAEpC,KAAK,IAAID,CAAA,GAAI,GAAGA,CAAA,GAAIuG,CAAA,EAAavG,CAAA,IAAK;cACpC,MAAMC,CAAA,GAAOQ,CAAA,CAAKwhD,iBAAA,CAAkBzhD,CAAA,EAAeR,CAAA;cACtC,MAATC,CAAA,KACF,GAAAqD,CAAA,CAAAk8C,cAAA,EAAe,8BAEjBl0C,CAAA,CAAuBtE,IAAA,CAAK/G,CAAA,GAC5BuG,CAAA,CAAYQ,IAAA,CAAKvG,CAAA,CAAKuhD,YAAA,CAAa/hD,CAAA,E;;YAIrC,OADAyD,CAAA,CAAeK,GAAA,CAAIvD,CAAA,EAAe,CAACA,CAAA,EAAe6K,CAAA,EAAuBC,CAAA,IAClE,CAAC9K,CAAA,EAAekL,CAAA,EAAYlF,CAAA,C;WACnC,QAAOxG,CAAA;YAOP,MANAqL,CAAA,CAAsBR,OAAA,CAAQ7K,CAAA,IAAOS,CAAA,CAAKyhD,QAAA,CAASliD,CAAA,IACnDsL,CAAA,CAAuBT,OAAA,CAAQ7K,CAAA,IAAOS,CAAA,CAAKyhD,QAAA,CAASliD,CAAA,IAE9B,MAAlBQ,CAAA,IACFC,CAAA,CAAK0hD,kBAAA,CAAmB3hD,CAAA,GAEpBR,C;;YAENS,CAAA,CAAKq/C,KAAA,CAAM9/C,CAAA,CAAU,KACQ,MAAzBiB,CAAA,IACFR,CAAA,CAAKugD,yBAAA,CAA0B//C,CAAA,GAEjCwJ,CAAA,CAAOI,OAAA,CAAQ7K,CAAA,IAASS,CAAA,CAAKq/C,KAAA,CAAM9/C,CAAA,E;;WAS9BC,CAAA,CAAA0+C,aAAA,GACT,CAAC3+C,CAAA,EAAmBS,CAAA;UAClB,MAAMD,CAAA,IAAmC,GAAAP,CAAA,CAAAs+C,qBAAA,EAAsBv+C,CAAA;UAC/D,QAAO,GAAAC,CAAA,CAAAu+C,qBAAA,EAAsBh+C,CAAA,EAAWC,CAAA,CAAQ;QAAA,GAGzCR,CAAA,CAAA2+C,cAAA,GAAkB5+C,CAAA;UAC7B,MAAMC,CAAA,IAAO,GAAAiB,CAAA,CAAAg+C,WAAA;YACPz+C,CAAA,GAAUiD,CAAA,CAAec,GAAA,CAAIxE,CAAA;UACnC,KAAKS,CAAA,EACH,MAAM,IAAI4D,KAAA,CAAM,+CAA+CrE,CAAA;UAEjE,OAAOQ,CAAA,EAAeE,CAAA,EAAuBO,CAAA,IAA0BR,CAAA;UAEvEC,CAAA,CAAsBmK,OAAA,CAAQ7K,CAAA,IAAOC,CAAA,CAAKiiD,QAAA,CAASliD,CAAA,IACnDiB,CAAA,CAAuB4J,OAAA,CAAQ7K,CAAA,IAAOC,CAAA,CAAKiiD,QAAA,CAASliD,CAAA,IACpDC,CAAA,CAAKkiD,kBAAA,CAAmB3hD,CAAA,GACxBkD,CAAA,CAAeY,MAAA,CAAOtE,CAAA,CAAU;QAAA,GAMrBC,CAAA,CAAAkU,GAAA,GAAM,OACfnU,CAAA,EAAmBC,CAAA,EAAwBQ,CAAA,EAA8BC,CAAA,EACzE+J,CAAA;UACF,MAAMY,CAAA,IAAO,GAAAnK,CAAA,CAAAg+C,WAAA;YACP5zC,CAAA,GAAU5H,CAAA,CAAec,GAAA,CAAIxE,CAAA;UACnC,KAAKsL,CAAA,EACH,MAAM,IAAIjH,KAAA,CAAM,6CAA6CrE,CAAA;UAE/D,OAAOuL,CAAA,EAAehF,CAAA,EAAuBmF,CAAA,IAA0BJ,CAAA;YAEjE9E,CAAA,GAAavG,CAAA,CAAa6B,MAAA;YAC1B8J,CAAA,GAAclL,CAAA,CAAcoB,MAAA;UAElC,IAAI+J,CAAA,GAAmB;YACnBE,CAAA,GAA6B;UAEjC,MAAMC,CAAA,GAAwB;YACxBC,CAAA,GAAwB;UAE9B;YAAA,CACGJ,CAAA,EAAkBE,CAAA,KAAoB,GAAAvL,CAAA,CAAAy+C,aAAA,EAAcx0C,CAAA;YAGrD,KAAK,IAAIzK,CAAA,GAAI,GAAGA,CAAA,GAAIwG,CAAA,EAAYxG,CAAA,IAAK;cACnC,MAAMC,CAAA,GAAWQ,CAAA,CAAOT,CAAA,EAAG;gBACrBQ,CAAA,GAAOC,CAAA,CAAOT,CAAA,EAAG;gBACjBU,CAAA,GAAOD,CAAA,CAAOT,CAAA,EAAG;cAEvB,IAAIkB,CAAA,EACAwC,CAAA;cAEJ,IAAIsC,KAAA,CAAM+oB,OAAA,CAAQruB,CAAA,GAAO;gBAEvBgD,CAAA,GAAiB,IAAIhD,CAAA,CAAKoB,MAAA,EAC1BZ,CAAA,GAAamK,CAAA,CAAKk2C,OAAA,CAAQ79C,CAAA,GAC1BuI,CAAA,CAAYjF,IAAA,CAAK9F,CAAA;gBACjB,IAAIlB,CAAA,GAAYkB,CAAA,GAAa;gBAC7B,KAAK,IAAIjB,CAAA,GAAI,GAAGA,CAAA,GAAIS,CAAA,CAAKoB,MAAA,EAAQ7B,CAAA,IAAK;kBACpC,IAAuB,mBAAZS,CAAA,CAAKT,CAAA,GACd,MAAM,IAAI8hB,SAAA,CAAU,wBAAwB9hB,CAAA;kBAE9CoL,CAAA,CAAK+2C,OAAA,CAAQpiD,CAAA,OAAe,GAAAsD,CAAA,CAAAg8C,eAAA,EAAgB5+C,CAAA,CAAKT,CAAA,GAAIgM,CAAA,C;;qBAGvDvI,CAAA,GAAiBhD,CAAA,CAAKouB,UAAA,EACtB5tB,CAAA,GAAamK,CAAA,CAAKk2C,OAAA,CAAQ79C,CAAA,GAC1BuI,CAAA,CAAYjF,IAAA,CAAK9F,CAAA,GACjBmK,CAAA,CAAKm2C,MAAA,CAAOz9C,GAAA,CAAI,IAAI0L,UAAA,CAAW/O,CAAA,CAAKkuB,MAAA,EAAQluB,CAAA,CAAKmuB,UAAA,EAAYnrB,CAAA,GAAiBxC,CAAA;cAGhF,MAAMuJ,CAAA,GAAQY,CAAA,CAAKq2C,SAAA;gBACbp2C,CAAA,GAAaD,CAAA,CAAKs2C,UAAA,CAAW,IAAInhD,CAAA,CAAKsB,MAAA;cAC5C;gBACE,IAAIrB,CAAA,GAAW6K,CAAA,GAAa;gBAC5B9K,CAAA,CAAKqK,OAAA,CAAQ7K,CAAA,IAAKqL,CAAA,CAAKw2C,MAAA,CAAOphD,CAAA,MAAcT,CAAA;gBAC5C,MAAMU,CAAA,GAAS2K,CAAA,CAAKg3C,gBAAA,EAChB,GAAAphD,CAAA,CAAA+6C,0BAAA,EAA2B/7C,CAAA,GAAWiB,CAAA,EAAYwC,CAAA,EAAgB4H,CAAA,EAAY9K,CAAA,CAAKsB,MAAA;gBACxE,MAAXpB,CAAA,KACF,GAAA4C,CAAA,CAAAk8C,cAAA,EAAe,iCAAiCx/C,CAAA,OAElDgM,CAAA,CAAYhF,IAAA,CAAKtG,CAAA,C;;gBAEjB2K,CAAA,CAAKy2C,YAAA,CAAar3C,CAAA,C;;;YAItB,MAAMzK,CAAA,GAAiBqL,CAAA,CAAKq2C,SAAA;cACtBxgD,CAAA,GAAoBmK,CAAA,CAAKs2C,UAAA,CAAwB,IAAbn7C,CAAA;cACpC9C,CAAA,GAAmB2H,CAAA,CAAKs2C,UAAA,CAAwB,IAAbn7C,CAAA;cACnC8E,CAAA,GAAqBD,CAAA,CAAKs2C,UAAA,CAAyB,IAAd/1C,CAAA;cACrCO,CAAA,GAAoBd,CAAA,CAAKs2C,UAAA,CAAyB,IAAd/1C,CAAA;YAE1C;cACE,IAAI5L,CAAA,GAAmBkB,CAAA,GAAoB;gBACvCT,CAAA,GAAkBiD,CAAA,GAAmB;gBACrClD,CAAA,GAAoB8K,CAAA,GAAqB;gBACzCb,CAAA,GAAmB0B,CAAA,GAAoB;cAC3C,KAAK,IAAI3L,CAAA,GAAI,GAAGA,CAAA,GAAIgG,CAAA,EAAYhG,CAAA,IAC9B6K,CAAA,CAAK+2C,OAAA,CAAQpiD,CAAA,MAAsBgM,CAAA,CAAYxL,CAAA,GAC/C6K,CAAA,CAAK+2C,OAAA,CAAQ3hD,CAAA,MAAqB8F,CAAA,CAAsBtG,CAAA,CAAaO,CAAA;cAEvE,KAAK,IAAIR,CAAA,GAAI,GAAGA,CAAA,GAAI4L,CAAA,EAAa5L,CAAA,IAC/BqL,CAAA,CAAK+2C,OAAA,CAAQ5hD,CAAA,MAAuB,GACpC6K,CAAA,CAAK+2C,OAAA,CAAQ33C,CAAA,MAAsBiB,CAAA,CAAuBhL,CAAA,CAAcV,CAAA;cAI1E,IAAI+L,CAAA,GAAYV,CAAA,CAAKi3C,OAAA,CACjB/2C,CAAA,EAAe7H,CAAA,EAAkBxC,CAAA,EAAmBsF,CAAA,EAAY2F,CAAA,EAAmBP,CAAA,EACnFN,CAAA,EAAoBO,CAAA;cAGxB,MAAMI,CAAA,GAAaZ,CAAA,CAAKk3C,cAAA;cACpBt2C,CAAA,SAAyC,MAApBA,CAAA,CAAWw0B,IAAA,KAClC10B,CAAA,SAAkBE,CAAA;cAGpB,MAAMI,CAAA,GAA+B;cAEnB,MAAdN,CAAA,KACF,GAAAzI,CAAA,CAAAk8C,cAAA,EAAe;cAGjB,KAAK,IAAIx/C,CAAA,GAAI,GAAGA,CAAA,GAAI4L,CAAA,EAAa5L,CAAA,IAAK;gBACpC,MAAMC,CAAA,GAASoL,CAAA,CAAK+2C,OAAA,CAAQ92C,CAAA,GAAqB,IAAItL,CAAA;kBAE/CS,CAAA,GAA2B4K,CAAA,CAAKq2C,SAAA;kBAEhClhD,CAAA,GAAmB6K,CAAA,CAAKs2C,UAAA,CAAW;gBAEzC,IAAIjhD,CAAA;kBAA6BQ,CAAA,GAAa;gBAC9C;kBACE6K,CAAA,GAAYV,CAAA,CAAKm3C,iBAAA,CACbviD,CAAA,EAAQO,CAAA,EAAkBA,CAAA,GAAmB,GAAGA,CAAA,GAAmB,GAAGA,CAAA,GAAmB,KAC3E,MAAduL,CAAA,KACF,GAAAzI,CAAA,CAAAk8C,cAAA,EAAe,4CAA4Cx/C,CAAA;kBAE7D,IAAIS,CAAA,GAAkBD,CAAA,GAAmB;kBACzC,MAAMkD,CAAA,GAAW2H,CAAA,CAAK+2C,OAAA,CAAQ3hD,CAAA;kBAC9BS,CAAA,GAAamK,CAAA,CAAK+2C,OAAA,CAAQ3hD,CAAA;kBAC1B,MAAMgK,CAAA,GAAaY,CAAA,CAAK+2C,OAAA,CAAQ3hD,CAAA;oBAC1B6K,CAAA,GAAaD,CAAA,CAAK+2C,OAAA,CAAQ3hD,CAAA;oBAC1B8K,CAAA,GAAO;kBACb,KAAK,IAAIvL,CAAA,GAAI,GAAGA,CAAA,GAAIsL,CAAA,EAAYtL,CAAA,IAC9BuL,CAAA,CAAKvE,IAAA,CAAKqE,CAAA,CAAK+2C,OAAA,CAAQ33C,CAAA,GAAa,IAAIzK,CAAA;kBAE1CqL,CAAA,CAAK62C,QAAA,CAASz3C,CAAA;kBAEd,MAAMlE,CAAA,GAAuB,MAAhBgF,CAAA,CAAKzJ,MAAA,GAAe,IAAIyJ,CAAA,CAAKia,MAAA,CAAO,CAACxlB,CAAA,EAAGC,CAAA,KAAMD,CAAA,GAAIC,CAAA;kBAE/D,IADAS,CAAA,IAAO,GAAAO,CAAA,CAAAggD,0BAAA,EAA2Bv9C,CAAA,GACrB,aAAThD,CAAA,EAAmB;oBACrB,MAAMV,CAAA,GAAuB;oBAC7B,IAAIC,CAAA,GAAYiB,CAAA,GAAa;oBAC7B,KAAK,IAAIT,CAAA,GAAI,GAAGA,CAAA,GAAI8F,CAAA,EAAM9F,CAAA,IAAK;sBAC7B,MAAMD,CAAA,GAAS6K,CAAA,CAAK+2C,OAAA,CAAQniD,CAAA;wBACtBS,CAAA,GAAiBD,CAAA,KAAM8F,CAAA,GAAO,SAAI,IAAY8E,CAAA,CAAK+2C,OAAA,CAAQniD,CAAA,IAAaO,CAAA;sBAC9ER,CAAA,CAAWgH,IAAA,CAAKqE,CAAA,CAAK22C,YAAA,CAAaxhD,CAAA,EAAQE,CAAA,E;;oBAE5C2L,CAAA,CAAOrF,IAAA,CAAK,CAACtG,CAAA,EAAM6K,CAAA,EAAMvL,CAAA,E;yBACpB;oBACL,MACMA,CAAA,GAAO,MADiB,GAAAiB,CAAA,CAAAkgD,iCAAA,EAAkCzgD,CAAA,GACzB6F,CAAA;oBACvC,IAAIkJ,UAAA,CAAWzP,CAAA,CAAK4uB,MAAA,EAAQ5uB,CAAA,CAAK6uB,UAAA,EAAY7uB,CAAA,CAAK8uB,UAAA,EAC7C/qB,GAAA,CAAIsH,CAAA,CAAKm2C,MAAA,CAAO3sC,QAAA,CAAS3T,CAAA,EAAYA,CAAA,GAAalB,CAAA,CAAK8uB,UAAA,IAC5DziB,CAAA,CAAOrF,IAAA,CAAK,CAACtG,CAAA,EAAM6K,CAAA,EAAMvL,CAAA,E;;;kBAG3BqL,CAAA,CAAKy2C,YAAA,CAAarhD,CAAA,GACL,aAATC,CAAA,IAAqBQ,CAAA,IACvBmK,CAAA,CAAKy0C,KAAA,CAAM5+C,CAAA,GAEbmK,CAAA,CAAKo3C,iBAAA,CAAkBxiD,CAAA,C;;;cAI3B,OAAOoM,C;;cAEPhB,CAAA,CAAKy2C,YAAA,CAAa9hD,CAAA,C;;;YAGpBgM,CAAA,CAAYnB,OAAA,CAAQ7K,CAAA,IAAKqL,CAAA,CAAKo3C,iBAAA,CAAkBziD,CAAA,IAChDiM,CAAA,CAAYpB,OAAA,CAAQ7K,CAAA,IAAKqL,CAAA,CAAKy0C,KAAA,CAAM9/C,CAAA,IAEX,MAArB6L,CAAA,IACFR,CAAA,CAAKw0C,qBAAA,CAAsBh0C,CAAA,GAE7BE,CAAA,CAAiBlB,OAAA,CAAQ7K,CAAA,IAAKqL,CAAA,CAAKy0C,KAAA,CAAM9/C,CAAA,E;;WAOhCC,CAAA,CAAAo4C,YAAA,GAAgBr4C,CAAA;UAC3B,MAAMC,CAAA,IAAO,GAAAiB,CAAA,CAAAg+C,WAAA;YACPz+C,CAAA,GAAUiD,CAAA,CAAec,GAAA,CAAIxE,CAAA;UACnC,KAAKS,CAAA,EACH,MAAM,IAAI4D,KAAA,CAAM;UAElB,MAAM7D,CAAA,GAAgBC,CAAA,CAAQ;YAGxBC,CAAA,GAAkBT,CAAA,CAAKyiD,gBAAA,CAAiBliD,CAAA;UACtB,MAApBE,CAAA,KACF,GAAA4C,CAAA,CAAAk8C,cAAA,EAAe,oCAEjBv/C,CAAA,CAAKiiD,QAAA,CAASxhD,CAAA,CAAgB;QAAA,GAGnBT,CAAA,CAAA++C,0BAAA,GAA8Bh/C,CAAA;UACzC,MAAMC,CAAA,GAA6B;UACnC,KAAK,MAAMQ,CAAA,IAAUT,CAAA,EAAS;YAC5B,MAAMA,CAAA,GAAOS,CAAA,CAAO;YAAA,CACfuF,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,KAASA,CAAA,CAAK4uB,MAAA,IAC/B3uB,CAAA,CAAQ+G,IAAA,CAAKhH,CAAA,CAAK4uB,MAAA,C;;UAGtB,OAAO3uB,CAAO;QAAA,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QC/WhB,MAAAiB,CAAA,GAAAD,CAAA,CAAAR,CAAA;UAMM6C,CAAA,GAC0B7C,CAAA,CAAQ;UAElCiD,CAAA,GAC2BjD,CAAA,CAAQ;QAKzC,IAAIgK,CAAA;UACAY,CAAA,IAAc;UACdC,CAAA,IAAe;UACfC,CAAA,IAAU;QA2DDtL,CAAA,CAAAm+C,qBAAA,GAAwB,MAAMp+C,CAAA;UACzC,IAAIqL,CAAA,EACF,OAAO/I,OAAA,CAAQC,OAAA;UAEjB,IAAI+I,CAAA,EACF,MAAM,IAAIjH,KAAA,CAAM;UAElB,IAAIkH,CAAA,EACF,MAAM,IAAIlH,KAAA,CAAM;UAGlBiH,CAAA,IAAe;UAGf,MAAMrL,CAAA,GAAUD,CAAA,CAAMsB,WAAA;YAChBd,CAAA,GAAaR,CAAA,CAAMyB,UAAA;YACnBf,CAAA,GAAOV,CAAA,CAAMuB,IAAA;YAEbN,CAAA,GAAaT,CAAA,GAAa,KA3EH;cAC7B;gBAEE,OAAiC,sBAAtBmiD,iBAAA,KAMmB,sBAAnBC,cAAA,IACT,IAAIA,cAAA,GAAiBC,KAAA,CAAM1E,WAAA,CAAY,IAAIwE,iBAAA,CAAkB,KAKxDG,WAAA,CAAYC,QAAA,CAAS,IAAItzC,UAAA,CAAW,CACzC,GAAG,IAAI,KAAK,KAAK,GAAG,GAAI,GAAI,GAAG,GAAG,GAAG,GAAI,IAAI,GAAK,GAAI,GAAG,GAAG,GAAI,GAAG,GACnE,GAAG,GAAI,GAAK,GAAK,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAI,KAAK,IAAI,GAAG,GAAG,IAAI,M;eAElE,QAAOzP,CAAA;gBACP,QAAO,C;;eAuD4B;YAC/BuG,CAAA,GAAU7F,CAAA,IApDM;cACtB;gBAeE,OAAOoiD,WAAA,CAAYC,QAAA,CAAS,IAAItzC,UAAA,CAAW,CACzC,GAAK,IAAI,KAAK,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAK,IAAK,GAAG,IAAI,GACvF,KAAK,IAAI,KAAK,IAAK,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAI,GAAI,KAAK,KAAK,GAAG,IAAI,K;eAEzF,QAAOzP,CAAA;gBACP,QAAO,C;;eA+Be;YAElB0L,CAAA,GAAY1L,CAAA,CAAM49C,SAAA;YAClBp3C,CAAA,GAA0C,mBAAdkF,CAAA,GAAyBA,CAAA,QAAY;YACjEE,CAAA,GA/BgB,EAAC5L,CAAA,EAAkBC,CAAA,KACrCA,CAAA,GACKD,CAAA,GAAU,gCAAgC,2BAE1CA,CAAA,GAAU,uBAAuB,iBA2BLuG,CAAA,EAAStF,CAAA;YACxC4K,CAAA,GAAwC,mBAAdH,CAAA,GAAyBA,CAAA,CAAUE,CAAA,SAAgB;UAEnF,IAAIG,CAAA,IAAY;UAEhB,MAAMC,CAAA,GAA8B;UA6EpC,IA1EI/L,CAAA,GAAU,KACZ+L,CAAA,CAAMhF,IAAA,CAAK,IAAI1E,OAAA,CAAStC,CAAA;YACtBkxB,UAAA,CAAW;cACTnlB,CAAA,IAAY,GACZ/L,CAAA,EAAS;YAAA,GACRC,CAAA,CAAQ;UAAA,KAKf+L,CAAA,CAAMhF,IAAA,CAAK,IAAI1E,OAAA,CAAQ,CAACtC,CAAA,EAASC,CAAA;YAC/B,MAAMO,CAAA,GAAUS,CAAA,GAAayC,CAAA,GAAyBJ,CAAA;cAChD5C,CAAA,GAAiC;gBACrCsiD,UAAA,EAAYA,CAAChjD,CAAA,EAAkBC,CAAA,KACUgB,CAAA,IAAcjB,CAAA,CAASiiC,QAAA,CAAS,iBACnD,sBAATghB,IAAA,GACFC,GAAA,CAAIC,eAAA,CAAgB,IAAIF,IAAA,CAC3B,CAGExiD,CAAA,CAAQ,QAEV;kBAACuE,IAAA,EAAM;gBAAA,MAGThF,CAAA,CAASiiC,QAAA,CAAS,WAChBp2B,CAAA,KAIW,QAAArF,CAAA,GAAAA,CAAA,GAAsBvG,CAAA,IAUrB2L,CAAA,GAGX3L,CAAA,GAAkBD;cAAA;YAI7B,IAAuCiB,CAAA,EACrC,IAAoB,sBAATgiD,IAAA,EACTviD,CAAA,CAAO0iD,mBAAA,GAAsBliD,CAAA,CAAKkC,IAAA,CAAKigD,SAAA,EAAW,6BAC7C;cACL,MAAMrjD,CAAA,GAAmB,yDAAyDQ,CAAA,CAAQ+1B,QAAA;cAC1F71B,CAAA,CAAO0iD,mBAAA,GAAsB,IAAIH,IAAA,CAAK,CAACjjD,CAAA,GAAmB;gBAACgF,IAAA,EAAM;cAAA,E;;YAIrExE,CAAA,CAAQE,CAAA,EAAQ+/B,IAAA,CAEZxgC,CAAA;cACEqL,CAAA,IAAe,GACfD,CAAA,IAAc,GACdZ,CAAA,GAAOxK,CAAA,EACPD,CAAA,EAAS;YAAA,GAGVA,CAAA;cACCsL,CAAA,IAAe,GACfC,CAAA,IAAU,GACVtL,CAAA,CAAOD,CAAA,CAAK;YAAA,EACZ;UAAA,WAGFsC,OAAA,CAAQghD,IAAA,CAAKt3C,CAAA,GAEfD,CAAA,EACF,MAAM,IAAI1H,KAAA,CAAM,2DAA2DpE,CAAA,K;WAIlEA,CAAA,CAAAi/C,WAAA,GAAc;UACzB,IAAI7zC,CAAA,IAAeZ,CAAA,EACjB,OAAOA,CAAA;UAGT,MAAM,IAAIpG,KAAA,CAAM,sCAAsC;QAAA,GAG3CpE,CAAA,CAAAoH,OAAA,GAAU;;WACjBgE,CAAA,IAAgBC,CAAA,IAAiBC,CAAA,KACnCD,CAAA,IAAe,GAEwB,UAAtCtL,CAAA,GAAAyK,CAAA,CAA+B84C,OAAA,UAAO,MAAAvjD,CAAA,IAAAA,CAAA,CAAEwjD,mBAAA,IACzC/4C,CAAA,QAAO,GAEPa,CAAA,IAAe,GACfD,CAAA,IAAc,GACdE,CAAA,IAAU,E;;;;;;;;;QC7Md,MAAA/K,CAAA,GAAAC,CAAA;QAEaR,CAAA,CAAAq/C,eAAA,GAAkB,CAACt/C,CAAA,EAAcC,CAAA;UAC5C,MAAMQ,CAAA,IAAO,GAAAD,CAAA,CAAA0+C,WAAA;YAEPx+C,CAAA,GAAaD,CAAA,CAAKgjD,eAAA,CAAgBzjD,CAAA,IAAQ;YAC1CiB,CAAA,GAAaR,CAAA,CAAK8gD,OAAA,CAAQ7gD,CAAA;UAIhC,OAHAD,CAAA,CAAKijD,YAAA,CAAa1jD,CAAA,EAAMiB,CAAA,EAAYP,CAAA,GACpCT,CAAA,CAAO+G,IAAA,CAAK/F,CAAA,GAELA,CAAU;QAAA,GAONhB,CAAA,CAAAy/C,mBAAA,GACT,CAAC1/C,CAAA,EAAkCS,CAAA,EAAgBD,CAAA,EAClDE,CAAA;UACC,IAAsB,mBAAXV,CAAA,IAAmC,SAAZA,CAAA,EAAkB;YAClD,IAAIQ,CAAA,CAAKsO,GAAA,CAAI9O,CAAA,GACX,MAAM,IAAIqE,KAAA,CAAM;YAEhB7D,CAAA,CAAKuO,GAAA,CAAI/O,CAAA,C;;UAIb6C,MAAA,CAAOm9C,OAAA,CAAQhgD,CAAA,EAAS6K,OAAA,CAAQ,EAAE7K,CAAA,EAAKiB,CAAA;YACrC,MAAMC,CAAA,GAAOT,CAAA,GAAWA,CAAA,GAAST,CAAA,GAAMA,CAAA;YACvC,IAAqB,mBAAViB,CAAA,GACT,GAAAhB,CAAA,CAAAy/C,mBAAA,EAAoBz+C,CAAA,EAAkCC,CAAA,GAAO,KAAKV,CAAA,EAAME,CAAA,OACnE,IAAqB,mBAAVO,CAAA,IAAuC,mBAAVA,CAAA,EAC7CP,CAAA,CAAQQ,CAAA,EAAMD,CAAA,CAAMs1B,QAAA,SACf;cAAA,IAAqB,oBAAVt1B,CAAA,EAGhB,MAAM,IAAIoD,KAAA,CAAM,4CAA0CpD,CAAA;cAF1DP,CAAA,CAAQQ,CAAA,EAAMD,CAAA,GAAU,MAAM,I;;YAIhC;QAAA,GAOKhB,CAAA,CAAAu/C,cAAA,GAAkBx/C,CAAA;UAC7B,MAAMC,CAAA,IAAO,GAAAO,CAAA,CAAA0+C,WAAA;YAEPz+C,CAAA,GAAQR,CAAA,CAAKyhD,SAAA;UACnB;YACE,MAAMjhD,CAAA,GAAeR,CAAA,CAAK0hD,UAAA,CAAW;YACrC1hD,CAAA,CAAK0jD,gBAAA,CAAiBljD,CAAA,EAAcA,CAAA,GAAe;YACnD,MAAMD,CAAA,GAAYP,CAAA,CAAK4hD,MAAA,CAAOphD,CAAA,GAAe;cACvCC,CAAA,GAAsBT,CAAA,CAAKmiD,OAAA,CAAQ3hD,CAAA,GAAe,IAAI;cACtDQ,CAAA,GAAeP,CAAA,GAAsBT,CAAA,CAAK+hD,YAAA,CAAathD,CAAA,IAAuB;YACpF,MAAM,IAAI2D,KAAA,CAAM,GAAGrE,CAAA,gBAAuBQ,CAAA,oBAA6BS,CAAA,G;;YAEvEhB,CAAA,CAAK6hD,YAAA,CAAarhD,CAAA,C;;;;;;;;;;;;QC1DP,SAASQ,EAAA;UACtB,OAAOP,CAAA,GAAO,22wDAAk+yD,eAAU,QAAW,EACvgzD;QAAA;;;;;QCAAV,CAAA,CAAOE,OAAA,GAAU,UAAUF,CAAA,EAASC,CAAA,EAAmBQ,CAAA,EAAeD,CAAA;UACpE,IAAIE,CAAA,GAAcH,IAAA,IAAQqjD,MAAA;UAE1B;YACE;cACE,IAAI3iD,CAAA;cAEJ;gBAEEA,CAAA,GAAO,IAAIP,CAAA,CAAYuiD,IAAA,CAAK,CAACjjD,CAAA,EAC/B;cAAA,CAAE,QAAOC,CAAA;gBAAA,CAGPgB,CAAA,GAAO,KADWP,CAAA,CAAYmjD,WAAA,IAAenjD,CAAA,CAAYojD,iBAAA,IAAqBpjD,CAAA,CAAYqjD,cAAA,IAAkBrjD,CAAA,CAAYsjD,aAAA,KAEnHC,MAAA,CAAOjkD,CAAA,GACZiB,CAAA,GAAOA,CAAA,CAAKijD,OAAA,EACd;cAAA;cAEA,IAAIhjD,CAAA,GAAMR,CAAA,CAAYwiD,GAAA,IAAOxiD,CAAA,CAAYyjD,SAAA;gBACrC7gD,CAAA,GAAYpC,CAAA,CAAIiiD,eAAA,CAAgBliD,CAAA;gBAChCyC,CAAA,GAAS,IAAIhD,CAAA,CAAYT,CAAA,EAAmBqD,CAAA,EAAW7C,CAAA;cAE3D,OADAS,CAAA,CAAIkjD,eAAA,CAAgB9gD,CAAA,GACbI,CACT;YAAA,CAAE,QAAOlD,CAAA;cACP,OAAO,IAAIE,CAAA,CAAYT,CAAA,EAAmB,+BAA+BmY,MAAA,CAAOisC,kBAAA,CAAmBrkD,CAAA,IAAWS,CAAA,CAChH;YAAA;UACF,CAAE,QAAOT,CAAA;YACP,KAAKQ,CAAA,EACH,MAAM6D,KAAA,CAAM;YAGd,OAAO,IAAI3D,CAAA,CAAYT,CAAA,EAAmBO,CAAA,EAAKC,CAAA,CACjD;UAAA;QACF,C;;;;;QCnCA,IAiCYD,CAAA;UAAiBE,CAAA;UAlBrBO,CAAA;UAfJC,CAAA,GAAYT,CAAA,CAAQ;UAGpB6C,CAAA,GAAUpC,CAAA,CAAUojD,MAAA;UAAQ5gD,CAAA,GAAUxC,CAAA,CAAUqjD,MAAA;UAAQ95C,CAAA,GAAQvJ,CAAA,CAAUsjD,IAAA;UAG1En5C,CAAA,GAAQnK,CAAA,CAAUujD,KAAA,CAAelK,OAAA,KAAMr5C,CAAA,CAAUujD,KAAA,CAAelK,OAAA,GAAI,CAAC;QAEzElvC,CAAA,CAAMxH,IAAA,KAOE5C,CAAA,GAAO,CAAC,GAiBPyjD,OAAA,IACGlkD,CAAA,GAAa,CAAC,IAAGE,CAAA,GAASmC,MAAA,CAAO48B,MAAA,CAAOj/B,CAAA,GACrCA,CAAA,CAAW,KAAK,oBAAoB,GAC3CE,CAAA,CAAOF,CAAA,CAAW,KAAK,2BAA2B,GAClDE,CAAA,CAAOF,CAAA,CAAW,KAAK,2BAA2B,GAClDE,CAAA,CAAOF,CAAA,CAAW,KAAK,0BAA0B,GACjDE,CAAA,CAAOF,CAAA,CAAW,KAAK,0BAA0B,GACjDE,CAAA,CAAOF,CAAA,CAAW,KAAK,0BAA0B,GACjDE,CAAA,CAAOF,CAAA,CAAW,KAAK,0BAA0B,GACjDE,CAAA,CAAOF,CAAA,CAAW,KAAK,yBAAyB,GAChDE,CAAA,CAAOF,CAAA,CAAW,KAAK,0BAA0B,GACjDE,CAAA,CAAOF,CAAA,CAAW,KAAK,gBAAgB,GAChCE,CAAA,GAGXO,CAAA,CAAK6C,cAAA,GAAiB;UAkClB,SAAS9D,EAAeA,CAAA;YAQpB,IAPA,KAAKyG,MAAA,GAAS,IACd,KAAKC,IAAA,GAAO,IACZ,KAAKC,OAAA,GAAU,IACf,KAAKC,OAAA,GAAU,IACf,KAAKC,MAAA,GAAS,IACd,KAAK89C,aAAA,GAAgB,IACrB,KAAKC,UAAA,GAAa,IACd5kD,CAAA,EACA,KAAK,IAAIC,CAAA,GAAO4C,MAAA,CAAO6N,IAAA,CAAK1Q,CAAA,GAAaS,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK6B,MAAA,IAAUrB,CAAA,EACpC,QAAvBT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,OAChB,KAAKR,CAAA,CAAKQ,CAAA,KAAMT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,GAChD;UAAA;UA42BA,OAp2BAT,CAAA,CAAe6kD,SAAA,CAAU7gD,IAAA,GAAO,IAQhChE,CAAA,CAAe6kD,SAAA,CAAUC,WAAA,GAAc,IAQvC9kD,CAAA,CAAe6kD,SAAA,CAAUna,SAAA,GAAY,IAQrC1qC,CAAA,CAAe6kD,SAAA,CAAU7/C,IAAA,GAAO,GAQhChF,CAAA,CAAe6kD,SAAA,CAAUt+C,CAAA,GAAI,GAQ7BvG,CAAA,CAAe6kD,SAAA,CAAU5jD,CAAA,GAAIwJ,CAAA,CAAMwxC,IAAA,GAAOxxC,CAAA,CAAMwxC,IAAA,CAAKb,QAAA,CAAS,GAAE,IAAE,KAAS,GAQ3Ep7C,CAAA,CAAe6kD,SAAA,CAAUvhD,CAAA,GAAImH,CAAA,CAAMs6C,SAAA,CAAU,KAQ7C/kD,CAAA,CAAe6kD,SAAA,CAAU5kD,CAAA,GAAI,MAQ7BD,CAAA,CAAe6kD,SAAA,CAAUr+C,CAAA,GAAI,MAQ7BxG,CAAA,CAAe6kD,SAAA,CAAUG,YAAA,GAAe,MAQxChlD,CAAA,CAAe6kD,SAAA,CAAUI,EAAA,GAAK,MAQ9BjlD,CAAA,CAAe6kD,SAAA,CAAUp+C,MAAA,GAASgE,CAAA,CAAMy6C,UAAA,EAQxCllD,CAAA,CAAe6kD,SAAA,CAAUn+C,IAAA,GAAO+D,CAAA,CAAMy6C,UAAA,EAQtCllD,CAAA,CAAe6kD,SAAA,CAAUl+C,OAAA,GAAU8D,CAAA,CAAMy6C,UAAA,EAQzCllD,CAAA,CAAe6kD,SAAA,CAAUj+C,OAAA,GAAU6D,CAAA,CAAMy6C,UAAA,EAQzCllD,CAAA,CAAe6kD,SAAA,CAAUh+C,MAAA,GAAS4D,CAAA,CAAMy6C,UAAA,EAQxCllD,CAAA,CAAe6kD,SAAA,CAAUF,aAAA,GAAgBl6C,CAAA,CAAMy6C,UAAA,EAQ/CllD,CAAA,CAAe6kD,SAAA,CAAUD,UAAA,GAAan6C,CAAA,CAAMy6C,UAAA,EAU5CllD,CAAA,CAAey/B,MAAA,GAAS,UAAgBx/B,CAAA;YACpC,OAAO,IAAID,CAAA,CAAeC,CAAA,CAC9B;UAAA,GAWAD,CAAA,CAAekP,MAAA,GAAS,UAAgBlP,CAAA,EAASC,CAAA;YAe7C,IAdKA,CAAA,KACDA,CAAA,GAASyD,CAAA,CAAQ+7B,MAAA,KACD,QAAhBz/B,CAAA,CAAQgE,IAAA,IAAgBnB,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,WAC5DC,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQgE,IAAA,GAC3C,QAAbhE,CAAA,CAAQuG,CAAA,IAAa1D,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,QACzDC,CAAA,CAAOklD,MAAA,CAA8B,IAAIE,KAAA,CAAMrlD,CAAA,CAAQuG,CAAA,GAC1C,QAAbvG,CAAA,CAAQiB,CAAA,IAAa4B,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,QACzDC,CAAA,CAAOklD,MAAA,CAA8B,IAAIG,KAAA,CAAMtlD,CAAA,CAAQiB,CAAA,GAC1C,QAAbjB,CAAA,CAAQsD,CAAA,IAAaT,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,QACzDC,CAAA,CAAOklD,MAAA,CAA8B,IAAIla,KAAA,CAAMjrC,CAAA,CAAQsD,CAAA,GAC1C,QAAbtD,CAAA,CAAQC,CAAA,IAAa4C,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,QACzDqL,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAY/qC,MAAA,CAAOlP,CAAA,CAAQC,CAAA,EAAGA,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA,IAC7E,QAAbxlD,CAAA,CAAQwG,CAAA,IAAa3D,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,QACzDqL,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAWntB,MAAA,CAAOlP,CAAA,CAAQwG,CAAA,EAAGvG,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA,IACvE,QAAlBxlD,CAAA,CAAQyG,MAAA,IAAkBzG,CAAA,CAAQyG,MAAA,CAAO3E,MAAA,EAAQ;cACjD7B,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA;cACzC,KAAK,IAAI9kD,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQyG,MAAA,CAAO3E,MAAA,IAAUrB,CAAA,EACzCR,CAAA,CAAOolD,KAAA,CAAMrlD,CAAA,CAAQyG,MAAA,CAAOhG,CAAA;cAChCR,CAAA,CAAOulD,MAAA,EACX;YAAA;YACA,IAAoB,QAAhBxlD,CAAA,CAAQ0G,IAAA,IAAgB1G,CAAA,CAAQ0G,IAAA,CAAK5E,MAAA,EAAQ;cAE7C,KADA7B,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAChC9kD,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQ0G,IAAA,CAAK5E,MAAA,IAAUrB,CAAA,EACvCR,CAAA,CAAOqlD,KAAA,CAAMtlD,CAAA,CAAQ0G,IAAA,CAAKjG,CAAA;cAC9BR,CAAA,CAAOulD,MAAA,EACX;YAAA;YACA,IAAuB,QAAnBxlD,CAAA,CAAQ2G,OAAA,IAAmB3G,CAAA,CAAQ2G,OAAA,CAAQ7E,MAAA,EAC3C,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQ2G,OAAA,CAAQ7E,MAAA,IAAUrB,CAAA,EAC1CR,CAAA,CAAOklD,MAAA,CAA8B,IAAIla,KAAA,CAAMjrC,CAAA,CAAQ2G,OAAA,CAAQlG,CAAA;YACvE,IAAuB,QAAnBT,CAAA,CAAQ4G,OAAA,IAAmB5G,CAAA,CAAQ4G,OAAA,CAAQ9E,MAAA,EAC3C,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQ4G,OAAA,CAAQ9E,MAAA,IAAUrB,CAAA,EAC1C4K,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAY/qC,MAAA,CAAOlP,CAAA,CAAQ4G,OAAA,CAAQnG,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA+B,IAAII,IAAA,IAAQC,MAAA;YAC5G,IAAsB,QAAlBxlD,CAAA,CAAQ6G,MAAA,IAAkB7G,CAAA,CAAQ6G,MAAA,CAAO/E,MAAA,EACzC,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQ6G,MAAA,CAAO/E,MAAA,IAAUrB,CAAA,EACzC4K,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAWntB,MAAA,CAAOlP,CAAA,CAAQ6G,MAAA,CAAOpG,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA+B,IAAII,IAAA,IAAQC,MAAA;YAK1G,IAJyB,QAArBxlD,CAAA,CAAQ0qC,SAAA,IAAqB7nC,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,gBACjEC,CAAA,CAAOklD,MAAA,CAA+B,KAAKC,MAAA,CAAOplD,CAAA,CAAQ0qC,SAAA,GAC5C,QAAd1qC,CAAA,CAAQilD,EAAA,IAAcpiD,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,SAC1DqL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUv2C,MAAA,CAAOlP,CAAA,CAAQilD,EAAA,EAAIhlD,CAAA,CAAOklD,MAAA,CAA+B,KAAKI,IAAA,IAAQC,MAAA,IACrE,QAAtBxlD,CAAA,CAAQ4kD,UAAA,IAAsB5kD,CAAA,CAAQ4kD,UAAA,CAAW9iD,MAAA,EACjD,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQ4kD,UAAA,CAAW9iD,MAAA,IAAUrB,CAAA,EAC7C4K,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUv2C,MAAA,CAAOlP,CAAA,CAAQ4kD,UAAA,CAAWnkD,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA+B,KAAKI,IAAA,IAAQC,MAAA;YAO9G,IANoB,QAAhBxlD,CAAA,CAAQgF,IAAA,IAAgBnC,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,WAC5DC,CAAA,CAAOklD,MAAA,CAA+B,KAAKO,KAAA,CAAM1lD,CAAA,CAAQgF,IAAA,GAClC,QAAvBhF,CAAA,CAAQ8kD,WAAA,IAAuBjiD,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,kBACnEC,CAAA,CAAOklD,MAAA,CAA+B,KAAKC,MAAA,CAAOplD,CAAA,CAAQ8kD,WAAA,GAClC,QAAxB9kD,CAAA,CAAQglD,YAAA,IAAwBniD,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,mBACpEqL,CAAA,CAAMxH,IAAA,CAAK8hD,iBAAA,CAAkBz2C,MAAA,CAAOlP,CAAA,CAAQglD,YAAA,EAAc/kD,CAAA,CAAOklD,MAAA,CAA+B,KAAKI,IAAA,IAAQC,MAAA,IACpF,QAAzBxlD,CAAA,CAAQ2kD,aAAA,IAAyB3kD,CAAA,CAAQ2kD,aAAA,CAAc7iD,MAAA,EACvD,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQ2kD,aAAA,CAAc7iD,MAAA,IAAUrB,CAAA,EAChD4K,CAAA,CAAMxH,IAAA,CAAK8hD,iBAAA,CAAkBz2C,MAAA,CAAOlP,CAAA,CAAQ2kD,aAAA,CAAclkD,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA+B,KAAKI,IAAA,IAAQC,MAAA;YACzH,OAAOvlD,CACX;UAAA,GAWAD,CAAA,CAAe4lD,eAAA,GAAkB,UAAyB5lD,CAAA,EAASC,CAAA;YAC/D,OAAO,KAAKiP,MAAA,CAAOlP,CAAA,EAASC,CAAA,EAAQulD,MAAA,EACxC;UAAA,GAaAxlD,CAAA,CAAemP,MAAA,GAAS,UAAgBnP,CAAA,EAAQC,CAAA;YACtCD,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAASsD,CAAA,CAAQm8B,MAAA,CAAOz/B,CAAA;YAE5B,KADA,IAAIS,CAAA,QAAiB,MAAXR,CAAA,GAAuBD,CAAA,CAAO6lD,GAAA,GAAM7lD,CAAA,CAAO8lD,GAAA,GAAM7lD,CAAA,EAAQO,CAAA,GAAU,IAAI6K,CAAA,CAAMxH,IAAA,CAAKC,cAAA,IACrF9D,CAAA,CAAO8lD,GAAA,GAAMrlD,CAAA,GAAK;cACrB,IAAIC,CAAA,GAAMV,CAAA,CAAOmlD,MAAA;cACjB,QAAQzkD,CAAA,KAAQ;gBAChB,KAAK;kBACGF,CAAA,CAAQwD,IAAA,GAAOhE,CAAA,CAAOolD,MAAA;kBACtB;gBAER,KAAK;kBACG5kD,CAAA,CAAQskD,WAAA,GAAc9kD,CAAA,CAAOolD,MAAA;kBAC7B;gBAER,KAAK;kBACG5kD,CAAA,CAAQkqC,SAAA,GAAY1qC,CAAA,CAAOolD,MAAA;kBAC3B;gBAER,KAAK;kBACG5kD,CAAA,CAAQwE,IAAA,GAAOhF,CAAA,CAAO0lD,KAAA;kBACtB;gBAER,KAAK;kBACGllD,CAAA,CAAQ+F,CAAA,GAAIvG,CAAA,CAAOqlD,KAAA;kBACnB;gBAER,KAAK;kBACG7kD,CAAA,CAAQS,CAAA,GAAIjB,CAAA,CAAOslD,KAAA;kBACnB;gBAER,KAAK;kBACG9kD,CAAA,CAAQ8C,CAAA,GAAItD,CAAA,CAAOirC,KAAA;kBACnB;gBAER,KAAK;kBACGzqC,CAAA,CAAQP,CAAA,GAAIoL,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAY9qC,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBACzD;gBAER,KAAK;kBACG3kD,CAAA,CAAQgG,CAAA,GAAI6E,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAWltB,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBACxD;gBAER,KAAK;kBACG3kD,CAAA,CAAQwkD,YAAA,GAAe35C,CAAA,CAAMxH,IAAA,CAAK8hD,iBAAA,CAAkBx2C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBAC1E;gBAER,KAAK;kBACG3kD,CAAA,CAAQykD,EAAA,GAAK55C,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUt2C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBACxD;gBAER,KAAK;kBAGG,IAFM3kD,CAAA,CAAQiG,MAAA,IAAUjG,CAAA,CAAQiG,MAAA,CAAO3E,MAAA,KACnCtB,CAAA,CAAQiG,MAAA,GAAS,KACH,MAAP,IAAN/F,CAAA,GAED,KADA,IAAIO,CAAA,GAAOjB,CAAA,CAAOmlD,MAAA,KAAWnlD,CAAA,CAAO8lD,GAAA,EAC7B9lD,CAAA,CAAO8lD,GAAA,GAAM7kD,CAAA,GAChBT,CAAA,CAAQiG,MAAA,CAAOO,IAAA,CAAKhH,CAAA,CAAOqlD,KAAA,SAE/B7kD,CAAA,CAAQiG,MAAA,CAAOO,IAAA,CAAKhH,CAAA,CAAOqlD,KAAA;kBAC/B;gBAER,KAAK;kBAGG,IAFM7kD,CAAA,CAAQkG,IAAA,IAAQlG,CAAA,CAAQkG,IAAA,CAAK5E,MAAA,KAC/BtB,CAAA,CAAQkG,IAAA,GAAO,KACD,MAAP,IAANhG,CAAA,GAED,KADIO,CAAA,GAAOjB,CAAA,CAAOmlD,MAAA,KAAWnlD,CAAA,CAAO8lD,GAAA,EAC7B9lD,CAAA,CAAO8lD,GAAA,GAAM7kD,CAAA,GAChBT,CAAA,CAAQkG,IAAA,CAAKM,IAAA,CAAKhH,CAAA,CAAOslD,KAAA,SAE7B9kD,CAAA,CAAQkG,IAAA,CAAKM,IAAA,CAAKhH,CAAA,CAAOslD,KAAA;kBAC7B;gBAER,KAAK;kBACS9kD,CAAA,CAAQmG,OAAA,IAAWnG,CAAA,CAAQmG,OAAA,CAAQ7E,MAAA,KACrCtB,CAAA,CAAQmG,OAAA,GAAU,KACtBnG,CAAA,CAAQmG,OAAA,CAAQK,IAAA,CAAKhH,CAAA,CAAOirC,KAAA;kBAC5B;gBAER,KAAK;kBACSzqC,CAAA,CAAQoG,OAAA,IAAWpG,CAAA,CAAQoG,OAAA,CAAQ9E,MAAA,KACrCtB,CAAA,CAAQoG,OAAA,GAAU,KACtBpG,CAAA,CAAQoG,OAAA,CAAQI,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAY9qC,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBAClE;gBAER,KAAK;kBACS3kD,CAAA,CAAQqG,MAAA,IAAUrG,CAAA,CAAQqG,MAAA,CAAO/E,MAAA,KACnCtB,CAAA,CAAQqG,MAAA,GAAS,KACrBrG,CAAA,CAAQqG,MAAA,CAAOG,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAWltB,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBAChE;gBAER,KAAK;kBACS3kD,CAAA,CAAQmkD,aAAA,IAAiBnkD,CAAA,CAAQmkD,aAAA,CAAc7iD,MAAA,KACjDtB,CAAA,CAAQmkD,aAAA,GAAgB,KAC5BnkD,CAAA,CAAQmkD,aAAA,CAAc39C,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAK8hD,iBAAA,CAAkBx2C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBAC9E;gBAER,KAAK;kBACS3kD,CAAA,CAAQokD,UAAA,IAAcpkD,CAAA,CAAQokD,UAAA,CAAW9iD,MAAA,KAC3CtB,CAAA,CAAQokD,UAAA,GAAa,KACzBpkD,CAAA,CAAQokD,UAAA,CAAW59C,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUt2C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBACnE;gBAER;kBACInlD,CAAA,CAAO+lD,QAAA,CAAe,IAANrlD,CAAA;cAAA;YAGxB;YACA,OAAOF,CACX;UAAA,GAYAR,CAAA,CAAegmD,eAAA,GAAkB,UAAyBhmD,CAAA;YAGtD,OAFMA,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAAS,IAAIsD,CAAA,CAAQtD,CAAA,IAClB,KAAKmP,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,GACtC;UAAA,GAUAnlD,CAAA,CAAeimD,MAAA,GAAS,UAAgBjmD,CAAA;YACpC,IAAuB,mBAAZA,CAAA,IAAoC,SAAZA,CAAA,EAC/B,OAAO;YACX,IAAoB,QAAhBA,CAAA,CAAQgE,IAAA,IAAgBhE,CAAA,CAAQmlB,cAAA,CAAe,YAC1C1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQgE,IAAA,GACxB,OAAO;YACf,IAA2B,QAAvBhE,CAAA,CAAQ8kD,WAAA,IAAuB9kD,CAAA,CAAQmlB,cAAA,CAAe,mBACjD1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQ8kD,WAAA,GACxB,OAAO;YACf,IAAyB,QAArB9kD,CAAA,CAAQ0qC,SAAA,IAAqB1qC,CAAA,CAAQmlB,cAAA,CAAe,iBAC/C1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQ0qC,SAAA,GACxB,OAAO;YACf,IAAoB,QAAhB1qC,CAAA,CAAQgF,IAAA,IAAgBhF,CAAA,CAAQmlB,cAAA,CAAe,SAC/C,QAAQnlB,CAAA,CAAQgF,IAAA;cAChB;gBACI,OAAO;cACX,KAAK;cACL,KAAK;cACL,KAAK;cACL,KAAK;cACL,KAAK;cACL,KAAK;cACL,KAAK;cACL,KAAK;cACL,KAAK;cACL,KAAK;cACL,KAAK;cACL,KAAK;cACL,KAAK;cACL,KAAK;cACL,KAAK;YAAA;YAGT,IAAiB,QAAbhF,CAAA,CAAQuG,CAAA,IAAavG,CAAA,CAAQmlB,cAAA,CAAe,QACnB,mBAAdnlB,CAAA,CAAQuG,CAAA,EACf,OAAO;YACf,IAAiB,QAAbvG,CAAA,CAAQiB,CAAA,IAAajB,CAAA,CAAQmlB,cAAA,CAAe,UACvC1a,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQiB,CAAA,KAAQjB,CAAA,CAAQiB,CAAA,IAAKwJ,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQiB,CAAA,CAAEk7C,GAAA,KAAQ1xC,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQiB,CAAA,CAAEm7C,IAAA,IAC1G,OAAO;YACf,IAAiB,QAAbp8C,CAAA,CAAQsD,CAAA,IAAatD,CAAA,CAAQmlB,cAAA,CAAe,UACtCnlB,CAAA,CAAQsD,CAAA,IAAiC,mBAArBtD,CAAA,CAAQsD,CAAA,CAAExB,MAAA,IAAuB2I,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQsD,CAAA,IAC9E,OAAO;YACf,IAAiB,QAAbtD,CAAA,CAAQC,CAAA,IAAaD,CAAA,CAAQmlB,cAAA,CAAe,SACxC1kB,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYgM,MAAA,CAAOjmD,CAAA,CAAQC,CAAA,IAE9C,OAAO,OAAOQ,CAAA;YAEtB,IAAiB,QAAbT,CAAA,CAAQwG,CAAA,IAAaxG,CAAA,CAAQmlB,cAAA,CAAe,SACxC1kB,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAW4pB,MAAA,CAAOjmD,CAAA,CAAQwG,CAAA,IAE7C,OAAO,OAAO/F,CAAA;YAEtB,IAA4B,QAAxBT,CAAA,CAAQglD,YAAA,IAAwBhlD,CAAA,CAAQmlB,cAAA,CAAe,oBACnD1kB,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAK8hD,iBAAA,CAAkBM,MAAA,CAAOjmD,CAAA,CAAQglD,YAAA,IAEpD,OAAO,kBAAkBvkD,CAAA;YAEjC,IAAkB,QAAdT,CAAA,CAAQilD,EAAA,IAAcjlD,CAAA,CAAQmlB,cAAA,CAAe,UACzC1kB,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUQ,MAAA,CAAOjmD,CAAA,CAAQilD,EAAA,IAE5C,OAAO,QAAQxkD,CAAA;YAEvB,IAAsB,QAAlBT,CAAA,CAAQyG,MAAA,IAAkBzG,CAAA,CAAQmlB,cAAA,CAAe,WAAW;cAC5D,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQyG,MAAA,GACvB,OAAO;cACX,KAAK,IAAIxG,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQyG,MAAA,CAAO3E,MAAA,IAAU7B,CAAA,EACzC,IAAiC,mBAAtBD,CAAA,CAAQyG,MAAA,CAAOxG,CAAA,GACtB,OAAO,2BACnB;YAAA;YACA,IAAoB,QAAhBD,CAAA,CAAQ0G,IAAA,IAAgB1G,CAAA,CAAQmlB,cAAA,CAAe,SAAS;cACxD,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQ0G,IAAA,GACvB,OAAO;cACX,KAASzG,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQ0G,IAAA,CAAK5E,MAAA,IAAU7B,CAAA,EACvC,MAAKwK,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQ0G,IAAA,CAAKzG,CAAA,MAASD,CAAA,CAAQ0G,IAAA,CAAKzG,CAAA,KAAMwK,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQ0G,IAAA,CAAKzG,CAAA,EAAGk8C,GAAA,KAAQ1xC,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQ0G,IAAA,CAAKzG,CAAA,EAAGm8C,IAAA,IAClI,OAAO,+BACnB;YAAA;YACA,IAAuB,QAAnBp8C,CAAA,CAAQ2G,OAAA,IAAmB3G,CAAA,CAAQmlB,cAAA,CAAe,YAAY;cAC9D,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQ2G,OAAA,GACvB,OAAO;cACX,KAAS1G,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQ2G,OAAA,CAAQ7E,MAAA,IAAU7B,CAAA,EAC1C,MAAMD,CAAA,CAAQ2G,OAAA,CAAQ1G,CAAA,KAA2C,mBAA9BD,CAAA,CAAQ2G,OAAA,CAAQ1G,CAAA,EAAG6B,MAAA,IAAuB2I,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQ2G,OAAA,CAAQ1G,CAAA,KACxG,OAAO,4BACnB;YAAA;YACA,IAAuB,QAAnBD,CAAA,CAAQ4G,OAAA,IAAmB5G,CAAA,CAAQmlB,cAAA,CAAe,YAAY;cAC9D,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQ4G,OAAA,GACvB,OAAO;cACX,KAAS3G,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQ4G,OAAA,CAAQ9E,MAAA,IAAU7B,CAAA,EAE1C,IADIQ,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYgM,MAAA,CAAOjmD,CAAA,CAAQ4G,OAAA,CAAQ3G,CAAA,IAEtD,OAAO,aAAaQ,CAEhC;YAAA;YACA,IAAsB,QAAlBT,CAAA,CAAQ6G,MAAA,IAAkB7G,CAAA,CAAQmlB,cAAA,CAAe,WAAW;cAC5D,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQ6G,MAAA,GACvB,OAAO;cACX,KAAS5G,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQ6G,MAAA,CAAO/E,MAAA,IAAU7B,CAAA,EAEzC,IADIQ,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAW4pB,MAAA,CAAOjmD,CAAA,CAAQ6G,MAAA,CAAO5G,CAAA,IAEpD,OAAO,YAAYQ,CAE/B;YAAA;YACA,IAA6B,QAAzBT,CAAA,CAAQ2kD,aAAA,IAAyB3kD,CAAA,CAAQmlB,cAAA,CAAe,kBAAkB;cAC1E,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQ2kD,aAAA,GACvB,OAAO;cACX,KAAS1kD,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQ2kD,aAAA,CAAc7iD,MAAA,IAAU7B,CAAA,EAEhD,IADIQ,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAK8hD,iBAAA,CAAkBM,MAAA,CAAOjmD,CAAA,CAAQ2kD,aAAA,CAAc1kD,CAAA,IAElE,OAAO,mBAAmBQ,CAEtC;YAAA;YACA,IAA0B,QAAtBT,CAAA,CAAQ4kD,UAAA,IAAsB5kD,CAAA,CAAQmlB,cAAA,CAAe,eAAe;cACpE,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQ4kD,UAAA,GACvB,OAAO;cACX,KAAS3kD,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQ4kD,UAAA,CAAW9iD,MAAA,IAAU7B,CAAA,EAAG;gBAChD,IAAIQ,CAAA;gBACJ,IADIA,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUQ,MAAA,CAAOjmD,CAAA,CAAQ4kD,UAAA,CAAW3kD,CAAA,IAEvD,OAAO,gBAAgBQ,CAC/B;cAAA;YACJ;YACA,OAAO,IACX;UAAA,GAUAT,CAAA,CAAemmD,UAAA,GAAa,UAAoBnmD,CAAA;YAC5C,IAAIA,CAAA,YAAkBqL,CAAA,CAAMxH,IAAA,CAAKC,cAAA,EAC7B,OAAO9D,CAAA;YACX,IAAIC,CAAA,GAAU,IAAIoL,CAAA,CAAMxH,IAAA,CAAKC,cAAA;YAO7B,QANmB,QAAf9D,CAAA,CAAOgE,IAAA,KACP/D,CAAA,CAAQ+D,IAAA,GAAOoiD,MAAA,CAAOpmD,CAAA,CAAOgE,IAAA,IACP,QAAtBhE,CAAA,CAAO8kD,WAAA,KACP7kD,CAAA,CAAQ6kD,WAAA,GAAcsB,MAAA,CAAOpmD,CAAA,CAAO8kD,WAAA,IAChB,QAApB9kD,CAAA,CAAO0qC,SAAA,KACPzqC,CAAA,CAAQyqC,SAAA,GAAY0b,MAAA,CAAOpmD,CAAA,CAAO0qC,SAAA,IAC9B1qC,CAAA,CAAOgF,IAAA;cACf;gBACI,IAA2B,mBAAhBhF,CAAA,CAAOgF,IAAA,EAAmB;kBACjC/E,CAAA,CAAQ+E,IAAA,GAAOhF,CAAA,CAAOgF,IAAA;kBACtB;gBACJ;gBACA;cACJ,KAAK;cACL,KAAK;gBACD/E,CAAA,CAAQ+E,IAAA,GAAO;gBACf;cACJ,KAAK;cACL,KAAK;gBACD/E,CAAA,CAAQ+E,IAAA,GAAO;gBACf;cACJ,KAAK;cACL,KAAK;gBACD/E,CAAA,CAAQ+E,IAAA,GAAO;gBACf;cACJ,KAAK;cACL,KAAK;gBACD/E,CAAA,CAAQ+E,IAAA,GAAO;gBACf;cACJ,KAAK;cACL,KAAK;gBACD/E,CAAA,CAAQ+E,IAAA,GAAO;gBACf;cACJ,KAAK;cACL,KAAK;gBACD/E,CAAA,CAAQ+E,IAAA,GAAO;gBACf;cACJ,KAAK;cACL,KAAK;gBACD/E,CAAA,CAAQ+E,IAAA,GAAO;gBACf;cACJ,KAAK;cACL,KAAK;gBACD/E,CAAA,CAAQ+E,IAAA,GAAO;gBACf;cACJ,KAAK;cACL,KAAK;gBACD/E,CAAA,CAAQ+E,IAAA,GAAO;gBACf;cACJ,KAAK;cACL,KAAK;gBACD/E,CAAA,CAAQ+E,IAAA,GAAO;gBACf;cACJ,KAAK;cACL,KAAK;gBACD/E,CAAA,CAAQ+E,IAAA,GAAO;gBACf;cACJ,KAAK;cACL,KAAK;gBACD/E,CAAA,CAAQ+E,IAAA,GAAO;gBACf;cACJ,KAAK;cACL,KAAK;gBACD/E,CAAA,CAAQ+E,IAAA,GAAO;gBACf;cACJ,KAAK;cACL,KAAK;gBACD/E,CAAA,CAAQ+E,IAAA,GAAO;gBACf;cACJ,KAAK;cACL,KAAK;gBACD/E,CAAA,CAAQ+E,IAAA,GAAO;YAAA;YAmBnB,IAhBgB,QAAZhF,CAAA,CAAOuG,CAAA,KACPtG,CAAA,CAAQsG,CAAA,GAAI7E,MAAA,CAAO1B,CAAA,CAAOuG,CAAA,IACd,QAAZvG,CAAA,CAAOiB,CAAA,KACHwJ,CAAA,CAAMwxC,IAAA,IACLh8C,CAAA,CAAQgB,CAAA,GAAIwJ,CAAA,CAAMwxC,IAAA,CAAKC,SAAA,CAAUl8C,CAAA,CAAOiB,CAAA,GAAIo7C,QAAA,IAAW,IAC/B,mBAAbr8C,CAAA,CAAOiB,CAAA,GACnBhB,CAAA,CAAQgB,CAAA,GAAIihC,QAAA,CAASliC,CAAA,CAAOiB,CAAA,EAAG,MACN,mBAAbjB,CAAA,CAAOiB,CAAA,GACnBhB,CAAA,CAAQgB,CAAA,GAAIjB,CAAA,CAAOiB,CAAA,GACM,mBAAbjB,CAAA,CAAOiB,CAAA,KACnBhB,CAAA,CAAQgB,CAAA,GAAI,IAAIwJ,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAOiB,CAAA,CAAEk7C,GAAA,KAAQ,GAAGn8C,CAAA,CAAOiB,CAAA,CAAEm7C,IAAA,KAAS,GAAGxB,QAAA,MAChE,QAAZ56C,CAAA,CAAOsD,CAAA,KACiB,mBAAbtD,CAAA,CAAOsD,CAAA,GACdmH,CAAA,CAAM67C,MAAA,CAAOn3C,MAAA,CAAOnP,CAAA,CAAOsD,CAAA,EAAGrD,CAAA,CAAQqD,CAAA,GAAImH,CAAA,CAAMs6C,SAAA,CAAUt6C,CAAA,CAAM67C,MAAA,CAAOxkD,MAAA,CAAO9B,CAAA,CAAOsD,CAAA,IAAK,KACrFtD,CAAA,CAAOsD,CAAA,CAAExB,MAAA,IAAU,MACxB7B,CAAA,CAAQqD,CAAA,GAAItD,CAAA,CAAOsD,CAAA,IACX,QAAZtD,CAAA,CAAOC,CAAA,EAAW;cAClB,IAAwB,mBAAbD,CAAA,CAAOC,CAAA,EACd,MAAM8hB,SAAA,CAAU;cACpB9hB,CAAA,CAAQA,CAAA,GAAIoL,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYkM,UAAA,CAAWnmD,CAAA,CAAOC,CAAA,CACzD;YAAA;YACA,IAAgB,QAAZD,CAAA,CAAOwG,CAAA,EAAW;cAClB,IAAwB,mBAAbxG,CAAA,CAAOwG,CAAA,EACd,MAAMub,SAAA,CAAU;cACpB9hB,CAAA,CAAQuG,CAAA,GAAI6E,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAW8pB,UAAA,CAAWnmD,CAAA,CAAOwG,CAAA,CACxD;YAAA;YACA,IAA2B,QAAvBxG,CAAA,CAAOglD,YAAA,EAAsB;cAC7B,IAAmC,mBAAxBhlD,CAAA,CAAOglD,YAAA,EACd,MAAMjjC,SAAA,CAAU;cACpB9hB,CAAA,CAAQ+kD,YAAA,GAAe35C,CAAA,CAAMxH,IAAA,CAAK8hD,iBAAA,CAAkBQ,UAAA,CAAWnmD,CAAA,CAAOglD,YAAA,CAC1E;YAAA;YACA,IAAiB,QAAbhlD,CAAA,CAAOilD,EAAA,EAAY;cACnB,IAAyB,mBAAdjlD,CAAA,CAAOilD,EAAA,EACd,MAAMljC,SAAA,CAAU;cACpB9hB,CAAA,CAAQglD,EAAA,GAAK55C,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUU,UAAA,CAAWnmD,CAAA,CAAOilD,EAAA,CACxD;YAAA;YACA,IAAIjlD,CAAA,CAAOyG,MAAA,EAAQ;cACf,KAAKT,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOyG,MAAA,GACtB,MAAMsb,SAAA,CAAU;cACpB9hB,CAAA,CAAQwG,MAAA,GAAS;cACjB,KAAK,IAAIhG,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOyG,MAAA,CAAO3E,MAAA,IAAUrB,CAAA,EACxCR,CAAA,CAAQwG,MAAA,CAAOhG,CAAA,IAAKiB,MAAA,CAAO1B,CAAA,CAAOyG,MAAA,CAAOhG,CAAA,EACjD;YAAA;YACA,IAAIT,CAAA,CAAO0G,IAAA,EAAM;cACb,KAAKV,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAO0G,IAAA,GACtB,MAAMqb,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQyG,IAAA,GAAO,IACNjG,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAO0G,IAAA,CAAK5E,MAAA,IAAUrB,CAAA,EAClCgK,CAAA,CAAMwxC,IAAA,IACLh8C,CAAA,CAAQyG,IAAA,CAAKjG,CAAA,IAAKgK,CAAA,CAAMwxC,IAAA,CAAKC,SAAA,CAAUl8C,CAAA,CAAO0G,IAAA,CAAKjG,CAAA,IAAK47C,QAAA,IAAW,IACrC,mBAAnBr8C,CAAA,CAAO0G,IAAA,CAAKjG,CAAA,IACxBR,CAAA,CAAQyG,IAAA,CAAKjG,CAAA,IAAKyhC,QAAA,CAASliC,CAAA,CAAO0G,IAAA,CAAKjG,CAAA,GAAI,MACZ,mBAAnBT,CAAA,CAAO0G,IAAA,CAAKjG,CAAA,IACxBR,CAAA,CAAQyG,IAAA,CAAKjG,CAAA,IAAKT,CAAA,CAAO0G,IAAA,CAAKjG,CAAA,IACC,mBAAnBT,CAAA,CAAO0G,IAAA,CAAKjG,CAAA,MACxBR,CAAA,CAAQyG,IAAA,CAAKjG,CAAA,IAAK,IAAIgK,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAO0G,IAAA,CAAKjG,CAAA,EAAG07C,GAAA,KAAQ,GAAGn8C,CAAA,CAAO0G,IAAA,CAAKjG,CAAA,EAAG27C,IAAA,KAAS,GAAGxB,QAAA,GACtG;YAAA;YACA,IAAI56C,CAAA,CAAO2G,OAAA,EAAS;cAChB,KAAKX,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAO2G,OAAA,GACtB,MAAMob,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQ0G,OAAA,GAAU,IACTlG,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAO2G,OAAA,CAAQ7E,MAAA,IAAUrB,CAAA,EACR,mBAAtBT,CAAA,CAAO2G,OAAA,CAAQlG,CAAA,IACtBgK,CAAA,CAAM67C,MAAA,CAAOn3C,MAAA,CAAOnP,CAAA,CAAO2G,OAAA,CAAQlG,CAAA,GAAIR,CAAA,CAAQ0G,OAAA,CAAQlG,CAAA,IAAKgK,CAAA,CAAMs6C,SAAA,CAAUt6C,CAAA,CAAM67C,MAAA,CAAOxkD,MAAA,CAAO9B,CAAA,CAAO2G,OAAA,CAAQlG,CAAA,KAAM,KAChHT,CAAA,CAAO2G,OAAA,CAAQlG,CAAA,EAAGqB,MAAA,IAAU,MACjC7B,CAAA,CAAQ0G,OAAA,CAAQlG,CAAA,IAAKT,CAAA,CAAO2G,OAAA,CAAQlG,CAAA,EAChD;YAAA;YACA,IAAIT,CAAA,CAAO4G,OAAA,EAAS;cAChB,KAAKZ,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAO4G,OAAA,GACtB,MAAMmb,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQ2G,OAAA,GAAU,IACTnG,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAO4G,OAAA,CAAQ9E,MAAA,IAAUrB,CAAA,EAAG;gBAC5C,IAAiC,mBAAtBT,CAAA,CAAO4G,OAAA,CAAQnG,CAAA,GACtB,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQ2G,OAAA,CAAQnG,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYkM,UAAA,CAAWnmD,CAAA,CAAO4G,OAAA,CAAQnG,CAAA,EAC1E;cAAA;YACJ;YACA,IAAIT,CAAA,CAAO6G,MAAA,EAAQ;cACf,KAAKb,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAO6G,MAAA,GACtB,MAAMkb,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQ4G,MAAA,GAAS,IACRpG,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAO6G,MAAA,CAAO/E,MAAA,IAAUrB,CAAA,EAAG;gBAC3C,IAAgC,mBAArBT,CAAA,CAAO6G,MAAA,CAAOpG,CAAA,GACrB,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQ4G,MAAA,CAAOpG,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAW8pB,UAAA,CAAWnmD,CAAA,CAAO6G,MAAA,CAAOpG,CAAA,EACvE;cAAA;YACJ;YACA,IAAIT,CAAA,CAAO2kD,aAAA,EAAe;cACtB,KAAK3+C,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAO2kD,aAAA,GACtB,MAAM5iC,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQ0kD,aAAA,GAAgB,IACflkD,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAO2kD,aAAA,CAAc7iD,MAAA,IAAUrB,CAAA,EAAG;gBAClD,IAAuC,mBAA5BT,CAAA,CAAO2kD,aAAA,CAAclkD,CAAA,GAC5B,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQ0kD,aAAA,CAAclkD,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAK8hD,iBAAA,CAAkBQ,UAAA,CAAWnmD,CAAA,CAAO2kD,aAAA,CAAclkD,CAAA,EAC5F;cAAA;YACJ;YACA,IAAIT,CAAA,CAAO4kD,UAAA,EAAY;cACnB,KAAK5+C,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAO4kD,UAAA,GACtB,MAAM7iC,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQ2kD,UAAA,GAAa,IACZnkD,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAO4kD,UAAA,CAAW9iD,MAAA,IAAUrB,CAAA,EAAG;gBAC/C,IAAoC,mBAAzBT,CAAA,CAAO4kD,UAAA,CAAWnkD,CAAA,GACzB,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQ2kD,UAAA,CAAWnkD,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUU,UAAA,CAAWnmD,CAAA,CAAO4kD,UAAA,CAAWnkD,CAAA,EAC9E;cAAA;YACJ;YACA,OAAOR,CACX;UAAA,GAWAD,CAAA,CAAeumD,QAAA,GAAW,UAAkBvmD,CAAA,EAASC,CAAA;YAC5CA,CAAA,KACDA,CAAA,GAAU,CAAC;YACf,IAAIQ,CAAA,GAAS,CAAC;YAUd,KATIR,CAAA,CAAQumD,MAAA,IAAUvmD,CAAA,CAAQwmD,QAAA,MAC1BhmD,CAAA,CAAOgG,MAAA,GAAS,IAChBhG,CAAA,CAAOiG,IAAA,GAAO,IACdjG,CAAA,CAAOkG,OAAA,GAAU,IACjBlG,CAAA,CAAOmG,OAAA,GAAU,IACjBnG,CAAA,CAAOoG,MAAA,GAAS,IAChBpG,CAAA,CAAOmkD,UAAA,GAAa,IACpBnkD,CAAA,CAAOkkD,aAAA,GAAgB,KAEvB1kD,CAAA,CAAQwmD,QAAA,EAAU;cAGlB,IAFAhmD,CAAA,CAAOuD,IAAA,GAAO,IACdvD,CAAA,CAAO8F,CAAA,GAAI,GACPkE,CAAA,CAAMwxC,IAAA,EAAM;gBACZ,IAAIz7C,CAAA,GAAO,IAAIiK,CAAA,CAAMwxC,IAAA,CAAK,GAAG,IAAG;gBAChCx7C,CAAA,CAAOQ,CAAA,GAAIhB,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS5lD,CAAA,CAAK+1B,QAAA,KAAat2B,CAAA,CAAQymD,KAAA,KAAUhlD,MAAA,GAASlB,CAAA,CAAKo6C,QAAA,KAAap6C,CACzG;cAAA,OACIC,CAAA,CAAOQ,CAAA,GAAIhB,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS,MAAM;cAC5CnmD,CAAA,CAAQgrC,KAAA,KAAUmb,MAAA,GAClB3lD,CAAA,CAAO6C,CAAA,GAAI,MAEX7C,CAAA,CAAO6C,CAAA,GAAI,IACPrD,CAAA,CAAQgrC,KAAA,KAAUjlC,KAAA,KAClBvF,CAAA,CAAO6C,CAAA,GAAImH,CAAA,CAAMs6C,SAAA,CAAUtkD,CAAA,CAAO6C,CAAA,KAE1C7C,CAAA,CAAOR,CAAA,GAAI,MACXQ,CAAA,CAAO+F,CAAA,GAAI,MACX/F,CAAA,CAAOiqC,SAAA,GAAY,IACnBjqC,CAAA,CAAOwkD,EAAA,GAAK,MACZxkD,CAAA,CAAOuE,IAAA,GAAO/E,CAAA,CAAQ0mD,KAAA,KAAUP,MAAA,GAAS,cAAc,GACvD3lD,CAAA,CAAOqkD,WAAA,GAAc,IACrBrkD,CAAA,CAAOukD,YAAA,GAAe,IAC1B;YAAA;YAgBA,IAfoB,QAAhBhlD,CAAA,CAAQgE,IAAA,IAAgBhE,CAAA,CAAQmlB,cAAA,CAAe,YAC/C1kB,CAAA,CAAOuD,IAAA,GAAOhE,CAAA,CAAQgE,IAAA,GACT,QAAbhE,CAAA,CAAQuG,CAAA,IAAavG,CAAA,CAAQmlB,cAAA,CAAe,SAC5C1kB,CAAA,CAAO8F,CAAA,GAAItG,CAAA,CAAQ2mD,IAAA,KAASC,QAAA,CAAS7mD,CAAA,CAAQuG,CAAA,IAAK6/C,MAAA,CAAOpmD,CAAA,CAAQuG,CAAA,IAAKvG,CAAA,CAAQuG,CAAA,GACjE,QAAbvG,CAAA,CAAQiB,CAAA,IAAajB,CAAA,CAAQmlB,cAAA,CAAe,SACnB,mBAAdnlB,CAAA,CAAQiB,CAAA,GACfR,CAAA,CAAOQ,CAAA,GAAIhB,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAASA,MAAA,CAAOpmD,CAAA,CAAQiB,CAAA,IAAKjB,CAAA,CAAQiB,CAAA,GAElER,CAAA,CAAOQ,CAAA,GAAIhB,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS37C,CAAA,CAAMwxC,IAAA,CAAK4I,SAAA,CAAUtuB,QAAA,CAASnR,IAAA,CAAKplB,CAAA,CAAQiB,CAAA,IAAKhB,CAAA,CAAQymD,KAAA,KAAUhlD,MAAA,GAAS,IAAI+I,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAQiB,CAAA,CAAEk7C,GAAA,KAAQ,GAAGn8C,CAAA,CAAQiB,CAAA,CAAEm7C,IAAA,KAAS,GAAGxB,QAAA,KAAa56C,CAAA,CAAQiB,CAAA,GAC3L,QAAbjB,CAAA,CAAQsD,CAAA,IAAatD,CAAA,CAAQmlB,cAAA,CAAe,SAC5C1kB,CAAA,CAAO6C,CAAA,GAAIrD,CAAA,CAAQgrC,KAAA,KAAUmb,MAAA,GAAS37C,CAAA,CAAM67C,MAAA,CAAOp3C,MAAA,CAAOlP,CAAA,CAAQsD,CAAA,EAAG,GAAGtD,CAAA,CAAQsD,CAAA,CAAExB,MAAA,IAAU7B,CAAA,CAAQgrC,KAAA,KAAUjlC,KAAA,GAAQA,KAAA,CAAM6+C,SAAA,CAAU33C,KAAA,CAAMkY,IAAA,CAAKplB,CAAA,CAAQsD,CAAA,IAAKtD,CAAA,CAAQsD,CAAA,GACzJ,QAAbtD,CAAA,CAAQC,CAAA,IAAaD,CAAA,CAAQmlB,cAAA,CAAe,SAC5C1kB,CAAA,CAAOR,CAAA,GAAIoL,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYsM,QAAA,CAASvmD,CAAA,CAAQC,CAAA,EAAGA,CAAA,IACzC,QAAbD,CAAA,CAAQwG,CAAA,IAAaxG,CAAA,CAAQmlB,cAAA,CAAe,SAC5C1kB,CAAA,CAAO+F,CAAA,GAAI6E,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAWkqB,QAAA,CAASvmD,CAAA,CAAQwG,CAAA,EAAGvG,CAAA,IACrDD,CAAA,CAAQyG,MAAA,IAAUzG,CAAA,CAAQyG,MAAA,CAAO3E,MAAA,EAAQ;cACzCrB,CAAA,CAAOgG,MAAA,GAAS;cAChB,KAAK,IAAI/F,CAAA,GAAI,GAAGA,CAAA,GAAIV,CAAA,CAAQyG,MAAA,CAAO3E,MAAA,IAAUpB,CAAA,EACzCD,CAAA,CAAOgG,MAAA,CAAO/F,CAAA,IAAKT,CAAA,CAAQ2mD,IAAA,KAASC,QAAA,CAAS7mD,CAAA,CAAQyG,MAAA,CAAO/F,CAAA,KAAM0lD,MAAA,CAAOpmD,CAAA,CAAQyG,MAAA,CAAO/F,CAAA,KAAMV,CAAA,CAAQyG,MAAA,CAAO/F,CAAA,CACrH;YAAA;YACA,IAAIV,CAAA,CAAQ0G,IAAA,IAAQ1G,CAAA,CAAQ0G,IAAA,CAAK5E,MAAA,EAE7B,KADArB,CAAA,CAAOiG,IAAA,GAAO,IACLhG,CAAA,GAAI,GAAGA,CAAA,GAAIV,CAAA,CAAQ0G,IAAA,CAAK5E,MAAA,IAAUpB,CAAA,EACR,mBAApBV,CAAA,CAAQ0G,IAAA,CAAKhG,CAAA,IACpBD,CAAA,CAAOiG,IAAA,CAAKhG,CAAA,IAAKT,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAASA,MAAA,CAAOpmD,CAAA,CAAQ0G,IAAA,CAAKhG,CAAA,KAAMV,CAAA,CAAQ0G,IAAA,CAAKhG,CAAA,IAEnFD,CAAA,CAAOiG,IAAA,CAAKhG,CAAA,IAAKT,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS37C,CAAA,CAAMwxC,IAAA,CAAK4I,SAAA,CAAUtuB,QAAA,CAASnR,IAAA,CAAKplB,CAAA,CAAQ0G,IAAA,CAAKhG,CAAA,KAAMT,CAAA,CAAQymD,KAAA,KAAUhlD,MAAA,GAAS,IAAI+I,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAQ0G,IAAA,CAAKhG,CAAA,EAAGy7C,GAAA,KAAQ,GAAGn8C,CAAA,CAAQ0G,IAAA,CAAKhG,CAAA,EAAG07C,IAAA,KAAS,GAAGxB,QAAA,KAAa56C,CAAA,CAAQ0G,IAAA,CAAKhG,CAAA;YAE7O,IAAIV,CAAA,CAAQ2G,OAAA,IAAW3G,CAAA,CAAQ2G,OAAA,CAAQ7E,MAAA,EAEnC,KADArB,CAAA,CAAOkG,OAAA,GAAU,IACRjG,CAAA,GAAI,GAAGA,CAAA,GAAIV,CAAA,CAAQ2G,OAAA,CAAQ7E,MAAA,IAAUpB,CAAA,EAC1CD,CAAA,CAAOkG,OAAA,CAAQjG,CAAA,IAAKT,CAAA,CAAQgrC,KAAA,KAAUmb,MAAA,GAAS37C,CAAA,CAAM67C,MAAA,CAAOp3C,MAAA,CAAOlP,CAAA,CAAQ2G,OAAA,CAAQjG,CAAA,GAAI,GAAGV,CAAA,CAAQ2G,OAAA,CAAQjG,CAAA,EAAGoB,MAAA,IAAU7B,CAAA,CAAQgrC,KAAA,KAAUjlC,KAAA,GAAQA,KAAA,CAAM6+C,SAAA,CAAU33C,KAAA,CAAMkY,IAAA,CAAKplB,CAAA,CAAQ2G,OAAA,CAAQjG,CAAA,KAAMV,CAAA,CAAQ2G,OAAA,CAAQjG,CAAA;YAE1N,IAAIV,CAAA,CAAQ4G,OAAA,IAAW5G,CAAA,CAAQ4G,OAAA,CAAQ9E,MAAA,EAEnC,KADArB,CAAA,CAAOmG,OAAA,GAAU,IACRlG,CAAA,GAAI,GAAGA,CAAA,GAAIV,CAAA,CAAQ4G,OAAA,CAAQ9E,MAAA,IAAUpB,CAAA,EAC1CD,CAAA,CAAOmG,OAAA,CAAQlG,CAAA,IAAK2K,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYsM,QAAA,CAASvmD,CAAA,CAAQ4G,OAAA,CAAQlG,CAAA,GAAIT,CAAA;YAEhF,IAAID,CAAA,CAAQ6G,MAAA,IAAU7G,CAAA,CAAQ6G,MAAA,CAAO/E,MAAA,EAEjC,KADArB,CAAA,CAAOoG,MAAA,GAAS,IACPnG,CAAA,GAAI,GAAGA,CAAA,GAAIV,CAAA,CAAQ6G,MAAA,CAAO/E,MAAA,IAAUpB,CAAA,EACzCD,CAAA,CAAOoG,MAAA,CAAOnG,CAAA,IAAK2K,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAWkqB,QAAA,CAASvmD,CAAA,CAAQ6G,MAAA,CAAOnG,CAAA,GAAIT,CAAA;YAM7E,IAJyB,QAArBD,CAAA,CAAQ0qC,SAAA,IAAqB1qC,CAAA,CAAQmlB,cAAA,CAAe,iBACpD1kB,CAAA,CAAOiqC,SAAA,GAAY1qC,CAAA,CAAQ0qC,SAAA,GACb,QAAd1qC,CAAA,CAAQilD,EAAA,IAAcjlD,CAAA,CAAQmlB,cAAA,CAAe,UAC7C1kB,CAAA,CAAOwkD,EAAA,GAAK55C,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUc,QAAA,CAASvmD,CAAA,CAAQilD,EAAA,EAAIhlD,CAAA,IACtDD,CAAA,CAAQ4kD,UAAA,IAAc5kD,CAAA,CAAQ4kD,UAAA,CAAW9iD,MAAA,EAEzC,KADArB,CAAA,CAAOmkD,UAAA,GAAa,IACXlkD,CAAA,GAAI,GAAGA,CAAA,GAAIV,CAAA,CAAQ4kD,UAAA,CAAW9iD,MAAA,IAAUpB,CAAA,EAC7CD,CAAA,CAAOmkD,UAAA,CAAWlkD,CAAA,IAAK2K,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUc,QAAA,CAASvmD,CAAA,CAAQ4kD,UAAA,CAAWlkD,CAAA,GAAIT,CAAA;YAQpF,IANoB,QAAhBD,CAAA,CAAQgF,IAAA,IAAgBhF,CAAA,CAAQmlB,cAAA,CAAe,YAC/C1kB,CAAA,CAAOuE,IAAA,GAAO/E,CAAA,CAAQ0mD,KAAA,KAAUP,MAAA,QAAmE,MAA1D/6C,CAAA,CAAMxH,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcjF,CAAA,CAAQgF,IAAA,IAAsBhF,CAAA,CAAQgF,IAAA,GAAOqG,CAAA,CAAMxH,IAAA,CAAKC,cAAA,CAAemB,aAAA,CAAcjF,CAAA,CAAQgF,IAAA,IAAQhF,CAAA,CAAQgF,IAAA,GACvK,QAAvBhF,CAAA,CAAQ8kD,WAAA,IAAuB9kD,CAAA,CAAQmlB,cAAA,CAAe,mBACtD1kB,CAAA,CAAOqkD,WAAA,GAAc9kD,CAAA,CAAQ8kD,WAAA,GACL,QAAxB9kD,CAAA,CAAQglD,YAAA,IAAwBhlD,CAAA,CAAQmlB,cAAA,CAAe,oBACvD1kB,CAAA,CAAOukD,YAAA,GAAe35C,CAAA,CAAMxH,IAAA,CAAK8hD,iBAAA,CAAkBY,QAAA,CAASvmD,CAAA,CAAQglD,YAAA,EAAc/kD,CAAA,IAClFD,CAAA,CAAQ2kD,aAAA,IAAiB3kD,CAAA,CAAQ2kD,aAAA,CAAc7iD,MAAA,EAE/C,KADArB,CAAA,CAAOkkD,aAAA,GAAgB,IACdjkD,CAAA,GAAI,GAAGA,CAAA,GAAIV,CAAA,CAAQ2kD,aAAA,CAAc7iD,MAAA,IAAUpB,CAAA,EAChDD,CAAA,CAAOkkD,aAAA,CAAcjkD,CAAA,IAAK2K,CAAA,CAAMxH,IAAA,CAAK8hD,iBAAA,CAAkBY,QAAA,CAASvmD,CAAA,CAAQ2kD,aAAA,CAAcjkD,CAAA,GAAIT,CAAA;YAElG,OAAOQ,CACX;UAAA,GASAT,CAAA,CAAe6kD,SAAA,CAAUiC,MAAA,GAAS;YAC9B,OAAO,KAAKlkD,WAAA,CAAY2jD,QAAA,CAAS,MAAMrlD,CAAA,CAAUsjD,IAAA,CAAKuC,aAAA,CAC1D;UAAA,GAUA/mD,CAAA,CAAegnD,UAAA,GAAa,UAAoBhnD,CAAA;YAI5C,YAHsB,MAAlBA,CAAA,KACAA,CAAA,GAAgB,wBAEbA,CAAA,GAAgB,sBAC3B;UAAA,GAsBAA,CAAA,CAAeiF,aAAA,GAAgB;YAC3B,IAAIjF,CAAA,GAAa,CAAC;cAAGC,CAAA,GAAS4C,MAAA,CAAO48B,MAAA,CAAOz/B,CAAA;YAgB5C,OAfAC,CAAA,CAAOD,CAAA,CAAW,KAAK,eAAe,GACtCC,CAAA,CAAOD,CAAA,CAAW,KAAK,WAAW,GAClCC,CAAA,CAAOD,CAAA,CAAW,KAAK,SAAS,GAChCC,CAAA,CAAOD,CAAA,CAAW,KAAK,YAAY,GACnCC,CAAA,CAAOD,CAAA,CAAW,KAAK,YAAY,GACnCC,CAAA,CAAOD,CAAA,CAAW,KAAK,WAAW,GAClCC,CAAA,CAAOD,CAAA,CAAW,MAAM,mBAAmB,IAC3CC,CAAA,CAAOD,CAAA,CAAW,MAAM,gBAAgB,IACxCC,CAAA,CAAOD,CAAA,CAAW,KAAK,YAAY,GACnCC,CAAA,CAAOD,CAAA,CAAW,KAAK,UAAU,GACjCC,CAAA,CAAOD,CAAA,CAAW,KAAK,aAAa,GACpCC,CAAA,CAAOD,CAAA,CAAW,KAAK,aAAa,GACpCC,CAAA,CAAOD,CAAA,CAAW,MAAM,YAAY,IACpCC,CAAA,CAAOD,CAAA,CAAW,MAAM,oBAAoB,IAC5CC,CAAA,CAAOD,CAAA,CAAW,MAAM,iBAAiB,IAClCC,CACV;UAAA,CAlB8B,IAoBxBD,CACV;QAAA,CA35BqB,IA65BtBiB,CAAA,CAAKgmD,cAAA,GAAiB;UAmBlB,SAASjnD,EAAeA,CAAA;YACpB,IAAIA,CAAA,EACA,KAAK,IAAIC,CAAA,GAAO4C,MAAA,CAAO6N,IAAA,CAAK1Q,CAAA,GAAaS,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK6B,MAAA,IAAUrB,CAAA,EACpC,QAAvBT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,OAChB,KAAKR,CAAA,CAAKQ,CAAA,KAAMT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,GAChD;UAAA;UAoOA,OA5NAT,CAAA,CAAe6kD,SAAA,CAAU7gD,IAAA,GAAO,IAQhChE,CAAA,CAAe6kD,SAAA,CAAU7/C,IAAA,GAAO,MAQhChF,CAAA,CAAe6kD,SAAA,CAAUna,SAAA,GAAY,IAUrC1qC,CAAA,CAAey/B,MAAA,GAAS,UAAgBx/B,CAAA;YACpC,OAAO,IAAID,CAAA,CAAeC,CAAA,CAC9B;UAAA,GAWAD,CAAA,CAAekP,MAAA,GAAS,UAAgBlP,CAAA,EAASC,CAAA;YAS7C,OARKA,CAAA,KACDA,CAAA,GAASyD,CAAA,CAAQ+7B,MAAA,KACD,QAAhBz/B,CAAA,CAAQgE,IAAA,IAAgBnB,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,WAC5DC,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQgE,IAAA,GACxC,QAAhBhE,CAAA,CAAQgF,IAAA,IAAgBnC,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,WAC5DqL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUv2C,MAAA,CAAOlP,CAAA,CAAQgF,IAAA,EAAM/E,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA,IACtE,QAArBxlD,CAAA,CAAQ0qC,SAAA,IAAqB7nC,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,gBACjEC,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQ0qC,SAAA,GACrDzqC,CACX;UAAA,GAWAD,CAAA,CAAe4lD,eAAA,GAAkB,UAAyB5lD,CAAA,EAASC,CAAA;YAC/D,OAAO,KAAKiP,MAAA,CAAOlP,CAAA,EAASC,CAAA,EAAQulD,MAAA,EACxC;UAAA,GAaAxlD,CAAA,CAAemP,MAAA,GAAS,UAAgBnP,CAAA,EAAQC,CAAA;YACtCD,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAASsD,CAAA,CAAQm8B,MAAA,CAAOz/B,CAAA;YAE5B,KADA,IAAIS,CAAA,QAAiB,MAAXR,CAAA,GAAuBD,CAAA,CAAO6lD,GAAA,GAAM7lD,CAAA,CAAO8lD,GAAA,GAAM7lD,CAAA,EAAQO,CAAA,GAAU,IAAI6K,CAAA,CAAMxH,IAAA,CAAKojD,cAAA,IACrFjnD,CAAA,CAAO8lD,GAAA,GAAMrlD,CAAA,GAAK;cACrB,IAAIC,CAAA,GAAMV,CAAA,CAAOmlD,MAAA;cACjB,QAAQzkD,CAAA,KAAQ;gBAChB,KAAK;kBACGF,CAAA,CAAQwD,IAAA,GAAOhE,CAAA,CAAOolD,MAAA;kBACtB;gBAER,KAAK;kBACG5kD,CAAA,CAAQwE,IAAA,GAAOqG,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUt2C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBAC1D;gBAER,KAAK;kBACG3kD,CAAA,CAAQkqC,SAAA,GAAY1qC,CAAA,CAAOolD,MAAA;kBAC3B;gBAER;kBACIplD,CAAA,CAAO+lD,QAAA,CAAe,IAANrlD,CAAA;cAAA;YAGxB;YACA,OAAOF,CACX;UAAA,GAYAR,CAAA,CAAegmD,eAAA,GAAkB,UAAyBhmD,CAAA;YAGtD,OAFMA,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAAS,IAAIsD,CAAA,CAAQtD,CAAA,IAClB,KAAKmP,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,GACtC;UAAA,GAUAnlD,CAAA,CAAeimD,MAAA,GAAS,UAAgBjmD,CAAA;YACpC,IAAuB,mBAAZA,CAAA,IAAoC,SAAZA,CAAA,EAC/B,OAAO;YACX,IAAoB,QAAhBA,CAAA,CAAQgE,IAAA,IAAgBhE,CAAA,CAAQmlB,cAAA,CAAe,YAC1C1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQgE,IAAA,GACxB,OAAO;YACf,IAAoB,QAAhBhE,CAAA,CAAQgF,IAAA,IAAgBhF,CAAA,CAAQmlB,cAAA,CAAe,SAAS;cACxD,IAAIllB,CAAA,GAAQoL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUQ,MAAA,CAAOjmD,CAAA,CAAQgF,IAAA;cAChD,IAAI/E,CAAA,EACA,OAAO,UAAUA,CACzB;YAAA;YACA,OAAyB,QAArBD,CAAA,CAAQ0qC,SAAA,IAAqB1qC,CAAA,CAAQmlB,cAAA,CAAe,iBAC/C1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQ0qC,SAAA,IACjB,+BACR,IACX;UAAA,GAUA1qC,CAAA,CAAemmD,UAAA,GAAa,UAAoBnmD,CAAA;YAC5C,IAAIA,CAAA,YAAkBqL,CAAA,CAAMxH,IAAA,CAAKojD,cAAA,EAC7B,OAAOjnD,CAAA;YACX,IAAIC,CAAA,GAAU,IAAIoL,CAAA,CAAMxH,IAAA,CAAKojD,cAAA;YAG7B,IAFmB,QAAfjnD,CAAA,CAAOgE,IAAA,KACP/D,CAAA,CAAQ+D,IAAA,GAAOoiD,MAAA,CAAOpmD,CAAA,CAAOgE,IAAA,IACd,QAAfhE,CAAA,CAAOgF,IAAA,EAAc;cACrB,IAA2B,mBAAhBhF,CAAA,CAAOgF,IAAA,EACd,MAAM+c,SAAA,CAAU;cACpB9hB,CAAA,CAAQ+E,IAAA,GAAOqG,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUU,UAAA,CAAWnmD,CAAA,CAAOgF,IAAA,CAC1D;YAAA;YAGA,OAFwB,QAApBhF,CAAA,CAAO0qC,SAAA,KACPzqC,CAAA,CAAQyqC,SAAA,GAAY0b,MAAA,CAAOpmD,CAAA,CAAO0qC,SAAA,IAC/BzqC,CACX;UAAA,GAWAD,CAAA,CAAeumD,QAAA,GAAW,UAAkBvmD,CAAA,EAASC,CAAA;YAC5CA,CAAA,KACDA,CAAA,GAAU,CAAC;YACf,IAAIQ,CAAA,GAAS,CAAC;YAYd,OAXIR,CAAA,CAAQwmD,QAAA,KACRhmD,CAAA,CAAOuD,IAAA,GAAO,IACdvD,CAAA,CAAOuE,IAAA,GAAO,MACdvE,CAAA,CAAOiqC,SAAA,GAAY,KAEH,QAAhB1qC,CAAA,CAAQgE,IAAA,IAAgBhE,CAAA,CAAQmlB,cAAA,CAAe,YAC/C1kB,CAAA,CAAOuD,IAAA,GAAOhE,CAAA,CAAQgE,IAAA,GACN,QAAhBhE,CAAA,CAAQgF,IAAA,IAAgBhF,CAAA,CAAQmlB,cAAA,CAAe,YAC/C1kB,CAAA,CAAOuE,IAAA,GAAOqG,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUc,QAAA,CAASvmD,CAAA,CAAQgF,IAAA,EAAM/E,CAAA,IACrC,QAArBD,CAAA,CAAQ0qC,SAAA,IAAqB1qC,CAAA,CAAQmlB,cAAA,CAAe,iBACpD1kB,CAAA,CAAOiqC,SAAA,GAAY1qC,CAAA,CAAQ0qC,SAAA,GACxBjqC,CACX;UAAA,GASAT,CAAA,CAAe6kD,SAAA,CAAUiC,MAAA,GAAS;YAC9B,OAAO,KAAKlkD,WAAA,CAAY2jD,QAAA,CAAS,MAAMrlD,CAAA,CAAUsjD,IAAA,CAAKuC,aAAA,CAC1D;UAAA,GAUA/mD,CAAA,CAAegnD,UAAA,GAAa,UAAoBhnD,CAAA;YAI5C,YAHsB,MAAlBA,CAAA,KACAA,CAAA,GAAgB,wBAEbA,CAAA,GAAgB,sBAC3B;UAAA,GAEOA,CACV;QAAA,CA7PqB,IA+PtBiB,CAAA,CAAKo6B,SAAA,GAAY;UAuBb,SAASr7B,EAAUA,CAAA;YAIf,IAHA,KAAKw8B,KAAA,GAAQ,IACb,KAAK1yB,MAAA,GAAS,IACd,KAAKsI,SAAA,GAAY,IACbpS,CAAA,EACA,KAAK,IAAIC,CAAA,GAAO4C,MAAA,CAAO6N,IAAA,CAAK1Q,CAAA,GAAaS,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK6B,MAAA,IAAUrB,CAAA,EACpC,QAAvBT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,OAChB,KAAKR,CAAA,CAAKQ,CAAA,KAAMT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,GAChD;UAAA;UA2WA,OAnWAT,CAAA,CAAU6kD,SAAA,CAAUroB,KAAA,GAAQ/xB,CAAA,CAAMy6C,UAAA,EAQlCllD,CAAA,CAAU6kD,SAAA,CAAU/6C,MAAA,GAASW,CAAA,CAAMy6C,UAAA,EAQnCllD,CAAA,CAAU6kD,SAAA,CAAU7gD,IAAA,GAAO,IAQ3BhE,CAAA,CAAU6kD,SAAA,CAAUvpB,MAAA,GAAS,IAQ7Bt7B,CAAA,CAAU6kD,SAAA,CAAUvjB,MAAA,GAAS,IAQ7BthC,CAAA,CAAU6kD,SAAA,CAAUzyC,SAAA,GAAY3H,CAAA,CAAMy6C,UAAA,EAQtCllD,CAAA,CAAU6kD,SAAA,CAAUna,SAAA,GAAY,IAUhC1qC,CAAA,CAAUy/B,MAAA,GAAS,UAAgBx/B,CAAA;YAC/B,OAAO,IAAID,CAAA,CAAUC,CAAA,CACzB;UAAA,GAWAD,CAAA,CAAUkP,MAAA,GAAS,UAAgBlP,CAAA,EAASC,CAAA;YAGxC,IAFKA,CAAA,KACDA,CAAA,GAASyD,CAAA,CAAQ+7B,MAAA,KACA,QAAjBz/B,CAAA,CAAQw8B,KAAA,IAAiBx8B,CAAA,CAAQw8B,KAAA,CAAM16B,MAAA,EACvC,KAAK,IAAIrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQw8B,KAAA,CAAM16B,MAAA,IAAUrB,CAAA,EACxCR,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQw8B,KAAA,CAAM/7B,CAAA;YACtE,IAAsB,QAAlBT,CAAA,CAAQ8J,MAAA,IAAkB9J,CAAA,CAAQ8J,MAAA,CAAOhI,MAAA,EACzC,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQ8J,MAAA,CAAOhI,MAAA,IAAUrB,CAAA,EACzCR,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQ8J,MAAA,CAAOrJ,CAAA;YAKvE,IAJoB,QAAhBT,CAAA,CAAQgE,IAAA,IAAgBnB,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,WAC5DC,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQgE,IAAA,GACtC,QAAlBhE,CAAA,CAAQs7B,MAAA,IAAkBz4B,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,aAC9DC,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQs7B,MAAA,GACnC,QAArBt7B,CAAA,CAAQoS,SAAA,IAAqBpS,CAAA,CAAQoS,SAAA,CAAUtQ,MAAA,EAC/C,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQoS,SAAA,CAAUtQ,MAAA,IAAUrB,CAAA,EAC5C4K,CAAA,CAAMxH,IAAA,CAAKC,cAAA,CAAeoL,MAAA,CAAOlP,CAAA,CAAQoS,SAAA,CAAU3R,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA;YAKhH,OAJyB,QAArBxlD,CAAA,CAAQ0qC,SAAA,IAAqB7nC,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,gBACjEC,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQ0qC,SAAA,GACtC,QAAlB1qC,CAAA,CAAQshC,MAAA,IAAkBz+B,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,aAC9DC,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQshC,MAAA,GACrDrhC,CACX;UAAA,GAWAD,CAAA,CAAU4lD,eAAA,GAAkB,UAAyB5lD,CAAA,EAASC,CAAA;YAC1D,OAAO,KAAKiP,MAAA,CAAOlP,CAAA,EAASC,CAAA,EAAQulD,MAAA,EACxC;UAAA,GAaAxlD,CAAA,CAAUmP,MAAA,GAAS,UAAgBnP,CAAA,EAAQC,CAAA;YACjCD,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAASsD,CAAA,CAAQm8B,MAAA,CAAOz/B,CAAA;YAE5B,KADA,IAAIS,CAAA,QAAiB,MAAXR,CAAA,GAAuBD,CAAA,CAAO6lD,GAAA,GAAM7lD,CAAA,CAAO8lD,GAAA,GAAM7lD,CAAA,EAAQO,CAAA,GAAU,IAAI6K,CAAA,CAAMxH,IAAA,CAAKw3B,SAAA,IACrFr7B,CAAA,CAAO8lD,GAAA,GAAMrlD,CAAA,GAAK;cACrB,IAAIC,CAAA,GAAMV,CAAA,CAAOmlD,MAAA;cACjB,QAAQzkD,CAAA,KAAQ;gBAChB,KAAK;kBACSF,CAAA,CAAQg8B,KAAA,IAASh8B,CAAA,CAAQg8B,KAAA,CAAM16B,MAAA,KACjCtB,CAAA,CAAQg8B,KAAA,GAAQ,KACpBh8B,CAAA,CAAQg8B,KAAA,CAAMx1B,IAAA,CAAKhH,CAAA,CAAOolD,MAAA;kBAC1B;gBAER,KAAK;kBACS5kD,CAAA,CAAQsJ,MAAA,IAAUtJ,CAAA,CAAQsJ,MAAA,CAAOhI,MAAA,KACnCtB,CAAA,CAAQsJ,MAAA,GAAS,KACrBtJ,CAAA,CAAQsJ,MAAA,CAAO9C,IAAA,CAAKhH,CAAA,CAAOolD,MAAA;kBAC3B;gBAER,KAAK;kBACG5kD,CAAA,CAAQwD,IAAA,GAAOhE,CAAA,CAAOolD,MAAA;kBACtB;gBAER,KAAK;kBACG5kD,CAAA,CAAQ86B,MAAA,GAASt7B,CAAA,CAAOolD,MAAA;kBACxB;gBAER,KAAK;kBACG5kD,CAAA,CAAQ8gC,MAAA,GAASthC,CAAA,CAAOolD,MAAA;kBACxB;gBAER,KAAK;kBACS5kD,CAAA,CAAQ4R,SAAA,IAAa5R,CAAA,CAAQ4R,SAAA,CAAUtQ,MAAA,KACzCtB,CAAA,CAAQ4R,SAAA,GAAY,KACxB5R,CAAA,CAAQ4R,SAAA,CAAUpL,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAKC,cAAA,CAAeqL,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBACvE;gBAER,KAAK;kBACG3kD,CAAA,CAAQkqC,SAAA,GAAY1qC,CAAA,CAAOolD,MAAA;kBAC3B;gBAER;kBACIplD,CAAA,CAAO+lD,QAAA,CAAe,IAANrlD,CAAA;cAAA;YAGxB;YACA,OAAOF,CACX;UAAA,GAYAR,CAAA,CAAUgmD,eAAA,GAAkB,UAAyBhmD,CAAA;YAGjD,OAFMA,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAAS,IAAIsD,CAAA,CAAQtD,CAAA,IAClB,KAAKmP,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,GACtC;UAAA,GAUAnlD,CAAA,CAAUimD,MAAA,GAAS,UAAgBjmD,CAAA;YAC/B,IAAuB,mBAAZA,CAAA,IAAoC,SAAZA,CAAA,EAC/B,OAAO;YACX,IAAqB,QAAjBA,CAAA,CAAQw8B,KAAA,IAAiBx8B,CAAA,CAAQmlB,cAAA,CAAe,UAAU;cAC1D,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQw8B,KAAA,GACvB,OAAO;cACX,KAAK,IAAIv8B,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQw8B,KAAA,CAAM16B,MAAA,IAAU7B,CAAA,EACxC,KAAKwK,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQw8B,KAAA,CAAMv8B,CAAA,IAC9B,OAAO,0BACnB;YAAA;YACA,IAAsB,QAAlBD,CAAA,CAAQ8J,MAAA,IAAkB9J,CAAA,CAAQmlB,cAAA,CAAe,WAAW;cAC5D,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQ8J,MAAA,GACvB,OAAO;cACX,KAAS7J,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQ8J,MAAA,CAAOhI,MAAA,IAAU7B,CAAA,EACzC,KAAKwK,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQ8J,MAAA,CAAO7J,CAAA,IAC/B,OAAO,2BACnB;YAAA;YACA,IAAoB,QAAhBD,CAAA,CAAQgE,IAAA,IAAgBhE,CAAA,CAAQmlB,cAAA,CAAe,YAC1C1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQgE,IAAA,GACxB,OAAO;YACf,IAAsB,QAAlBhE,CAAA,CAAQs7B,MAAA,IAAkBt7B,CAAA,CAAQmlB,cAAA,CAAe,cAC5C1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQs7B,MAAA,GACxB,OAAO;YACf,IAAsB,QAAlBt7B,CAAA,CAAQshC,MAAA,IAAkBthC,CAAA,CAAQmlB,cAAA,CAAe,cAC5C1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQshC,MAAA,GACxB,OAAO;YACf,IAAyB,QAArBthC,CAAA,CAAQoS,SAAA,IAAqBpS,CAAA,CAAQmlB,cAAA,CAAe,cAAc;cAClE,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQoS,SAAA,GACvB,OAAO;cACX,KAASnS,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQoS,SAAA,CAAUtQ,MAAA,IAAU7B,CAAA,EAAG;gBAC/C,IAAIQ,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAKC,cAAA,CAAemiD,MAAA,CAAOjmD,CAAA,CAAQoS,SAAA,CAAUnS,CAAA;gBAC/D,IAAIQ,CAAA,EACA,OAAO,eAAeA,CAC9B;cAAA;YACJ;YACA,OAAyB,QAArBT,CAAA,CAAQ0qC,SAAA,IAAqB1qC,CAAA,CAAQmlB,cAAA,CAAe,iBAC/C1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQ0qC,SAAA,IACjB,+BACR,IACX;UAAA,GAUA1qC,CAAA,CAAUmmD,UAAA,GAAa,UAAoBnmD,CAAA;YACvC,IAAIA,CAAA,YAAkBqL,CAAA,CAAMxH,IAAA,CAAKw3B,SAAA,EAC7B,OAAOr7B,CAAA;YACX,IAAIC,CAAA,GAAU,IAAIoL,CAAA,CAAMxH,IAAA,CAAKw3B,SAAA;YAC7B,IAAIr7B,CAAA,CAAOw8B,KAAA,EAAO;cACd,KAAKx2B,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOw8B,KAAA,GACtB,MAAMza,SAAA,CAAU;cACpB9hB,CAAA,CAAQu8B,KAAA,GAAQ;cAChB,KAAK,IAAI/7B,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOw8B,KAAA,CAAM16B,MAAA,IAAUrB,CAAA,EACvCR,CAAA,CAAQu8B,KAAA,CAAM/7B,CAAA,IAAK2lD,MAAA,CAAOpmD,CAAA,CAAOw8B,KAAA,CAAM/7B,CAAA,EAC/C;YAAA;YACA,IAAIT,CAAA,CAAO8J,MAAA,EAAQ;cACf,KAAK9D,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAO8J,MAAA,GACtB,MAAMiY,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQ6J,MAAA,GAAS,IACRrJ,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAO8J,MAAA,CAAOhI,MAAA,IAAUrB,CAAA,EACxCR,CAAA,CAAQ6J,MAAA,CAAOrJ,CAAA,IAAK2lD,MAAA,CAAOpmD,CAAA,CAAO8J,MAAA,CAAOrJ,CAAA,EACjD;YAAA;YAOA,IANmB,QAAfT,CAAA,CAAOgE,IAAA,KACP/D,CAAA,CAAQ+D,IAAA,GAAOoiD,MAAA,CAAOpmD,CAAA,CAAOgE,IAAA,IACZ,QAAjBhE,CAAA,CAAOs7B,MAAA,KACPr7B,CAAA,CAAQq7B,MAAA,GAAS8qB,MAAA,CAAOpmD,CAAA,CAAOs7B,MAAA,IACd,QAAjBt7B,CAAA,CAAOshC,MAAA,KACPrhC,CAAA,CAAQqhC,MAAA,GAAS8kB,MAAA,CAAOpmD,CAAA,CAAOshC,MAAA,IAC/BthC,CAAA,CAAOoS,SAAA,EAAW;cAClB,KAAKpM,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOoS,SAAA,GACtB,MAAM2P,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQmS,SAAA,GAAY,IACX3R,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOoS,SAAA,CAAUtQ,MAAA,IAAUrB,CAAA,EAAG;gBAC9C,IAAmC,mBAAxBT,CAAA,CAAOoS,SAAA,CAAU3R,CAAA,GACxB,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQmS,SAAA,CAAU3R,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAKC,cAAA,CAAeqiD,UAAA,CAAWnmD,CAAA,CAAOoS,SAAA,CAAU3R,CAAA,EACjF;cAAA;YACJ;YAGA,OAFwB,QAApBT,CAAA,CAAO0qC,SAAA,KACPzqC,CAAA,CAAQyqC,SAAA,GAAY0b,MAAA,CAAOpmD,CAAA,CAAO0qC,SAAA,IAC/BzqC,CACX;UAAA,GAWAD,CAAA,CAAUumD,QAAA,GAAW,UAAkBvmD,CAAA,EAASC,CAAA;YACvCA,CAAA,KACDA,CAAA,GAAU,CAAC;YACf,IAAIQ,CAAA,GAAS,CAAC;YAYd,KAXIR,CAAA,CAAQumD,MAAA,IAAUvmD,CAAA,CAAQwmD,QAAA,MAC1BhmD,CAAA,CAAO+7B,KAAA,GAAQ,IACf/7B,CAAA,CAAOqJ,MAAA,GAAS,IAChBrJ,CAAA,CAAO2R,SAAA,GAAY,KAEnBnS,CAAA,CAAQwmD,QAAA,KACRhmD,CAAA,CAAOuD,IAAA,GAAO,IACdvD,CAAA,CAAO66B,MAAA,GAAS,IAChB76B,CAAA,CAAOiqC,SAAA,GAAY,IACnBjqC,CAAA,CAAO6gC,MAAA,GAAS,KAEhBthC,CAAA,CAAQw8B,KAAA,IAASx8B,CAAA,CAAQw8B,KAAA,CAAM16B,MAAA,EAAQ;cACvCrB,CAAA,CAAO+7B,KAAA,GAAQ;cACf,KAAK,IAAIh8B,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQw8B,KAAA,CAAM16B,MAAA,IAAUtB,CAAA,EACxCC,CAAA,CAAO+7B,KAAA,CAAMh8B,CAAA,IAAKR,CAAA,CAAQw8B,KAAA,CAAMh8B,CAAA,CACxC;YAAA;YACA,IAAIR,CAAA,CAAQ8J,MAAA,IAAU9J,CAAA,CAAQ8J,MAAA,CAAOhI,MAAA,EAEjC,KADArB,CAAA,CAAOqJ,MAAA,GAAS,IACPtJ,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQ8J,MAAA,CAAOhI,MAAA,IAAUtB,CAAA,EACzCC,CAAA,CAAOqJ,MAAA,CAAOtJ,CAAA,IAAKR,CAAA,CAAQ8J,MAAA,CAAOtJ,CAAA;YAM1C,IAJoB,QAAhBR,CAAA,CAAQgE,IAAA,IAAgBhE,CAAA,CAAQmlB,cAAA,CAAe,YAC/C1kB,CAAA,CAAOuD,IAAA,GAAOhE,CAAA,CAAQgE,IAAA,GACJ,QAAlBhE,CAAA,CAAQs7B,MAAA,IAAkBt7B,CAAA,CAAQmlB,cAAA,CAAe,cACjD1kB,CAAA,CAAO66B,MAAA,GAASt7B,CAAA,CAAQs7B,MAAA,GACxBt7B,CAAA,CAAQoS,SAAA,IAAapS,CAAA,CAAQoS,SAAA,CAAUtQ,MAAA,EAEvC,KADArB,CAAA,CAAO2R,SAAA,GAAY,IACV5R,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQoS,SAAA,CAAUtQ,MAAA,IAAUtB,CAAA,EAC5CC,CAAA,CAAO2R,SAAA,CAAU5R,CAAA,IAAK6K,CAAA,CAAMxH,IAAA,CAAKC,cAAA,CAAeyiD,QAAA,CAASvmD,CAAA,CAAQoS,SAAA,CAAU5R,CAAA,GAAIP,CAAA;YAMvF,OAJyB,QAArBD,CAAA,CAAQ0qC,SAAA,IAAqB1qC,CAAA,CAAQmlB,cAAA,CAAe,iBACpD1kB,CAAA,CAAOiqC,SAAA,GAAY1qC,CAAA,CAAQ0qC,SAAA,GACT,QAAlB1qC,CAAA,CAAQshC,MAAA,IAAkBthC,CAAA,CAAQmlB,cAAA,CAAe,cACjD1kB,CAAA,CAAO6gC,MAAA,GAASthC,CAAA,CAAQshC,MAAA,GACrB7gC,CACX;UAAA,GASAT,CAAA,CAAU6kD,SAAA,CAAUiC,MAAA,GAAS;YACzB,OAAO,KAAKlkD,WAAA,CAAY2jD,QAAA,CAAS,MAAMrlD,CAAA,CAAUsjD,IAAA,CAAKuC,aAAA,CAC1D;UAAA,GAUA/mD,CAAA,CAAUgnD,UAAA,GAAa,UAAoBhnD,CAAA;YAIvC,YAHsB,MAAlBA,CAAA,KACAA,CAAA,GAAgB,wBAEbA,CAAA,GAAgB,iBAC3B;UAAA,GAEOA,CACV;QAAA,CA3YgB,IA6YjBiB,CAAA,CAAKimD,iBAAA,GAAoB;UAoBrB,SAASlnD,EAAkBA,CAAA;YAGvB,IAFA,KAAKmnD,qBAAA,GAAwB,IAC7B,KAAKC,aAAA,GAAgB,IACjBpnD,CAAA,EACA,KAAK,IAAIC,CAAA,GAAO4C,MAAA,CAAO6N,IAAA,CAAK1Q,CAAA,GAAaS,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK6B,MAAA,IAAUrB,CAAA,EACpC,QAAvBT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,OAChB,KAAKR,CAAA,CAAKQ,CAAA,KAAMT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,GAChD;UAAA;UAySA,OAjSAT,CAAA,CAAkB6kD,SAAA,CAAUwC,cAAA,GAAiB,MAQ7CrnD,CAAA,CAAkB6kD,SAAA,CAAUyC,SAAA,GAAY,MAQxCtnD,CAAA,CAAkB6kD,SAAA,CAAUsC,qBAAA,GAAwB18C,CAAA,CAAMy6C,UAAA,EAQ1DllD,CAAA,CAAkB6kD,SAAA,CAAUuC,aAAA,GAAgB38C,CAAA,CAAMy6C,UAAA,EAUlDllD,CAAA,CAAkBy/B,MAAA,GAAS,UAAgBx/B,CAAA;YACvC,OAAO,IAAID,CAAA,CAAkBC,CAAA,CACjC;UAAA,GAWAD,CAAA,CAAkBkP,MAAA,GAAS,UAAgBlP,CAAA,EAASC,CAAA;YAOhD,IANKA,CAAA,KACDA,CAAA,GAASyD,CAAA,CAAQ+7B,MAAA,KACS,QAA1Bz/B,CAAA,CAAQqnD,cAAA,IAA0BxkD,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,qBACtEqL,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAWntB,MAAA,CAAOlP,CAAA,CAAQqnD,cAAA,EAAgBpnD,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA,IACjF,QAArBxlD,CAAA,CAAQsnD,SAAA,IAAqBzkD,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,gBACjEqL,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAWntB,MAAA,CAAOlP,CAAA,CAAQsnD,SAAA,EAAWrnD,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA,IAChE,QAAjCxlD,CAAA,CAAQmnD,qBAAA,IAAiCnnD,CAAA,CAAQmnD,qBAAA,CAAsBrlD,MAAA,EACvE,KAAK,IAAIrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQmnD,qBAAA,CAAsBrlD,MAAA,IAAUrB,CAAA,EACxD4K,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBr4C,MAAA,CAAOlP,CAAA,CAAQmnD,qBAAA,CAAsB1mD,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA;YACpI,IAA6B,QAAzBxlD,CAAA,CAAQonD,aAAA,IAAyBpnD,CAAA,CAAQonD,aAAA,CAActlD,MAAA,EACvD,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQonD,aAAA,CAActlD,MAAA,IAAUrB,CAAA,EAChD4K,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBr4C,MAAA,CAAOlP,CAAA,CAAQonD,aAAA,CAAc3mD,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA;YAC5H,OAAOvlD,CACX;UAAA,GAWAD,CAAA,CAAkB4lD,eAAA,GAAkB,UAAyB5lD,CAAA,EAASC,CAAA;YAClE,OAAO,KAAKiP,MAAA,CAAOlP,CAAA,EAASC,CAAA,EAAQulD,MAAA,EACxC;UAAA,GAaAxlD,CAAA,CAAkBmP,MAAA,GAAS,UAAgBnP,CAAA,EAAQC,CAAA;YACzCD,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAASsD,CAAA,CAAQm8B,MAAA,CAAOz/B,CAAA;YAE5B,KADA,IAAIS,CAAA,QAAiB,MAAXR,CAAA,GAAuBD,CAAA,CAAO6lD,GAAA,GAAM7lD,CAAA,CAAO8lD,GAAA,GAAM7lD,CAAA,EAAQO,CAAA,GAAU,IAAI6K,CAAA,CAAMxH,IAAA,CAAKqjD,iBAAA,IACrFlnD,CAAA,CAAO8lD,GAAA,GAAMrlD,CAAA,GAAK;cACrB,IAAIC,CAAA,GAAMV,CAAA,CAAOmlD,MAAA;cACjB,QAAQzkD,CAAA,KAAQ;gBAChB,KAAK;kBACGF,CAAA,CAAQ6mD,cAAA,GAAiBh8C,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAWltB,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBACrE;gBAER,KAAK;kBACG3kD,CAAA,CAAQ8mD,SAAA,GAAYj8C,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAWltB,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBAChE;gBAER,KAAK;kBACS3kD,CAAA,CAAQ2mD,qBAAA,IAAyB3mD,CAAA,CAAQ2mD,qBAAA,CAAsBrlD,MAAA,KACjEtB,CAAA,CAAQ2mD,qBAAA,GAAwB,KACpC3mD,CAAA,CAAQ2mD,qBAAA,CAAsBngD,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBp4C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBAC3F;gBAER,KAAK;kBACS3kD,CAAA,CAAQ4mD,aAAA,IAAiB5mD,CAAA,CAAQ4mD,aAAA,CAActlD,MAAA,KACjDtB,CAAA,CAAQ4mD,aAAA,GAAgB,KAC5B5mD,CAAA,CAAQ4mD,aAAA,CAAcpgD,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBp4C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBACnF;gBAER;kBACInlD,CAAA,CAAO+lD,QAAA,CAAe,IAANrlD,CAAA;cAAA;YAGxB;YACA,OAAOF,CACX;UAAA,GAYAR,CAAA,CAAkBgmD,eAAA,GAAkB,UAAyBhmD,CAAA;YAGzD,OAFMA,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAAS,IAAIsD,CAAA,CAAQtD,CAAA,IAClB,KAAKmP,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,GACtC;UAAA,GAUAnlD,CAAA,CAAkBimD,MAAA,GAAS,UAAgBjmD,CAAA;YACvC,IAAuB,mBAAZA,CAAA,IAAoC,SAAZA,CAAA,EAC/B,OAAO;YACX,IAA8B,QAA1BA,CAAA,CAAQqnD,cAAA,IAA0BrnD,CAAA,CAAQmlB,cAAA,CAAe,sBACrD1kB,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAW4pB,MAAA,CAAOjmD,CAAA,CAAQqnD,cAAA,IAE7C,OAAO,oBAAoB5mD,CAAA;YAEnC,IAAyB,QAArBT,CAAA,CAAQsnD,SAAA,IAAqBtnD,CAAA,CAAQmlB,cAAA,CAAe,iBAChD1kB,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAW4pB,MAAA,CAAOjmD,CAAA,CAAQsnD,SAAA,IAE7C,OAAO,eAAe7mD,CAAA;YAE9B,IAAqC,QAAjCT,CAAA,CAAQmnD,qBAAA,IAAiCnnD,CAAA,CAAQmlB,cAAA,CAAe,0BAA0B;cAC1F,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQmnD,qBAAA,GACvB,OAAO;cACX,KAAK,IAAIlnD,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQmnD,qBAAA,CAAsBrlD,MAAA,IAAU7B,CAAA,EAExD,IADIQ,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBtB,MAAA,CAAOjmD,CAAA,CAAQmnD,qBAAA,CAAsBlnD,CAAA,IAE/E,OAAO,2BAA2BQ,CAE9C;YAAA;YACA,IAA6B,QAAzBT,CAAA,CAAQonD,aAAA,IAAyBpnD,CAAA,CAAQmlB,cAAA,CAAe,kBAAkB;cAC1E,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQonD,aAAA,GACvB,OAAO;cACX,KAASnnD,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQonD,aAAA,CAActlD,MAAA,IAAU7B,CAAA,EAAG;gBACnD,IAAIQ,CAAA;gBACJ,IADIA,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBtB,MAAA,CAAOjmD,CAAA,CAAQonD,aAAA,CAAcnnD,CAAA,IAEvE,OAAO,mBAAmBQ,CAClC;cAAA;YACJ;YACA,OAAO,IACX;UAAA,GAUAT,CAAA,CAAkBmmD,UAAA,GAAa,UAAoBnmD,CAAA;YAC/C,IAAIA,CAAA,YAAkBqL,CAAA,CAAMxH,IAAA,CAAKqjD,iBAAA,EAC7B,OAAOlnD,CAAA;YACX,IAAIC,CAAA,GAAU,IAAIoL,CAAA,CAAMxH,IAAA,CAAKqjD,iBAAA;YAC7B,IAA6B,QAAzBlnD,CAAA,CAAOqnD,cAAA,EAAwB;cAC/B,IAAqC,mBAA1BrnD,CAAA,CAAOqnD,cAAA,EACd,MAAMtlC,SAAA,CAAU;cACpB9hB,CAAA,CAAQonD,cAAA,GAAiBh8C,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAW8pB,UAAA,CAAWnmD,CAAA,CAAOqnD,cAAA,CACrE;YAAA;YACA,IAAwB,QAApBrnD,CAAA,CAAOsnD,SAAA,EAAmB;cAC1B,IAAgC,mBAArBtnD,CAAA,CAAOsnD,SAAA,EACd,MAAMvlC,SAAA,CAAU;cACpB9hB,CAAA,CAAQqnD,SAAA,GAAYj8C,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAW8pB,UAAA,CAAWnmD,CAAA,CAAOsnD,SAAA,CAChE;YAAA;YACA,IAAItnD,CAAA,CAAOmnD,qBAAA,EAAuB;cAC9B,KAAKnhD,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOmnD,qBAAA,GACtB,MAAMplC,SAAA,CAAU;cACpB9hB,CAAA,CAAQknD,qBAAA,GAAwB;cAChC,KAAK,IAAI1mD,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOmnD,qBAAA,CAAsBrlD,MAAA,IAAUrB,CAAA,EAAG;gBAC1D,IAA+C,mBAApCT,CAAA,CAAOmnD,qBAAA,CAAsB1mD,CAAA,GACpC,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQknD,qBAAA,CAAsB1mD,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBpB,UAAA,CAAWnmD,CAAA,CAAOmnD,qBAAA,CAAsB1mD,CAAA,EACjH;cAAA;YACJ;YACA,IAAIT,CAAA,CAAOonD,aAAA,EAAe;cACtB,KAAKphD,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOonD,aAAA,GACtB,MAAMrlC,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQmnD,aAAA,GAAgB,IACf3mD,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOonD,aAAA,CAActlD,MAAA,IAAUrB,CAAA,EAAG;gBAClD,IAAuC,mBAA5BT,CAAA,CAAOonD,aAAA,CAAc3mD,CAAA,GAC5B,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQmnD,aAAA,CAAc3mD,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBpB,UAAA,CAAWnmD,CAAA,CAAOonD,aAAA,CAAc3mD,CAAA,EACjG;cAAA;YACJ;YACA,OAAOR,CACX;UAAA,GAWAD,CAAA,CAAkBumD,QAAA,GAAW,UAAkBvmD,CAAA,EAASC,CAAA;YAC/CA,CAAA,KACDA,CAAA,GAAU,CAAC;YACf,IAAIQ,CAAA,GAAS,CAAC;YAad,KAZIR,CAAA,CAAQumD,MAAA,IAAUvmD,CAAA,CAAQwmD,QAAA,MAC1BhmD,CAAA,CAAO0mD,qBAAA,GAAwB,IAC/B1mD,CAAA,CAAO2mD,aAAA,GAAgB,KAEvBnnD,CAAA,CAAQwmD,QAAA,KACRhmD,CAAA,CAAO4mD,cAAA,GAAiB,MACxB5mD,CAAA,CAAO6mD,SAAA,GAAY,OAEO,QAA1BtnD,CAAA,CAAQqnD,cAAA,IAA0BrnD,CAAA,CAAQmlB,cAAA,CAAe,sBACzD1kB,CAAA,CAAO4mD,cAAA,GAAiBh8C,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAWkqB,QAAA,CAASvmD,CAAA,CAAQqnD,cAAA,EAAgBpnD,CAAA,IAC1D,QAArBD,CAAA,CAAQsnD,SAAA,IAAqBtnD,CAAA,CAAQmlB,cAAA,CAAe,iBACpD1kB,CAAA,CAAO6mD,SAAA,GAAYj8C,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAWkqB,QAAA,CAASvmD,CAAA,CAAQsnD,SAAA,EAAWrnD,CAAA,IACrED,CAAA,CAAQmnD,qBAAA,IAAyBnnD,CAAA,CAAQmnD,qBAAA,CAAsBrlD,MAAA,EAAQ;cACvErB,CAAA,CAAO0mD,qBAAA,GAAwB;cAC/B,KAAK,IAAI3mD,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQmnD,qBAAA,CAAsBrlD,MAAA,IAAUtB,CAAA,EACxDC,CAAA,CAAO0mD,qBAAA,CAAsB3mD,CAAA,IAAK6K,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBhB,QAAA,CAASvmD,CAAA,CAAQmnD,qBAAA,CAAsB3mD,CAAA,GAAIP,CAAA,CACvH;YAAA;YACA,IAAID,CAAA,CAAQonD,aAAA,IAAiBpnD,CAAA,CAAQonD,aAAA,CAActlD,MAAA,EAE/C,KADArB,CAAA,CAAO2mD,aAAA,GAAgB,IACd5mD,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQonD,aAAA,CAActlD,MAAA,IAAUtB,CAAA,EAChDC,CAAA,CAAO2mD,aAAA,CAAc5mD,CAAA,IAAK6K,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBhB,QAAA,CAASvmD,CAAA,CAAQonD,aAAA,CAAc5mD,CAAA,GAAIP,CAAA;YAEvG,OAAOQ,CACX;UAAA,GASAT,CAAA,CAAkB6kD,SAAA,CAAUiC,MAAA,GAAS;YACjC,OAAO,KAAKlkD,WAAA,CAAY2jD,QAAA,CAAS,MAAMrlD,CAAA,CAAUsjD,IAAA,CAAKuC,aAAA,CAC1D;UAAA,GAUA/mD,CAAA,CAAkBgnD,UAAA,GAAa,UAAoBhnD,CAAA;YAI/C,YAHsB,MAAlBA,CAAA,KACAA,CAAA,GAAgB,wBAEbA,CAAA,GAAgB,yBAC3B;UAAA,GAEOA,CACV;QAAA,CArUwB,IAuUzBiB,CAAA,CAAKigC,UAAA,GAAa;UA2Bd,SAASlhC,EAAWA,CAAA;YAKhB,IAJA,KAAKqhC,WAAA,GAAc,IACnB,KAAKmmB,aAAA,GAAgB,IACrB,KAAKC,YAAA,GAAe,IACpB,KAAKC,SAAA,GAAY,IACb1nD,CAAA,EACA,KAAK,IAAIC,CAAA,GAAO4C,MAAA,CAAO6N,IAAA,CAAK1Q,CAAA,GAAaS,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK6B,MAAA,IAAUrB,CAAA,EACpC,QAAvBT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,OAChB,KAAKR,CAAA,CAAKQ,CAAA,KAAMT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,GAChD;UAAA;UAkgBA,OA1fAT,CAAA,CAAW6kD,SAAA,CAAU1jB,SAAA,GAAY12B,CAAA,CAAMwxC,IAAA,GAAOxxC,CAAA,CAAMwxC,IAAA,CAAKb,QAAA,CAAS,GAAE,IAAE,KAAS,GAQ/Ep7C,CAAA,CAAW6kD,SAAA,CAAUxjB,WAAA,GAAc52B,CAAA,CAAMy6C,UAAA,EAQzCllD,CAAA,CAAW6kD,SAAA,CAAU/Q,YAAA,GAAe,IAQpC9zC,CAAA,CAAW6kD,SAAA,CAAU9Q,eAAA,GAAkB,IAQvC/zC,CAAA,CAAW6kD,SAAA,CAAUvjB,MAAA,GAAS,IAQ9BthC,CAAA,CAAW6kD,SAAA,CAAU7Q,YAAA,GAAevpC,CAAA,CAAMwxC,IAAA,GAAOxxC,CAAA,CAAMwxC,IAAA,CAAKb,QAAA,CAAS,GAAE,IAAE,KAAS,GAQlFp7C,CAAA,CAAW6kD,SAAA,CAAUna,SAAA,GAAY,IAQjC1qC,CAAA,CAAW6kD,SAAA,CAAUxqB,KAAA,GAAQ,MAQ7Br6B,CAAA,CAAW6kD,SAAA,CAAU2C,aAAA,GAAgB/8C,CAAA,CAAMy6C,UAAA,EAQ3CllD,CAAA,CAAW6kD,SAAA,CAAU4C,YAAA,GAAeh9C,CAAA,CAAMy6C,UAAA,EAQ1CllD,CAAA,CAAW6kD,SAAA,CAAU6C,SAAA,GAAYj9C,CAAA,CAAMy6C,UAAA,EAUvCllD,CAAA,CAAWy/B,MAAA,GAAS,UAAgBx/B,CAAA;YAChC,OAAO,IAAID,CAAA,CAAWC,CAAA,CAC1B;UAAA,GAWAD,CAAA,CAAWkP,MAAA,GAAS,UAAgBlP,CAAA,EAASC,CAAA;YAiBzC,IAhBKA,CAAA,KACDA,CAAA,GAASyD,CAAA,CAAQ+7B,MAAA,KACI,QAArBz/B,CAAA,CAAQmhC,SAAA,IAAqBt+B,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,gBACjEC,CAAA,CAAOklD,MAAA,CAA8B,GAAGG,KAAA,CAAMtlD,CAAA,CAAQmhC,SAAA,GAC9B,QAAxBnhC,CAAA,CAAQ8zC,YAAA,IAAwBjxC,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,mBACpEC,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQ8zC,YAAA,GAC7B,QAA3B9zC,CAAA,CAAQ+zC,eAAA,IAA2BlxC,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,sBACvEC,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQ+zC,eAAA,GACtC,QAAlB/zC,CAAA,CAAQshC,MAAA,IAAkBz+B,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,aAC9DC,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQshC,MAAA,GAChC,QAAxBthC,CAAA,CAAQg0C,YAAA,IAAwBnxC,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,mBACpEC,CAAA,CAAOklD,MAAA,CAA8B,IAAIG,KAAA,CAAMtlD,CAAA,CAAQg0C,YAAA,GAClC,QAArBh0C,CAAA,CAAQ0qC,SAAA,IAAqB7nC,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,gBACjEC,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQ0qC,SAAA,GACvC,QAAjB1qC,CAAA,CAAQq6B,KAAA,IAAiBx3B,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,YAC7DqL,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAWntB,MAAA,CAAOlP,CAAA,CAAQq6B,KAAA,EAAOp6B,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA,IACtE,QAAvBxlD,CAAA,CAAQqhC,WAAA,IAAuBrhC,CAAA,CAAQqhC,WAAA,CAAYv/B,MAAA,EACnD,KAAK,IAAIrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQqhC,WAAA,CAAYv/B,MAAA,IAAUrB,CAAA,EAC9C4K,CAAA,CAAMxH,IAAA,CAAK8jD,kBAAA,CAAmBz4C,MAAA,CAAOlP,CAAA,CAAQqhC,WAAA,CAAY5gC,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA;YACtH,IAA6B,QAAzBxlD,CAAA,CAAQwnD,aAAA,IAAyBxnD,CAAA,CAAQwnD,aAAA,CAAc1lD,MAAA,EACvD,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQwnD,aAAA,CAAc1lD,MAAA,IAAUrB,CAAA,EAChD4K,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBr4C,MAAA,CAAOlP,CAAA,CAAQwnD,aAAA,CAAc/mD,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA+B,KAAKI,IAAA,IAAQC,MAAA;YAC9H,IAA4B,QAAxBxlD,CAAA,CAAQynD,YAAA,IAAwBznD,CAAA,CAAQynD,YAAA,CAAa3lD,MAAA,EACrD,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQynD,YAAA,CAAa3lD,MAAA,IAAUrB,CAAA,EAC/C4K,CAAA,CAAMxH,IAAA,CAAKqjD,iBAAA,CAAkBh4C,MAAA,CAAOlP,CAAA,CAAQynD,YAAA,CAAahnD,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA+B,KAAKI,IAAA,IAAQC,MAAA;YACxH,IAAyB,QAArBxlD,CAAA,CAAQ0nD,SAAA,IAAqB1nD,CAAA,CAAQ0nD,SAAA,CAAU5lD,MAAA,EAC/C,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQ0nD,SAAA,CAAU5lD,MAAA,IAAUrB,CAAA,EAC5C4K,CAAA,CAAMxH,IAAA,CAAK+jD,aAAA,CAAc14C,MAAA,CAAOlP,CAAA,CAAQ0nD,SAAA,CAAUjnD,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA+B,KAAKI,IAAA,IAAQC,MAAA;YACjH,OAAOvlD,CACX;UAAA,GAWAD,CAAA,CAAW4lD,eAAA,GAAkB,UAAyB5lD,CAAA,EAASC,CAAA;YAC3D,OAAO,KAAKiP,MAAA,CAAOlP,CAAA,EAASC,CAAA,EAAQulD,MAAA,EACxC;UAAA,GAaAxlD,CAAA,CAAWmP,MAAA,GAAS,UAAgBnP,CAAA,EAAQC,CAAA;YAClCD,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAASsD,CAAA,CAAQm8B,MAAA,CAAOz/B,CAAA;YAE5B,KADA,IAAIS,CAAA,QAAiB,MAAXR,CAAA,GAAuBD,CAAA,CAAO6lD,GAAA,GAAM7lD,CAAA,CAAO8lD,GAAA,GAAM7lD,CAAA,EAAQO,CAAA,GAAU,IAAI6K,CAAA,CAAMxH,IAAA,CAAKq9B,UAAA,IACrFlhC,CAAA,CAAO8lD,GAAA,GAAMrlD,CAAA,GAAK;cACrB,IAAIC,CAAA,GAAMV,CAAA,CAAOmlD,MAAA;cACjB,QAAQzkD,CAAA,KAAQ;gBAChB,KAAK;kBACGF,CAAA,CAAQ2gC,SAAA,GAAYnhC,CAAA,CAAOslD,KAAA;kBAC3B;gBAER,KAAK;kBACS9kD,CAAA,CAAQ6gC,WAAA,IAAe7gC,CAAA,CAAQ6gC,WAAA,CAAYv/B,MAAA,KAC7CtB,CAAA,CAAQ6gC,WAAA,GAAc,KAC1B7gC,CAAA,CAAQ6gC,WAAA,CAAYr6B,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAK8jD,kBAAA,CAAmBx4C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBAC7E;gBAER,KAAK;kBACG3kD,CAAA,CAAQszC,YAAA,GAAe9zC,CAAA,CAAOolD,MAAA;kBAC9B;gBAER,KAAK;kBACG5kD,CAAA,CAAQuzC,eAAA,GAAkB/zC,CAAA,CAAOolD,MAAA;kBACjC;gBAER,KAAK;kBACG5kD,CAAA,CAAQ8gC,MAAA,GAASthC,CAAA,CAAOolD,MAAA;kBACxB;gBAER,KAAK;kBACG5kD,CAAA,CAAQwzC,YAAA,GAAeh0C,CAAA,CAAOslD,KAAA;kBAC9B;gBAER,KAAK;kBACG9kD,CAAA,CAAQkqC,SAAA,GAAY1qC,CAAA,CAAOolD,MAAA;kBAC3B;gBAER,KAAK;kBACG5kD,CAAA,CAAQ65B,KAAA,GAAQhvB,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAWltB,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBAC5D;gBAER,KAAK;kBACS3kD,CAAA,CAAQgnD,aAAA,IAAiBhnD,CAAA,CAAQgnD,aAAA,CAAc1lD,MAAA,KACjDtB,CAAA,CAAQgnD,aAAA,GAAgB,KAC5BhnD,CAAA,CAAQgnD,aAAA,CAAcxgD,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBp4C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBACnF;gBAER,KAAK;kBACS3kD,CAAA,CAAQinD,YAAA,IAAgBjnD,CAAA,CAAQinD,YAAA,CAAa3lD,MAAA,KAC/CtB,CAAA,CAAQinD,YAAA,GAAe,KAC3BjnD,CAAA,CAAQinD,YAAA,CAAazgD,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAKqjD,iBAAA,CAAkB/3C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBAC7E;gBAER,KAAK;kBACS3kD,CAAA,CAAQknD,SAAA,IAAalnD,CAAA,CAAQknD,SAAA,CAAU5lD,MAAA,KACzCtB,CAAA,CAAQknD,SAAA,GAAY,KACxBlnD,CAAA,CAAQknD,SAAA,CAAU1gD,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAK+jD,aAAA,CAAcz4C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBACtE;gBAER;kBACInlD,CAAA,CAAO+lD,QAAA,CAAe,IAANrlD,CAAA;cAAA;YAGxB;YACA,OAAOF,CACX;UAAA,GAYAR,CAAA,CAAWgmD,eAAA,GAAkB,UAAyBhmD,CAAA;YAGlD,OAFMA,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAAS,IAAIsD,CAAA,CAAQtD,CAAA,IAClB,KAAKmP,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,GACtC;UAAA,GAUAnlD,CAAA,CAAWimD,MAAA,GAAS,UAAgBjmD,CAAA;YAChC,IAAuB,mBAAZA,CAAA,IAAoC,SAAZA,CAAA,EAC/B,OAAO;YACX,IAAyB,QAArBA,CAAA,CAAQmhC,SAAA,IAAqBnhC,CAAA,CAAQmlB,cAAA,CAAe,kBAC/C1a,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQmhC,SAAA,KAAgBnhC,CAAA,CAAQmhC,SAAA,IAAa12B,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQmhC,SAAA,CAAUgb,GAAA,KAAQ1xC,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQmhC,SAAA,CAAUib,IAAA,IAC1I,OAAO;YACf,IAA2B,QAAvBp8C,CAAA,CAAQqhC,WAAA,IAAuBrhC,CAAA,CAAQmlB,cAAA,CAAe,gBAAgB;cACtE,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQqhC,WAAA,GACvB,OAAO;cACX,KAAK,IAAIphC,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQqhC,WAAA,CAAYv/B,MAAA,IAAU7B,CAAA,EAE9C,IADIQ,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAK8jD,kBAAA,CAAmB1B,MAAA,CAAOjmD,CAAA,CAAQqhC,WAAA,CAAYphC,CAAA,IAEjE,OAAO,iBAAiBQ,CAEpC;YAAA;YACA,IAA4B,QAAxBT,CAAA,CAAQ8zC,YAAA,IAAwB9zC,CAAA,CAAQmlB,cAAA,CAAe,oBAClD1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQ8zC,YAAA,GACxB,OAAO;YACf,IAA+B,QAA3B9zC,CAAA,CAAQ+zC,eAAA,IAA2B/zC,CAAA,CAAQmlB,cAAA,CAAe,uBACrD1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQ+zC,eAAA,GACxB,OAAO;YACf,IAAsB,QAAlB/zC,CAAA,CAAQshC,MAAA,IAAkBthC,CAAA,CAAQmlB,cAAA,CAAe,cAC5C1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQshC,MAAA,GACxB,OAAO;YACf,IAA4B,QAAxBthC,CAAA,CAAQg0C,YAAA,IAAwBh0C,CAAA,CAAQmlB,cAAA,CAAe,qBAClD1a,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQg0C,YAAA,KAAmBh0C,CAAA,CAAQg0C,YAAA,IAAgBvpC,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQg0C,YAAA,CAAamI,GAAA,KAAQ1xC,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQg0C,YAAA,CAAaoI,IAAA,IACtJ,OAAO;YACf,IAAyB,QAArBp8C,CAAA,CAAQ0qC,SAAA,IAAqB1qC,CAAA,CAAQmlB,cAAA,CAAe,iBAC/C1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQ0qC,SAAA,GACxB,OAAO;YACf,IAAqB,QAAjB1qC,CAAA,CAAQq6B,KAAA,IAAiBr6B,CAAA,CAAQmlB,cAAA,CAAe,aAC5C1kB,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAW4pB,MAAA,CAAOjmD,CAAA,CAAQq6B,KAAA,IAE7C,OAAO,WAAW55B,CAAA;YAE1B,IAA6B,QAAzBT,CAAA,CAAQwnD,aAAA,IAAyBxnD,CAAA,CAAQmlB,cAAA,CAAe,kBAAkB;cAC1E,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQwnD,aAAA,GACvB,OAAO;cACX,KAASvnD,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQwnD,aAAA,CAAc1lD,MAAA,IAAU7B,CAAA,EAEhD,IADIQ,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBtB,MAAA,CAAOjmD,CAAA,CAAQwnD,aAAA,CAAcvnD,CAAA,IAEvE,OAAO,mBAAmBQ,CAEtC;YAAA;YACA,IAA4B,QAAxBT,CAAA,CAAQynD,YAAA,IAAwBznD,CAAA,CAAQmlB,cAAA,CAAe,iBAAiB;cACxE,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQynD,YAAA,GACvB,OAAO;cACX,KAASxnD,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQynD,YAAA,CAAa3lD,MAAA,IAAU7B,CAAA,EAE/C,IADIQ,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAKqjD,iBAAA,CAAkBjB,MAAA,CAAOjmD,CAAA,CAAQynD,YAAA,CAAaxnD,CAAA,IAEjE,OAAO,kBAAkBQ,CAErC;YAAA;YACA,IAAyB,QAArBT,CAAA,CAAQ0nD,SAAA,IAAqB1nD,CAAA,CAAQmlB,cAAA,CAAe,cAAc;cAClE,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQ0nD,SAAA,GACvB,OAAO;cACX,KAASznD,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQ0nD,SAAA,CAAU5lD,MAAA,IAAU7B,CAAA,EAAG;gBAC/C,IAAIQ,CAAA;gBACJ,IADIA,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAK+jD,aAAA,CAAc3B,MAAA,CAAOjmD,CAAA,CAAQ0nD,SAAA,CAAUznD,CAAA,IAE1D,OAAO,eAAeQ,CAC9B;cAAA;YACJ;YACA,OAAO,IACX;UAAA,GAUAT,CAAA,CAAWmmD,UAAA,GAAa,UAAoBnmD,CAAA;YACxC,IAAIA,CAAA,YAAkBqL,CAAA,CAAMxH,IAAA,CAAKq9B,UAAA,EAC7B,OAAOlhC,CAAA;YACX,IAAIC,CAAA,GAAU,IAAIoL,CAAA,CAAMxH,IAAA,CAAKq9B,UAAA;YAU7B,IATwB,QAApBlhC,CAAA,CAAOmhC,SAAA,KACH12B,CAAA,CAAMwxC,IAAA,IACLh8C,CAAA,CAAQkhC,SAAA,GAAY12B,CAAA,CAAMwxC,IAAA,CAAKC,SAAA,CAAUl8C,CAAA,CAAOmhC,SAAA,GAAYkb,QAAA,IAAW,IACvC,mBAArBr8C,CAAA,CAAOmhC,SAAA,GACnBlhC,CAAA,CAAQkhC,SAAA,GAAYe,QAAA,CAASliC,CAAA,CAAOmhC,SAAA,EAAW,MACd,mBAArBnhC,CAAA,CAAOmhC,SAAA,GACnBlhC,CAAA,CAAQkhC,SAAA,GAAYnhC,CAAA,CAAOmhC,SAAA,GACM,mBAArBnhC,CAAA,CAAOmhC,SAAA,KACnBlhC,CAAA,CAAQkhC,SAAA,GAAY,IAAI12B,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAOmhC,SAAA,CAAUgb,GAAA,KAAQ,GAAGn8C,CAAA,CAAOmhC,SAAA,CAAUib,IAAA,KAAS,GAAGxB,QAAA,MACpG56C,CAAA,CAAOqhC,WAAA,EAAa;cACpB,KAAKr7B,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOqhC,WAAA,GACtB,MAAMtf,SAAA,CAAU;cACpB9hB,CAAA,CAAQohC,WAAA,GAAc;cACtB,KAAK,IAAI5gC,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOqhC,WAAA,CAAYv/B,MAAA,IAAUrB,CAAA,EAAG;gBAChD,IAAqC,mBAA1BT,CAAA,CAAOqhC,WAAA,CAAY5gC,CAAA,GAC1B,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQohC,WAAA,CAAY5gC,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAK8jD,kBAAA,CAAmBxB,UAAA,CAAWnmD,CAAA,CAAOqhC,WAAA,CAAY5gC,CAAA,EACzF;cAAA;YACJ;YAkBA,IAjB2B,QAAvBT,CAAA,CAAO8zC,YAAA,KACP7zC,CAAA,CAAQ6zC,YAAA,GAAesS,MAAA,CAAOpmD,CAAA,CAAO8zC,YAAA,IACX,QAA1B9zC,CAAA,CAAO+zC,eAAA,KACP9zC,CAAA,CAAQ8zC,eAAA,GAAkBqS,MAAA,CAAOpmD,CAAA,CAAO+zC,eAAA,IACvB,QAAjB/zC,CAAA,CAAOshC,MAAA,KACPrhC,CAAA,CAAQqhC,MAAA,GAAS8kB,MAAA,CAAOpmD,CAAA,CAAOshC,MAAA,IACR,QAAvBthC,CAAA,CAAOg0C,YAAA,KACHvpC,CAAA,CAAMwxC,IAAA,IACLh8C,CAAA,CAAQ+zC,YAAA,GAAevpC,CAAA,CAAMwxC,IAAA,CAAKC,SAAA,CAAUl8C,CAAA,CAAOg0C,YAAA,GAAeqI,QAAA,IAAW,IAC1C,mBAAxBr8C,CAAA,CAAOg0C,YAAA,GACnB/zC,CAAA,CAAQ+zC,YAAA,GAAe9R,QAAA,CAASliC,CAAA,CAAOg0C,YAAA,EAAc,MACjB,mBAAxBh0C,CAAA,CAAOg0C,YAAA,GACnB/zC,CAAA,CAAQ+zC,YAAA,GAAeh0C,CAAA,CAAOg0C,YAAA,GACM,mBAAxBh0C,CAAA,CAAOg0C,YAAA,KACnB/zC,CAAA,CAAQ+zC,YAAA,GAAe,IAAIvpC,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAOg0C,YAAA,CAAamI,GAAA,KAAQ,GAAGn8C,CAAA,CAAOg0C,YAAA,CAAaoI,IAAA,KAAS,GAAGxB,QAAA,MACzF,QAApB56C,CAAA,CAAO0qC,SAAA,KACPzqC,CAAA,CAAQyqC,SAAA,GAAY0b,MAAA,CAAOpmD,CAAA,CAAO0qC,SAAA,IAClB,QAAhB1qC,CAAA,CAAOq6B,KAAA,EAAe;cACtB,IAA4B,mBAAjBr6B,CAAA,CAAOq6B,KAAA,EACd,MAAMtY,SAAA,CAAU;cACpB9hB,CAAA,CAAQo6B,KAAA,GAAQhvB,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAW8pB,UAAA,CAAWnmD,CAAA,CAAOq6B,KAAA,CAC5D;YAAA;YACA,IAAIr6B,CAAA,CAAOwnD,aAAA,EAAe;cACtB,KAAKxhD,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOwnD,aAAA,GACtB,MAAMzlC,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQunD,aAAA,GAAgB,IACf/mD,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOwnD,aAAA,CAAc1lD,MAAA,IAAUrB,CAAA,EAAG;gBAClD,IAAuC,mBAA5BT,CAAA,CAAOwnD,aAAA,CAAc/mD,CAAA,GAC5B,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQunD,aAAA,CAAc/mD,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBpB,UAAA,CAAWnmD,CAAA,CAAOwnD,aAAA,CAAc/mD,CAAA,EACjG;cAAA;YACJ;YACA,IAAIT,CAAA,CAAOynD,YAAA,EAAc;cACrB,KAAKzhD,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOynD,YAAA,GACtB,MAAM1lC,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQwnD,YAAA,GAAe,IACdhnD,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOynD,YAAA,CAAa3lD,MAAA,IAAUrB,CAAA,EAAG;gBACjD,IAAsC,mBAA3BT,CAAA,CAAOynD,YAAA,CAAahnD,CAAA,GAC3B,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQwnD,YAAA,CAAahnD,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAKqjD,iBAAA,CAAkBf,UAAA,CAAWnmD,CAAA,CAAOynD,YAAA,CAAahnD,CAAA,EAC1F;cAAA;YACJ;YACA,IAAIT,CAAA,CAAO0nD,SAAA,EAAW;cAClB,KAAK1hD,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAO0nD,SAAA,GACtB,MAAM3lC,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQynD,SAAA,GAAY,IACXjnD,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAO0nD,SAAA,CAAU5lD,MAAA,IAAUrB,CAAA,EAAG;gBAC9C,IAAmC,mBAAxBT,CAAA,CAAO0nD,SAAA,CAAUjnD,CAAA,GACxB,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQynD,SAAA,CAAUjnD,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAK+jD,aAAA,CAAczB,UAAA,CAAWnmD,CAAA,CAAO0nD,SAAA,CAAUjnD,CAAA,EAChF;cAAA;YACJ;YACA,OAAOR,CACX;UAAA,GAWAD,CAAA,CAAWumD,QAAA,GAAW,UAAkBvmD,CAAA,EAASC,CAAA;YACxCA,CAAA,KACDA,CAAA,GAAU,CAAC;YACf,IAAIQ,CAAA,GAAS,CAAC;YAOd,KANIR,CAAA,CAAQumD,MAAA,IAAUvmD,CAAA,CAAQwmD,QAAA,MAC1BhmD,CAAA,CAAO4gC,WAAA,GAAc,IACrB5gC,CAAA,CAAO+mD,aAAA,GAAgB,IACvB/mD,CAAA,CAAOgnD,YAAA,GAAe,IACtBhnD,CAAA,CAAOinD,SAAA,GAAY,KAEnBznD,CAAA,CAAQwmD,QAAA,EAAU;cAClB,IAAIh8C,CAAA,CAAMwxC,IAAA,EAAM;gBACZ,IAAIz7C,CAAA,GAAO,IAAIiK,CAAA,CAAMwxC,IAAA,CAAK,GAAG,IAAG;gBAChCx7C,CAAA,CAAO0gC,SAAA,GAAYlhC,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS5lD,CAAA,CAAK+1B,QAAA,KAAat2B,CAAA,CAAQymD,KAAA,KAAUhlD,MAAA,GAASlB,CAAA,CAAKo6C,QAAA,KAAap6C,CACjH;cAAA,OACIC,CAAA,CAAO0gC,SAAA,GAAYlhC,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS,MAAM;cACxD3lD,CAAA,CAAOqzC,YAAA,GAAe,IACtBrzC,CAAA,CAAOszC,eAAA,GAAkB,IACzBtzC,CAAA,CAAO6gC,MAAA,GAAS,IACZ72B,CAAA,CAAMwxC,IAAA,IACFz7C,CAAA,GAAO,IAAIiK,CAAA,CAAMwxC,IAAA,CAAK,GAAG,IAAG,IAChCx7C,CAAA,CAAOuzC,YAAA,GAAe/zC,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS5lD,CAAA,CAAK+1B,QAAA,KAAat2B,CAAA,CAAQymD,KAAA,KAAUhlD,MAAA,GAASlB,CAAA,CAAKo6C,QAAA,KAAap6C,CAAA,IAEhHC,CAAA,CAAOuzC,YAAA,GAAe/zC,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS,MAAM,GAC3D3lD,CAAA,CAAOiqC,SAAA,GAAY,IACnBjqC,CAAA,CAAO45B,KAAA,GAAQ,IACnB;YAAA;YAqBA,IApByB,QAArBr6B,CAAA,CAAQmhC,SAAA,IAAqBnhC,CAAA,CAAQmlB,cAAA,CAAe,iBACnB,mBAAtBnlB,CAAA,CAAQmhC,SAAA,GACf1gC,CAAA,CAAO0gC,SAAA,GAAYlhC,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAASA,MAAA,CAAOpmD,CAAA,CAAQmhC,SAAA,IAAanhC,CAAA,CAAQmhC,SAAA,GAElF1gC,CAAA,CAAO0gC,SAAA,GAAYlhC,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS37C,CAAA,CAAMwxC,IAAA,CAAK4I,SAAA,CAAUtuB,QAAA,CAASnR,IAAA,CAAKplB,CAAA,CAAQmhC,SAAA,IAAalhC,CAAA,CAAQymD,KAAA,KAAUhlD,MAAA,GAAS,IAAI+I,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAQmhC,SAAA,CAAUgb,GAAA,KAAQ,GAAGn8C,CAAA,CAAQmhC,SAAA,CAAUib,IAAA,KAAS,GAAGxB,QAAA,KAAa56C,CAAA,CAAQmhC,SAAA,GAChN,QAAxBnhC,CAAA,CAAQ8zC,YAAA,IAAwB9zC,CAAA,CAAQmlB,cAAA,CAAe,oBACvD1kB,CAAA,CAAOqzC,YAAA,GAAe9zC,CAAA,CAAQ8zC,YAAA,GACH,QAA3B9zC,CAAA,CAAQ+zC,eAAA,IAA2B/zC,CAAA,CAAQmlB,cAAA,CAAe,uBAC1D1kB,CAAA,CAAOszC,eAAA,GAAkB/zC,CAAA,CAAQ+zC,eAAA,GACf,QAAlB/zC,CAAA,CAAQshC,MAAA,IAAkBthC,CAAA,CAAQmlB,cAAA,CAAe,cACjD1kB,CAAA,CAAO6gC,MAAA,GAASthC,CAAA,CAAQshC,MAAA,GACA,QAAxBthC,CAAA,CAAQg0C,YAAA,IAAwBh0C,CAAA,CAAQmlB,cAAA,CAAe,oBACnB,mBAAzBnlB,CAAA,CAAQg0C,YAAA,GACfvzC,CAAA,CAAOuzC,YAAA,GAAe/zC,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAASA,MAAA,CAAOpmD,CAAA,CAAQg0C,YAAA,IAAgBh0C,CAAA,CAAQg0C,YAAA,GAExFvzC,CAAA,CAAOuzC,YAAA,GAAe/zC,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS37C,CAAA,CAAMwxC,IAAA,CAAK4I,SAAA,CAAUtuB,QAAA,CAASnR,IAAA,CAAKplB,CAAA,CAAQg0C,YAAA,IAAgB/zC,CAAA,CAAQymD,KAAA,KAAUhlD,MAAA,GAAS,IAAI+I,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAQg0C,YAAA,CAAamI,GAAA,KAAQ,GAAGn8C,CAAA,CAAQg0C,YAAA,CAAaoI,IAAA,KAAS,GAAGxB,QAAA,KAAa56C,CAAA,CAAQg0C,YAAA,GAC/N,QAArBh0C,CAAA,CAAQ0qC,SAAA,IAAqB1qC,CAAA,CAAQmlB,cAAA,CAAe,iBACpD1kB,CAAA,CAAOiqC,SAAA,GAAY1qC,CAAA,CAAQ0qC,SAAA,GACV,QAAjB1qC,CAAA,CAAQq6B,KAAA,IAAiBr6B,CAAA,CAAQmlB,cAAA,CAAe,aAChD1kB,CAAA,CAAO45B,KAAA,GAAQhvB,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,CAAWkqB,QAAA,CAASvmD,CAAA,CAAQq6B,KAAA,EAAOp6B,CAAA,IAC7DD,CAAA,CAAQqhC,WAAA,IAAerhC,CAAA,CAAQqhC,WAAA,CAAYv/B,MAAA,EAAQ;cACnDrB,CAAA,CAAO4gC,WAAA,GAAc;cACrB,KAAK,IAAI3gC,CAAA,GAAI,GAAGA,CAAA,GAAIV,CAAA,CAAQqhC,WAAA,CAAYv/B,MAAA,IAAUpB,CAAA,EAC9CD,CAAA,CAAO4gC,WAAA,CAAY3gC,CAAA,IAAK2K,CAAA,CAAMxH,IAAA,CAAK8jD,kBAAA,CAAmBpB,QAAA,CAASvmD,CAAA,CAAQqhC,WAAA,CAAY3gC,CAAA,GAAIT,CAAA,CAC/F;YAAA;YACA,IAAID,CAAA,CAAQwnD,aAAA,IAAiBxnD,CAAA,CAAQwnD,aAAA,CAAc1lD,MAAA,EAE/C,KADArB,CAAA,CAAO+mD,aAAA,GAAgB,IACd9mD,CAAA,GAAI,GAAGA,CAAA,GAAIV,CAAA,CAAQwnD,aAAA,CAAc1lD,MAAA,IAAUpB,CAAA,EAChDD,CAAA,CAAO+mD,aAAA,CAAc9mD,CAAA,IAAK2K,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBhB,QAAA,CAASvmD,CAAA,CAAQwnD,aAAA,CAAc9mD,CAAA,GAAIT,CAAA;YAEvG,IAAID,CAAA,CAAQynD,YAAA,IAAgBznD,CAAA,CAAQynD,YAAA,CAAa3lD,MAAA,EAE7C,KADArB,CAAA,CAAOgnD,YAAA,GAAe,IACb/mD,CAAA,GAAI,GAAGA,CAAA,GAAIV,CAAA,CAAQynD,YAAA,CAAa3lD,MAAA,IAAUpB,CAAA,EAC/CD,CAAA,CAAOgnD,YAAA,CAAa/mD,CAAA,IAAK2K,CAAA,CAAMxH,IAAA,CAAKqjD,iBAAA,CAAkBX,QAAA,CAASvmD,CAAA,CAAQynD,YAAA,CAAa/mD,CAAA,GAAIT,CAAA;YAEhG,IAAID,CAAA,CAAQ0nD,SAAA,IAAa1nD,CAAA,CAAQ0nD,SAAA,CAAU5lD,MAAA,EAEvC,KADArB,CAAA,CAAOinD,SAAA,GAAY,IACVhnD,CAAA,GAAI,GAAGA,CAAA,GAAIV,CAAA,CAAQ0nD,SAAA,CAAU5lD,MAAA,IAAUpB,CAAA,EAC5CD,CAAA,CAAOinD,SAAA,CAAUhnD,CAAA,IAAK2K,CAAA,CAAMxH,IAAA,CAAK+jD,aAAA,CAAcrB,QAAA,CAASvmD,CAAA,CAAQ0nD,SAAA,CAAUhnD,CAAA,GAAIT,CAAA;YAEtF,OAAOQ,CACX;UAAA,GASAT,CAAA,CAAW6kD,SAAA,CAAUiC,MAAA,GAAS;YAC1B,OAAO,KAAKlkD,WAAA,CAAY2jD,QAAA,CAAS,MAAMrlD,CAAA,CAAUsjD,IAAA,CAAKuC,aAAA,CAC1D;UAAA,GAUA/mD,CAAA,CAAWgnD,UAAA,GAAa,UAAoBhnD,CAAA;YAIxC,YAHsB,MAAlBA,CAAA,KACAA,CAAA,GAAgB,wBAEbA,CAAA,GAAgB,kBAC3B;UAAA,GAEOA,CACV;QAAA,CAviBiB,IAyiBlBiB,CAAA,CAAKsmD,sBAAA,GAAyB;UAkB1B,SAASvnD,EAAuBA,CAAA;YAC5B,IAAIA,CAAA,EACA,KAAK,IAAIC,CAAA,GAAO4C,MAAA,CAAO6N,IAAA,CAAK1Q,CAAA,GAAaS,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK6B,MAAA,IAAUrB,CAAA,EACpC,QAAvBT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,OAChB,KAAKR,CAAA,CAAKQ,CAAA,KAAMT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,GAChD;UAAA;UAyMA,OAjMAT,CAAA,CAAuB6kD,SAAA,CAAUxhC,GAAA,GAAM,IAQvCrjB,CAAA,CAAuB6kD,SAAA,CAAU1gC,KAAA,GAAQ,IAUzCnkB,CAAA,CAAuBy/B,MAAA,GAAS,UAAgBx/B,CAAA;YAC5C,OAAO,IAAID,CAAA,CAAuBC,CAAA,CACtC;UAAA,GAWAD,CAAA,CAAuBkP,MAAA,GAAS,UAAgBlP,CAAA,EAASC,CAAA;YAOrD,OANKA,CAAA,KACDA,CAAA,GAASyD,CAAA,CAAQ+7B,MAAA,KACF,QAAfz/B,CAAA,CAAQqjB,GAAA,IAAexgB,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,UAC3DC,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQqjB,GAAA,GACvC,QAAjBrjB,CAAA,CAAQmkB,KAAA,IAAiBthB,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,YAC7DC,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQmkB,KAAA,GACrDlkB,CACX;UAAA,GAWAD,CAAA,CAAuB4lD,eAAA,GAAkB,UAAyB5lD,CAAA,EAASC,CAAA;YACvE,OAAO,KAAKiP,MAAA,CAAOlP,CAAA,EAASC,CAAA,EAAQulD,MAAA,EACxC;UAAA,GAaAxlD,CAAA,CAAuBmP,MAAA,GAAS,UAAgBnP,CAAA,EAAQC,CAAA;YAC9CD,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAASsD,CAAA,CAAQm8B,MAAA,CAAOz/B,CAAA;YAE5B,KADA,IAAIS,CAAA,QAAiB,MAAXR,CAAA,GAAuBD,CAAA,CAAO6lD,GAAA,GAAM7lD,CAAA,CAAO8lD,GAAA,GAAM7lD,CAAA,EAAQO,CAAA,GAAU,IAAI6K,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,IACrFvnD,CAAA,CAAO8lD,GAAA,GAAMrlD,CAAA,GAAK;cACrB,IAAIC,CAAA,GAAMV,CAAA,CAAOmlD,MAAA;cACjB,QAAQzkD,CAAA,KAAQ;gBAChB,KAAK;kBACGF,CAAA,CAAQ6iB,GAAA,GAAMrjB,CAAA,CAAOolD,MAAA;kBACrB;gBAER,KAAK;kBACG5kD,CAAA,CAAQ2jB,KAAA,GAAQnkB,CAAA,CAAOolD,MAAA;kBACvB;gBAER;kBACIplD,CAAA,CAAO+lD,QAAA,CAAe,IAANrlD,CAAA;cAAA;YAGxB;YACA,OAAOF,CACX;UAAA,GAYAR,CAAA,CAAuBgmD,eAAA,GAAkB,UAAyBhmD,CAAA;YAG9D,OAFMA,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAAS,IAAIsD,CAAA,CAAQtD,CAAA,IAClB,KAAKmP,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,GACtC;UAAA,GAUAnlD,CAAA,CAAuBimD,MAAA,GAAS,UAAgBjmD,CAAA;YAC5C,OAAuB,mBAAZA,CAAA,IAAoC,SAAZA,CAAA,GACxB,oBACQ,QAAfA,CAAA,CAAQqjB,GAAA,IAAerjB,CAAA,CAAQmlB,cAAA,CAAe,WACzC1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQqjB,GAAA,IACjB,yBACM,QAAjBrjB,CAAA,CAAQmkB,KAAA,IAAiBnkB,CAAA,CAAQmlB,cAAA,CAAe,aAC3C1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQmkB,KAAA,IACjB,2BACR,IACX;UAAA,GAUAnkB,CAAA,CAAuBmmD,UAAA,GAAa,UAAoBnmD,CAAA;YACpD,IAAIA,CAAA,YAAkBqL,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,EAC7B,OAAOvnD,CAAA;YACX,IAAIC,CAAA,GAAU,IAAIoL,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA;YAK7B,OAJkB,QAAdvnD,CAAA,CAAOqjB,GAAA,KACPpjB,CAAA,CAAQojB,GAAA,GAAM+iC,MAAA,CAAOpmD,CAAA,CAAOqjB,GAAA,IACZ,QAAhBrjB,CAAA,CAAOmkB,KAAA,KACPlkB,CAAA,CAAQkkB,KAAA,GAAQiiC,MAAA,CAAOpmD,CAAA,CAAOmkB,KAAA,IAC3BlkB,CACX;UAAA,GAWAD,CAAA,CAAuBumD,QAAA,GAAW,UAAkBvmD,CAAA,EAASC,CAAA;YACpDA,CAAA,KACDA,CAAA,GAAU,CAAC;YACf,IAAIQ,CAAA,GAAS,CAAC;YASd,OARIR,CAAA,CAAQwmD,QAAA,KACRhmD,CAAA,CAAO4iB,GAAA,GAAM,IACb5iB,CAAA,CAAO0jB,KAAA,GAAQ,KAEA,QAAfnkB,CAAA,CAAQqjB,GAAA,IAAerjB,CAAA,CAAQmlB,cAAA,CAAe,WAC9C1kB,CAAA,CAAO4iB,GAAA,GAAMrjB,CAAA,CAAQqjB,GAAA,GACJ,QAAjBrjB,CAAA,CAAQmkB,KAAA,IAAiBnkB,CAAA,CAAQmlB,cAAA,CAAe,aAChD1kB,CAAA,CAAO0jB,KAAA,GAAQnkB,CAAA,CAAQmkB,KAAA,GACpB1jB,CACX;UAAA,GASAT,CAAA,CAAuB6kD,SAAA,CAAUiC,MAAA,GAAS;YACtC,OAAO,KAAKlkD,WAAA,CAAY2jD,QAAA,CAAS,MAAMrlD,CAAA,CAAUsjD,IAAA,CAAKuC,aAAA,CAC1D;UAAA,GAUA/mD,CAAA,CAAuBgnD,UAAA,GAAa,UAAoBhnD,CAAA;YAIpD,YAHsB,MAAlBA,CAAA,KACAA,CAAA,GAAgB,wBAEbA,CAAA,GAAgB,8BAC3B;UAAA,GAEOA,CACV;QAAA,CAjO6B,IAmO9BiB,CAAA,CAAK4mD,gBAAA,GAAmB;UAkBpB,SAAS7nD,EAAiBA,CAAA;YAEtB,IADA,KAAK8nD,yBAAA,GAA4B,IAC7B9nD,CAAA,EACA,KAAK,IAAIC,CAAA,GAAO4C,MAAA,CAAO6N,IAAA,CAAK1Q,CAAA,GAAaS,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK6B,MAAA,IAAUrB,CAAA,EACpC,QAAvBT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,OAChB,KAAKR,CAAA,CAAKQ,CAAA,KAAMT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,GAChD;UAAA;UA6NA,OArNAT,CAAA,CAAiB6kD,SAAA,CAAUkD,UAAA,GAAa,IAQxC/nD,CAAA,CAAiB6kD,SAAA,CAAUiD,yBAAA,GAA4Br9C,CAAA,CAAMy6C,UAAA,EAU7DllD,CAAA,CAAiBy/B,MAAA,GAAS,UAAgBx/B,CAAA;YACtC,OAAO,IAAID,CAAA,CAAiBC,CAAA,CAChC;UAAA,GAWAD,CAAA,CAAiBkP,MAAA,GAAS,UAAgBlP,CAAA,EAASC,CAAA;YAK/C,IAJKA,CAAA,KACDA,CAAA,GAASyD,CAAA,CAAQ+7B,MAAA,KACK,QAAtBz/B,CAAA,CAAQ+nD,UAAA,IAAsBllD,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,iBAClEC,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQ+nD,UAAA,GACnB,QAArC/nD,CAAA,CAAQ8nD,yBAAA,IAAqC9nD,CAAA,CAAQ8nD,yBAAA,CAA0BhmD,MAAA,EAC/E,KAAK,IAAIrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQ8nD,yBAAA,CAA0BhmD,MAAA,IAAUrB,CAAA,EAC5D4K,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBr4C,MAAA,CAAOlP,CAAA,CAAQ8nD,yBAAA,CAA0BrnD,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA;YACxI,OAAOvlD,CACX;UAAA,GAWAD,CAAA,CAAiB4lD,eAAA,GAAkB,UAAyB5lD,CAAA,EAASC,CAAA;YACjE,OAAO,KAAKiP,MAAA,CAAOlP,CAAA,EAASC,CAAA,EAAQulD,MAAA,EACxC;UAAA,GAaAxlD,CAAA,CAAiBmP,MAAA,GAAS,UAAgBnP,CAAA,EAAQC,CAAA;YACxCD,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAASsD,CAAA,CAAQm8B,MAAA,CAAOz/B,CAAA;YAE5B,KADA,IAAIS,CAAA,QAAiB,MAAXR,CAAA,GAAuBD,CAAA,CAAO6lD,GAAA,GAAM7lD,CAAA,CAAO8lD,GAAA,GAAM7lD,CAAA,EAAQO,CAAA,GAAU,IAAI6K,CAAA,CAAMxH,IAAA,CAAKgkD,gBAAA,IACrF7nD,CAAA,CAAO8lD,GAAA,GAAMrlD,CAAA,GAAK;cACrB,IAAIC,CAAA,GAAMV,CAAA,CAAOmlD,MAAA;cACjB,QAAQzkD,CAAA,KAAQ;gBAChB,KAAK;kBACGF,CAAA,CAAQunD,UAAA,GAAa/nD,CAAA,CAAOolD,MAAA;kBAC5B;gBAER,KAAK;kBACS5kD,CAAA,CAAQsnD,yBAAA,IAA6BtnD,CAAA,CAAQsnD,yBAAA,CAA0BhmD,MAAA,KACzEtB,CAAA,CAAQsnD,yBAAA,GAA4B,KACxCtnD,CAAA,CAAQsnD,yBAAA,CAA0B9gD,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBp4C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBAC/F;gBAER;kBACInlD,CAAA,CAAO+lD,QAAA,CAAe,IAANrlD,CAAA;cAAA;YAGxB;YACA,OAAOF,CACX;UAAA,GAYAR,CAAA,CAAiBgmD,eAAA,GAAkB,UAAyBhmD,CAAA;YAGxD,OAFMA,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAAS,IAAIsD,CAAA,CAAQtD,CAAA,IAClB,KAAKmP,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,GACtC;UAAA,GAUAnlD,CAAA,CAAiBimD,MAAA,GAAS,UAAgBjmD,CAAA;YACtC,IAAuB,mBAAZA,CAAA,IAAoC,SAAZA,CAAA,EAC/B,OAAO;YACX,IAA0B,QAAtBA,CAAA,CAAQ+nD,UAAA,IAAsB/nD,CAAA,CAAQmlB,cAAA,CAAe,kBAChD1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQ+nD,UAAA,GACxB,OAAO;YACf,IAAyC,QAArC/nD,CAAA,CAAQ8nD,yBAAA,IAAqC9nD,CAAA,CAAQmlB,cAAA,CAAe,8BAA8B;cAClG,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQ8nD,yBAAA,GACvB,OAAO;cACX,KAAK,IAAI7nD,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQ8nD,yBAAA,CAA0BhmD,MAAA,IAAU7B,CAAA,EAAG;gBAC/D,IAAIQ,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBtB,MAAA,CAAOjmD,CAAA,CAAQ8nD,yBAAA,CAA0B7nD,CAAA;gBACvF,IAAIQ,CAAA,EACA,OAAO,+BAA+BA,CAC9C;cAAA;YACJ;YACA,OAAO,IACX;UAAA,GAUAT,CAAA,CAAiBmmD,UAAA,GAAa,UAAoBnmD,CAAA;YAC9C,IAAIA,CAAA,YAAkBqL,CAAA,CAAMxH,IAAA,CAAKgkD,gBAAA,EAC7B,OAAO7nD,CAAA;YACX,IAAIC,CAAA,GAAU,IAAIoL,CAAA,CAAMxH,IAAA,CAAKgkD,gBAAA;YAG7B,IAFyB,QAArB7nD,CAAA,CAAO+nD,UAAA,KACP9nD,CAAA,CAAQ8nD,UAAA,GAAa3B,MAAA,CAAOpmD,CAAA,CAAO+nD,UAAA,IACnC/nD,CAAA,CAAO8nD,yBAAA,EAA2B;cAClC,KAAK9hD,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAO8nD,yBAAA,GACtB,MAAM/lC,SAAA,CAAU;cACpB9hB,CAAA,CAAQ6nD,yBAAA,GAA4B;cACpC,KAAK,IAAIrnD,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAO8nD,yBAAA,CAA0BhmD,MAAA,IAAUrB,CAAA,EAAG;gBAC9D,IAAmD,mBAAxCT,CAAA,CAAO8nD,yBAAA,CAA0BrnD,CAAA,GACxC,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQ6nD,yBAAA,CAA0BrnD,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBpB,UAAA,CAAWnmD,CAAA,CAAO8nD,yBAAA,CAA0BrnD,CAAA,EACzH;cAAA;YACJ;YACA,OAAOR,CACX;UAAA,GAWAD,CAAA,CAAiBumD,QAAA,GAAW,UAAkBvmD,CAAA,EAASC,CAAA;YAC9CA,CAAA,KACDA,CAAA,GAAU,CAAC;YACf,IAAIQ,CAAA,GAAS,CAAC;YAOd,KANIR,CAAA,CAAQumD,MAAA,IAAUvmD,CAAA,CAAQwmD,QAAA,MAC1BhmD,CAAA,CAAOqnD,yBAAA,GAA4B,KACnC7nD,CAAA,CAAQwmD,QAAA,KACRhmD,CAAA,CAAOsnD,UAAA,GAAa,KACE,QAAtB/nD,CAAA,CAAQ+nD,UAAA,IAAsB/nD,CAAA,CAAQmlB,cAAA,CAAe,kBACrD1kB,CAAA,CAAOsnD,UAAA,GAAa/nD,CAAA,CAAQ+nD,UAAA,GAC5B/nD,CAAA,CAAQ8nD,yBAAA,IAA6B9nD,CAAA,CAAQ8nD,yBAAA,CAA0BhmD,MAAA,EAAQ;cAC/ErB,CAAA,CAAOqnD,yBAAA,GAA4B;cACnC,KAAK,IAAItnD,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQ8nD,yBAAA,CAA0BhmD,MAAA,IAAUtB,CAAA,EAC5DC,CAAA,CAAOqnD,yBAAA,CAA0BtnD,CAAA,IAAK6K,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBhB,QAAA,CAASvmD,CAAA,CAAQ8nD,yBAAA,CAA0BtnD,CAAA,GAAIP,CAAA,CAC/H;YAAA;YACA,OAAOQ,CACX;UAAA,GASAT,CAAA,CAAiB6kD,SAAA,CAAUiC,MAAA,GAAS;YAChC,OAAO,KAAKlkD,WAAA,CAAY2jD,QAAA,CAAS,MAAMrlD,CAAA,CAAUsjD,IAAA,CAAKuC,aAAA,CAC1D;UAAA,GAUA/mD,CAAA,CAAiBgnD,UAAA,GAAa,UAAoBhnD,CAAA;YAI9C,YAHsB,MAAlBA,CAAA,KACAA,CAAA,GAAgB,wBAEbA,CAAA,GAAgB,wBAC3B;UAAA,GAEOA,CACV;QAAA,CAtPuB,IAwPxBiB,CAAA,CAAKo7B,UAAA,GAAa;UAyBd,SAASr8B,EAAWA,CAAA;YAQhB,IAPA,KAAKm6B,IAAA,GAAO,IACZ,KAAKsC,WAAA,GAAc,IACnB,KAAKurB,iBAAA,GAAoB,IACzB,KAAKxrB,KAAA,GAAQ,IACb,KAAK1yB,MAAA,GAAS,IACd,KAAKm+C,SAAA,GAAY,IACjB,KAAKC,sBAAA,GAAyB,IAC1BloD,CAAA,EACA,KAAK,IAAIC,CAAA,GAAO4C,MAAA,CAAO6N,IAAA,CAAK1Q,CAAA,GAAaS,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK6B,MAAA,IAAUrB,CAAA,EACpC,QAAvBT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,OAChB,KAAKR,CAAA,CAAKQ,CAAA,KAAMT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,GAChD;UAAA;UAifA,OAzeAT,CAAA,CAAW6kD,SAAA,CAAU1qB,IAAA,GAAO1vB,CAAA,CAAMy6C,UAAA,EAQlCllD,CAAA,CAAW6kD,SAAA,CAAU7gD,IAAA,GAAO,IAQ5BhE,CAAA,CAAW6kD,SAAA,CAAUpoB,WAAA,GAAchyB,CAAA,CAAMy6C,UAAA,EAQzCllD,CAAA,CAAW6kD,SAAA,CAAUmD,iBAAA,GAAoBv9C,CAAA,CAAMy6C,UAAA,EAQ/CllD,CAAA,CAAW6kD,SAAA,CAAUna,SAAA,GAAY,IAQjC1qC,CAAA,CAAW6kD,SAAA,CAAUroB,KAAA,GAAQ/xB,CAAA,CAAMy6C,UAAA,EAQnCllD,CAAA,CAAW6kD,SAAA,CAAU/6C,MAAA,GAASW,CAAA,CAAMy6C,UAAA,EAQpCllD,CAAA,CAAW6kD,SAAA,CAAUoD,SAAA,GAAYx9C,CAAA,CAAMy6C,UAAA,EAQvCllD,CAAA,CAAW6kD,SAAA,CAAUqD,sBAAA,GAAyBz9C,CAAA,CAAMy6C,UAAA,EAUpDllD,CAAA,CAAWy/B,MAAA,GAAS,UAAgBx/B,CAAA;YAChC,OAAO,IAAID,CAAA,CAAWC,CAAA,CAC1B;UAAA,GAWAD,CAAA,CAAWkP,MAAA,GAAS,UAAgBlP,CAAA,EAASC,CAAA;YAGzC,IAFKA,CAAA,KACDA,CAAA,GAASyD,CAAA,CAAQ+7B,MAAA,KACD,QAAhBz/B,CAAA,CAAQm6B,IAAA,IAAgBn6B,CAAA,CAAQm6B,IAAA,CAAKr4B,MAAA,EACrC,KAAK,IAAIrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQm6B,IAAA,CAAKr4B,MAAA,IAAUrB,CAAA,EACvC4K,CAAA,CAAMxH,IAAA,CAAKw3B,SAAA,CAAUnsB,MAAA,CAAOlP,CAAA,CAAQm6B,IAAA,CAAK15B,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA;YAGtG,IAFoB,QAAhBxlD,CAAA,CAAQgE,IAAA,IAAgBnB,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,WAC5DC,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQgE,IAAA,GACjC,QAAvBhE,CAAA,CAAQy8B,WAAA,IAAuBz8B,CAAA,CAAQy8B,WAAA,CAAY36B,MAAA,EACnD,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQy8B,WAAA,CAAY36B,MAAA,IAAUrB,CAAA,EAC9C4K,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAY/qC,MAAA,CAAOlP,CAAA,CAAQy8B,WAAA,CAAYh8B,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA;YAG/G,IAFyB,QAArBxlD,CAAA,CAAQ0qC,SAAA,IAAqB7nC,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,gBACjEC,CAAA,CAAOklD,MAAA,CAA+B,IAAIC,MAAA,CAAOplD,CAAA,CAAQ0qC,SAAA,GACxC,QAAjB1qC,CAAA,CAAQw8B,KAAA,IAAiBx8B,CAAA,CAAQw8B,KAAA,CAAM16B,MAAA,EACvC,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQw8B,KAAA,CAAM16B,MAAA,IAAUrB,CAAA,EACxC4K,CAAA,CAAMxH,IAAA,CAAKojD,cAAA,CAAe/3C,MAAA,CAAOlP,CAAA,CAAQw8B,KAAA,CAAM/7B,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA+B,IAAII,IAAA,IAAQC,MAAA;YAC7G,IAAsB,QAAlBxlD,CAAA,CAAQ8J,MAAA,IAAkB9J,CAAA,CAAQ8J,MAAA,CAAOhI,MAAA,EACzC,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQ8J,MAAA,CAAOhI,MAAA,IAAUrB,CAAA,EACzC4K,CAAA,CAAMxH,IAAA,CAAKojD,cAAA,CAAe/3C,MAAA,CAAOlP,CAAA,CAAQ8J,MAAA,CAAOrJ,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA+B,IAAII,IAAA,IAAQC,MAAA;YAC9G,IAAyB,QAArBxlD,CAAA,CAAQioD,SAAA,IAAqBjoD,CAAA,CAAQioD,SAAA,CAAUnmD,MAAA,EAC/C,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQioD,SAAA,CAAUnmD,MAAA,IAAUrB,CAAA,EAC5C4K,CAAA,CAAMxH,IAAA,CAAKojD,cAAA,CAAe/3C,MAAA,CAAOlP,CAAA,CAAQioD,SAAA,CAAUxnD,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA+B,KAAKI,IAAA,IAAQC,MAAA;YAClH,IAAsC,QAAlCxlD,CAAA,CAAQkoD,sBAAA,IAAkCloD,CAAA,CAAQkoD,sBAAA,CAAuBpmD,MAAA,EACzE,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQkoD,sBAAA,CAAuBpmD,MAAA,IAAUrB,CAAA,EACzD4K,CAAA,CAAMxH,IAAA,CAAKgkD,gBAAA,CAAiB34C,MAAA,CAAOlP,CAAA,CAAQkoD,sBAAA,CAAuBznD,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA+B,KAAKI,IAAA,IAAQC,MAAA;YACjI,IAAiC,QAA7BxlD,CAAA,CAAQgoD,iBAAA,IAA6BhoD,CAAA,CAAQgoD,iBAAA,CAAkBlmD,MAAA,EAC/D,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQgoD,iBAAA,CAAkBlmD,MAAA,IAAUrB,CAAA,EACpD4K,CAAA,CAAMxH,IAAA,CAAK8hD,iBAAA,CAAkBz2C,MAAA,CAAOlP,CAAA,CAAQgoD,iBAAA,CAAkBvnD,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA+B,KAAKI,IAAA,IAAQC,MAAA;YAC7H,OAAOvlD,CACX;UAAA,GAWAD,CAAA,CAAW4lD,eAAA,GAAkB,UAAyB5lD,CAAA,EAASC,CAAA;YAC3D,OAAO,KAAKiP,MAAA,CAAOlP,CAAA,EAASC,CAAA,EAAQulD,MAAA,EACxC;UAAA,GAaAxlD,CAAA,CAAWmP,MAAA,GAAS,UAAgBnP,CAAA,EAAQC,CAAA;YAClCD,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAASsD,CAAA,CAAQm8B,MAAA,CAAOz/B,CAAA;YAE5B,KADA,IAAIS,CAAA,QAAiB,MAAXR,CAAA,GAAuBD,CAAA,CAAO6lD,GAAA,GAAM7lD,CAAA,CAAO8lD,GAAA,GAAM7lD,CAAA,EAAQO,CAAA,GAAU,IAAI6K,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,IACrFr8B,CAAA,CAAO8lD,GAAA,GAAMrlD,CAAA,GAAK;cACrB,IAAIC,CAAA,GAAMV,CAAA,CAAOmlD,MAAA;cACjB,QAAQzkD,CAAA,KAAQ;gBAChB,KAAK;kBACSF,CAAA,CAAQ25B,IAAA,IAAQ35B,CAAA,CAAQ25B,IAAA,CAAKr4B,MAAA,KAC/BtB,CAAA,CAAQ25B,IAAA,GAAO,KACnB35B,CAAA,CAAQ25B,IAAA,CAAKnzB,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAKw3B,SAAA,CAAUlsB,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBAC7D;gBAER,KAAK;kBACG3kD,CAAA,CAAQwD,IAAA,GAAOhE,CAAA,CAAOolD,MAAA;kBACtB;gBAER,KAAK;kBACS5kD,CAAA,CAAQi8B,WAAA,IAAej8B,CAAA,CAAQi8B,WAAA,CAAY36B,MAAA,KAC7CtB,CAAA,CAAQi8B,WAAA,GAAc,KAC1Bj8B,CAAA,CAAQi8B,WAAA,CAAYz1B,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAY9qC,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBACtE;gBAER,KAAK;kBACS3kD,CAAA,CAAQwnD,iBAAA,IAAqBxnD,CAAA,CAAQwnD,iBAAA,CAAkBlmD,MAAA,KACzDtB,CAAA,CAAQwnD,iBAAA,GAAoB,KAChCxnD,CAAA,CAAQwnD,iBAAA,CAAkBhhD,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAK8hD,iBAAA,CAAkBx2C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBAClF;gBAER,KAAK;kBACG3kD,CAAA,CAAQkqC,SAAA,GAAY1qC,CAAA,CAAOolD,MAAA;kBAC3B;gBAER,KAAK;kBACS5kD,CAAA,CAAQg8B,KAAA,IAASh8B,CAAA,CAAQg8B,KAAA,CAAM16B,MAAA,KACjCtB,CAAA,CAAQg8B,KAAA,GAAQ,KACpBh8B,CAAA,CAAQg8B,KAAA,CAAMx1B,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAKojD,cAAA,CAAe93C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBACnE;gBAER,KAAK;kBACS3kD,CAAA,CAAQsJ,MAAA,IAAUtJ,CAAA,CAAQsJ,MAAA,CAAOhI,MAAA,KACnCtB,CAAA,CAAQsJ,MAAA,GAAS,KACrBtJ,CAAA,CAAQsJ,MAAA,CAAO9C,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAKojD,cAAA,CAAe93C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBACpE;gBAER,KAAK;kBACS3kD,CAAA,CAAQynD,SAAA,IAAaznD,CAAA,CAAQynD,SAAA,CAAUnmD,MAAA,KACzCtB,CAAA,CAAQynD,SAAA,GAAY,KACxBznD,CAAA,CAAQynD,SAAA,CAAUjhD,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAKojD,cAAA,CAAe93C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBACvE;gBAER,KAAK;kBACS3kD,CAAA,CAAQ0nD,sBAAA,IAA0B1nD,CAAA,CAAQ0nD,sBAAA,CAAuBpmD,MAAA,KACnEtB,CAAA,CAAQ0nD,sBAAA,GAAyB,KACrC1nD,CAAA,CAAQ0nD,sBAAA,CAAuBlhD,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAKgkD,gBAAA,CAAiB14C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBACtF;gBAER;kBACInlD,CAAA,CAAO+lD,QAAA,CAAe,IAANrlD,CAAA;cAAA;YAGxB;YACA,OAAOF,CACX;UAAA,GAYAR,CAAA,CAAWgmD,eAAA,GAAkB,UAAyBhmD,CAAA;YAGlD,OAFMA,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAAS,IAAIsD,CAAA,CAAQtD,CAAA,IAClB,KAAKmP,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,GACtC;UAAA,GAUAnlD,CAAA,CAAWimD,MAAA,GAAS,UAAgBjmD,CAAA;YAChC,IAAuB,mBAAZA,CAAA,IAAoC,SAAZA,CAAA,EAC/B,OAAO;YACX,IAAoB,QAAhBA,CAAA,CAAQm6B,IAAA,IAAgBn6B,CAAA,CAAQmlB,cAAA,CAAe,SAAS;cACxD,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQm6B,IAAA,GACvB,OAAO;cACX,KAAK,IAAIl6B,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQm6B,IAAA,CAAKr4B,MAAA,IAAU7B,CAAA,EAEvC,IADIQ,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAKw3B,SAAA,CAAU4qB,MAAA,CAAOjmD,CAAA,CAAQm6B,IAAA,CAAKl6B,CAAA,IAEjD,OAAO,UAAUQ,CAE7B;YAAA;YACA,IAAoB,QAAhBT,CAAA,CAAQgE,IAAA,IAAgBhE,CAAA,CAAQmlB,cAAA,CAAe,YAC1C1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQgE,IAAA,GACxB,OAAO;YACf,IAA2B,QAAvBhE,CAAA,CAAQy8B,WAAA,IAAuBz8B,CAAA,CAAQmlB,cAAA,CAAe,gBAAgB;cACtE,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQy8B,WAAA,GACvB,OAAO;cACX,KAASx8B,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQy8B,WAAA,CAAY36B,MAAA,IAAU7B,CAAA,EAE9C,IADIQ,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYgM,MAAA,CAAOjmD,CAAA,CAAQy8B,WAAA,CAAYx8B,CAAA,IAE1D,OAAO,iBAAiBQ,CAEpC;YAAA;YACA,IAAiC,QAA7BT,CAAA,CAAQgoD,iBAAA,IAA6BhoD,CAAA,CAAQmlB,cAAA,CAAe,sBAAsB;cAClF,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQgoD,iBAAA,GACvB,OAAO;cACX,KAAS/nD,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQgoD,iBAAA,CAAkBlmD,MAAA,IAAU7B,CAAA,EAEpD,IADIQ,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAK8hD,iBAAA,CAAkBM,MAAA,CAAOjmD,CAAA,CAAQgoD,iBAAA,CAAkB/nD,CAAA,IAEtE,OAAO,uBAAuBQ,CAE1C;YAAA;YACA,IAAyB,QAArBT,CAAA,CAAQ0qC,SAAA,IAAqB1qC,CAAA,CAAQmlB,cAAA,CAAe,iBAC/C1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQ0qC,SAAA,GACxB,OAAO;YACf,IAAqB,QAAjB1qC,CAAA,CAAQw8B,KAAA,IAAiBx8B,CAAA,CAAQmlB,cAAA,CAAe,UAAU;cAC1D,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQw8B,KAAA,GACvB,OAAO;cACX,KAASv8B,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQw8B,KAAA,CAAM16B,MAAA,IAAU7B,CAAA,EAExC,IADIQ,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAKojD,cAAA,CAAehB,MAAA,CAAOjmD,CAAA,CAAQw8B,KAAA,CAAMv8B,CAAA,IAEvD,OAAO,WAAWQ,CAE9B;YAAA;YACA,IAAsB,QAAlBT,CAAA,CAAQ8J,MAAA,IAAkB9J,CAAA,CAAQmlB,cAAA,CAAe,WAAW;cAC5D,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQ8J,MAAA,GACvB,OAAO;cACX,KAAS7J,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQ8J,MAAA,CAAOhI,MAAA,IAAU7B,CAAA,EAEzC,IADIQ,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAKojD,cAAA,CAAehB,MAAA,CAAOjmD,CAAA,CAAQ8J,MAAA,CAAO7J,CAAA,IAExD,OAAO,YAAYQ,CAE/B;YAAA;YACA,IAAyB,QAArBT,CAAA,CAAQioD,SAAA,IAAqBjoD,CAAA,CAAQmlB,cAAA,CAAe,cAAc;cAClE,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQioD,SAAA,GACvB,OAAO;cACX,KAAShoD,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQioD,SAAA,CAAUnmD,MAAA,IAAU7B,CAAA,EAE5C,IADIQ,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAKojD,cAAA,CAAehB,MAAA,CAAOjmD,CAAA,CAAQioD,SAAA,CAAUhoD,CAAA,IAE3D,OAAO,eAAeQ,CAElC;YAAA;YACA,IAAsC,QAAlCT,CAAA,CAAQkoD,sBAAA,IAAkCloD,CAAA,CAAQmlB,cAAA,CAAe,2BAA2B;cAC5F,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQkoD,sBAAA,GACvB,OAAO;cACX,KAASjoD,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQkoD,sBAAA,CAAuBpmD,MAAA,IAAU7B,CAAA,EAAG;gBAC5D,IAAIQ,CAAA;gBACJ,IADIA,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAKgkD,gBAAA,CAAiB5B,MAAA,CAAOjmD,CAAA,CAAQkoD,sBAAA,CAAuBjoD,CAAA,IAE1E,OAAO,4BAA4BQ,CAC3C;cAAA;YACJ;YACA,OAAO,IACX;UAAA,GAUAT,CAAA,CAAWmmD,UAAA,GAAa,UAAoBnmD,CAAA;YACxC,IAAIA,CAAA,YAAkBqL,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA,EAC7B,OAAOr8B,CAAA;YACX,IAAIC,CAAA,GAAU,IAAIoL,CAAA,CAAMxH,IAAA,CAAKw4B,UAAA;YAC7B,IAAIr8B,CAAA,CAAOm6B,IAAA,EAAM;cACb,KAAKn0B,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOm6B,IAAA,GACtB,MAAMpY,SAAA,CAAU;cACpB9hB,CAAA,CAAQk6B,IAAA,GAAO;cACf,KAAK,IAAI15B,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOm6B,IAAA,CAAKr4B,MAAA,IAAUrB,CAAA,EAAG;gBACzC,IAA8B,mBAAnBT,CAAA,CAAOm6B,IAAA,CAAK15B,CAAA,GACnB,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQk6B,IAAA,CAAK15B,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAKw3B,SAAA,CAAU8qB,UAAA,CAAWnmD,CAAA,CAAOm6B,IAAA,CAAK15B,CAAA,EAClE;cAAA;YACJ;YAGA,IAFmB,QAAfT,CAAA,CAAOgE,IAAA,KACP/D,CAAA,CAAQ+D,IAAA,GAAOoiD,MAAA,CAAOpmD,CAAA,CAAOgE,IAAA,IAC7BhE,CAAA,CAAOy8B,WAAA,EAAa;cACpB,KAAKz2B,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOy8B,WAAA,GACtB,MAAM1a,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQw8B,WAAA,GAAc,IACbh8B,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOy8B,WAAA,CAAY36B,MAAA,IAAUrB,CAAA,EAAG;gBAChD,IAAqC,mBAA1BT,CAAA,CAAOy8B,WAAA,CAAYh8B,CAAA,GAC1B,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQw8B,WAAA,CAAYh8B,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYkM,UAAA,CAAWnmD,CAAA,CAAOy8B,WAAA,CAAYh8B,CAAA,EAClF;cAAA;YACJ;YACA,IAAIT,CAAA,CAAOgoD,iBAAA,EAAmB;cAC1B,KAAKhiD,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOgoD,iBAAA,GACtB,MAAMjmC,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQ+nD,iBAAA,GAAoB,IACnBvnD,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOgoD,iBAAA,CAAkBlmD,MAAA,IAAUrB,CAAA,EAAG;gBACtD,IAA2C,mBAAhCT,CAAA,CAAOgoD,iBAAA,CAAkBvnD,CAAA,GAChC,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQ+nD,iBAAA,CAAkBvnD,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAK8hD,iBAAA,CAAkBQ,UAAA,CAAWnmD,CAAA,CAAOgoD,iBAAA,CAAkBvnD,CAAA,EACpG;cAAA;YACJ;YAGA,IAFwB,QAApBT,CAAA,CAAO0qC,SAAA,KACPzqC,CAAA,CAAQyqC,SAAA,GAAY0b,MAAA,CAAOpmD,CAAA,CAAO0qC,SAAA,IAClC1qC,CAAA,CAAOw8B,KAAA,EAAO;cACd,KAAKx2B,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOw8B,KAAA,GACtB,MAAMza,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQu8B,KAAA,GAAQ,IACP/7B,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOw8B,KAAA,CAAM16B,MAAA,IAAUrB,CAAA,EAAG;gBAC1C,IAA+B,mBAApBT,CAAA,CAAOw8B,KAAA,CAAM/7B,CAAA,GACpB,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQu8B,KAAA,CAAM/7B,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAKojD,cAAA,CAAed,UAAA,CAAWnmD,CAAA,CAAOw8B,KAAA,CAAM/7B,CAAA,EACzE;cAAA;YACJ;YACA,IAAIT,CAAA,CAAO8J,MAAA,EAAQ;cACf,KAAK9D,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAO8J,MAAA,GACtB,MAAMiY,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQ6J,MAAA,GAAS,IACRrJ,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAO8J,MAAA,CAAOhI,MAAA,IAAUrB,CAAA,EAAG;gBAC3C,IAAgC,mBAArBT,CAAA,CAAO8J,MAAA,CAAOrJ,CAAA,GACrB,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQ6J,MAAA,CAAOrJ,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAKojD,cAAA,CAAed,UAAA,CAAWnmD,CAAA,CAAO8J,MAAA,CAAOrJ,CAAA,EAC3E;cAAA;YACJ;YACA,IAAIT,CAAA,CAAOioD,SAAA,EAAW;cAClB,KAAKjiD,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOioD,SAAA,GACtB,MAAMlmC,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQgoD,SAAA,GAAY,IACXxnD,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOioD,SAAA,CAAUnmD,MAAA,IAAUrB,CAAA,EAAG;gBAC9C,IAAmC,mBAAxBT,CAAA,CAAOioD,SAAA,CAAUxnD,CAAA,GACxB,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQgoD,SAAA,CAAUxnD,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAKojD,cAAA,CAAed,UAAA,CAAWnmD,CAAA,CAAOioD,SAAA,CAAUxnD,CAAA,EACjF;cAAA;YACJ;YACA,IAAIT,CAAA,CAAOkoD,sBAAA,EAAwB;cAC/B,KAAKliD,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOkoD,sBAAA,GACtB,MAAMnmC,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQioD,sBAAA,GAAyB,IACxBznD,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOkoD,sBAAA,CAAuBpmD,MAAA,IAAUrB,CAAA,EAAG;gBAC3D,IAAgD,mBAArCT,CAAA,CAAOkoD,sBAAA,CAAuBznD,CAAA,GACrC,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQioD,sBAAA,CAAuBznD,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAKgkD,gBAAA,CAAiB1B,UAAA,CAAWnmD,CAAA,CAAOkoD,sBAAA,CAAuBznD,CAAA,EAC7G;cAAA;YACJ;YACA,OAAOR,CACX;UAAA,GAWAD,CAAA,CAAWumD,QAAA,GAAW,UAAkBvmD,CAAA,EAASC,CAAA;YACxCA,CAAA,KACDA,CAAA,GAAU,CAAC;YACf,IAAIQ,CAAA,GAAS,CAAC;YAcd,KAbIR,CAAA,CAAQumD,MAAA,IAAUvmD,CAAA,CAAQwmD,QAAA,MAC1BhmD,CAAA,CAAO05B,IAAA,GAAO,IACd15B,CAAA,CAAOg8B,WAAA,GAAc,IACrBh8B,CAAA,CAAO+7B,KAAA,GAAQ,IACf/7B,CAAA,CAAOqJ,MAAA,GAAS,IAChBrJ,CAAA,CAAOwnD,SAAA,GAAY,IACnBxnD,CAAA,CAAOynD,sBAAA,GAAyB,IAChCznD,CAAA,CAAOunD,iBAAA,GAAoB,KAE3B/nD,CAAA,CAAQwmD,QAAA,KACRhmD,CAAA,CAAOuD,IAAA,GAAO,IACdvD,CAAA,CAAOiqC,SAAA,GAAY,KAEnB1qC,CAAA,CAAQm6B,IAAA,IAAQn6B,CAAA,CAAQm6B,IAAA,CAAKr4B,MAAA,EAAQ;cACrCrB,CAAA,CAAO05B,IAAA,GAAO;cACd,KAAK,IAAI35B,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQm6B,IAAA,CAAKr4B,MAAA,IAAUtB,CAAA,EACvCC,CAAA,CAAO05B,IAAA,CAAK35B,CAAA,IAAK6K,CAAA,CAAMxH,IAAA,CAAKw3B,SAAA,CAAUkrB,QAAA,CAASvmD,CAAA,CAAQm6B,IAAA,CAAK35B,CAAA,GAAIP,CAAA,CACxE;YAAA;YAGA,IAFoB,QAAhBD,CAAA,CAAQgE,IAAA,IAAgBhE,CAAA,CAAQmlB,cAAA,CAAe,YAC/C1kB,CAAA,CAAOuD,IAAA,GAAOhE,CAAA,CAAQgE,IAAA,GACtBhE,CAAA,CAAQy8B,WAAA,IAAez8B,CAAA,CAAQy8B,WAAA,CAAY36B,MAAA,EAE3C,KADArB,CAAA,CAAOg8B,WAAA,GAAc,IACZj8B,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQy8B,WAAA,CAAY36B,MAAA,IAAUtB,CAAA,EAC9CC,CAAA,CAAOg8B,WAAA,CAAYj8B,CAAA,IAAK6K,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYsM,QAAA,CAASvmD,CAAA,CAAQy8B,WAAA,CAAYj8B,CAAA,GAAIP,CAAA;YAIxF,IAFyB,QAArBD,CAAA,CAAQ0qC,SAAA,IAAqB1qC,CAAA,CAAQmlB,cAAA,CAAe,iBACpD1kB,CAAA,CAAOiqC,SAAA,GAAY1qC,CAAA,CAAQ0qC,SAAA,GAC3B1qC,CAAA,CAAQw8B,KAAA,IAASx8B,CAAA,CAAQw8B,KAAA,CAAM16B,MAAA,EAE/B,KADArB,CAAA,CAAO+7B,KAAA,GAAQ,IACNh8B,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQw8B,KAAA,CAAM16B,MAAA,IAAUtB,CAAA,EACxCC,CAAA,CAAO+7B,KAAA,CAAMh8B,CAAA,IAAK6K,CAAA,CAAMxH,IAAA,CAAKojD,cAAA,CAAeV,QAAA,CAASvmD,CAAA,CAAQw8B,KAAA,CAAMh8B,CAAA,GAAIP,CAAA;YAE/E,IAAID,CAAA,CAAQ8J,MAAA,IAAU9J,CAAA,CAAQ8J,MAAA,CAAOhI,MAAA,EAEjC,KADArB,CAAA,CAAOqJ,MAAA,GAAS,IACPtJ,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQ8J,MAAA,CAAOhI,MAAA,IAAUtB,CAAA,EACzCC,CAAA,CAAOqJ,MAAA,CAAOtJ,CAAA,IAAK6K,CAAA,CAAMxH,IAAA,CAAKojD,cAAA,CAAeV,QAAA,CAASvmD,CAAA,CAAQ8J,MAAA,CAAOtJ,CAAA,GAAIP,CAAA;YAEjF,IAAID,CAAA,CAAQioD,SAAA,IAAajoD,CAAA,CAAQioD,SAAA,CAAUnmD,MAAA,EAEvC,KADArB,CAAA,CAAOwnD,SAAA,GAAY,IACVznD,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQioD,SAAA,CAAUnmD,MAAA,IAAUtB,CAAA,EAC5CC,CAAA,CAAOwnD,SAAA,CAAUznD,CAAA,IAAK6K,CAAA,CAAMxH,IAAA,CAAKojD,cAAA,CAAeV,QAAA,CAASvmD,CAAA,CAAQioD,SAAA,CAAUznD,CAAA,GAAIP,CAAA;YAEvF,IAAID,CAAA,CAAQkoD,sBAAA,IAA0BloD,CAAA,CAAQkoD,sBAAA,CAAuBpmD,MAAA,EAEjE,KADArB,CAAA,CAAOynD,sBAAA,GAAyB,IACvB1nD,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQkoD,sBAAA,CAAuBpmD,MAAA,IAAUtB,CAAA,EACzDC,CAAA,CAAOynD,sBAAA,CAAuB1nD,CAAA,IAAK6K,CAAA,CAAMxH,IAAA,CAAKgkD,gBAAA,CAAiBtB,QAAA,CAASvmD,CAAA,CAAQkoD,sBAAA,CAAuB1nD,CAAA,GAAIP,CAAA;YAEnH,IAAID,CAAA,CAAQgoD,iBAAA,IAAqBhoD,CAAA,CAAQgoD,iBAAA,CAAkBlmD,MAAA,EAEvD,KADArB,CAAA,CAAOunD,iBAAA,GAAoB,IAClBxnD,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQgoD,iBAAA,CAAkBlmD,MAAA,IAAUtB,CAAA,EACpDC,CAAA,CAAOunD,iBAAA,CAAkBxnD,CAAA,IAAK6K,CAAA,CAAMxH,IAAA,CAAK8hD,iBAAA,CAAkBY,QAAA,CAASvmD,CAAA,CAAQgoD,iBAAA,CAAkBxnD,CAAA,GAAIP,CAAA;YAE1G,OAAOQ,CACX;UAAA,GASAT,CAAA,CAAW6kD,SAAA,CAAUiC,MAAA,GAAS;YAC1B,OAAO,KAAKlkD,WAAA,CAAY2jD,QAAA,CAAS,MAAMrlD,CAAA,CAAUsjD,IAAA,CAAKuC,aAAA,CAC1D;UAAA,GAUA/mD,CAAA,CAAWgnD,UAAA,GAAa,UAAoBhnD,CAAA;YAIxC,YAHsB,MAAlBA,CAAA,KACAA,CAAA,GAAgB,wBAEbA,CAAA,GAAgB,kBAC3B;UAAA,GAEOA,CACV;QAAA,CAvhBiB,IAyhBlBiB,CAAA,CAAKg5C,WAAA,GAAc;UA8Bf,SAASj6C,EAAYA,CAAA;YASjB,IARA,KAAK6T,IAAA,GAAO,IACZ,KAAKyQ,SAAA,GAAY,IACjB,KAAK61B,SAAA,GAAY,IACjB,KAAK1L,UAAA,GAAa,IAClB,KAAK2L,SAAA,GAAY,IACjB,KAAK+N,YAAA,GAAe,IACpB,KAAK9N,UAAA,GAAa,IAClB,KAAKC,UAAA,GAAa,IACdt6C,CAAA,EACA,KAAK,IAAIC,CAAA,GAAO4C,MAAA,CAAO6N,IAAA,CAAK1Q,CAAA,GAAaS,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK6B,MAAA,IAAUrB,CAAA,EACpC,QAAvBT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,OAChB,KAAKR,CAAA,CAAKQ,CAAA,KAAMT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,GAChD;UAAA;UAmgCA,OA3/BAT,CAAA,CAAY6kD,SAAA,CAAUhxC,IAAA,GAAOpJ,CAAA,CAAMy6C,UAAA,EAQnCllD,CAAA,CAAY6kD,SAAA,CAAUloB,QAAA,GAAW,GAQjC38B,CAAA,CAAY6kD,SAAA,CAAUuD,OAAA,GAAU,MAQhCpoD,CAAA,CAAY6kD,SAAA,CAAUvgC,SAAA,GAAY7Z,CAAA,CAAMy6C,UAAA,EAQxCllD,CAAA,CAAY6kD,SAAA,CAAU1K,SAAA,GAAY1vC,CAAA,CAAMy6C,UAAA,EAQxCllD,CAAA,CAAY6kD,SAAA,CAAUpW,UAAA,GAAahkC,CAAA,CAAMy6C,UAAA,EAQzCllD,CAAA,CAAY6kD,SAAA,CAAUzK,SAAA,GAAY3vC,CAAA,CAAMy6C,UAAA,EAQxCllD,CAAA,CAAY6kD,SAAA,CAAU7gD,IAAA,GAAO,IAQ7BhE,CAAA,CAAY6kD,SAAA,CAAUna,SAAA,GAAY,IAQlC1qC,CAAA,CAAY6kD,SAAA,CAAUvW,OAAA,GAAU7jC,CAAA,CAAMs6C,SAAA,CAAU,KAQhD/kD,CAAA,CAAY6kD,SAAA,CAAUsD,YAAA,GAAe19C,CAAA,CAAMy6C,UAAA,EAQ3CllD,CAAA,CAAY6kD,SAAA,CAAUwD,YAAA,GAAe,GAQrCroD,CAAA,CAAY6kD,SAAA,CAAUxK,UAAA,GAAa5vC,CAAA,CAAMy6C,UAAA,EAQzCllD,CAAA,CAAY6kD,SAAA,CAAUvK,UAAA,GAAa7vC,CAAA,CAAMy6C,UAAA,EAUzCllD,CAAA,CAAYy/B,MAAA,GAAS,UAAgBx/B,CAAA;YACjC,OAAO,IAAID,CAAA,CAAYC,CAAA,CAC3B;UAAA,GAWAD,CAAA,CAAYkP,MAAA,GAAS,UAAgBlP,CAAA,EAASC,CAAA;YAG1C,IAFKA,CAAA,KACDA,CAAA,GAASyD,CAAA,CAAQ+7B,MAAA,KACD,QAAhBz/B,CAAA,CAAQ6T,IAAA,IAAgB7T,CAAA,CAAQ6T,IAAA,CAAK/R,MAAA,EAAQ;cAC7C7B,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA;cACzC,KAAK,IAAI9kD,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQ6T,IAAA,CAAK/R,MAAA,IAAUrB,CAAA,EACvCR,CAAA,CAAOqlD,KAAA,CAAMtlD,CAAA,CAAQ6T,IAAA,CAAKpT,CAAA;cAC9BR,CAAA,CAAOulD,MAAA,EACX;YAAA;YAKA,IAJwB,QAApBxlD,CAAA,CAAQ28B,QAAA,IAAoB95B,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,eAChEC,CAAA,CAAOklD,MAAA,CAA8B,IAAIO,KAAA,CAAM1lD,CAAA,CAAQ28B,QAAA,GACpC,QAAnB38B,CAAA,CAAQooD,OAAA,IAAmBvlD,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,cAC/DqL,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYqO,OAAA,CAAQp5C,MAAA,CAAOlP,CAAA,CAAQooD,OAAA,EAASnoD,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA,IACnF,QAArBxlD,CAAA,CAAQskB,SAAA,IAAqBtkB,CAAA,CAAQskB,SAAA,CAAUxiB,MAAA,EAAQ;cAEvD,KADA7B,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAChC9kD,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQskB,SAAA,CAAUxiB,MAAA,IAAUrB,CAAA,EAC5CR,CAAA,CAAOolD,KAAA,CAAMrlD,CAAA,CAAQskB,SAAA,CAAU7jB,CAAA;cACnCR,CAAA,CAAOulD,MAAA,EACX;YAAA;YACA,IAAyB,QAArBxlD,CAAA,CAAQm6C,SAAA,IAAqBn6C,CAAA,CAAQm6C,SAAA,CAAUr4C,MAAA,EAAQ;cAEvD,KADA7B,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAChC9kD,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQm6C,SAAA,CAAUr4C,MAAA,IAAUrB,CAAA,EAC5CR,CAAA,CAAOylD,KAAA,CAAM1lD,CAAA,CAAQm6C,SAAA,CAAU15C,CAAA;cACnCR,CAAA,CAAOulD,MAAA,EACX;YAAA;YACA,IAA0B,QAAtBxlD,CAAA,CAAQyuC,UAAA,IAAsBzuC,CAAA,CAAQyuC,UAAA,CAAW3sC,MAAA,EACjD,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQyuC,UAAA,CAAW3sC,MAAA,IAAUrB,CAAA,EAC7CR,CAAA,CAAOklD,MAAA,CAA8B,IAAIla,KAAA,CAAMjrC,CAAA,CAAQyuC,UAAA,CAAWhuC,CAAA;YAC1E,IAAyB,QAArBT,CAAA,CAAQo6C,SAAA,IAAqBp6C,CAAA,CAAQo6C,SAAA,CAAUt4C,MAAA,EAAQ;cAEvD,KADA7B,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAChC9kD,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQo6C,SAAA,CAAUt4C,MAAA,IAAUrB,CAAA,EAC5CR,CAAA,CAAOqlD,KAAA,CAAMtlD,CAAA,CAAQo6C,SAAA,CAAU35C,CAAA;cACnCR,CAAA,CAAOulD,MAAA,EACX;YAAA;YAKA,IAJoB,QAAhBxlD,CAAA,CAAQgE,IAAA,IAAgBnB,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,WAC5DC,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQgE,IAAA,GACrC,QAAnBhE,CAAA,CAAQsuC,OAAA,IAAmBzrC,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,cAC/DC,CAAA,CAAOklD,MAAA,CAA8B,IAAIla,KAAA,CAAMjrC,CAAA,CAAQsuC,OAAA,GACjC,QAAtBtuC,CAAA,CAAQq6C,UAAA,IAAsBr6C,CAAA,CAAQq6C,UAAA,CAAWv4C,MAAA,EAAQ;cAEzD,KADA7B,CAAA,CAAOklD,MAAA,CAA+B,IAAII,IAAA,IACjC9kD,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQq6C,UAAA,CAAWv4C,MAAA,IAAUrB,CAAA,EAC7CR,CAAA,CAAOsoD,MAAA,CAAOvoD,CAAA,CAAQq6C,UAAA,CAAW55C,CAAA;cACrCR,CAAA,CAAOulD,MAAA,EACX;YAAA;YACA,IAA0B,QAAtBxlD,CAAA,CAAQs6C,UAAA,IAAsBt6C,CAAA,CAAQs6C,UAAA,CAAWx4C,MAAA,EAAQ;cAEzD,KADA7B,CAAA,CAAOklD,MAAA,CAA+B,IAAII,IAAA,IACjC9kD,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQs6C,UAAA,CAAWx4C,MAAA,IAAUrB,CAAA,EAC7CR,CAAA,CAAOuoD,MAAA,CAAOxoD,CAAA,CAAQs6C,UAAA,CAAW75C,CAAA;cACrCR,CAAA,CAAOulD,MAAA,EACX;YAAA;YAGA,IAFyB,QAArBxlD,CAAA,CAAQ0qC,SAAA,IAAqB7nC,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,gBACjEC,CAAA,CAAOklD,MAAA,CAA+B,IAAIC,MAAA,CAAOplD,CAAA,CAAQ0qC,SAAA,GACjC,QAAxB1qC,CAAA,CAAQmoD,YAAA,IAAwBnoD,CAAA,CAAQmoD,YAAA,CAAarmD,MAAA,EACrD,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQmoD,YAAA,CAAarmD,MAAA,IAAUrB,CAAA,EAC/C4K,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBr4C,MAAA,CAAOlP,CAAA,CAAQmoD,YAAA,CAAa1nD,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA+B,KAAKI,IAAA,IAAQC,MAAA;YAG7H,OAF4B,QAAxBxlD,CAAA,CAAQqoD,YAAA,IAAwBxlD,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,mBACpEC,CAAA,CAAOklD,MAAA,CAA+B,KAAKO,KAAA,CAAM1lD,CAAA,CAAQqoD,YAAA,GACtDpoD,CACX;UAAA,GAWAD,CAAA,CAAY4lD,eAAA,GAAkB,UAAyB5lD,CAAA,EAASC,CAAA;YAC5D,OAAO,KAAKiP,MAAA,CAAOlP,CAAA,EAASC,CAAA,EAAQulD,MAAA,EACxC;UAAA,GAaAxlD,CAAA,CAAYmP,MAAA,GAAS,UAAgBnP,CAAA,EAAQC,CAAA;YACnCD,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAASsD,CAAA,CAAQm8B,MAAA,CAAOz/B,CAAA;YAE5B,KADA,IAAIS,CAAA,QAAiB,MAAXR,CAAA,GAAuBD,CAAA,CAAO6lD,GAAA,GAAM7lD,CAAA,CAAO8lD,GAAA,GAAM7lD,CAAA,EAAQO,CAAA,GAAU,IAAI6K,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,IACrFj6C,CAAA,CAAO8lD,GAAA,GAAMrlD,CAAA,GAAK;cACrB,IAAIC,CAAA,GAAMV,CAAA,CAAOmlD,MAAA;cACjB,QAAQzkD,CAAA,KAAQ;gBAChB,KAAK;kBAGG,IAFMF,CAAA,CAAQqT,IAAA,IAAQrT,CAAA,CAAQqT,IAAA,CAAK/R,MAAA,KAC/BtB,CAAA,CAAQqT,IAAA,GAAO,KACD,MAAP,IAANnT,CAAA,GAED,KADA,IAAIO,CAAA,GAAOjB,CAAA,CAAOmlD,MAAA,KAAWnlD,CAAA,CAAO8lD,GAAA,EAC7B9lD,CAAA,CAAO8lD,GAAA,GAAM7kD,CAAA,GAChBT,CAAA,CAAQqT,IAAA,CAAK7M,IAAA,CAAKhH,CAAA,CAAOslD,KAAA,SAE7B9kD,CAAA,CAAQqT,IAAA,CAAK7M,IAAA,CAAKhH,CAAA,CAAOslD,KAAA;kBAC7B;gBAER,KAAK;kBACG9kD,CAAA,CAAQm8B,QAAA,GAAW38B,CAAA,CAAO0lD,KAAA;kBAC1B;gBAER,KAAK;kBACGllD,CAAA,CAAQ4nD,OAAA,GAAU/8C,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYqO,OAAA,CAAQn5C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBACvE;gBAER,KAAK;kBAGG,IAFM3kD,CAAA,CAAQ8jB,SAAA,IAAa9jB,CAAA,CAAQ8jB,SAAA,CAAUxiB,MAAA,KACzCtB,CAAA,CAAQ8jB,SAAA,GAAY,KACN,MAAP,IAAN5jB,CAAA,GAED,KADIO,CAAA,GAAOjB,CAAA,CAAOmlD,MAAA,KAAWnlD,CAAA,CAAO8lD,GAAA,EAC7B9lD,CAAA,CAAO8lD,GAAA,GAAM7kD,CAAA,GAChBT,CAAA,CAAQ8jB,SAAA,CAAUtd,IAAA,CAAKhH,CAAA,CAAOqlD,KAAA,SAElC7kD,CAAA,CAAQ8jB,SAAA,CAAUtd,IAAA,CAAKhH,CAAA,CAAOqlD,KAAA;kBAClC;gBAER,KAAK;kBAGG,IAFM7kD,CAAA,CAAQ25C,SAAA,IAAa35C,CAAA,CAAQ25C,SAAA,CAAUr4C,MAAA,KACzCtB,CAAA,CAAQ25C,SAAA,GAAY,KACN,MAAP,IAANz5C,CAAA,GAED,KADIO,CAAA,GAAOjB,CAAA,CAAOmlD,MAAA,KAAWnlD,CAAA,CAAO8lD,GAAA,EAC7B9lD,CAAA,CAAO8lD,GAAA,GAAM7kD,CAAA,GAChBT,CAAA,CAAQ25C,SAAA,CAAUnzC,IAAA,CAAKhH,CAAA,CAAO0lD,KAAA,SAElCllD,CAAA,CAAQ25C,SAAA,CAAUnzC,IAAA,CAAKhH,CAAA,CAAO0lD,KAAA;kBAClC;gBAER,KAAK;kBACSllD,CAAA,CAAQiuC,UAAA,IAAcjuC,CAAA,CAAQiuC,UAAA,CAAW3sC,MAAA,KAC3CtB,CAAA,CAAQiuC,UAAA,GAAa,KACzBjuC,CAAA,CAAQiuC,UAAA,CAAWznC,IAAA,CAAKhH,CAAA,CAAOirC,KAAA;kBAC/B;gBAER,KAAK;kBAGG,IAFMzqC,CAAA,CAAQ45C,SAAA,IAAa55C,CAAA,CAAQ45C,SAAA,CAAUt4C,MAAA,KACzCtB,CAAA,CAAQ45C,SAAA,GAAY,KACN,MAAP,IAAN15C,CAAA,GAED,KADIO,CAAA,GAAOjB,CAAA,CAAOmlD,MAAA,KAAWnlD,CAAA,CAAO8lD,GAAA,EAC7B9lD,CAAA,CAAO8lD,GAAA,GAAM7kD,CAAA,GAChBT,CAAA,CAAQ45C,SAAA,CAAUpzC,IAAA,CAAKhH,CAAA,CAAOslD,KAAA,SAElC9kD,CAAA,CAAQ45C,SAAA,CAAUpzC,IAAA,CAAKhH,CAAA,CAAOslD,KAAA;kBAClC;gBAER,KAAK;kBACG9kD,CAAA,CAAQwD,IAAA,GAAOhE,CAAA,CAAOolD,MAAA;kBACtB;gBAER,KAAK;kBACG5kD,CAAA,CAAQkqC,SAAA,GAAY1qC,CAAA,CAAOolD,MAAA;kBAC3B;gBAER,KAAK;kBACG5kD,CAAA,CAAQ8tC,OAAA,GAAUtuC,CAAA,CAAOirC,KAAA;kBACzB;gBAER,KAAK;kBACSzqC,CAAA,CAAQ2nD,YAAA,IAAgB3nD,CAAA,CAAQ2nD,YAAA,CAAarmD,MAAA,KAC/CtB,CAAA,CAAQ2nD,YAAA,GAAe,KAC3B3nD,CAAA,CAAQ2nD,YAAA,CAAanhD,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBp4C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBAClF;gBAER,KAAK;kBACG3kD,CAAA,CAAQ6nD,YAAA,GAAeroD,CAAA,CAAO0lD,KAAA;kBAC9B;gBAER,KAAK;kBAGG,IAFMllD,CAAA,CAAQ65C,UAAA,IAAc75C,CAAA,CAAQ65C,UAAA,CAAWv4C,MAAA,KAC3CtB,CAAA,CAAQ65C,UAAA,GAAa,KACP,MAAP,IAAN35C,CAAA,GAED,KADIO,CAAA,GAAOjB,CAAA,CAAOmlD,MAAA,KAAWnlD,CAAA,CAAO8lD,GAAA,EAC7B9lD,CAAA,CAAO8lD,GAAA,GAAM7kD,CAAA,GAChBT,CAAA,CAAQ65C,UAAA,CAAWrzC,IAAA,CAAKhH,CAAA,CAAOuoD,MAAA,SAEnC/nD,CAAA,CAAQ65C,UAAA,CAAWrzC,IAAA,CAAKhH,CAAA,CAAOuoD,MAAA;kBACnC;gBAER,KAAK;kBAGG,IAFM/nD,CAAA,CAAQ85C,UAAA,IAAc95C,CAAA,CAAQ85C,UAAA,CAAWx4C,MAAA,KAC3CtB,CAAA,CAAQ85C,UAAA,GAAa,KACP,MAAP,IAAN55C,CAAA,GAED,KADIO,CAAA,GAAOjB,CAAA,CAAOmlD,MAAA,KAAWnlD,CAAA,CAAO8lD,GAAA,EAC7B9lD,CAAA,CAAO8lD,GAAA,GAAM7kD,CAAA,GAChBT,CAAA,CAAQ85C,UAAA,CAAWtzC,IAAA,CAAKhH,CAAA,CAAOwoD,MAAA,SAEnChoD,CAAA,CAAQ85C,UAAA,CAAWtzC,IAAA,CAAKhH,CAAA,CAAOwoD,MAAA;kBACnC;gBAER;kBACIxoD,CAAA,CAAO+lD,QAAA,CAAe,IAANrlD,CAAA;cAAA;YAGxB;YACA,OAAOF,CACX;UAAA,GAYAR,CAAA,CAAYgmD,eAAA,GAAkB,UAAyBhmD,CAAA;YAGnD,OAFMA,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAAS,IAAIsD,CAAA,CAAQtD,CAAA,IAClB,KAAKmP,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,GACtC;UAAA,GAUAnlD,CAAA,CAAYimD,MAAA,GAAS,UAAgBjmD,CAAA;YACjC,IAAuB,mBAAZA,CAAA,IAAoC,SAAZA,CAAA,EAC/B,OAAO;YACX,IAAoB,QAAhBA,CAAA,CAAQ6T,IAAA,IAAgB7T,CAAA,CAAQmlB,cAAA,CAAe,SAAS;cACxD,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQ6T,IAAA,GACvB,OAAO;cACX,KAAK,IAAI5T,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQ6T,IAAA,CAAK/R,MAAA,IAAU7B,CAAA,EACvC,MAAKwK,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQ6T,IAAA,CAAK5T,CAAA,MAASD,CAAA,CAAQ6T,IAAA,CAAK5T,CAAA,KAAMwK,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQ6T,IAAA,CAAK5T,CAAA,EAAGk8C,GAAA,KAAQ1xC,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQ6T,IAAA,CAAK5T,CAAA,EAAGm8C,IAAA,IAClI,OAAO,+BACnB;YAAA;YACA,IAAwB,QAApBp8C,CAAA,CAAQ28B,QAAA,IAAoB38B,CAAA,CAAQmlB,cAAA,CAAe,gBAC9C1a,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQ28B,QAAA,GACzB,OAAO;YACf,IAAuB,QAAnB38B,CAAA,CAAQooD,OAAA,IAAmBpoD,CAAA,CAAQmlB,cAAA,CAAe,eAC9C1kB,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYqO,OAAA,CAAQrC,MAAA,CAAOjmD,CAAA,CAAQooD,OAAA,IAEtD,OAAO,aAAa3nD,CAAA;YAE5B,IAAyB,QAArBT,CAAA,CAAQskB,SAAA,IAAqBtkB,CAAA,CAAQmlB,cAAA,CAAe,cAAc;cAClE,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQskB,SAAA,GACvB,OAAO;cACX,KAASrkB,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQskB,SAAA,CAAUxiB,MAAA,IAAU7B,CAAA,EAC5C,IAAoC,mBAAzBD,CAAA,CAAQskB,SAAA,CAAUrkB,CAAA,GACzB,OAAO,8BACnB;YAAA;YACA,IAAyB,QAArBD,CAAA,CAAQm6C,SAAA,IAAqBn6C,CAAA,CAAQmlB,cAAA,CAAe,cAAc;cAClE,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQm6C,SAAA,GACvB,OAAO;cACX,KAASl6C,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQm6C,SAAA,CAAUr4C,MAAA,IAAU7B,CAAA,EAC5C,KAAKwK,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQm6C,SAAA,CAAUl6C,CAAA,IACnC,OAAO,+BACnB;YAAA;YACA,IAA0B,QAAtBD,CAAA,CAAQyuC,UAAA,IAAsBzuC,CAAA,CAAQmlB,cAAA,CAAe,eAAe;cACpE,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQyuC,UAAA,GACvB,OAAO;cACX,KAASxuC,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQyuC,UAAA,CAAW3sC,MAAA,IAAU7B,CAAA,EAC7C,MAAMD,CAAA,CAAQyuC,UAAA,CAAWxuC,CAAA,KAA8C,mBAAjCD,CAAA,CAAQyuC,UAAA,CAAWxuC,CAAA,EAAG6B,MAAA,IAAuB2I,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQyuC,UAAA,CAAWxuC,CAAA,KACjH,OAAO,+BACnB;YAAA;YACA,IAAyB,QAArBD,CAAA,CAAQo6C,SAAA,IAAqBp6C,CAAA,CAAQmlB,cAAA,CAAe,cAAc;cAClE,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQo6C,SAAA,GACvB,OAAO;cACX,KAASn6C,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQo6C,SAAA,CAAUt4C,MAAA,IAAU7B,CAAA,EAC5C,MAAKwK,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQo6C,SAAA,CAAUn6C,CAAA,MAASD,CAAA,CAAQo6C,SAAA,CAAUn6C,CAAA,KAAMwK,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQo6C,SAAA,CAAUn6C,CAAA,EAAGk8C,GAAA,KAAQ1xC,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQo6C,SAAA,CAAUn6C,CAAA,EAAGm8C,IAAA,IACtJ,OAAO,oCACnB;YAAA;YACA,IAAoB,QAAhBp8C,CAAA,CAAQgE,IAAA,IAAgBhE,CAAA,CAAQmlB,cAAA,CAAe,YAC1C1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQgE,IAAA,GACxB,OAAO;YACf,IAAyB,QAArBhE,CAAA,CAAQ0qC,SAAA,IAAqB1qC,CAAA,CAAQmlB,cAAA,CAAe,iBAC/C1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQ0qC,SAAA,GACxB,OAAO;YACf,IAAuB,QAAnB1qC,CAAA,CAAQsuC,OAAA,IAAmBtuC,CAAA,CAAQmlB,cAAA,CAAe,gBAC5CnlB,CAAA,CAAQsuC,OAAA,IAA6C,mBAA3BtuC,CAAA,CAAQsuC,OAAA,CAAQxsC,MAAA,IAAuB2I,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQsuC,OAAA,IAC1F,OAAO;YACf,IAA4B,QAAxBtuC,CAAA,CAAQmoD,YAAA,IAAwBnoD,CAAA,CAAQmlB,cAAA,CAAe,iBAAiB;cACxE,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQmoD,YAAA,GACvB,OAAO;cACX,KAASloD,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQmoD,YAAA,CAAarmD,MAAA,IAAU7B,CAAA,EAAG;gBAClD,IAAIQ,CAAA;gBACJ,IADIA,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBtB,MAAA,CAAOjmD,CAAA,CAAQmoD,YAAA,CAAaloD,CAAA,IAEtE,OAAO,kBAAkBQ,CACjC;cAAA;YACJ;YACA,IAA4B,QAAxBT,CAAA,CAAQqoD,YAAA,IAAwBroD,CAAA,CAAQmlB,cAAA,CAAe,iBACvD,QAAQnlB,CAAA,CAAQqoD,YAAA;cAChB;gBACI,OAAO;cACX,KAAK;cACL,KAAK;YAAA;YAGT,IAA0B,QAAtBroD,CAAA,CAAQq6C,UAAA,IAAsBr6C,CAAA,CAAQmlB,cAAA,CAAe,eAAe;cACpE,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQq6C,UAAA,GACvB,OAAO;cACX,KAASp6C,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQq6C,UAAA,CAAWv4C,MAAA,IAAU7B,CAAA,EAC7C,IAAqC,mBAA1BD,CAAA,CAAQq6C,UAAA,CAAWp6C,CAAA,GAC1B,OAAO,+BACnB;YAAA;YACA,IAA0B,QAAtBD,CAAA,CAAQs6C,UAAA,IAAsBt6C,CAAA,CAAQmlB,cAAA,CAAe,eAAe;cACpE,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQs6C,UAAA,GACvB,OAAO;cACX,KAASr6C,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQs6C,UAAA,CAAWx4C,MAAA,IAAU7B,CAAA,EAC7C,MAAKwK,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQs6C,UAAA,CAAWr6C,CAAA,MAASD,CAAA,CAAQs6C,UAAA,CAAWr6C,CAAA,KAAMwK,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQs6C,UAAA,CAAWr6C,CAAA,EAAGk8C,GAAA,KAAQ1xC,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQs6C,UAAA,CAAWr6C,CAAA,EAAGm8C,IAAA,IAC1J,OAAO,qCACnB;YAAA;YACA,OAAO,IACX;UAAA,GAUAp8C,CAAA,CAAYmmD,UAAA,GAAa,UAAoBnmD,CAAA;YACzC,IAAIA,CAAA,YAAkBqL,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,EAC7B,OAAOj6C,CAAA;YACX,IAAIC,CAAA,GAAU,IAAIoL,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA;YAC7B,IAAIj6C,CAAA,CAAO6T,IAAA,EAAM;cACb,KAAK7N,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAO6T,IAAA,GACtB,MAAMkO,SAAA,CAAU;cACpB9hB,CAAA,CAAQ4T,IAAA,GAAO;cACf,KAAK,IAAIpT,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAO6T,IAAA,CAAK/R,MAAA,IAAUrB,CAAA,EAClCgK,CAAA,CAAMwxC,IAAA,IACLh8C,CAAA,CAAQ4T,IAAA,CAAKpT,CAAA,IAAKgK,CAAA,CAAMwxC,IAAA,CAAKC,SAAA,CAAUl8C,CAAA,CAAO6T,IAAA,CAAKpT,CAAA,IAAK47C,QAAA,IAAW,IACrC,mBAAnBr8C,CAAA,CAAO6T,IAAA,CAAKpT,CAAA,IACxBR,CAAA,CAAQ4T,IAAA,CAAKpT,CAAA,IAAKyhC,QAAA,CAASliC,CAAA,CAAO6T,IAAA,CAAKpT,CAAA,GAAI,MACZ,mBAAnBT,CAAA,CAAO6T,IAAA,CAAKpT,CAAA,IACxBR,CAAA,CAAQ4T,IAAA,CAAKpT,CAAA,IAAKT,CAAA,CAAO6T,IAAA,CAAKpT,CAAA,IACC,mBAAnBT,CAAA,CAAO6T,IAAA,CAAKpT,CAAA,MACxBR,CAAA,CAAQ4T,IAAA,CAAKpT,CAAA,IAAK,IAAIgK,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAO6T,IAAA,CAAKpT,CAAA,EAAG07C,GAAA,KAAQ,GAAGn8C,CAAA,CAAO6T,IAAA,CAAKpT,CAAA,EAAG27C,IAAA,KAAS,GAAGxB,QAAA,GACtG;YAAA;YAGA,IAFuB,QAAnB56C,CAAA,CAAO28B,QAAA,KACP18B,CAAA,CAAQ08B,QAAA,GAA6B,IAAlB38B,CAAA,CAAO28B,QAAA,GACR,QAAlB38B,CAAA,CAAOooD,OAAA,EAAiB;cACxB,IAA8B,mBAAnBpoD,CAAA,CAAOooD,OAAA,EACd,MAAMrmC,SAAA,CAAU;cACpB9hB,CAAA,CAAQmoD,OAAA,GAAU/8C,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYqO,OAAA,CAAQnC,UAAA,CAAWnmD,CAAA,CAAOooD,OAAA,CACvE;YAAA;YACA,IAAIpoD,CAAA,CAAOskB,SAAA,EAAW;cAClB,KAAKte,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOskB,SAAA,GACtB,MAAMvC,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQqkB,SAAA,GAAY,IACX7jB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOskB,SAAA,CAAUxiB,MAAA,IAAUrB,CAAA,EAC3CR,CAAA,CAAQqkB,SAAA,CAAU7jB,CAAA,IAAKiB,MAAA,CAAO1B,CAAA,CAAOskB,SAAA,CAAU7jB,CAAA,EACvD;YAAA;YACA,IAAIT,CAAA,CAAOm6C,SAAA,EAAW;cAClB,KAAKn0C,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOm6C,SAAA,GACtB,MAAMp4B,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQk6C,SAAA,GAAY,IACX15C,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOm6C,SAAA,CAAUr4C,MAAA,IAAUrB,CAAA,EAC3CR,CAAA,CAAQk6C,SAAA,CAAU15C,CAAA,IAA2B,IAAtBT,CAAA,CAAOm6C,SAAA,CAAU15C,CAAA,CAChD;YAAA;YACA,IAAIT,CAAA,CAAOyuC,UAAA,EAAY;cACnB,KAAKzoC,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOyuC,UAAA,GACtB,MAAM1sB,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQwuC,UAAA,GAAa,IACZhuC,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOyuC,UAAA,CAAW3sC,MAAA,IAAUrB,CAAA,EACR,mBAAzBT,CAAA,CAAOyuC,UAAA,CAAWhuC,CAAA,IACzBgK,CAAA,CAAM67C,MAAA,CAAOn3C,MAAA,CAAOnP,CAAA,CAAOyuC,UAAA,CAAWhuC,CAAA,GAAIR,CAAA,CAAQwuC,UAAA,CAAWhuC,CAAA,IAAKgK,CAAA,CAAMs6C,SAAA,CAAUt6C,CAAA,CAAM67C,MAAA,CAAOxkD,MAAA,CAAO9B,CAAA,CAAOyuC,UAAA,CAAWhuC,CAAA,KAAM,KACzHT,CAAA,CAAOyuC,UAAA,CAAWhuC,CAAA,EAAGqB,MAAA,IAAU,MACpC7B,CAAA,CAAQwuC,UAAA,CAAWhuC,CAAA,IAAKT,CAAA,CAAOyuC,UAAA,CAAWhuC,CAAA,EACtD;YAAA;YACA,IAAIT,CAAA,CAAOo6C,SAAA,EAAW;cAClB,KAAKp0C,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOo6C,SAAA,GACtB,MAAMr4B,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQm6C,SAAA,GAAY,IACX35C,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOo6C,SAAA,CAAUt4C,MAAA,IAAUrB,CAAA,EACvCgK,CAAA,CAAMwxC,IAAA,IACLh8C,CAAA,CAAQm6C,SAAA,CAAU35C,CAAA,IAAKgK,CAAA,CAAMwxC,IAAA,CAAKC,SAAA,CAAUl8C,CAAA,CAAOo6C,SAAA,CAAU35C,CAAA,IAAK47C,QAAA,IAAW,IAC1C,mBAAxBr8C,CAAA,CAAOo6C,SAAA,CAAU35C,CAAA,IAC7BR,CAAA,CAAQm6C,SAAA,CAAU35C,CAAA,IAAKyhC,QAAA,CAASliC,CAAA,CAAOo6C,SAAA,CAAU35C,CAAA,GAAI,MACjB,mBAAxBT,CAAA,CAAOo6C,SAAA,CAAU35C,CAAA,IAC7BR,CAAA,CAAQm6C,SAAA,CAAU35C,CAAA,IAAKT,CAAA,CAAOo6C,SAAA,CAAU35C,CAAA,IACJ,mBAAxBT,CAAA,CAAOo6C,SAAA,CAAU35C,CAAA,MAC7BR,CAAA,CAAQm6C,SAAA,CAAU35C,CAAA,IAAK,IAAIgK,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAOo6C,SAAA,CAAU35C,CAAA,EAAG07C,GAAA,KAAQ,GAAGn8C,CAAA,CAAOo6C,SAAA,CAAU35C,CAAA,EAAG27C,IAAA,KAAS,GAAGxB,QAAA,GACrH;YAAA;YAUA,IATmB,QAAf56C,CAAA,CAAOgE,IAAA,KACP/D,CAAA,CAAQ+D,IAAA,GAAOoiD,MAAA,CAAOpmD,CAAA,CAAOgE,IAAA,IACT,QAApBhE,CAAA,CAAO0qC,SAAA,KACPzqC,CAAA,CAAQyqC,SAAA,GAAY0b,MAAA,CAAOpmD,CAAA,CAAO0qC,SAAA,IAChB,QAAlB1qC,CAAA,CAAOsuC,OAAA,KACuB,mBAAnBtuC,CAAA,CAAOsuC,OAAA,GACd7jC,CAAA,CAAM67C,MAAA,CAAOn3C,MAAA,CAAOnP,CAAA,CAAOsuC,OAAA,EAASruC,CAAA,CAAQquC,OAAA,GAAU7jC,CAAA,CAAMs6C,SAAA,CAAUt6C,CAAA,CAAM67C,MAAA,CAAOxkD,MAAA,CAAO9B,CAAA,CAAOsuC,OAAA,IAAW,KACvGtuC,CAAA,CAAOsuC,OAAA,CAAQxsC,MAAA,IAAU,MAC9B7B,CAAA,CAAQquC,OAAA,GAAUtuC,CAAA,CAAOsuC,OAAA,IAC7BtuC,CAAA,CAAOmoD,YAAA,EAAc;cACrB,KAAKniD,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOmoD,YAAA,GACtB,MAAMpmC,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQkoD,YAAA,GAAe,IACd1nD,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOmoD,YAAA,CAAarmD,MAAA,IAAUrB,CAAA,EAAG;gBACjD,IAAsC,mBAA3BT,CAAA,CAAOmoD,YAAA,CAAa1nD,CAAA,GAC3B,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQkoD,YAAA,CAAa1nD,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBpB,UAAA,CAAWnmD,CAAA,CAAOmoD,YAAA,CAAa1nD,CAAA,EAC/F;cAAA;YACJ;YACA,QAAQT,CAAA,CAAOqoD,YAAA;cACf;gBACI,IAAmC,mBAAxBroD,CAAA,CAAOqoD,YAAA,EAA2B;kBACzCpoD,CAAA,CAAQooD,YAAA,GAAeroD,CAAA,CAAOqoD,YAAA;kBAC9B;gBACJ;gBACA;cACJ,KAAK;cACL,KAAK;gBACDpoD,CAAA,CAAQooD,YAAA,GAAe;gBACvB;cACJ,KAAK;cACL,KAAK;gBACDpoD,CAAA,CAAQooD,YAAA,GAAe;YAAA;YAG3B,IAAIroD,CAAA,CAAOq6C,UAAA,EAAY;cACnB,KAAKr0C,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOq6C,UAAA,GACtB,MAAMt4B,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQo6C,UAAA,GAAa,IACZ55C,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOq6C,UAAA,CAAWv4C,MAAA,IAAUrB,CAAA,EAC5CR,CAAA,CAAQo6C,UAAA,CAAW55C,CAAA,IAAKiB,MAAA,CAAO1B,CAAA,CAAOq6C,UAAA,CAAW55C,CAAA,EACzD;YAAA;YACA,IAAIT,CAAA,CAAOs6C,UAAA,EAAY;cACnB,KAAKt0C,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOs6C,UAAA,GACtB,MAAMv4B,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQq6C,UAAA,GAAa,IACZ75C,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOs6C,UAAA,CAAWx4C,MAAA,IAAUrB,CAAA,EACxCgK,CAAA,CAAMwxC,IAAA,IACLh8C,CAAA,CAAQq6C,UAAA,CAAW75C,CAAA,IAAKgK,CAAA,CAAMwxC,IAAA,CAAKC,SAAA,CAAUl8C,CAAA,CAAOs6C,UAAA,CAAW75C,CAAA,IAAK47C,QAAA,IAAW,IAC3C,mBAAzBr8C,CAAA,CAAOs6C,UAAA,CAAW75C,CAAA,IAC9BR,CAAA,CAAQq6C,UAAA,CAAW75C,CAAA,IAAKyhC,QAAA,CAASliC,CAAA,CAAOs6C,UAAA,CAAW75C,CAAA,GAAI,MAClB,mBAAzBT,CAAA,CAAOs6C,UAAA,CAAW75C,CAAA,IAC9BR,CAAA,CAAQq6C,UAAA,CAAW75C,CAAA,IAAKT,CAAA,CAAOs6C,UAAA,CAAW75C,CAAA,IACL,mBAAzBT,CAAA,CAAOs6C,UAAA,CAAW75C,CAAA,MAC9BR,CAAA,CAAQq6C,UAAA,CAAW75C,CAAA,IAAK,IAAIgK,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAOs6C,UAAA,CAAW75C,CAAA,EAAG07C,GAAA,KAAQ,GAAGn8C,CAAA,CAAOs6C,UAAA,CAAW75C,CAAA,EAAG27C,IAAA,KAAS,GAAGxB,QAAA,EAAS,GACjI;YAAA;YACA,OAAO36C,CACX;UAAA,GAWAD,CAAA,CAAYumD,QAAA,GAAW,UAAkBvmD,CAAA,EAASC,CAAA;YACzCA,CAAA,KACDA,CAAA,GAAU,CAAC;YACf,IAAIQ,CAAA,GAAS,CAAC;YAyBd,KAxBIR,CAAA,CAAQumD,MAAA,IAAUvmD,CAAA,CAAQwmD,QAAA,MAC1BhmD,CAAA,CAAOoT,IAAA,GAAO,IACdpT,CAAA,CAAO6jB,SAAA,GAAY,IACnB7jB,CAAA,CAAO05C,SAAA,GAAY,IACnB15C,CAAA,CAAOguC,UAAA,GAAa,IACpBhuC,CAAA,CAAO25C,SAAA,GAAY,IACnB35C,CAAA,CAAO45C,UAAA,GAAa,IACpB55C,CAAA,CAAO65C,UAAA,GAAa,IACpB75C,CAAA,CAAO0nD,YAAA,GAAe,KAEtBloD,CAAA,CAAQwmD,QAAA,KACRhmD,CAAA,CAAOk8B,QAAA,GAAW,GAClBl8B,CAAA,CAAO2nD,OAAA,GAAU,MACjB3nD,CAAA,CAAOuD,IAAA,GAAO,IACV/D,CAAA,CAAQgrC,KAAA,KAAUmb,MAAA,GAClB3lD,CAAA,CAAO6tC,OAAA,GAAU,MAEjB7tC,CAAA,CAAO6tC,OAAA,GAAU,IACbruC,CAAA,CAAQgrC,KAAA,KAAUjlC,KAAA,KAClBvF,CAAA,CAAO6tC,OAAA,GAAU7jC,CAAA,CAAMs6C,SAAA,CAAUtkD,CAAA,CAAO6tC,OAAA,KAEhD7tC,CAAA,CAAOiqC,SAAA,GAAY,IACnBjqC,CAAA,CAAO4nD,YAAA,GAAepoD,CAAA,CAAQ0mD,KAAA,KAAUP,MAAA,GAAS,YAAY,IAE7DpmD,CAAA,CAAQ6T,IAAA,IAAQ7T,CAAA,CAAQ6T,IAAA,CAAK/R,MAAA,EAAQ;cACrCrB,CAAA,CAAOoT,IAAA,GAAO;cACd,KAAK,IAAIrT,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQ6T,IAAA,CAAK/R,MAAA,IAAUtB,CAAA,EACR,mBAApBR,CAAA,CAAQ6T,IAAA,CAAKrT,CAAA,IACpBC,CAAA,CAAOoT,IAAA,CAAKrT,CAAA,IAAKP,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAASA,MAAA,CAAOpmD,CAAA,CAAQ6T,IAAA,CAAKrT,CAAA,KAAMR,CAAA,CAAQ6T,IAAA,CAAKrT,CAAA,IAEnFC,CAAA,CAAOoT,IAAA,CAAKrT,CAAA,IAAKP,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS37C,CAAA,CAAMwxC,IAAA,CAAK4I,SAAA,CAAUtuB,QAAA,CAASnR,IAAA,CAAKplB,CAAA,CAAQ6T,IAAA,CAAKrT,CAAA,KAAMP,CAAA,CAAQymD,KAAA,KAAUhlD,MAAA,GAAS,IAAI+I,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAQ6T,IAAA,CAAKrT,CAAA,EAAG27C,GAAA,KAAQ,GAAGn8C,CAAA,CAAQ6T,IAAA,CAAKrT,CAAA,EAAG47C,IAAA,KAAS,GAAGxB,QAAA,KAAa56C,CAAA,CAAQ6T,IAAA,CAAKrT,CAAA,CAC7O;YAAA;YAKA,IAJwB,QAApBR,CAAA,CAAQ28B,QAAA,IAAoB38B,CAAA,CAAQmlB,cAAA,CAAe,gBACnD1kB,CAAA,CAAOk8B,QAAA,GAAW38B,CAAA,CAAQ28B,QAAA,GACP,QAAnB38B,CAAA,CAAQooD,OAAA,IAAmBpoD,CAAA,CAAQmlB,cAAA,CAAe,eAClD1kB,CAAA,CAAO2nD,OAAA,GAAU/8C,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYqO,OAAA,CAAQ/B,QAAA,CAASvmD,CAAA,CAAQooD,OAAA,EAASnoD,CAAA,IAC1ED,CAAA,CAAQskB,SAAA,IAAatkB,CAAA,CAAQskB,SAAA,CAAUxiB,MAAA,EAEvC,KADArB,CAAA,CAAO6jB,SAAA,GAAY,IACV9jB,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQskB,SAAA,CAAUxiB,MAAA,IAAUtB,CAAA,EAC5CC,CAAA,CAAO6jB,SAAA,CAAU9jB,CAAA,IAAKP,CAAA,CAAQ2mD,IAAA,KAASC,QAAA,CAAS7mD,CAAA,CAAQskB,SAAA,CAAU9jB,CAAA,KAAM4lD,MAAA,CAAOpmD,CAAA,CAAQskB,SAAA,CAAU9jB,CAAA,KAAMR,CAAA,CAAQskB,SAAA,CAAU9jB,CAAA;YAEjI,IAAIR,CAAA,CAAQm6C,SAAA,IAAan6C,CAAA,CAAQm6C,SAAA,CAAUr4C,MAAA,EAEvC,KADArB,CAAA,CAAO05C,SAAA,GAAY,IACV35C,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQm6C,SAAA,CAAUr4C,MAAA,IAAUtB,CAAA,EAC5CC,CAAA,CAAO05C,SAAA,CAAU35C,CAAA,IAAKR,CAAA,CAAQm6C,SAAA,CAAU35C,CAAA;YAEhD,IAAIR,CAAA,CAAQyuC,UAAA,IAAczuC,CAAA,CAAQyuC,UAAA,CAAW3sC,MAAA,EAEzC,KADArB,CAAA,CAAOguC,UAAA,GAAa,IACXjuC,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQyuC,UAAA,CAAW3sC,MAAA,IAAUtB,CAAA,EAC7CC,CAAA,CAAOguC,UAAA,CAAWjuC,CAAA,IAAKP,CAAA,CAAQgrC,KAAA,KAAUmb,MAAA,GAAS37C,CAAA,CAAM67C,MAAA,CAAOp3C,MAAA,CAAOlP,CAAA,CAAQyuC,UAAA,CAAWjuC,CAAA,GAAI,GAAGR,CAAA,CAAQyuC,UAAA,CAAWjuC,CAAA,EAAGsB,MAAA,IAAU7B,CAAA,CAAQgrC,KAAA,KAAUjlC,KAAA,GAAQA,KAAA,CAAM6+C,SAAA,CAAU33C,KAAA,CAAMkY,IAAA,CAAKplB,CAAA,CAAQyuC,UAAA,CAAWjuC,CAAA,KAAMR,CAAA,CAAQyuC,UAAA,CAAWjuC,CAAA;YAEzO,IAAIR,CAAA,CAAQo6C,SAAA,IAAap6C,CAAA,CAAQo6C,SAAA,CAAUt4C,MAAA,EAEvC,KADArB,CAAA,CAAO25C,SAAA,GAAY,IACV55C,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQo6C,SAAA,CAAUt4C,MAAA,IAAUtB,CAAA,EACR,mBAAzBR,CAAA,CAAQo6C,SAAA,CAAU55C,CAAA,IACzBC,CAAA,CAAO25C,SAAA,CAAU55C,CAAA,IAAKP,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAASA,MAAA,CAAOpmD,CAAA,CAAQo6C,SAAA,CAAU55C,CAAA,KAAMR,CAAA,CAAQo6C,SAAA,CAAU55C,CAAA,IAElGC,CAAA,CAAO25C,SAAA,CAAU55C,CAAA,IAAKP,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS37C,CAAA,CAAMwxC,IAAA,CAAK4I,SAAA,CAAUtuB,QAAA,CAASnR,IAAA,CAAKplB,CAAA,CAAQo6C,SAAA,CAAU55C,CAAA,KAAMP,CAAA,CAAQymD,KAAA,KAAUhlD,MAAA,GAAS,IAAI+I,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAQo6C,SAAA,CAAU55C,CAAA,EAAG27C,GAAA,KAAQ,GAAGn8C,CAAA,CAAQo6C,SAAA,CAAU55C,CAAA,EAAG47C,IAAA,KAAS,GAAGxB,QAAA,KAAa56C,CAAA,CAAQo6C,SAAA,CAAU55C,CAAA;YAMtQ,IAJoB,QAAhBR,CAAA,CAAQgE,IAAA,IAAgBhE,CAAA,CAAQmlB,cAAA,CAAe,YAC/C1kB,CAAA,CAAOuD,IAAA,GAAOhE,CAAA,CAAQgE,IAAA,GACH,QAAnBhE,CAAA,CAAQsuC,OAAA,IAAmBtuC,CAAA,CAAQmlB,cAAA,CAAe,eAClD1kB,CAAA,CAAO6tC,OAAA,GAAUruC,CAAA,CAAQgrC,KAAA,KAAUmb,MAAA,GAAS37C,CAAA,CAAM67C,MAAA,CAAOp3C,MAAA,CAAOlP,CAAA,CAAQsuC,OAAA,EAAS,GAAGtuC,CAAA,CAAQsuC,OAAA,CAAQxsC,MAAA,IAAU7B,CAAA,CAAQgrC,KAAA,KAAUjlC,KAAA,GAAQA,KAAA,CAAM6+C,SAAA,CAAU33C,KAAA,CAAMkY,IAAA,CAAKplB,CAAA,CAAQsuC,OAAA,IAAWtuC,CAAA,CAAQsuC,OAAA,GAC9LtuC,CAAA,CAAQq6C,UAAA,IAAcr6C,CAAA,CAAQq6C,UAAA,CAAWv4C,MAAA,EAEzC,KADArB,CAAA,CAAO45C,UAAA,GAAa,IACX75C,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQq6C,UAAA,CAAWv4C,MAAA,IAAUtB,CAAA,EAC7CC,CAAA,CAAO45C,UAAA,CAAW75C,CAAA,IAAKP,CAAA,CAAQ2mD,IAAA,KAASC,QAAA,CAAS7mD,CAAA,CAAQq6C,UAAA,CAAW75C,CAAA,KAAM4lD,MAAA,CAAOpmD,CAAA,CAAQq6C,UAAA,CAAW75C,CAAA,KAAMR,CAAA,CAAQq6C,UAAA,CAAW75C,CAAA;YAErI,IAAIR,CAAA,CAAQs6C,UAAA,IAAct6C,CAAA,CAAQs6C,UAAA,CAAWx4C,MAAA,EAEzC,KADArB,CAAA,CAAO65C,UAAA,GAAa,IACX95C,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQs6C,UAAA,CAAWx4C,MAAA,IAAUtB,CAAA,EACR,mBAA1BR,CAAA,CAAQs6C,UAAA,CAAW95C,CAAA,IAC1BC,CAAA,CAAO65C,UAAA,CAAW95C,CAAA,IAAKP,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAASA,MAAA,CAAOpmD,CAAA,CAAQs6C,UAAA,CAAW95C,CAAA,KAAMR,CAAA,CAAQs6C,UAAA,CAAW95C,CAAA,IAErGC,CAAA,CAAO65C,UAAA,CAAW95C,CAAA,IAAKP,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS37C,CAAA,CAAMwxC,IAAA,CAAK4I,SAAA,CAAUtuB,QAAA,CAASnR,IAAA,CAAKplB,CAAA,CAAQs6C,UAAA,CAAW95C,CAAA,KAAMP,CAAA,CAAQymD,KAAA,KAAUhlD,MAAA,GAAS,IAAI+I,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAQs6C,UAAA,CAAW95C,CAAA,EAAG27C,GAAA,KAAQ,GAAGn8C,CAAA,CAAQs6C,UAAA,CAAW95C,CAAA,EAAG47C,IAAA,KAAS,GAAGxB,QAAA,EAAS,KAAQ56C,CAAA,CAAQs6C,UAAA,CAAW95C,CAAA;YAI/Q,IAFyB,QAArBR,CAAA,CAAQ0qC,SAAA,IAAqB1qC,CAAA,CAAQmlB,cAAA,CAAe,iBACpD1kB,CAAA,CAAOiqC,SAAA,GAAY1qC,CAAA,CAAQ0qC,SAAA,GAC3B1qC,CAAA,CAAQmoD,YAAA,IAAgBnoD,CAAA,CAAQmoD,YAAA,CAAarmD,MAAA,EAE7C,KADArB,CAAA,CAAO0nD,YAAA,GAAe,IACb3nD,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQmoD,YAAA,CAAarmD,MAAA,IAAUtB,CAAA,EAC/CC,CAAA,CAAO0nD,YAAA,CAAa3nD,CAAA,IAAK6K,CAAA,CAAMxH,IAAA,CAAK0jD,sBAAA,CAAuBhB,QAAA,CAASvmD,CAAA,CAAQmoD,YAAA,CAAa3nD,CAAA,GAAIP,CAAA;YAIrG,OAF4B,QAAxBD,CAAA,CAAQqoD,YAAA,IAAwBroD,CAAA,CAAQmlB,cAAA,CAAe,oBACvD1kB,CAAA,CAAO4nD,YAAA,GAAepoD,CAAA,CAAQ0mD,KAAA,KAAUP,MAAA,QAAuE,MAA9D/6C,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYwO,YAAA,CAAazoD,CAAA,CAAQqoD,YAAA,IAA8BroD,CAAA,CAAQqoD,YAAA,GAAeh9C,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYwO,YAAA,CAAazoD,CAAA,CAAQqoD,YAAA,IAAgBroD,CAAA,CAAQqoD,YAAA,GACnN5nD,CACX;UAAA,GASAT,CAAA,CAAY6kD,SAAA,CAAUiC,MAAA,GAAS;YAC3B,OAAO,KAAKlkD,WAAA,CAAY2jD,QAAA,CAAS,MAAMrlD,CAAA,CAAUsjD,IAAA,CAAKuC,aAAA,CAC1D;UAAA,GAUA/mD,CAAA,CAAYgnD,UAAA,GAAa,UAAoBhnD,CAAA;YAIzC,YAHsB,MAAlBA,CAAA,KACAA,CAAA,GAAgB,wBAEbA,CAAA,GAAgB,mBAC3B;UAAA,GA4BAA,CAAA,CAAYk6C,QAAA,GAAW;YACnB,IAAIl6C,CAAA,GAAa,CAAC;cAAGC,CAAA,GAAS4C,MAAA,CAAO48B,MAAA,CAAOz/B,CAAA;YAsB5C,OArBAC,CAAA,CAAOD,CAAA,CAAW,KAAK,eAAe,GACtCC,CAAA,CAAOD,CAAA,CAAW,KAAK,WAAW,GAClCC,CAAA,CAAOD,CAAA,CAAW,KAAK,WAAW,GAClCC,CAAA,CAAOD,CAAA,CAAW,KAAK,UAAU,GACjCC,CAAA,CAAOD,CAAA,CAAW,KAAK,YAAY,GACnCC,CAAA,CAAOD,CAAA,CAAW,KAAK,WAAW,GAClCC,CAAA,CAAOD,CAAA,CAAW,KAAK,WAAW,GAClCC,CAAA,CAAOD,CAAA,CAAW,KAAK,WAAW,GAClCC,CAAA,CAAOD,CAAA,CAAW,KAAK,YAAY,GACnCC,CAAA,CAAOD,CAAA,CAAW,KAAK,UAAU,GACjCC,CAAA,CAAOD,CAAA,CAAW,MAAM,aAAa,IACrCC,CAAA,CAAOD,CAAA,CAAW,MAAM,YAAY,IACpCC,CAAA,CAAOD,CAAA,CAAW,MAAM,YAAY,IACpCC,CAAA,CAAOD,CAAA,CAAW,MAAM,YAAY,IACpCC,CAAA,CAAOD,CAAA,CAAW,MAAM,eAAe,IACvCC,CAAA,CAAOD,CAAA,CAAW,MAAM,gBAAgB,IACxCC,CAAA,CAAOD,CAAA,CAAW,MAAM,cAAc,IACtCC,CAAA,CAAOD,CAAA,CAAW,MAAM,kBAAkB,IAC1CC,CAAA,CAAOD,CAAA,CAAW,MAAM,oBAAoB,IAC5CC,CAAA,CAAOD,CAAA,CAAW,MAAM,gBAAgB,IACxCC,CAAA,CAAOD,CAAA,CAAW,MAAM,oBAAoB,IACrCC,CACV;UAAA,CAxBsB,IA0BvBD,CAAA,CAAYsoD,OAAA,GAAU;YAkBlB,SAAStoD,EAAQA,CAAA;cACb,IAAIA,CAAA,EACA,KAAK,IAAIC,CAAA,GAAO4C,MAAA,CAAO6N,IAAA,CAAK1Q,CAAA,GAAaS,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK6B,MAAA,IAAUrB,CAAA,EACpC,QAAvBT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,OAChB,KAAKR,CAAA,CAAKQ,CAAA,KAAMT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,GAChD;YAAA;YAqOA,OA7NAT,CAAA,CAAQ6kD,SAAA,CAAUrkB,KAAA,GAAQ/1B,CAAA,CAAMwxC,IAAA,GAAOxxC,CAAA,CAAMwxC,IAAA,CAAKb,QAAA,CAAS,GAAE,IAAE,KAAS,GAQxEp7C,CAAA,CAAQ6kD,SAAA,CAAUxlB,GAAA,GAAM50B,CAAA,CAAMwxC,IAAA,GAAOxxC,CAAA,CAAMwxC,IAAA,CAAKb,QAAA,CAAS,GAAE,IAAE,KAAS,GAUtEp7C,CAAA,CAAQy/B,MAAA,GAAS,UAAgBx/B,CAAA;cAC7B,OAAO,IAAID,CAAA,CAAQC,CAAA,CACvB;YAAA,GAWAD,CAAA,CAAQkP,MAAA,GAAS,UAAgBlP,CAAA,EAASC,CAAA;cAOtC,OANKA,CAAA,KACDA,CAAA,GAASyD,CAAA,CAAQ+7B,MAAA,KACA,QAAjBz/B,CAAA,CAAQwgC,KAAA,IAAiB39B,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,YAC7DC,CAAA,CAAOklD,MAAA,CAA8B,GAAGG,KAAA,CAAMtlD,CAAA,CAAQwgC,KAAA,GACvC,QAAfxgC,CAAA,CAAQq/B,GAAA,IAAex8B,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,UAC3DC,CAAA,CAAOklD,MAAA,CAA8B,IAAIG,KAAA,CAAMtlD,CAAA,CAAQq/B,GAAA,GACpDp/B,CACX;YAAA,GAWAD,CAAA,CAAQ4lD,eAAA,GAAkB,UAAyB5lD,CAAA,EAASC,CAAA;cACxD,OAAO,KAAKiP,MAAA,CAAOlP,CAAA,EAASC,CAAA,EAAQulD,MAAA,EACxC;YAAA,GAaAxlD,CAAA,CAAQmP,MAAA,GAAS,UAAgBnP,CAAA,EAAQC,CAAA;cAC/BD,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAASsD,CAAA,CAAQm8B,MAAA,CAAOz/B,CAAA;cAE5B,KADA,IAAIS,CAAA,QAAiB,MAAXR,CAAA,GAAuBD,CAAA,CAAO6lD,GAAA,GAAM7lD,CAAA,CAAO8lD,GAAA,GAAM7lD,CAAA,EAAQO,CAAA,GAAU,IAAI6K,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYqO,OAAA,IACjGtoD,CAAA,CAAO8lD,GAAA,GAAMrlD,CAAA,GAAK;gBACrB,IAAIC,CAAA,GAAMV,CAAA,CAAOmlD,MAAA;gBACjB,QAAQzkD,CAAA,KAAQ;kBAChB,KAAK;oBACGF,CAAA,CAAQggC,KAAA,GAAQxgC,CAAA,CAAOslD,KAAA;oBACvB;kBAER,KAAK;oBACG9kD,CAAA,CAAQ6+B,GAAA,GAAMr/B,CAAA,CAAOslD,KAAA;oBACrB;kBAER;oBACItlD,CAAA,CAAO+lD,QAAA,CAAe,IAANrlD,CAAA;gBAAA;cAGxB;cACA,OAAOF,CACX;YAAA,GAYAR,CAAA,CAAQgmD,eAAA,GAAkB,UAAyBhmD,CAAA;cAG/C,OAFMA,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAAS,IAAIsD,CAAA,CAAQtD,CAAA,IAClB,KAAKmP,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,GACtC;YAAA,GAUAnlD,CAAA,CAAQimD,MAAA,GAAS,UAAgBjmD,CAAA;cAC7B,OAAuB,mBAAZA,CAAA,IAAoC,SAAZA,CAAA,GACxB,oBACU,QAAjBA,CAAA,CAAQwgC,KAAA,IAAiBxgC,CAAA,CAAQmlB,cAAA,CAAe,cAC3C1a,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQwgC,KAAA,KAAYxgC,CAAA,CAAQwgC,KAAA,IAAS/1B,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQwgC,KAAA,CAAM2b,GAAA,KAAQ1xC,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQwgC,KAAA,CAAM4b,IAAA,KACnH,iCACI,QAAfp8C,CAAA,CAAQq/B,GAAA,IAAer/B,CAAA,CAAQmlB,cAAA,CAAe,YACzC1a,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQq/B,GAAA,KAAUr/B,CAAA,CAAQq/B,GAAA,IAAO50B,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQq/B,GAAA,CAAI8c,GAAA,KAAQ1xC,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQq/B,GAAA,CAAI+c,IAAA,KAC3G,+BACR,IACX;YAAA,GAUAp8C,CAAA,CAAQmmD,UAAA,GAAa,UAAoBnmD,CAAA;cACrC,IAAIA,CAAA,YAAkBqL,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYqO,OAAA,EACzC,OAAOtoD,CAAA;cACX,IAAIC,CAAA,GAAU,IAAIoL,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYqO,OAAA;cAmBzC,OAlBoB,QAAhBtoD,CAAA,CAAOwgC,KAAA,KACH/1B,CAAA,CAAMwxC,IAAA,IACLh8C,CAAA,CAAQugC,KAAA,GAAQ/1B,CAAA,CAAMwxC,IAAA,CAAKC,SAAA,CAAUl8C,CAAA,CAAOwgC,KAAA,GAAQ6b,QAAA,IAAW,IACnC,mBAAjBr8C,CAAA,CAAOwgC,KAAA,GACnBvgC,CAAA,CAAQugC,KAAA,GAAQ0B,QAAA,CAASliC,CAAA,CAAOwgC,KAAA,EAAO,MACV,mBAAjBxgC,CAAA,CAAOwgC,KAAA,GACnBvgC,CAAA,CAAQugC,KAAA,GAAQxgC,CAAA,CAAOwgC,KAAA,GACM,mBAAjBxgC,CAAA,CAAOwgC,KAAA,KACnBvgC,CAAA,CAAQugC,KAAA,GAAQ,IAAI/1B,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAOwgC,KAAA,CAAM2b,GAAA,KAAQ,GAAGn8C,CAAA,CAAOwgC,KAAA,CAAM4b,IAAA,KAAS,GAAGxB,QAAA,MAC1E,QAAd56C,CAAA,CAAOq/B,GAAA,KACH50B,CAAA,CAAMwxC,IAAA,IACLh8C,CAAA,CAAQo/B,GAAA,GAAM50B,CAAA,CAAMwxC,IAAA,CAAKC,SAAA,CAAUl8C,CAAA,CAAOq/B,GAAA,GAAMgd,QAAA,IAAW,IACjC,mBAAfr8C,CAAA,CAAOq/B,GAAA,GACnBp/B,CAAA,CAAQo/B,GAAA,GAAM6C,QAAA,CAASliC,CAAA,CAAOq/B,GAAA,EAAK,MACR,mBAAfr/B,CAAA,CAAOq/B,GAAA,GACnBp/B,CAAA,CAAQo/B,GAAA,GAAMr/B,CAAA,CAAOq/B,GAAA,GACM,mBAAfr/B,CAAA,CAAOq/B,GAAA,KACnBp/B,CAAA,CAAQo/B,GAAA,GAAM,IAAI50B,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAOq/B,GAAA,CAAI8c,GAAA,KAAQ,GAAGn8C,CAAA,CAAOq/B,GAAA,CAAI+c,IAAA,KAAS,GAAGxB,QAAA,MAC/E36C,CACX;YAAA,GAWAD,CAAA,CAAQumD,QAAA,GAAW,UAAkBvmD,CAAA,EAASC,CAAA;cACrCA,CAAA,KACDA,CAAA,GAAU,CAAC;cACf,IAAIQ,CAAA,GAAS,CAAC;cACd,IAAIR,CAAA,CAAQwmD,QAAA,EAAU;gBAClB,IAAIh8C,CAAA,CAAMwxC,IAAA,EAAM;kBACZ,IAAIz7C,CAAA,GAAO,IAAIiK,CAAA,CAAMwxC,IAAA,CAAK,GAAG,IAAG;kBAChCx7C,CAAA,CAAO+/B,KAAA,GAAQvgC,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS5lD,CAAA,CAAK+1B,QAAA,KAAat2B,CAAA,CAAQymD,KAAA,KAAUhlD,MAAA,GAASlB,CAAA,CAAKo6C,QAAA,KAAap6C,CAC7G;gBAAA,OACIC,CAAA,CAAO+/B,KAAA,GAAQvgC,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS,MAAM;gBAChD37C,CAAA,CAAMwxC,IAAA,IACFz7C,CAAA,GAAO,IAAIiK,CAAA,CAAMwxC,IAAA,CAAK,GAAG,IAAG,IAChCx7C,CAAA,CAAO4+B,GAAA,GAAMp/B,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS5lD,CAAA,CAAK+1B,QAAA,KAAat2B,CAAA,CAAQymD,KAAA,KAAUhlD,MAAA,GAASlB,CAAA,CAAKo6C,QAAA,KAAap6C,CAAA,IAEvGC,CAAA,CAAO4+B,GAAA,GAAMp/B,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS,MAAM,CACtD;cAAA;cAWA,OAVqB,QAAjBpmD,CAAA,CAAQwgC,KAAA,IAAiBxgC,CAAA,CAAQmlB,cAAA,CAAe,aACnB,mBAAlBnlB,CAAA,CAAQwgC,KAAA,GACf//B,CAAA,CAAO+/B,KAAA,GAAQvgC,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAASA,MAAA,CAAOpmD,CAAA,CAAQwgC,KAAA,IAASxgC,CAAA,CAAQwgC,KAAA,GAE1E//B,CAAA,CAAO+/B,KAAA,GAAQvgC,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS37C,CAAA,CAAMwxC,IAAA,CAAK4I,SAAA,CAAUtuB,QAAA,CAASnR,IAAA,CAAKplB,CAAA,CAAQwgC,KAAA,IAASvgC,CAAA,CAAQymD,KAAA,KAAUhlD,MAAA,GAAS,IAAI+I,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAQwgC,KAAA,CAAM2b,GAAA,KAAQ,GAAGn8C,CAAA,CAAQwgC,KAAA,CAAM4b,IAAA,KAAS,GAAGxB,QAAA,KAAa56C,CAAA,CAAQwgC,KAAA,GACzM,QAAfxgC,CAAA,CAAQq/B,GAAA,IAAer/B,CAAA,CAAQmlB,cAAA,CAAe,WACnB,mBAAhBnlB,CAAA,CAAQq/B,GAAA,GACf5+B,CAAA,CAAO4+B,GAAA,GAAMp/B,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAASA,MAAA,CAAOpmD,CAAA,CAAQq/B,GAAA,IAAOr/B,CAAA,CAAQq/B,GAAA,GAEtE5+B,CAAA,CAAO4+B,GAAA,GAAMp/B,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS37C,CAAA,CAAMwxC,IAAA,CAAK4I,SAAA,CAAUtuB,QAAA,CAASnR,IAAA,CAAKplB,CAAA,CAAQq/B,GAAA,IAAOp/B,CAAA,CAAQymD,KAAA,KAAUhlD,MAAA,GAAS,IAAI+I,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAQq/B,GAAA,CAAI8c,GAAA,KAAQ,GAAGn8C,CAAA,CAAQq/B,GAAA,CAAI+c,IAAA,KAAS,GAAGxB,QAAA,KAAa56C,CAAA,CAAQq/B,GAAA,GAC7M5+B,CACX;YAAA,GASAT,CAAA,CAAQ6kD,SAAA,CAAUiC,MAAA,GAAS;cACvB,OAAO,KAAKlkD,WAAA,CAAY2jD,QAAA,CAAS,MAAMrlD,CAAA,CAAUsjD,IAAA,CAAKuC,aAAA,CAC1D;YAAA,GAUA/mD,CAAA,CAAQgnD,UAAA,GAAa,UAAoBhnD,CAAA;cAIrC,YAHsB,MAAlBA,CAAA,KACAA,CAAA,GAAgB,wBAEbA,CAAA,GAAgB,2BAC3B;YAAA,GAEOA,CACV;UAAA,CA7PqB,IAsQtBA,CAAA,CAAYyoD,YAAA,GAAe;YACvB,IAAIzoD,CAAA,GAAa,CAAC;cAAGC,CAAA,GAAS4C,MAAA,CAAO48B,MAAA,CAAOz/B,CAAA;YAG5C,OAFAC,CAAA,CAAOD,CAAA,CAAW,KAAK,aAAa,GACpCC,CAAA,CAAOD,CAAA,CAAW,KAAK,cAAc,GAC9BC,CACV;UAAA,CAL0B,IAOpBD,CACV;QAAA,CA/iCkB,IAijCnBiB,CAAA,CAAK0kD,iBAAA,GAAoB;UAmBrB,SAAS3lD,EAAkBA,CAAA;YAEvB,IADA,KAAK6T,IAAA,GAAO,IACR7T,CAAA,EACA,KAAK,IAAIC,CAAA,GAAO4C,MAAA,CAAO6N,IAAA,CAAK1Q,CAAA,GAAaS,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK6B,MAAA,IAAUrB,CAAA,EACpC,QAAvBT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,OAChB,KAAKR,CAAA,CAAKQ,CAAA,KAAMT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,GAChD;UAAA;UA2QA,OAnQAT,CAAA,CAAkB6kD,SAAA,CAAUjV,MAAA,GAAS,MAQrC5vC,CAAA,CAAkB6kD,SAAA,CAAUhV,OAAA,GAAU,MAQtC7vC,CAAA,CAAkB6kD,SAAA,CAAUhxC,IAAA,GAAOpJ,CAAA,CAAMy6C,UAAA,EAUzCllD,CAAA,CAAkBy/B,MAAA,GAAS,UAAgBx/B,CAAA;YACvC,OAAO,IAAID,CAAA,CAAkBC,CAAA,CACjC;UAAA,GAWAD,CAAA,CAAkBkP,MAAA,GAAS,UAAgBlP,CAAA,EAASC,CAAA;YAOhD,IANKA,CAAA,KACDA,CAAA,GAASyD,CAAA,CAAQ+7B,MAAA,KACC,QAAlBz/B,CAAA,CAAQ4vC,MAAA,IAAkB/sC,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,aAC9DqL,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAY/qC,MAAA,CAAOlP,CAAA,CAAQ4vC,MAAA,EAAQ3vC,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA,IAC5E,QAAnBxlD,CAAA,CAAQ6vC,OAAA,IAAmBhtC,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,cAC/DqL,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAY/qC,MAAA,CAAOlP,CAAA,CAAQ6vC,OAAA,EAAS5vC,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA,IAChF,QAAhBxlD,CAAA,CAAQ6T,IAAA,IAAgB7T,CAAA,CAAQ6T,IAAA,CAAK/R,MAAA,EAAQ;cAC7C7B,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA;cACzC,KAAK,IAAI9kD,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQ6T,IAAA,CAAK/R,MAAA,IAAUrB,CAAA,EACvCR,CAAA,CAAOqlD,KAAA,CAAMtlD,CAAA,CAAQ6T,IAAA,CAAKpT,CAAA;cAC9BR,CAAA,CAAOulD,MAAA,EACX;YAAA;YACA,OAAOvlD,CACX;UAAA,GAWAD,CAAA,CAAkB4lD,eAAA,GAAkB,UAAyB5lD,CAAA,EAASC,CAAA;YAClE,OAAO,KAAKiP,MAAA,CAAOlP,CAAA,EAASC,CAAA,EAAQulD,MAAA,EACxC;UAAA,GAaAxlD,CAAA,CAAkBmP,MAAA,GAAS,UAAgBnP,CAAA,EAAQC,CAAA;YACzCD,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAASsD,CAAA,CAAQm8B,MAAA,CAAOz/B,CAAA;YAE5B,KADA,IAAIS,CAAA,QAAiB,MAAXR,CAAA,GAAuBD,CAAA,CAAO6lD,GAAA,GAAM7lD,CAAA,CAAO8lD,GAAA,GAAM7lD,CAAA,EAAQO,CAAA,GAAU,IAAI6K,CAAA,CAAMxH,IAAA,CAAK8hD,iBAAA,IACrF3lD,CAAA,CAAO8lD,GAAA,GAAMrlD,CAAA,GAAK;cACrB,IAAIC,CAAA,GAAMV,CAAA,CAAOmlD,MAAA;cACjB,QAAQzkD,CAAA,KAAQ;gBAChB,KAAK;kBACGF,CAAA,CAAQovC,MAAA,GAASvkC,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAY9qC,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBAC9D;gBAER,KAAK;kBACG3kD,CAAA,CAAQqvC,OAAA,GAAUxkC,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAY9qC,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBAC/D;gBAER,KAAK;kBAGG,IAFM3kD,CAAA,CAAQqT,IAAA,IAAQrT,CAAA,CAAQqT,IAAA,CAAK/R,MAAA,KAC/BtB,CAAA,CAAQqT,IAAA,GAAO,KACD,MAAP,IAANnT,CAAA,GAED,KADA,IAAIO,CAAA,GAAOjB,CAAA,CAAOmlD,MAAA,KAAWnlD,CAAA,CAAO8lD,GAAA,EAC7B9lD,CAAA,CAAO8lD,GAAA,GAAM7kD,CAAA,GAChBT,CAAA,CAAQqT,IAAA,CAAK7M,IAAA,CAAKhH,CAAA,CAAOslD,KAAA,SAE7B9kD,CAAA,CAAQqT,IAAA,CAAK7M,IAAA,CAAKhH,CAAA,CAAOslD,KAAA;kBAC7B;gBAER;kBACItlD,CAAA,CAAO+lD,QAAA,CAAe,IAANrlD,CAAA;cAAA;YAGxB;YACA,OAAOF,CACX;UAAA,GAYAR,CAAA,CAAkBgmD,eAAA,GAAkB,UAAyBhmD,CAAA;YAGzD,OAFMA,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAAS,IAAIsD,CAAA,CAAQtD,CAAA,IAClB,KAAKmP,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,GACtC;UAAA,GAUAnlD,CAAA,CAAkBimD,MAAA,GAAS,UAAgBjmD,CAAA;YACvC,IAAuB,mBAAZA,CAAA,IAAoC,SAAZA,CAAA,EAC/B,OAAO;YAEP,IAKIC,CAAA;YANR,IAAsB,QAAlBD,CAAA,CAAQ4vC,MAAA,IAAkB5vC,CAAA,CAAQmlB,cAAA,CAAe,cAC7CllB,CAAA,GAAQoL,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYgM,MAAA,CAAOjmD,CAAA,CAAQ4vC,MAAA,IAE9C,OAAO,YAAY3vC,CAAA;YAE3B,IAAuB,QAAnBD,CAAA,CAAQ6vC,OAAA,IAAmB7vC,CAAA,CAAQmlB,cAAA,CAAe,eAC9CllB,CAAA,GAAQoL,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYgM,MAAA,CAAOjmD,CAAA,CAAQ6vC,OAAA,IAE9C,OAAO,aAAa5vC,CAAA;YAE5B,IAAoB,QAAhBD,CAAA,CAAQ6T,IAAA,IAAgB7T,CAAA,CAAQmlB,cAAA,CAAe,SAAS;cACxD,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQ6T,IAAA,GACvB,OAAO;cACX,KAAK,IAAIpT,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQ6T,IAAA,CAAK/R,MAAA,IAAUrB,CAAA,EACvC,MAAKgK,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQ6T,IAAA,CAAKpT,CAAA,MAAST,CAAA,CAAQ6T,IAAA,CAAKpT,CAAA,KAAMgK,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQ6T,IAAA,CAAKpT,CAAA,EAAG07C,GAAA,KAAQ1xC,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQ6T,IAAA,CAAKpT,CAAA,EAAG27C,IAAA,IAClI,OAAO,+BACnB;YAAA;YACA,OAAO,IACX;UAAA,GAUAp8C,CAAA,CAAkBmmD,UAAA,GAAa,UAAoBnmD,CAAA;YAC/C,IAAIA,CAAA,YAAkBqL,CAAA,CAAMxH,IAAA,CAAK8hD,iBAAA,EAC7B,OAAO3lD,CAAA;YACX,IAAIC,CAAA,GAAU,IAAIoL,CAAA,CAAMxH,IAAA,CAAK8hD,iBAAA;YAC7B,IAAqB,QAAjB3lD,CAAA,CAAO4vC,MAAA,EAAgB;cACvB,IAA6B,mBAAlB5vC,CAAA,CAAO4vC,MAAA,EACd,MAAM7tB,SAAA,CAAU;cACpB9hB,CAAA,CAAQ2vC,MAAA,GAASvkC,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYkM,UAAA,CAAWnmD,CAAA,CAAO4vC,MAAA,CAC9D;YAAA;YACA,IAAsB,QAAlB5vC,CAAA,CAAO6vC,OAAA,EAAiB;cACxB,IAA8B,mBAAnB7vC,CAAA,CAAO6vC,OAAA,EACd,MAAM9tB,SAAA,CAAU;cACpB9hB,CAAA,CAAQ4vC,OAAA,GAAUxkC,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYkM,UAAA,CAAWnmD,CAAA,CAAO6vC,OAAA,CAC/D;YAAA;YACA,IAAI7vC,CAAA,CAAO6T,IAAA,EAAM;cACb,KAAK7N,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAO6T,IAAA,GACtB,MAAMkO,SAAA,CAAU;cACpB9hB,CAAA,CAAQ4T,IAAA,GAAO;cACf,KAAK,IAAIpT,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAO6T,IAAA,CAAK/R,MAAA,IAAUrB,CAAA,EAClCgK,CAAA,CAAMwxC,IAAA,IACLh8C,CAAA,CAAQ4T,IAAA,CAAKpT,CAAA,IAAKgK,CAAA,CAAMwxC,IAAA,CAAKC,SAAA,CAAUl8C,CAAA,CAAO6T,IAAA,CAAKpT,CAAA,IAAK47C,QAAA,IAAW,IACrC,mBAAnBr8C,CAAA,CAAO6T,IAAA,CAAKpT,CAAA,IACxBR,CAAA,CAAQ4T,IAAA,CAAKpT,CAAA,IAAKyhC,QAAA,CAASliC,CAAA,CAAO6T,IAAA,CAAKpT,CAAA,GAAI,MACZ,mBAAnBT,CAAA,CAAO6T,IAAA,CAAKpT,CAAA,IACxBR,CAAA,CAAQ4T,IAAA,CAAKpT,CAAA,IAAKT,CAAA,CAAO6T,IAAA,CAAKpT,CAAA,IACC,mBAAnBT,CAAA,CAAO6T,IAAA,CAAKpT,CAAA,MACxBR,CAAA,CAAQ4T,IAAA,CAAKpT,CAAA,IAAK,IAAIgK,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAO6T,IAAA,CAAKpT,CAAA,EAAG07C,GAAA,KAAQ,GAAGn8C,CAAA,CAAO6T,IAAA,CAAKpT,CAAA,EAAG27C,IAAA,KAAS,GAAGxB,QAAA,GACtG;YAAA;YACA,OAAO36C,CACX;UAAA,GAWAD,CAAA,CAAkBumD,QAAA,GAAW,UAAkBvmD,CAAA,EAASC,CAAA;YAC/CA,CAAA,KACDA,CAAA,GAAU,CAAC;YACf,IAAIQ,CAAA,GAAS,CAAC;YAWd,KAVIR,CAAA,CAAQumD,MAAA,IAAUvmD,CAAA,CAAQwmD,QAAA,MAC1BhmD,CAAA,CAAOoT,IAAA,GAAO,KACd5T,CAAA,CAAQwmD,QAAA,KACRhmD,CAAA,CAAOmvC,MAAA,GAAS,MAChBnvC,CAAA,CAAOovC,OAAA,GAAU,OAEC,QAAlB7vC,CAAA,CAAQ4vC,MAAA,IAAkB5vC,CAAA,CAAQmlB,cAAA,CAAe,cACjD1kB,CAAA,CAAOmvC,MAAA,GAASvkC,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYsM,QAAA,CAASvmD,CAAA,CAAQ4vC,MAAA,EAAQ3vC,CAAA,IAC7C,QAAnBD,CAAA,CAAQ6vC,OAAA,IAAmB7vC,CAAA,CAAQmlB,cAAA,CAAe,eAClD1kB,CAAA,CAAOovC,OAAA,GAAUxkC,CAAA,CAAMxH,IAAA,CAAKo2C,WAAA,CAAYsM,QAAA,CAASvmD,CAAA,CAAQ6vC,OAAA,EAAS5vC,CAAA,IAClED,CAAA,CAAQ6T,IAAA,IAAQ7T,CAAA,CAAQ6T,IAAA,CAAK/R,MAAA,EAAQ;cACrCrB,CAAA,CAAOoT,IAAA,GAAO;cACd,KAAK,IAAIrT,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQ6T,IAAA,CAAK/R,MAAA,IAAUtB,CAAA,EACR,mBAApBR,CAAA,CAAQ6T,IAAA,CAAKrT,CAAA,IACpBC,CAAA,CAAOoT,IAAA,CAAKrT,CAAA,IAAKP,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAASA,MAAA,CAAOpmD,CAAA,CAAQ6T,IAAA,CAAKrT,CAAA,KAAMR,CAAA,CAAQ6T,IAAA,CAAKrT,CAAA,IAEnFC,CAAA,CAAOoT,IAAA,CAAKrT,CAAA,IAAKP,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS37C,CAAA,CAAMwxC,IAAA,CAAK4I,SAAA,CAAUtuB,QAAA,CAASnR,IAAA,CAAKplB,CAAA,CAAQ6T,IAAA,CAAKrT,CAAA,KAAMP,CAAA,CAAQymD,KAAA,KAAUhlD,MAAA,GAAS,IAAI+I,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAQ6T,IAAA,CAAKrT,CAAA,EAAG27C,GAAA,KAAQ,GAAGn8C,CAAA,CAAQ6T,IAAA,CAAKrT,CAAA,EAAG47C,IAAA,KAAS,GAAGxB,QAAA,KAAa56C,CAAA,CAAQ6T,IAAA,CAAKrT,CAAA,CAC7O;YAAA;YACA,OAAOC,CACX;UAAA,GASAT,CAAA,CAAkB6kD,SAAA,CAAUiC,MAAA,GAAS;YACjC,OAAO,KAAKlkD,WAAA,CAAY2jD,QAAA,CAAS,MAAMrlD,CAAA,CAAUsjD,IAAA,CAAKuC,aAAA,CAC1D;UAAA,GAUA/mD,CAAA,CAAkBgnD,UAAA,GAAa,UAAoBhnD,CAAA;YAI/C,YAHsB,MAAlBA,CAAA,KACAA,CAAA,GAAgB,wBAEbA,CAAA,GAAgB,yBAC3B;UAAA,GAEOA,CACV;QAAA,CArSwB,IAuSzBiB,CAAA,CAAKynD,gBAAA,GAAmB;UAiBpB,SAAS1oD,EAAiBA,CAAA;YAEtB,IADA,KAAKq9B,GAAA,GAAM,IACPr9B,CAAA,EACA,KAAK,IAAIC,CAAA,GAAO4C,MAAA,CAAO6N,IAAA,CAAK1Q,CAAA,GAAaS,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK6B,MAAA,IAAUrB,CAAA,EACpC,QAAvBT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,OAChB,KAAKR,CAAA,CAAKQ,CAAA,KAAMT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,GAChD;UAAA;UAkeA,OA1dAT,CAAA,CAAiB6kD,SAAA,CAAUxnB,GAAA,GAAM5yB,CAAA,CAAMy6C,UAAA,EAUvCllD,CAAA,CAAiBy/B,MAAA,GAAS,UAAgBx/B,CAAA;YACtC,OAAO,IAAID,CAAA,CAAiBC,CAAA,CAChC;UAAA,GAWAD,CAAA,CAAiBkP,MAAA,GAAS,UAAgBlP,CAAA,EAASC,CAAA;YAG/C,IAFKA,CAAA,KACDA,CAAA,GAASyD,CAAA,CAAQ+7B,MAAA,KACF,QAAfz/B,CAAA,CAAQq9B,GAAA,IAAer9B,CAAA,CAAQq9B,GAAA,CAAIv7B,MAAA,EACnC,KAAK,IAAIrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQq9B,GAAA,CAAIv7B,MAAA,IAAUrB,CAAA,EACtC4K,CAAA,CAAMxH,IAAA,CAAK6kD,gBAAA,CAAiB5jB,SAAA,CAAU51B,MAAA,CAAOlP,CAAA,CAAQq9B,GAAA,CAAI58B,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA;YACtH,OAAOvlD,CACX;UAAA,GAWAD,CAAA,CAAiB4lD,eAAA,GAAkB,UAAyB5lD,CAAA,EAASC,CAAA;YACjE,OAAO,KAAKiP,MAAA,CAAOlP,CAAA,EAASC,CAAA,EAAQulD,MAAA,EACxC;UAAA,GAaAxlD,CAAA,CAAiBmP,MAAA,GAAS,UAAgBnP,CAAA,EAAQC,CAAA;YACxCD,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAASsD,CAAA,CAAQm8B,MAAA,CAAOz/B,CAAA;YAE5B,KADA,IAAIS,CAAA,QAAiB,MAAXR,CAAA,GAAuBD,CAAA,CAAO6lD,GAAA,GAAM7lD,CAAA,CAAO8lD,GAAA,GAAM7lD,CAAA,EAAQO,CAAA,GAAU,IAAI6K,CAAA,CAAMxH,IAAA,CAAK6kD,gBAAA,IACrF1oD,CAAA,CAAO8lD,GAAA,GAAMrlD,CAAA,GAAK;cACrB,IAAIC,CAAA,GAAMV,CAAA,CAAOmlD,MAAA;cACTzkD,CAAA,KAAQ,KACX,KACSF,CAAA,CAAQ68B,GAAA,IAAO78B,CAAA,CAAQ68B,GAAA,CAAIv7B,MAAA,KAC7BtB,CAAA,CAAQ68B,GAAA,GAAM,KAClB78B,CAAA,CAAQ68B,GAAA,CAAIr2B,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAK6kD,gBAAA,CAAiB5jB,SAAA,CAAU31B,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,QAIjFnlD,CAAA,CAAO+lD,QAAA,CAAe,IAANrlD,CAAA,CAGxB;YAAA;YACA,OAAOF,CACX;UAAA,GAYAR,CAAA,CAAiBgmD,eAAA,GAAkB,UAAyBhmD,CAAA;YAGxD,OAFMA,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAAS,IAAIsD,CAAA,CAAQtD,CAAA,IAClB,KAAKmP,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,GACtC;UAAA,GAUAnlD,CAAA,CAAiBimD,MAAA,GAAS,UAAgBjmD,CAAA;YACtC,IAAuB,mBAAZA,CAAA,IAAoC,SAAZA,CAAA,EAC/B,OAAO;YACX,IAAmB,QAAfA,CAAA,CAAQq9B,GAAA,IAAer9B,CAAA,CAAQmlB,cAAA,CAAe,QAAQ;cACtD,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQq9B,GAAA,GACvB,OAAO;cACX,KAAK,IAAIp9B,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQq9B,GAAA,CAAIv7B,MAAA,IAAU7B,CAAA,EAAG;gBACzC,IAAIQ,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAK6kD,gBAAA,CAAiB5jB,SAAA,CAAUmhB,MAAA,CAAOjmD,CAAA,CAAQq9B,GAAA,CAAIp9B,CAAA;gBACrE,IAAIQ,CAAA,EACA,OAAO,SAASA,CACxB;cAAA;YACJ;YACA,OAAO,IACX;UAAA,GAUAT,CAAA,CAAiBmmD,UAAA,GAAa,UAAoBnmD,CAAA;YAC9C,IAAIA,CAAA,YAAkBqL,CAAA,CAAMxH,IAAA,CAAK6kD,gBAAA,EAC7B,OAAO1oD,CAAA;YACX,IAAIC,CAAA,GAAU,IAAIoL,CAAA,CAAMxH,IAAA,CAAK6kD,gBAAA;YAC7B,IAAI1oD,CAAA,CAAOq9B,GAAA,EAAK;cACZ,KAAKr3B,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOq9B,GAAA,GACtB,MAAMtb,SAAA,CAAU;cACpB9hB,CAAA,CAAQo9B,GAAA,GAAM;cACd,KAAK,IAAI58B,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOq9B,GAAA,CAAIv7B,MAAA,IAAUrB,CAAA,EAAG;gBACxC,IAA6B,mBAAlBT,CAAA,CAAOq9B,GAAA,CAAI58B,CAAA,GAClB,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQo9B,GAAA,CAAI58B,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAK6kD,gBAAA,CAAiB5jB,SAAA,CAAUqhB,UAAA,CAAWnmD,CAAA,CAAOq9B,GAAA,CAAI58B,CAAA,EACjF;cAAA;YACJ;YACA,OAAOR,CACX;UAAA,GAWAD,CAAA,CAAiBumD,QAAA,GAAW,UAAkBvmD,CAAA,EAASC,CAAA;YAC9CA,CAAA,KACDA,CAAA,GAAU,CAAC;YACf,IAAIQ,CAAA,GAAS,CAAC;YAGd,KAFIR,CAAA,CAAQumD,MAAA,IAAUvmD,CAAA,CAAQwmD,QAAA,MAC1BhmD,CAAA,CAAO48B,GAAA,GAAM,KACbr9B,CAAA,CAAQq9B,GAAA,IAAOr9B,CAAA,CAAQq9B,GAAA,CAAIv7B,MAAA,EAAQ;cACnCrB,CAAA,CAAO48B,GAAA,GAAM;cACb,KAAK,IAAI78B,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQq9B,GAAA,CAAIv7B,MAAA,IAAUtB,CAAA,EACtCC,CAAA,CAAO48B,GAAA,CAAI78B,CAAA,IAAK6K,CAAA,CAAMxH,IAAA,CAAK6kD,gBAAA,CAAiB5jB,SAAA,CAAUyhB,QAAA,CAASvmD,CAAA,CAAQq9B,GAAA,CAAI78B,CAAA,GAAIP,CAAA,CACvF;YAAA;YACA,OAAOQ,CACX;UAAA,GASAT,CAAA,CAAiB6kD,SAAA,CAAUiC,MAAA,GAAS;YAChC,OAAO,KAAKlkD,WAAA,CAAY2jD,QAAA,CAAS,MAAMrlD,CAAA,CAAUsjD,IAAA,CAAKuC,aAAA,CAC1D;UAAA,GAUA/mD,CAAA,CAAiBgnD,UAAA,GAAa,UAAoBhnD,CAAA;YAI9C,YAHsB,MAAlBA,CAAA,KACAA,CAAA,GAAgB,wBAEbA,CAAA,GAAgB,wBAC3B;UAAA,GAEAA,CAAA,CAAiB8kC,SAAA,GAAY;YAmBzB,SAAS9kC,EAAUA,CAAA;cACf,IAAIA,CAAA,EACA,KAAK,IAAIC,CAAA,GAAO4C,MAAA,CAAO6N,IAAA,CAAK1Q,CAAA,GAAaS,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK6B,MAAA,IAAUrB,CAAA,EACpC,QAAvBT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,OAChB,KAAKR,CAAA,CAAKQ,CAAA,KAAMT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,GAChD;YAAA;YA2BA,IAAIR,CAAA;YAsOJ,OAzPAD,CAAA,CAAU6kD,SAAA,CAAUvnB,QAAA,GAAW,MAQ/Bt9B,CAAA,CAAU6kD,SAAA,CAAU9d,QAAA,GAAW,MAQ/B/mC,CAAA,CAAU6kD,SAAA,CAAU3e,UAAA,GAAa,IAWjCrjC,MAAA,CAAO8lD,cAAA,CAAe3oD,CAAA,CAAU6kD,SAAA,EAAW,SAAS;cAChDrgD,GAAA,EAAKiG,CAAA,CAAMm+C,WAAA,CAAY3oD,CAAA,GAAe,CAAC,YAAY;cACnD8D,GAAA,EAAK0G,CAAA,CAAMo+C,WAAA,CAAY5oD,CAAA;YAAA,IAW3BD,CAAA,CAAUy/B,MAAA,GAAS,UAAgBx/B,CAAA;cAC/B,OAAO,IAAID,CAAA,CAAUC,CAAA,CACzB;YAAA,GAWAD,CAAA,CAAUkP,MAAA,GAAS,UAAgBlP,CAAA,EAASC,CAAA;cASxC,OARKA,CAAA,KACDA,CAAA,GAASyD,CAAA,CAAQ+7B,MAAA,KACG,QAApBz/B,CAAA,CAAQs9B,QAAA,IAAoBz6B,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,eAChEC,CAAA,CAAOklD,MAAA,CAA8B,GAAGG,KAAA,CAAMtlD,CAAA,CAAQs9B,QAAA,GAClC,QAApBt9B,CAAA,CAAQ+mC,QAAA,IAAoBlkC,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,eAChEC,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQ+mC,QAAA,GAClC,QAAtB/mC,CAAA,CAAQkmC,UAAA,IAAsBrjC,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,iBAClEC,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQkmC,UAAA,GACrDjmC,CACX;YAAA,GAWAD,CAAA,CAAU4lD,eAAA,GAAkB,UAAyB5lD,CAAA,EAASC,CAAA;cAC1D,OAAO,KAAKiP,MAAA,CAAOlP,CAAA,EAASC,CAAA,EAAQulD,MAAA,EACxC;YAAA,GAaAxlD,CAAA,CAAUmP,MAAA,GAAS,UAAgBnP,CAAA,EAAQC,CAAA;cACjCD,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAASsD,CAAA,CAAQm8B,MAAA,CAAOz/B,CAAA;cAE5B,KADA,IAAIS,CAAA,QAAiB,MAAXR,CAAA,GAAuBD,CAAA,CAAO6lD,GAAA,GAAM7lD,CAAA,CAAO8lD,GAAA,GAAM7lD,CAAA,EAAQO,CAAA,GAAU,IAAI6K,CAAA,CAAMxH,IAAA,CAAK6kD,gBAAA,CAAiB5jB,SAAA,IACtG9kC,CAAA,CAAO8lD,GAAA,GAAMrlD,CAAA,GAAK;gBACrB,IAAIC,CAAA,GAAMV,CAAA,CAAOmlD,MAAA;gBACjB,QAAQzkD,CAAA,KAAQ;kBAChB,KAAK;oBACGF,CAAA,CAAQ88B,QAAA,GAAWt9B,CAAA,CAAOslD,KAAA;oBAC1B;kBAER,KAAK;oBACG9kD,CAAA,CAAQumC,QAAA,GAAW/mC,CAAA,CAAOolD,MAAA;oBAC1B;kBAER,KAAK;oBACG5kD,CAAA,CAAQ0lC,UAAA,GAAalmC,CAAA,CAAOolD,MAAA;oBAC5B;kBAER;oBACIplD,CAAA,CAAO+lD,QAAA,CAAe,IAANrlD,CAAA;gBAAA;cAGxB;cACA,OAAOF,CACX;YAAA,GAYAR,CAAA,CAAUgmD,eAAA,GAAkB,UAAyBhmD,CAAA;cAGjD,OAFMA,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAAS,IAAIsD,CAAA,CAAQtD,CAAA,IAClB,KAAKmP,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,GACtC;YAAA,GAUAnlD,CAAA,CAAUimD,MAAA,GAAS,UAAgBjmD,CAAA;cAC/B,IAAuB,mBAAZA,CAAA,IAAoC,SAAZA,CAAA,EAC/B,OAAO;cACX,IAAIC,CAAA,GAAa,CAAC;cAClB,IAAwB,QAApBD,CAAA,CAAQs9B,QAAA,IAAoBt9B,CAAA,CAAQmlB,cAAA,CAAe,gBACnDllB,CAAA,CAAWkkB,KAAA,GAAQ,KACd1Z,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQs9B,QAAA,KAAet9B,CAAA,CAAQs9B,QAAA,IAAY7yB,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQs9B,QAAA,CAAS6e,GAAA,KAAQ1xC,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQs9B,QAAA,CAAS8e,IAAA,KACtI,OAAO;cAEf,IAAwB,QAApBp8C,CAAA,CAAQ+mC,QAAA,IAAoB/mC,CAAA,CAAQmlB,cAAA,CAAe,aAAa;gBAChE,IAAyB,MAArBllB,CAAA,CAAWkkB,KAAA,EACX,OAAO;gBAEX,IADAlkB,CAAA,CAAWkkB,KAAA,GAAQ,IACd1Z,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQ+mC,QAAA,GACxB,OAAO,2BACf;cAAA;cACA,OAA0B,QAAtB/mC,CAAA,CAAQkmC,UAAA,IAAsBlmC,CAAA,CAAQmlB,cAAA,CAAe,kBAChD1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQkmC,UAAA,IACjB,gCACR,IACX;YAAA,GAUAlmC,CAAA,CAAUmmD,UAAA,GAAa,UAAoBnmD,CAAA;cACvC,IAAIA,CAAA,YAAkBqL,CAAA,CAAMxH,IAAA,CAAK6kD,gBAAA,CAAiB5jB,SAAA,EAC9C,OAAO9kC,CAAA;cACX,IAAIC,CAAA,GAAU,IAAIoL,CAAA,CAAMxH,IAAA,CAAK6kD,gBAAA,CAAiB5jB,SAAA;cAc9C,OAbuB,QAAnB9kC,CAAA,CAAOs9B,QAAA,KACH7yB,CAAA,CAAMwxC,IAAA,IACLh8C,CAAA,CAAQq9B,QAAA,GAAW7yB,CAAA,CAAMwxC,IAAA,CAAKC,SAAA,CAAUl8C,CAAA,CAAOs9B,QAAA,GAAW+e,QAAA,IAAW,IACtC,mBAApBr8C,CAAA,CAAOs9B,QAAA,GACnBr9B,CAAA,CAAQq9B,QAAA,GAAW4E,QAAA,CAASliC,CAAA,CAAOs9B,QAAA,EAAU,MACb,mBAApBt9B,CAAA,CAAOs9B,QAAA,GACnBr9B,CAAA,CAAQq9B,QAAA,GAAWt9B,CAAA,CAAOs9B,QAAA,GACM,mBAApBt9B,CAAA,CAAOs9B,QAAA,KACnBr9B,CAAA,CAAQq9B,QAAA,GAAW,IAAI7yB,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAOs9B,QAAA,CAAS6e,GAAA,KAAQ,GAAGn8C,CAAA,CAAOs9B,QAAA,CAAS8e,IAAA,KAAS,GAAGxB,QAAA,MAC9E,QAAnB56C,CAAA,CAAO+mC,QAAA,KACP9mC,CAAA,CAAQ8mC,QAAA,GAAWqf,MAAA,CAAOpmD,CAAA,CAAO+mC,QAAA,IACZ,QAArB/mC,CAAA,CAAOkmC,UAAA,KACPjmC,CAAA,CAAQimC,UAAA,GAAakgB,MAAA,CAAOpmD,CAAA,CAAOkmC,UAAA,IAChCjmC,CACX;YAAA,GAWAD,CAAA,CAAUumD,QAAA,GAAW,UAAkBvmD,CAAA,EAASC,CAAA;cACvCA,CAAA,KACDA,CAAA,GAAU,CAAC;cACf,IAAIQ,CAAA,GAAS,CAAC;cAkBd,OAjBIR,CAAA,CAAQwmD,QAAA,KACRhmD,CAAA,CAAOylC,UAAA,GAAa,KACA,QAApBlmC,CAAA,CAAQs9B,QAAA,IAAoBt9B,CAAA,CAAQmlB,cAAA,CAAe,gBACnB,mBAArBnlB,CAAA,CAAQs9B,QAAA,GACf78B,CAAA,CAAO68B,QAAA,GAAWr9B,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAASA,MAAA,CAAOpmD,CAAA,CAAQs9B,QAAA,IAAYt9B,CAAA,CAAQs9B,QAAA,GAEhF78B,CAAA,CAAO68B,QAAA,GAAWr9B,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS37C,CAAA,CAAMwxC,IAAA,CAAK4I,SAAA,CAAUtuB,QAAA,CAASnR,IAAA,CAAKplB,CAAA,CAAQs9B,QAAA,IAAYr9B,CAAA,CAAQymD,KAAA,KAAUhlD,MAAA,GAAS,IAAI+I,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAQs9B,QAAA,CAAS6e,GAAA,KAAQ,GAAGn8C,CAAA,CAAQs9B,QAAA,CAAS8e,IAAA,KAAS,GAAGxB,QAAA,KAAa56C,CAAA,CAAQs9B,QAAA,EAChOr9B,CAAA,CAAQ6oD,MAAA,KACRroD,CAAA,CAAO0jB,KAAA,GAAQ,cAEC,QAApBnkB,CAAA,CAAQ+mC,QAAA,IAAoB/mC,CAAA,CAAQmlB,cAAA,CAAe,gBACnD1kB,CAAA,CAAOsmC,QAAA,GAAW/mC,CAAA,CAAQ+mC,QAAA,EACtB9mC,CAAA,CAAQ6oD,MAAA,KACRroD,CAAA,CAAO0jB,KAAA,GAAQ,cAEG,QAAtBnkB,CAAA,CAAQkmC,UAAA,IAAsBlmC,CAAA,CAAQmlB,cAAA,CAAe,kBACrD1kB,CAAA,CAAOylC,UAAA,GAAalmC,CAAA,CAAQkmC,UAAA,GACzBzlC,CACX;YAAA,GASAT,CAAA,CAAU6kD,SAAA,CAAUiC,MAAA,GAAS;cACzB,OAAO,KAAKlkD,WAAA,CAAY2jD,QAAA,CAAS,MAAMrlD,CAAA,CAAUsjD,IAAA,CAAKuC,aAAA,CAC1D;YAAA,GAUA/mD,CAAA,CAAUgnD,UAAA,GAAa,UAAoBhnD,CAAA;cAIvC,YAHsB,MAAlBA,CAAA,KACAA,CAAA,GAAgB,wBAEbA,CAAA,GAAgB,kCAC3B;YAAA,GAEOA,CACV;UAAA,CA1R4B,IA4RtBA,CACV;QAAA,CA1fuB,IA4fxBiB,CAAA,CAAKwkD,SAAA,GAAY;UAsBb,SAASzlD,EAAUA,CAAA;YACf,IAAIA,CAAA,EACA,KAAK,IAAIC,CAAA,GAAO4C,MAAA,CAAO6N,IAAA,CAAK1Q,CAAA,GAAaS,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK6B,MAAA,IAAUrB,CAAA,EACpC,QAAvBT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,OAChB,KAAKR,CAAA,CAAKQ,CAAA,KAAMT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,GAChD;UAAA;UAmDA,IAAIR,CAAA;UA84CJ,OAz7CAD,CAAA,CAAU6kD,SAAA,CAAUzpB,UAAA,GAAa,MAQjCp7B,CAAA,CAAU6kD,SAAA,CAAUkE,YAAA,GAAe,MAQnC/oD,CAAA,CAAU6kD,SAAA,CAAUmE,OAAA,GAAU,MAQ9BhpD,CAAA,CAAU6kD,SAAA,CAAUoE,YAAA,GAAe,MAQnCjpD,CAAA,CAAU6kD,SAAA,CAAUqE,gBAAA,GAAmB,MAQvClpD,CAAA,CAAU6kD,SAAA,CAAU3e,UAAA,GAAa,IAWjCrjC,MAAA,CAAO8lD,cAAA,CAAe3oD,CAAA,CAAU6kD,SAAA,EAAW,SAAS;YAChDrgD,GAAA,EAAKiG,CAAA,CAAMm+C,WAAA,CAAY3oD,CAAA,GAAe,CAAC,cAAc,gBAAgB,WAAW,gBAAgB;YAChG8D,GAAA,EAAK0G,CAAA,CAAMo+C,WAAA,CAAY5oD,CAAA;UAAA,IAW3BD,CAAA,CAAUy/B,MAAA,GAAS,UAAgBx/B,CAAA;YAC/B,OAAO,IAAID,CAAA,CAAUC,CAAA,CACzB;UAAA,GAWAD,CAAA,CAAUkP,MAAA,GAAS,UAAgBlP,CAAA,EAASC,CAAA;YAexC,OAdKA,CAAA,KACDA,CAAA,GAASyD,CAAA,CAAQ+7B,MAAA,KACK,QAAtBz/B,CAAA,CAAQo7B,UAAA,IAAsBv4B,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,iBAClEqL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUx/C,MAAA,CAAOiJ,MAAA,CAAOlP,CAAA,CAAQo7B,UAAA,EAAYn7B,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA,IAChF,QAAxBxlD,CAAA,CAAQ+oD,YAAA,IAAwBlmD,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,mBACpEqL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU0D,QAAA,CAASj6C,MAAA,CAAOlP,CAAA,CAAQ+oD,YAAA,EAAc9oD,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA,IACzF,QAAnBxlD,CAAA,CAAQgpD,OAAA,IAAmBnmD,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,cAC/DqL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU7hD,GAAA,CAAIsL,MAAA,CAAOlP,CAAA,CAAQgpD,OAAA,EAAS/oD,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA,IAC5E,QAAtBxlD,CAAA,CAAQkmC,UAAA,IAAsBrjC,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,iBAClEC,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQkmC,UAAA,GAC5B,QAA5BlmC,CAAA,CAAQkpD,gBAAA,IAA4BrmD,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,uBACxEqL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUtV,YAAA,CAAajhC,MAAA,CAAOlP,CAAA,CAAQkpD,gBAAA,EAAkBjpD,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA,IAC5F,QAAxBxlD,CAAA,CAAQipD,YAAA,IAAwBpmD,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,mBACpEqL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU2D,QAAA,CAASl6C,MAAA,CAAOlP,CAAA,CAAQipD,YAAA,EAAchpD,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA,IACzGvlD,CACX;UAAA,GAWAD,CAAA,CAAU4lD,eAAA,GAAkB,UAAyB5lD,CAAA,EAASC,CAAA;YAC1D,OAAO,KAAKiP,MAAA,CAAOlP,CAAA,EAASC,CAAA,EAAQulD,MAAA,EACxC;UAAA,GAaAxlD,CAAA,CAAUmP,MAAA,GAAS,UAAgBnP,CAAA,EAAQC,CAAA;YACjCD,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAASsD,CAAA,CAAQm8B,MAAA,CAAOz/B,CAAA;YAE5B,KADA,IAAIS,CAAA,QAAiB,MAAXR,CAAA,GAAuBD,CAAA,CAAO6lD,GAAA,GAAM7lD,CAAA,CAAO8lD,GAAA,GAAM7lD,CAAA,EAAQO,CAAA,GAAU,IAAI6K,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,IACrFzlD,CAAA,CAAO8lD,GAAA,GAAMrlD,CAAA,GAAK;cACrB,IAAIC,CAAA,GAAMV,CAAA,CAAOmlD,MAAA;cACjB,QAAQzkD,CAAA,KAAQ;gBAChB,KAAK;kBACGF,CAAA,CAAQ46B,UAAA,GAAa/vB,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUx/C,MAAA,CAAOkJ,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBACvE;gBAER,KAAK;kBACG3kD,CAAA,CAAQuoD,YAAA,GAAe19C,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU0D,QAAA,CAASh6C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBAC3E;gBAER,KAAK;kBACG3kD,CAAA,CAAQwoD,OAAA,GAAU39C,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU7hD,GAAA,CAAIuL,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBACjE;gBAER,KAAK;kBACG3kD,CAAA,CAAQyoD,YAAA,GAAe59C,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU2D,QAAA,CAASj6C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBAC3E;gBAER,KAAK;kBACG3kD,CAAA,CAAQ0oD,gBAAA,GAAmB79C,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUtV,YAAA,CAAahhC,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBACnF;gBAER,KAAK;kBACG3kD,CAAA,CAAQ0lC,UAAA,GAAalmC,CAAA,CAAOolD,MAAA;kBAC5B;gBAER;kBACIplD,CAAA,CAAO+lD,QAAA,CAAe,IAANrlD,CAAA;cAAA;YAGxB;YACA,OAAOF,CACX;UAAA,GAYAR,CAAA,CAAUgmD,eAAA,GAAkB,UAAyBhmD,CAAA;YAGjD,OAFMA,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAAS,IAAIsD,CAAA,CAAQtD,CAAA,IAClB,KAAKmP,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,GACtC;UAAA,GAUAnlD,CAAA,CAAUimD,MAAA,GAAS,UAAgBjmD,CAAA;YAC/B,IAAuB,mBAAZA,CAAA,IAAoC,SAAZA,CAAA,EAC/B,OAAO;YACX,IAAIC,CAAA,GAAa,CAAC;YAClB,IAA0B,QAAtBD,CAAA,CAAQo7B,UAAA,IAAsBp7B,CAAA,CAAQmlB,cAAA,CAAe,kBACrDllB,CAAA,CAAWkkB,KAAA,GAAQ,GAEX1jB,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUx/C,MAAA,CAAOggD,MAAA,CAAOjmD,CAAA,CAAQo7B,UAAA,IAEnD,OAAO,gBAAgB36B,CAAA;YAGnC,IAA4B,QAAxBT,CAAA,CAAQ+oD,YAAA,IAAwB/oD,CAAA,CAAQmlB,cAAA,CAAe,iBAAiB;cACxE,IAAyB,MAArBllB,CAAA,CAAWkkB,KAAA,EACX,OAAO;cAIP,IAHJlkB,CAAA,CAAWkkB,KAAA,GAAQ,GAEX1jB,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU0D,QAAA,CAASlD,MAAA,CAAOjmD,CAAA,CAAQ+oD,YAAA,GAErD,OAAO,kBAAkBtoD,CAErC;YAAA;YACA,IAAuB,QAAnBT,CAAA,CAAQgpD,OAAA,IAAmBhpD,CAAA,CAAQmlB,cAAA,CAAe,YAAY;cAC9D,IAAyB,MAArBllB,CAAA,CAAWkkB,KAAA,EACX,OAAO;cAIP,IAHJlkB,CAAA,CAAWkkB,KAAA,GAAQ,GAEX1jB,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU7hD,GAAA,CAAIqiD,MAAA,CAAOjmD,CAAA,CAAQgpD,OAAA,GAEhD,OAAO,aAAavoD,CAEhC;YAAA;YACA,IAA4B,QAAxBT,CAAA,CAAQipD,YAAA,IAAwBjpD,CAAA,CAAQmlB,cAAA,CAAe,iBAAiB;cACxE,IAAyB,MAArBllB,CAAA,CAAWkkB,KAAA,EACX,OAAO;cAIP,IAHJlkB,CAAA,CAAWkkB,KAAA,GAAQ,GAEX1jB,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU2D,QAAA,CAASnD,MAAA,CAAOjmD,CAAA,CAAQipD,YAAA,GAErD,OAAO,kBAAkBxoD,CAErC;YAAA;YACA,IAAgC,QAA5BT,CAAA,CAAQkpD,gBAAA,IAA4BlpD,CAAA,CAAQmlB,cAAA,CAAe,qBAAqB;cAChF,IAAyB,MAArBllB,CAAA,CAAWkkB,KAAA,EACX,OAAO;cAGP,IAAI1jB,CAAA;cACJ,IAHJR,CAAA,CAAWkkB,KAAA,GAAQ,GAEX1jB,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUtV,YAAA,CAAa8V,MAAA,CAAOjmD,CAAA,CAAQkpD,gBAAA,GAEzD,OAAO,sBAAsBzoD,CAEzC;YAAA;YACA,OAA0B,QAAtBT,CAAA,CAAQkmC,UAAA,IAAsBlmC,CAAA,CAAQmlB,cAAA,CAAe,kBAChD1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQkmC,UAAA,IACjB,gCACR,IACX;UAAA,GAUAlmC,CAAA,CAAUmmD,UAAA,GAAa,UAAoBnmD,CAAA;YACvC,IAAIA,CAAA,YAAkBqL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,EAC7B,OAAOzlD,CAAA;YACX,IAAIC,CAAA,GAAU,IAAIoL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA;YAC7B,IAAyB,QAArBzlD,CAAA,CAAOo7B,UAAA,EAAoB;cAC3B,IAAiC,mBAAtBp7B,CAAA,CAAOo7B,UAAA,EACd,MAAMrZ,SAAA,CAAU;cACpB9hB,CAAA,CAAQm7B,UAAA,GAAa/vB,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUx/C,MAAA,CAAOkgD,UAAA,CAAWnmD,CAAA,CAAOo7B,UAAA,CACvE;YAAA;YACA,IAA2B,QAAvBp7B,CAAA,CAAO+oD,YAAA,EAAsB;cAC7B,IAAmC,mBAAxB/oD,CAAA,CAAO+oD,YAAA,EACd,MAAMhnC,SAAA,CAAU;cACpB9hB,CAAA,CAAQ8oD,YAAA,GAAe19C,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU0D,QAAA,CAAShD,UAAA,CAAWnmD,CAAA,CAAO+oD,YAAA,CAC3E;YAAA;YACA,IAAsB,QAAlB/oD,CAAA,CAAOgpD,OAAA,EAAiB;cACxB,IAA8B,mBAAnBhpD,CAAA,CAAOgpD,OAAA,EACd,MAAMjnC,SAAA,CAAU;cACpB9hB,CAAA,CAAQ+oD,OAAA,GAAU39C,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU7hD,GAAA,CAAIuiD,UAAA,CAAWnmD,CAAA,CAAOgpD,OAAA,CACjE;YAAA;YACA,IAA2B,QAAvBhpD,CAAA,CAAOipD,YAAA,EAAsB;cAC7B,IAAmC,mBAAxBjpD,CAAA,CAAOipD,YAAA,EACd,MAAMlnC,SAAA,CAAU;cACpB9hB,CAAA,CAAQgpD,YAAA,GAAe59C,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU2D,QAAA,CAASjD,UAAA,CAAWnmD,CAAA,CAAOipD,YAAA,CAC3E;YAAA;YACA,IAA+B,QAA3BjpD,CAAA,CAAOkpD,gBAAA,EAA0B;cACjC,IAAuC,mBAA5BlpD,CAAA,CAAOkpD,gBAAA,EACd,MAAMnnC,SAAA,CAAU;cACpB9hB,CAAA,CAAQipD,gBAAA,GAAmB79C,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUtV,YAAA,CAAagW,UAAA,CAAWnmD,CAAA,CAAOkpD,gBAAA,CACnF;YAAA;YAGA,OAFyB,QAArBlpD,CAAA,CAAOkmC,UAAA,KACPjmC,CAAA,CAAQimC,UAAA,GAAakgB,MAAA,CAAOpmD,CAAA,CAAOkmC,UAAA,IAChCjmC,CACX;UAAA,GAWAD,CAAA,CAAUumD,QAAA,GAAW,UAAkBvmD,CAAA,EAASC,CAAA;YACvCA,CAAA,KACDA,CAAA,GAAU,CAAC;YACf,IAAIQ,CAAA,GAAS,CAAC;YA8Bd,OA7BIR,CAAA,CAAQwmD,QAAA,KACRhmD,CAAA,CAAOylC,UAAA,GAAa,KACE,QAAtBlmC,CAAA,CAAQo7B,UAAA,IAAsBp7B,CAAA,CAAQmlB,cAAA,CAAe,kBACrD1kB,CAAA,CAAO26B,UAAA,GAAa/vB,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUx/C,MAAA,CAAOsgD,QAAA,CAASvmD,CAAA,CAAQo7B,UAAA,EAAYn7B,CAAA,GACzEA,CAAA,CAAQ6oD,MAAA,KACRroD,CAAA,CAAO0jB,KAAA,GAAQ,gBAEK,QAAxBnkB,CAAA,CAAQ+oD,YAAA,IAAwB/oD,CAAA,CAAQmlB,cAAA,CAAe,oBACvD1kB,CAAA,CAAOsoD,YAAA,GAAe19C,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU0D,QAAA,CAAS5C,QAAA,CAASvmD,CAAA,CAAQ+oD,YAAA,EAAc9oD,CAAA,GAC/EA,CAAA,CAAQ6oD,MAAA,KACRroD,CAAA,CAAO0jB,KAAA,GAAQ,kBAEA,QAAnBnkB,CAAA,CAAQgpD,OAAA,IAAmBhpD,CAAA,CAAQmlB,cAAA,CAAe,eAClD1kB,CAAA,CAAOuoD,OAAA,GAAU39C,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU7hD,GAAA,CAAI2iD,QAAA,CAASvmD,CAAA,CAAQgpD,OAAA,EAAS/oD,CAAA,GAChEA,CAAA,CAAQ6oD,MAAA,KACRroD,CAAA,CAAO0jB,KAAA,GAAQ,aAEG,QAAtBnkB,CAAA,CAAQkmC,UAAA,IAAsBlmC,CAAA,CAAQmlB,cAAA,CAAe,kBACrD1kB,CAAA,CAAOylC,UAAA,GAAalmC,CAAA,CAAQkmC,UAAA,GACA,QAA5BlmC,CAAA,CAAQkpD,gBAAA,IAA4BlpD,CAAA,CAAQmlB,cAAA,CAAe,wBAC3D1kB,CAAA,CAAOyoD,gBAAA,GAAmB79C,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUtV,YAAA,CAAaoW,QAAA,CAASvmD,CAAA,CAAQkpD,gBAAA,EAAkBjpD,CAAA,GAC3FA,CAAA,CAAQ6oD,MAAA,KACRroD,CAAA,CAAO0jB,KAAA,GAAQ,sBAEK,QAAxBnkB,CAAA,CAAQipD,YAAA,IAAwBjpD,CAAA,CAAQmlB,cAAA,CAAe,oBACvD1kB,CAAA,CAAOwoD,YAAA,GAAe59C,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU2D,QAAA,CAAS7C,QAAA,CAASvmD,CAAA,CAAQipD,YAAA,EAAchpD,CAAA,GAC/EA,CAAA,CAAQ6oD,MAAA,KACRroD,CAAA,CAAO0jB,KAAA,GAAQ,kBAEhB1jB,CACX;UAAA,GASAT,CAAA,CAAU6kD,SAAA,CAAUiC,MAAA,GAAS;YACzB,OAAO,KAAKlkD,WAAA,CAAY2jD,QAAA,CAAS,MAAMrlD,CAAA,CAAUsjD,IAAA,CAAKuC,aAAA,CAC1D;UAAA,GAUA/mD,CAAA,CAAUgnD,UAAA,GAAa,UAAoBhnD,CAAA;YAIvC,YAHsB,MAAlBA,CAAA,KACAA,CAAA,GAAgB,wBAEbA,CAAA,GAAgB,iBAC3B;UAAA,GAEAA,CAAA,CAAUiG,MAAA,GAAS;YAkBf,SAASjG,EAAOA,CAAA;cACZ,IAAIA,CAAA,EACA,KAAK,IAAIC,CAAA,GAAO4C,MAAA,CAAO6N,IAAA,CAAK1Q,CAAA,GAAaS,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK6B,MAAA,IAAUrB,CAAA,EACpC,QAAvBT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,OAChB,KAAKR,CAAA,CAAKQ,CAAA,KAAMT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,GAChD;YAAA;YA8MA,OAtMAT,CAAA,CAAO6kD,SAAA,CAAU1nB,QAAA,GAAW,GAQ5Bn9B,CAAA,CAAO6kD,SAAA,CAAU/2C,KAAA,GAAQ,MAUzB9N,CAAA,CAAOy/B,MAAA,GAAS,UAAgBx/B,CAAA;cAC5B,OAAO,IAAID,CAAA,CAAOC,CAAA,CACtB;YAAA,GAWAD,CAAA,CAAOkP,MAAA,GAAS,UAAgBlP,CAAA,EAASC,CAAA;cAOrC,OANKA,CAAA,KACDA,CAAA,GAASyD,CAAA,CAAQ+7B,MAAA,KACG,QAApBz/B,CAAA,CAAQm9B,QAAA,IAAoBt6B,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,eAChEC,CAAA,CAAOklD,MAAA,CAA8B,GAAGO,KAAA,CAAM1lD,CAAA,CAAQm9B,QAAA,GACrC,QAAjBn9B,CAAA,CAAQ8N,KAAA,IAAiBjL,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,YAC7DqL,CAAA,CAAMxH,IAAA,CAAK6kD,gBAAA,CAAiBx5C,MAAA,CAAOlP,CAAA,CAAQ8N,KAAA,EAAO7N,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA,IAChGvlD,CACX;YAAA,GAWAD,CAAA,CAAO4lD,eAAA,GAAkB,UAAyB5lD,CAAA,EAASC,CAAA;cACvD,OAAO,KAAKiP,MAAA,CAAOlP,CAAA,EAASC,CAAA,EAAQulD,MAAA,EACxC;YAAA,GAaAxlD,CAAA,CAAOmP,MAAA,GAAS,UAAgBnP,CAAA,EAAQC,CAAA;cAC9BD,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAASsD,CAAA,CAAQm8B,MAAA,CAAOz/B,CAAA;cAE5B,KADA,IAAIS,CAAA,QAAiB,MAAXR,CAAA,GAAuBD,CAAA,CAAO6lD,GAAA,GAAM7lD,CAAA,CAAO8lD,GAAA,GAAM7lD,CAAA,EAAQO,CAAA,GAAU,IAAI6K,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUx/C,MAAA,IAC/FjG,CAAA,CAAO8lD,GAAA,GAAMrlD,CAAA,GAAK;gBACrB,IAAIC,CAAA,GAAMV,CAAA,CAAOmlD,MAAA;gBACjB,QAAQzkD,CAAA,KAAQ;kBAChB,KAAK;oBACGF,CAAA,CAAQ28B,QAAA,GAAWn9B,CAAA,CAAO0lD,KAAA;oBAC1B;kBAER,KAAK;oBACGllD,CAAA,CAAQsN,KAAA,GAAQzC,CAAA,CAAMxH,IAAA,CAAK6kD,gBAAA,CAAiBv5C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;oBAClE;kBAER;oBACInlD,CAAA,CAAO+lD,QAAA,CAAe,IAANrlD,CAAA;gBAAA;cAGxB;cACA,OAAOF,CACX;YAAA,GAYAR,CAAA,CAAOgmD,eAAA,GAAkB,UAAyBhmD,CAAA;cAG9C,OAFMA,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAAS,IAAIsD,CAAA,CAAQtD,CAAA,IAClB,KAAKmP,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,GACtC;YAAA,GAUAnlD,CAAA,CAAOimD,MAAA,GAAS,UAAgBjmD,CAAA;cAC5B,IAAuB,mBAAZA,CAAA,IAAoC,SAAZA,CAAA,EAC/B,OAAO;cACX,IAAwB,QAApBA,CAAA,CAAQm9B,QAAA,IAAoBn9B,CAAA,CAAQmlB,cAAA,CAAe,gBAC9C1a,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQm9B,QAAA,GACzB,OAAO;cACf,IAAqB,QAAjBn9B,CAAA,CAAQ8N,KAAA,IAAiB9N,CAAA,CAAQmlB,cAAA,CAAe,UAAU;gBAC1D,IAAIllB,CAAA,GAAQoL,CAAA,CAAMxH,IAAA,CAAK6kD,gBAAA,CAAiBzC,MAAA,CAAOjmD,CAAA,CAAQ8N,KAAA;gBACvD,IAAI7N,CAAA,EACA,OAAO,WAAWA,CAC1B;cAAA;cACA,OAAO,IACX;YAAA,GAUAD,CAAA,CAAOmmD,UAAA,GAAa,UAAoBnmD,CAAA;cACpC,IAAIA,CAAA,YAAkBqL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUx/C,MAAA,EACvC,OAAOjG,CAAA;cACX,IAAIC,CAAA,GAAU,IAAIoL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUx/C,MAAA;cAGvC,IAFuB,QAAnBjG,CAAA,CAAOm9B,QAAA,KACPl9B,CAAA,CAAQk9B,QAAA,GAA6B,IAAlBn9B,CAAA,CAAOm9B,QAAA,GACV,QAAhBn9B,CAAA,CAAO8N,KAAA,EAAe;gBACtB,IAA4B,mBAAjB9N,CAAA,CAAO8N,KAAA,EACd,MAAMiU,SAAA,CAAU;gBACpB9hB,CAAA,CAAQ6N,KAAA,GAAQzC,CAAA,CAAMxH,IAAA,CAAK6kD,gBAAA,CAAiBvC,UAAA,CAAWnmD,CAAA,CAAO8N,KAAA,CAClE;cAAA;cACA,OAAO7N,CACX;YAAA,GAWAD,CAAA,CAAOumD,QAAA,GAAW,UAAkBvmD,CAAA,EAASC,CAAA;cACpCA,CAAA,KACDA,CAAA,GAAU,CAAC;cACf,IAAIQ,CAAA,GAAS,CAAC;cASd,OARIR,CAAA,CAAQwmD,QAAA,KACRhmD,CAAA,CAAO08B,QAAA,GAAW,GAClB18B,CAAA,CAAOqN,KAAA,GAAQ,OAEK,QAApB9N,CAAA,CAAQm9B,QAAA,IAAoBn9B,CAAA,CAAQmlB,cAAA,CAAe,gBACnD1kB,CAAA,CAAO08B,QAAA,GAAWn9B,CAAA,CAAQm9B,QAAA,GACT,QAAjBn9B,CAAA,CAAQ8N,KAAA,IAAiB9N,CAAA,CAAQmlB,cAAA,CAAe,aAChD1kB,CAAA,CAAOqN,KAAA,GAAQzC,CAAA,CAAMxH,IAAA,CAAK6kD,gBAAA,CAAiBnC,QAAA,CAASvmD,CAAA,CAAQ8N,KAAA,EAAO7N,CAAA,IAChEQ,CACX;YAAA,GASAT,CAAA,CAAO6kD,SAAA,CAAUiC,MAAA,GAAS;cACtB,OAAO,KAAKlkD,WAAA,CAAY2jD,QAAA,CAAS,MAAMrlD,CAAA,CAAUsjD,IAAA,CAAKuC,aAAA,CAC1D;YAAA,GAUA/mD,CAAA,CAAOgnD,UAAA,GAAa,UAAoBhnD,CAAA;cAIpC,YAHsB,MAAlBA,CAAA,KACAA,CAAA,GAAgB,wBAEbA,CAAA,GAAgB,wBAC3B;YAAA,GAEOA,CACV;UAAA,CAtOkB,IAwOnBA,CAAA,CAAUmpD,QAAA,GAAW;YAiBjB,SAASnpD,EAASA,CAAA;cACd,IAAIA,CAAA,EACA,KAAK,IAAIC,CAAA,GAAO4C,MAAA,CAAO6N,IAAA,CAAK1Q,CAAA,GAAaS,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK6B,MAAA,IAAUrB,CAAA,EACpC,QAAvBT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,OAChB,KAAKR,CAAA,CAAKQ,CAAA,KAAMT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,GAChD;YAAA;YAuLA,OA/KAT,CAAA,CAAS6kD,SAAA,CAAU1nB,QAAA,GAAW,MAU9Bn9B,CAAA,CAASy/B,MAAA,GAAS,UAAgBx/B,CAAA;cAC9B,OAAO,IAAID,CAAA,CAASC,CAAA,CACxB;YAAA,GAWAD,CAAA,CAASkP,MAAA,GAAS,UAAgBlP,CAAA,EAASC,CAAA;cAKvC,OAJKA,CAAA,KACDA,CAAA,GAASyD,CAAA,CAAQ+7B,MAAA,KACG,QAApBz/B,CAAA,CAAQm9B,QAAA,IAAoBt6B,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,eAChEqL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUv2C,MAAA,CAAOlP,CAAA,CAAQm9B,QAAA,EAAUl9B,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA,IAC5FvlD,CACX;YAAA,GAWAD,CAAA,CAAS4lD,eAAA,GAAkB,UAAyB5lD,CAAA,EAASC,CAAA;cACzD,OAAO,KAAKiP,MAAA,CAAOlP,CAAA,EAASC,CAAA,EAAQulD,MAAA,EACxC;YAAA,GAaAxlD,CAAA,CAASmP,MAAA,GAAS,UAAgBnP,CAAA,EAAQC,CAAA;cAChCD,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAASsD,CAAA,CAAQm8B,MAAA,CAAOz/B,CAAA;cAE5B,KADA,IAAIS,CAAA,QAAiB,MAAXR,CAAA,GAAuBD,CAAA,CAAO6lD,GAAA,GAAM7lD,CAAA,CAAO8lD,GAAA,GAAM7lD,CAAA,EAAQO,CAAA,GAAU,IAAI6K,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU0D,QAAA,IAC/FnpD,CAAA,CAAO8lD,GAAA,GAAMrlD,CAAA,GAAK;gBACrB,IAAIC,CAAA,GAAMV,CAAA,CAAOmlD,MAAA;gBACTzkD,CAAA,KAAQ,KACX,IACGF,CAAA,CAAQ28B,QAAA,GAAW9xB,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUt2C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,MAIlEnlD,CAAA,CAAO+lD,QAAA,CAAe,IAANrlD,CAAA,CAGxB;cAAA;cACA,OAAOF,CACX;YAAA,GAYAR,CAAA,CAASgmD,eAAA,GAAkB,UAAyBhmD,CAAA;cAGhD,OAFMA,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAAS,IAAIsD,CAAA,CAAQtD,CAAA,IAClB,KAAKmP,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,GACtC;YAAA,GAUAnlD,CAAA,CAASimD,MAAA,GAAS,UAAgBjmD,CAAA;cAC9B,IAAuB,mBAAZA,CAAA,IAAoC,SAAZA,CAAA,EAC/B,OAAO;cACX,IAAwB,QAApBA,CAAA,CAAQm9B,QAAA,IAAoBn9B,CAAA,CAAQmlB,cAAA,CAAe,aAAa;gBAChE,IAAIllB,CAAA,GAAQoL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUQ,MAAA,CAAOjmD,CAAA,CAAQm9B,QAAA;gBAChD,IAAIl9B,CAAA,EACA,OAAO,cAAcA,CAC7B;cAAA;cACA,OAAO,IACX;YAAA,GAUAD,CAAA,CAASmmD,UAAA,GAAa,UAAoBnmD,CAAA;cACtC,IAAIA,CAAA,YAAkBqL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU0D,QAAA,EACvC,OAAOnpD,CAAA;cACX,IAAIC,CAAA,GAAU,IAAIoL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU0D,QAAA;cACvC,IAAuB,QAAnBnpD,CAAA,CAAOm9B,QAAA,EAAkB;gBACzB,IAA+B,mBAApBn9B,CAAA,CAAOm9B,QAAA,EACd,MAAMpb,SAAA,CAAU;gBACpB9hB,CAAA,CAAQk9B,QAAA,GAAW9xB,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUU,UAAA,CAAWnmD,CAAA,CAAOm9B,QAAA,CAC9D;cAAA;cACA,OAAOl9B,CACX;YAAA,GAWAD,CAAA,CAASumD,QAAA,GAAW,UAAkBvmD,CAAA,EAASC,CAAA;cACtCA,CAAA,KACDA,CAAA,GAAU,CAAC;cACf,IAAIQ,CAAA,GAAS,CAAC;cAKd,OAJIR,CAAA,CAAQwmD,QAAA,KACRhmD,CAAA,CAAO08B,QAAA,GAAW,OACE,QAApBn9B,CAAA,CAAQm9B,QAAA,IAAoBn9B,CAAA,CAAQmlB,cAAA,CAAe,gBACnD1kB,CAAA,CAAO08B,QAAA,GAAW9xB,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUc,QAAA,CAASvmD,CAAA,CAAQm9B,QAAA,EAAUl9B,CAAA,IAC/DQ,CACX;YAAA,GASAT,CAAA,CAAS6kD,SAAA,CAAUiC,MAAA,GAAS;cACxB,OAAO,KAAKlkD,WAAA,CAAY2jD,QAAA,CAAS,MAAMrlD,CAAA,CAAUsjD,IAAA,CAAKuC,aAAA,CAC1D;YAAA,GAUA/mD,CAAA,CAASgnD,UAAA,GAAa,UAAoBhnD,CAAA;cAItC,YAHsB,MAAlBA,CAAA,KACAA,CAAA,GAAgB,wBAEbA,CAAA,GAAgB,0BAC3B;YAAA,GAEOA,CACV;UAAA,CA9MoB,IAgNrBA,CAAA,CAAU4D,GAAA,GAAM;YAkBZ,SAAS5D,EAAIA,CAAA;cACT,IAAIA,CAAA,EACA,KAAK,IAAIC,CAAA,GAAO4C,MAAA,CAAO6N,IAAA,CAAK1Q,CAAA,GAAaS,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK6B,MAAA,IAAUrB,CAAA,EACpC,QAAvBT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,OAChB,KAAKR,CAAA,CAAKQ,CAAA,KAAMT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,GAChD;YAAA;YA8MA,OAtMAT,CAAA,CAAI6kD,SAAA,CAAU3c,OAAA,GAAU,GAQxBloC,CAAA,CAAI6kD,SAAA,CAAU9nB,SAAA,GAAY,MAU1B/8B,CAAA,CAAIy/B,MAAA,GAAS,UAAgBx/B,CAAA;cACzB,OAAO,IAAID,CAAA,CAAIC,CAAA,CACnB;YAAA,GAWAD,CAAA,CAAIkP,MAAA,GAAS,UAAgBlP,CAAA,EAASC,CAAA;cAOlC,OANKA,CAAA,KACDA,CAAA,GAASyD,CAAA,CAAQ+7B,MAAA,KACE,QAAnBz/B,CAAA,CAAQkoC,OAAA,IAAmBrlC,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,cAC/DC,CAAA,CAAOklD,MAAA,CAA8B,GAAGO,KAAA,CAAM1lD,CAAA,CAAQkoC,OAAA,GACjC,QAArBloC,CAAA,CAAQ+8B,SAAA,IAAqBl6B,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,gBACjEqL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUv2C,MAAA,CAAOlP,CAAA,CAAQ+8B,SAAA,EAAW98B,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA,IAC7FvlD,CACX;YAAA,GAWAD,CAAA,CAAI4lD,eAAA,GAAkB,UAAyB5lD,CAAA,EAASC,CAAA;cACpD,OAAO,KAAKiP,MAAA,CAAOlP,CAAA,EAASC,CAAA,EAAQulD,MAAA,EACxC;YAAA,GAaAxlD,CAAA,CAAImP,MAAA,GAAS,UAAgBnP,CAAA,EAAQC,CAAA;cAC3BD,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAASsD,CAAA,CAAQm8B,MAAA,CAAOz/B,CAAA;cAE5B,KADA,IAAIS,CAAA,QAAiB,MAAXR,CAAA,GAAuBD,CAAA,CAAO6lD,GAAA,GAAM7lD,CAAA,CAAO8lD,GAAA,GAAM7lD,CAAA,EAAQO,CAAA,GAAU,IAAI6K,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU7hD,GAAA,IAC/F5D,CAAA,CAAO8lD,GAAA,GAAMrlD,CAAA,GAAK;gBACrB,IAAIC,CAAA,GAAMV,CAAA,CAAOmlD,MAAA;gBACjB,QAAQzkD,CAAA,KAAQ;kBAChB,KAAK;oBACGF,CAAA,CAAQ0nC,OAAA,GAAUloC,CAAA,CAAO0lD,KAAA;oBACzB;kBAER,KAAK;oBACGllD,CAAA,CAAQu8B,SAAA,GAAY1xB,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUt2C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;oBAC/D;kBAER;oBACInlD,CAAA,CAAO+lD,QAAA,CAAe,IAANrlD,CAAA;gBAAA;cAGxB;cACA,OAAOF,CACX;YAAA,GAYAR,CAAA,CAAIgmD,eAAA,GAAkB,UAAyBhmD,CAAA;cAG3C,OAFMA,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAAS,IAAIsD,CAAA,CAAQtD,CAAA,IAClB,KAAKmP,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,GACtC;YAAA,GAUAnlD,CAAA,CAAIimD,MAAA,GAAS,UAAgBjmD,CAAA;cACzB,IAAuB,mBAAZA,CAAA,IAAoC,SAAZA,CAAA,EAC/B,OAAO;cACX,IAAuB,QAAnBA,CAAA,CAAQkoC,OAAA,IAAmBloC,CAAA,CAAQmlB,cAAA,CAAe,eAC7C1a,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQkoC,OAAA,GACzB,OAAO;cACf,IAAyB,QAArBloC,CAAA,CAAQ+8B,SAAA,IAAqB/8B,CAAA,CAAQmlB,cAAA,CAAe,cAAc;gBAClE,IAAIllB,CAAA,GAAQoL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUQ,MAAA,CAAOjmD,CAAA,CAAQ+8B,SAAA;gBAChD,IAAI98B,CAAA,EACA,OAAO,eAAeA,CAC9B;cAAA;cACA,OAAO,IACX;YAAA,GAUAD,CAAA,CAAImmD,UAAA,GAAa,UAAoBnmD,CAAA;cACjC,IAAIA,CAAA,YAAkBqL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU7hD,GAAA,EACvC,OAAO5D,CAAA;cACX,IAAIC,CAAA,GAAU,IAAIoL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU7hD,GAAA;cAGvC,IAFsB,QAAlB5D,CAAA,CAAOkoC,OAAA,KACPjoC,CAAA,CAAQioC,OAAA,GAA2B,IAAjBloC,CAAA,CAAOkoC,OAAA,GACL,QAApBloC,CAAA,CAAO+8B,SAAA,EAAmB;gBAC1B,IAAgC,mBAArB/8B,CAAA,CAAO+8B,SAAA,EACd,MAAMhb,SAAA,CAAU;gBACpB9hB,CAAA,CAAQ88B,SAAA,GAAY1xB,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUU,UAAA,CAAWnmD,CAAA,CAAO+8B,SAAA,CAC/D;cAAA;cACA,OAAO98B,CACX;YAAA,GAWAD,CAAA,CAAIumD,QAAA,GAAW,UAAkBvmD,CAAA,EAASC,CAAA;cACjCA,CAAA,KACDA,CAAA,GAAU,CAAC;cACf,IAAIQ,CAAA,GAAS,CAAC;cASd,OARIR,CAAA,CAAQwmD,QAAA,KACRhmD,CAAA,CAAOynC,OAAA,GAAU,GACjBznC,CAAA,CAAOs8B,SAAA,GAAY,OAEA,QAAnB/8B,CAAA,CAAQkoC,OAAA,IAAmBloC,CAAA,CAAQmlB,cAAA,CAAe,eAClD1kB,CAAA,CAAOynC,OAAA,GAAUloC,CAAA,CAAQkoC,OAAA,GACJ,QAArBloC,CAAA,CAAQ+8B,SAAA,IAAqB/8B,CAAA,CAAQmlB,cAAA,CAAe,iBACpD1kB,CAAA,CAAOs8B,SAAA,GAAY1xB,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUc,QAAA,CAASvmD,CAAA,CAAQ+8B,SAAA,EAAW98B,CAAA,IACjEQ,CACX;YAAA,GASAT,CAAA,CAAI6kD,SAAA,CAAUiC,MAAA,GAAS;cACnB,OAAO,KAAKlkD,WAAA,CAAY2jD,QAAA,CAAS,MAAMrlD,CAAA,CAAUsjD,IAAA,CAAKuC,aAAA,CAC1D;YAAA,GAUA/mD,CAAA,CAAIgnD,UAAA,GAAa,UAAoBhnD,CAAA;cAIjC,YAHsB,MAAlBA,CAAA,KACAA,CAAA,GAAgB,wBAEbA,CAAA,GAAgB,qBAC3B;YAAA,GAEOA,CACV;UAAA,CAtOe,IAwOhBA,CAAA,CAAUopD,QAAA,GAAW;YAiBjB,SAASppD,EAASA,CAAA;cACd,IAAIA,CAAA,EACA,KAAK,IAAIC,CAAA,GAAO4C,MAAA,CAAO6N,IAAA,CAAK1Q,CAAA,GAAaS,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK6B,MAAA,IAAUrB,CAAA,EACpC,QAAvBT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,OAChB,KAAKR,CAAA,CAAKQ,CAAA,KAAMT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,GAChD;YAAA;YAuLA,OA/KAT,CAAA,CAAS6kD,SAAA,CAAU1nB,QAAA,GAAW,MAU9Bn9B,CAAA,CAASy/B,MAAA,GAAS,UAAgBx/B,CAAA;cAC9B,OAAO,IAAID,CAAA,CAASC,CAAA,CACxB;YAAA,GAWAD,CAAA,CAASkP,MAAA,GAAS,UAAgBlP,CAAA,EAASC,CAAA;cAKvC,OAJKA,CAAA,KACDA,CAAA,GAASyD,CAAA,CAAQ+7B,MAAA,KACG,QAApBz/B,CAAA,CAAQm9B,QAAA,IAAoBt6B,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,eAChEqL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUv2C,MAAA,CAAOlP,CAAA,CAAQm9B,QAAA,EAAUl9B,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA,IAC5FvlD,CACX;YAAA,GAWAD,CAAA,CAAS4lD,eAAA,GAAkB,UAAyB5lD,CAAA,EAASC,CAAA;cACzD,OAAO,KAAKiP,MAAA,CAAOlP,CAAA,EAASC,CAAA,EAAQulD,MAAA,EACxC;YAAA,GAaAxlD,CAAA,CAASmP,MAAA,GAAS,UAAgBnP,CAAA,EAAQC,CAAA;cAChCD,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAASsD,CAAA,CAAQm8B,MAAA,CAAOz/B,CAAA;cAE5B,KADA,IAAIS,CAAA,QAAiB,MAAXR,CAAA,GAAuBD,CAAA,CAAO6lD,GAAA,GAAM7lD,CAAA,CAAO8lD,GAAA,GAAM7lD,CAAA,EAAQO,CAAA,GAAU,IAAI6K,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU2D,QAAA,IAC/FppD,CAAA,CAAO8lD,GAAA,GAAMrlD,CAAA,GAAK;gBACrB,IAAIC,CAAA,GAAMV,CAAA,CAAOmlD,MAAA;gBACTzkD,CAAA,KAAQ,KACX,IACGF,CAAA,CAAQ28B,QAAA,GAAW9xB,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUt2C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,MAIlEnlD,CAAA,CAAO+lD,QAAA,CAAe,IAANrlD,CAAA,CAGxB;cAAA;cACA,OAAOF,CACX;YAAA,GAYAR,CAAA,CAASgmD,eAAA,GAAkB,UAAyBhmD,CAAA;cAGhD,OAFMA,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAAS,IAAIsD,CAAA,CAAQtD,CAAA,IAClB,KAAKmP,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,GACtC;YAAA,GAUAnlD,CAAA,CAASimD,MAAA,GAAS,UAAgBjmD,CAAA;cAC9B,IAAuB,mBAAZA,CAAA,IAAoC,SAAZA,CAAA,EAC/B,OAAO;cACX,IAAwB,QAApBA,CAAA,CAAQm9B,QAAA,IAAoBn9B,CAAA,CAAQmlB,cAAA,CAAe,aAAa;gBAChE,IAAIllB,CAAA,GAAQoL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUQ,MAAA,CAAOjmD,CAAA,CAAQm9B,QAAA;gBAChD,IAAIl9B,CAAA,EACA,OAAO,cAAcA,CAC7B;cAAA;cACA,OAAO,IACX;YAAA,GAUAD,CAAA,CAASmmD,UAAA,GAAa,UAAoBnmD,CAAA;cACtC,IAAIA,CAAA,YAAkBqL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU2D,QAAA,EACvC,OAAOppD,CAAA;cACX,IAAIC,CAAA,GAAU,IAAIoL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAU2D,QAAA;cACvC,IAAuB,QAAnBppD,CAAA,CAAOm9B,QAAA,EAAkB;gBACzB,IAA+B,mBAApBn9B,CAAA,CAAOm9B,QAAA,EACd,MAAMpb,SAAA,CAAU;gBACpB9hB,CAAA,CAAQk9B,QAAA,GAAW9xB,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUU,UAAA,CAAWnmD,CAAA,CAAOm9B,QAAA,CAC9D;cAAA;cACA,OAAOl9B,CACX;YAAA,GAWAD,CAAA,CAASumD,QAAA,GAAW,UAAkBvmD,CAAA,EAASC,CAAA;cACtCA,CAAA,KACDA,CAAA,GAAU,CAAC;cACf,IAAIQ,CAAA,GAAS,CAAC;cAKd,OAJIR,CAAA,CAAQwmD,QAAA,KACRhmD,CAAA,CAAO08B,QAAA,GAAW,OACE,QAApBn9B,CAAA,CAAQm9B,QAAA,IAAoBn9B,CAAA,CAAQmlB,cAAA,CAAe,gBACnD1kB,CAAA,CAAO08B,QAAA,GAAW9xB,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUc,QAAA,CAASvmD,CAAA,CAAQm9B,QAAA,EAAUl9B,CAAA,IAC/DQ,CACX;YAAA,GASAT,CAAA,CAAS6kD,SAAA,CAAUiC,MAAA,GAAS;cACxB,OAAO,KAAKlkD,WAAA,CAAY2jD,QAAA,CAAS,MAAMrlD,CAAA,CAAUsjD,IAAA,CAAKuC,aAAA,CAC1D;YAAA,GAUA/mD,CAAA,CAASgnD,UAAA,GAAa,UAAoBhnD,CAAA;cAItC,YAHsB,MAAlBA,CAAA,KACAA,CAAA,GAAgB,wBAEbA,CAAA,GAAgB,0BAC3B;YAAA,GAEOA,CACV;UAAA,CA9MoB,IAgNrBA,CAAA,CAAUmwC,YAAA,GAAe;YAkBrB,SAASnwC,EAAaA,CAAA;cAClB,IAAIA,CAAA,EACA,KAAK,IAAIC,CAAA,GAAO4C,MAAA,CAAO6N,IAAA,CAAK1Q,CAAA,GAAaS,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK6B,MAAA,IAAUrB,CAAA,EACpC,QAAvBT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,OAChB,KAAKR,CAAA,CAAKQ,CAAA,KAAMT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,GAChD;YAAA;YA8MA,OAtMAT,CAAA,CAAa6kD,SAAA,CAAU1nB,QAAA,GAAW,GAQlCn9B,CAAA,CAAa6kD,SAAA,CAAU/2C,KAAA,GAAQ,MAU/B9N,CAAA,CAAay/B,MAAA,GAAS,UAAgBx/B,CAAA;cAClC,OAAO,IAAID,CAAA,CAAaC,CAAA,CAC5B;YAAA,GAWAD,CAAA,CAAakP,MAAA,GAAS,UAAgBlP,CAAA,EAASC,CAAA;cAO3C,OANKA,CAAA,KACDA,CAAA,GAASyD,CAAA,CAAQ+7B,MAAA,KACG,QAApBz/B,CAAA,CAAQm9B,QAAA,IAAoBt6B,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,eAChEC,CAAA,CAAOklD,MAAA,CAA8B,GAAGO,KAAA,CAAM1lD,CAAA,CAAQm9B,QAAA,GACrC,QAAjBn9B,CAAA,CAAQ8N,KAAA,IAAiBjL,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,YAC7DqL,CAAA,CAAMxH,IAAA,CAAK6kD,gBAAA,CAAiBx5C,MAAA,CAAOlP,CAAA,CAAQ8N,KAAA,EAAO7N,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA,IAChGvlD,CACX;YAAA,GAWAD,CAAA,CAAa4lD,eAAA,GAAkB,UAAyB5lD,CAAA,EAASC,CAAA;cAC7D,OAAO,KAAKiP,MAAA,CAAOlP,CAAA,EAASC,CAAA,EAAQulD,MAAA,EACxC;YAAA,GAaAxlD,CAAA,CAAamP,MAAA,GAAS,UAAgBnP,CAAA,EAAQC,CAAA;cACpCD,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAASsD,CAAA,CAAQm8B,MAAA,CAAOz/B,CAAA;cAE5B,KADA,IAAIS,CAAA,QAAiB,MAAXR,CAAA,GAAuBD,CAAA,CAAO6lD,GAAA,GAAM7lD,CAAA,CAAO8lD,GAAA,GAAM7lD,CAAA,EAAQO,CAAA,GAAU,IAAI6K,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUtV,YAAA,IAC/FnwC,CAAA,CAAO8lD,GAAA,GAAMrlD,CAAA,GAAK;gBACrB,IAAIC,CAAA,GAAMV,CAAA,CAAOmlD,MAAA;gBACjB,QAAQzkD,CAAA,KAAQ;kBAChB,KAAK;oBACGF,CAAA,CAAQ28B,QAAA,GAAWn9B,CAAA,CAAO0lD,KAAA;oBAC1B;kBAER,KAAK;oBACGllD,CAAA,CAAQsN,KAAA,GAAQzC,CAAA,CAAMxH,IAAA,CAAK6kD,gBAAA,CAAiBv5C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;oBAClE;kBAER;oBACInlD,CAAA,CAAO+lD,QAAA,CAAe,IAANrlD,CAAA;gBAAA;cAGxB;cACA,OAAOF,CACX;YAAA,GAYAR,CAAA,CAAagmD,eAAA,GAAkB,UAAyBhmD,CAAA;cAGpD,OAFMA,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAAS,IAAIsD,CAAA,CAAQtD,CAAA,IAClB,KAAKmP,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,GACtC;YAAA,GAUAnlD,CAAA,CAAaimD,MAAA,GAAS,UAAgBjmD,CAAA;cAClC,IAAuB,mBAAZA,CAAA,IAAoC,SAAZA,CAAA,EAC/B,OAAO;cACX,IAAwB,QAApBA,CAAA,CAAQm9B,QAAA,IAAoBn9B,CAAA,CAAQmlB,cAAA,CAAe,gBAC9C1a,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQm9B,QAAA,GACzB,OAAO;cACf,IAAqB,QAAjBn9B,CAAA,CAAQ8N,KAAA,IAAiB9N,CAAA,CAAQmlB,cAAA,CAAe,UAAU;gBAC1D,IAAIllB,CAAA,GAAQoL,CAAA,CAAMxH,IAAA,CAAK6kD,gBAAA,CAAiBzC,MAAA,CAAOjmD,CAAA,CAAQ8N,KAAA;gBACvD,IAAI7N,CAAA,EACA,OAAO,WAAWA,CAC1B;cAAA;cACA,OAAO,IACX;YAAA,GAUAD,CAAA,CAAammD,UAAA,GAAa,UAAoBnmD,CAAA;cAC1C,IAAIA,CAAA,YAAkBqL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUtV,YAAA,EACvC,OAAOnwC,CAAA;cACX,IAAIC,CAAA,GAAU,IAAIoL,CAAA,CAAMxH,IAAA,CAAK4hD,SAAA,CAAUtV,YAAA;cAGvC,IAFuB,QAAnBnwC,CAAA,CAAOm9B,QAAA,KACPl9B,CAAA,CAAQk9B,QAAA,GAA6B,IAAlBn9B,CAAA,CAAOm9B,QAAA,GACV,QAAhBn9B,CAAA,CAAO8N,KAAA,EAAe;gBACtB,IAA4B,mBAAjB9N,CAAA,CAAO8N,KAAA,EACd,MAAMiU,SAAA,CAAU;gBACpB9hB,CAAA,CAAQ6N,KAAA,GAAQzC,CAAA,CAAMxH,IAAA,CAAK6kD,gBAAA,CAAiBvC,UAAA,CAAWnmD,CAAA,CAAO8N,KAAA,CAClE;cAAA;cACA,OAAO7N,CACX;YAAA,GAWAD,CAAA,CAAaumD,QAAA,GAAW,UAAkBvmD,CAAA,EAASC,CAAA;cAC1CA,CAAA,KACDA,CAAA,GAAU,CAAC;cACf,IAAIQ,CAAA,GAAS,CAAC;cASd,OARIR,CAAA,CAAQwmD,QAAA,KACRhmD,CAAA,CAAO08B,QAAA,GAAW,GAClB18B,CAAA,CAAOqN,KAAA,GAAQ,OAEK,QAApB9N,CAAA,CAAQm9B,QAAA,IAAoBn9B,CAAA,CAAQmlB,cAAA,CAAe,gBACnD1kB,CAAA,CAAO08B,QAAA,GAAWn9B,CAAA,CAAQm9B,QAAA,GACT,QAAjBn9B,CAAA,CAAQ8N,KAAA,IAAiB9N,CAAA,CAAQmlB,cAAA,CAAe,aAChD1kB,CAAA,CAAOqN,KAAA,GAAQzC,CAAA,CAAMxH,IAAA,CAAK6kD,gBAAA,CAAiBnC,QAAA,CAASvmD,CAAA,CAAQ8N,KAAA,EAAO7N,CAAA,IAChEQ,CACX;YAAA,GASAT,CAAA,CAAa6kD,SAAA,CAAUiC,MAAA,GAAS;cAC5B,OAAO,KAAKlkD,WAAA,CAAY2jD,QAAA,CAAS,MAAMrlD,CAAA,CAAUsjD,IAAA,CAAKuC,aAAA,CAC1D;YAAA,GAUA/mD,CAAA,CAAagnD,UAAA,GAAa,UAAoBhnD,CAAA;cAI1C,YAHsB,MAAlBA,CAAA,KACAA,CAAA,GAAgB,wBAEbA,CAAA,GAAgB,8BAC3B;YAAA,GAEOA,CACV;UAAA,CAtOwB,IAwOlBA,CACV;QAAA,CA79CgB,IA+9CjBiB,CAAA,CAAK0mD,kBAAA,GAAqB;UAkBtB,SAAS3nD,EAAmBA,CAAA;YACxB,IAAIA,CAAA,EACA,KAAK,IAAIC,CAAA,GAAO4C,MAAA,CAAO6N,IAAA,CAAK1Q,CAAA,GAAaS,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK6B,MAAA,IAAUrB,CAAA,EACpC,QAAvBT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,OAChB,KAAKR,CAAA,CAAKQ,CAAA,KAAMT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,GAChD;UAAA;UAuNA,OA/MAT,CAAA,CAAmB6kD,SAAA,CAAUvjB,MAAA,GAAS,IAQtCthC,CAAA,CAAmB6kD,SAAA,CAAUliD,OAAA,GAAU8H,CAAA,CAAMwxC,IAAA,GAAOxxC,CAAA,CAAMwxC,IAAA,CAAKb,QAAA,CAAS,GAAE,IAAE,KAAS,GAUrFp7C,CAAA,CAAmBy/B,MAAA,GAAS,UAAgBx/B,CAAA;YACxC,OAAO,IAAID,CAAA,CAAmBC,CAAA,CAClC;UAAA,GAWAD,CAAA,CAAmBkP,MAAA,GAAS,UAAgBlP,CAAA,EAASC,CAAA;YAOjD,OANKA,CAAA,KACDA,CAAA,GAASyD,CAAA,CAAQ+7B,MAAA,KACC,QAAlBz/B,CAAA,CAAQshC,MAAA,IAAkBz+B,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,aAC9DC,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQshC,MAAA,GACrC,QAAnBthC,CAAA,CAAQ2C,OAAA,IAAmBE,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,cAC/DC,CAAA,CAAOklD,MAAA,CAA8B,IAAIG,KAAA,CAAMtlD,CAAA,CAAQ2C,OAAA,GACpD1C,CACX;UAAA,GAWAD,CAAA,CAAmB4lD,eAAA,GAAkB,UAAyB5lD,CAAA,EAASC,CAAA;YACnE,OAAO,KAAKiP,MAAA,CAAOlP,CAAA,EAASC,CAAA,EAAQulD,MAAA,EACxC;UAAA,GAaAxlD,CAAA,CAAmBmP,MAAA,GAAS,UAAgBnP,CAAA,EAAQC,CAAA;YAC1CD,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAASsD,CAAA,CAAQm8B,MAAA,CAAOz/B,CAAA;YAE5B,KADA,IAAIS,CAAA,QAAiB,MAAXR,CAAA,GAAuBD,CAAA,CAAO6lD,GAAA,GAAM7lD,CAAA,CAAO8lD,GAAA,GAAM7lD,CAAA,EAAQO,CAAA,GAAU,IAAI6K,CAAA,CAAMxH,IAAA,CAAK8jD,kBAAA,IACrF3nD,CAAA,CAAO8lD,GAAA,GAAMrlD,CAAA,GAAK;cACrB,IAAIC,CAAA,GAAMV,CAAA,CAAOmlD,MAAA;cACjB,QAAQzkD,CAAA,KAAQ;gBAChB,KAAK;kBACGF,CAAA,CAAQ8gC,MAAA,GAASthC,CAAA,CAAOolD,MAAA;kBACxB;gBAER,KAAK;kBACG5kD,CAAA,CAAQmC,OAAA,GAAU3C,CAAA,CAAOslD,KAAA;kBACzB;gBAER;kBACItlD,CAAA,CAAO+lD,QAAA,CAAe,IAANrlD,CAAA;cAAA;YAGxB;YACA,OAAOF,CACX;UAAA,GAYAR,CAAA,CAAmBgmD,eAAA,GAAkB,UAAyBhmD,CAAA;YAG1D,OAFMA,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAAS,IAAIsD,CAAA,CAAQtD,CAAA,IAClB,KAAKmP,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,GACtC;UAAA,GAUAnlD,CAAA,CAAmBimD,MAAA,GAAS,UAAgBjmD,CAAA;YACxC,OAAuB,mBAAZA,CAAA,IAAoC,SAAZA,CAAA,GACxB,oBACW,QAAlBA,CAAA,CAAQshC,MAAA,IAAkBthC,CAAA,CAAQmlB,cAAA,CAAe,cAC5C1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQshC,MAAA,IACjB,4BACQ,QAAnBthC,CAAA,CAAQ2C,OAAA,IAAmB3C,CAAA,CAAQmlB,cAAA,CAAe,gBAC7C1a,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQ2C,OAAA,KAAc3C,CAAA,CAAQ2C,OAAA,IAAW8H,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQ2C,OAAA,CAAQw5C,GAAA,KAAQ1xC,CAAA,CAAM9I,SAAA,CAAU3B,CAAA,CAAQ2C,OAAA,CAAQy5C,IAAA,KAC3H,mCACR,IACX;UAAA,GAUAp8C,CAAA,CAAmBmmD,UAAA,GAAa,UAAoBnmD,CAAA;YAChD,IAAIA,CAAA,YAAkBqL,CAAA,CAAMxH,IAAA,CAAK8jD,kBAAA,EAC7B,OAAO3nD,CAAA;YACX,IAAIC,CAAA,GAAU,IAAIoL,CAAA,CAAMxH,IAAA,CAAK8jD,kBAAA;YAY7B,OAXqB,QAAjB3nD,CAAA,CAAOshC,MAAA,KACPrhC,CAAA,CAAQqhC,MAAA,GAAS8kB,MAAA,CAAOpmD,CAAA,CAAOshC,MAAA,IACb,QAAlBthC,CAAA,CAAO2C,OAAA,KACH8H,CAAA,CAAMwxC,IAAA,IACLh8C,CAAA,CAAQ0C,OAAA,GAAU8H,CAAA,CAAMwxC,IAAA,CAAKC,SAAA,CAAUl8C,CAAA,CAAO2C,OAAA,GAAU05C,QAAA,IAAW,IACrC,mBAAnBr8C,CAAA,CAAO2C,OAAA,GACnB1C,CAAA,CAAQ0C,OAAA,GAAUu/B,QAAA,CAASliC,CAAA,CAAO2C,OAAA,EAAS,MACZ,mBAAnB3C,CAAA,CAAO2C,OAAA,GACnB1C,CAAA,CAAQ0C,OAAA,GAAU3C,CAAA,CAAO2C,OAAA,GACM,mBAAnB3C,CAAA,CAAO2C,OAAA,KACnB1C,CAAA,CAAQ0C,OAAA,GAAU,IAAI8H,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAO2C,OAAA,CAAQw5C,GAAA,KAAQ,GAAGn8C,CAAA,CAAO2C,OAAA,CAAQy5C,IAAA,KAAS,GAAGxB,QAAA,MAC3F36C,CACX;UAAA,GAWAD,CAAA,CAAmBumD,QAAA,GAAW,UAAkBvmD,CAAA,EAASC,CAAA;YAChDA,CAAA,KACDA,CAAA,GAAU,CAAC;YACf,IAAIQ,CAAA,GAAS,CAAC;YACd,IAAIR,CAAA,CAAQwmD,QAAA,EAER,IADAhmD,CAAA,CAAO6gC,MAAA,GAAS,IACZ72B,CAAA,CAAMwxC,IAAA,EAAM;cACZ,IAAIz7C,CAAA,GAAO,IAAIiK,CAAA,CAAMwxC,IAAA,CAAK,GAAG,IAAG;cAChCx7C,CAAA,CAAOkC,OAAA,GAAU1C,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS5lD,CAAA,CAAK+1B,QAAA,KAAat2B,CAAA,CAAQymD,KAAA,KAAUhlD,MAAA,GAASlB,CAAA,CAAKo6C,QAAA,KAAap6C,CAC/G;YAAA,OACIC,CAAA,CAAOkC,OAAA,GAAU1C,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS,MAAM;YAS1D,OAPsB,QAAlBpmD,CAAA,CAAQshC,MAAA,IAAkBthC,CAAA,CAAQmlB,cAAA,CAAe,cACjD1kB,CAAA,CAAO6gC,MAAA,GAASthC,CAAA,CAAQshC,MAAA,GACL,QAAnBthC,CAAA,CAAQ2C,OAAA,IAAmB3C,CAAA,CAAQmlB,cAAA,CAAe,eACnB,mBAApBnlB,CAAA,CAAQ2C,OAAA,GACflC,CAAA,CAAOkC,OAAA,GAAU1C,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAASA,MAAA,CAAOpmD,CAAA,CAAQ2C,OAAA,IAAW3C,CAAA,CAAQ2C,OAAA,GAE9ElC,CAAA,CAAOkC,OAAA,GAAU1C,CAAA,CAAQymD,KAAA,KAAUN,MAAA,GAAS37C,CAAA,CAAMwxC,IAAA,CAAK4I,SAAA,CAAUtuB,QAAA,CAASnR,IAAA,CAAKplB,CAAA,CAAQ2C,OAAA,IAAW1C,CAAA,CAAQymD,KAAA,KAAUhlD,MAAA,GAAS,IAAI+I,CAAA,CAAM47C,QAAA,CAASrmD,CAAA,CAAQ2C,OAAA,CAAQw5C,GAAA,KAAQ,GAAGn8C,CAAA,CAAQ2C,OAAA,CAAQy5C,IAAA,KAAS,GAAGxB,QAAA,KAAa56C,CAAA,CAAQ2C,OAAA,GAC7NlC,CACX;UAAA,GASAT,CAAA,CAAmB6kD,SAAA,CAAUiC,MAAA,GAAS;YAClC,OAAO,KAAKlkD,WAAA,CAAY2jD,QAAA,CAAS,MAAMrlD,CAAA,CAAUsjD,IAAA,CAAKuC,aAAA,CAC1D;UAAA,GAUA/mD,CAAA,CAAmBgnD,UAAA,GAAa,UAAoBhnD,CAAA;YAIhD,YAHsB,MAAlBA,CAAA,KACAA,CAAA,GAAgB,wBAEbA,CAAA,GAAgB,0BAC3B;UAAA,GAEOA,CACV;QAAA,CA/OyB,IAwP1BiB,CAAA,CAAKooD,cAAA,GAAiB;UAClB,IAAIrpD,CAAA,GAAa,CAAC;YAAGC,CAAA,GAAS4C,MAAA,CAAO48B,MAAA,CAAOz/B,CAAA;UAG5C,OAFAC,CAAA,CAAOD,CAAA,CAAW,KAAK,kBAAkB,GACzCC,CAAA,CAAOD,CAAA,CAAW,KAAK,YAAY,GAC5BC,CACV;QAAA,CALqB,IAOtBgB,CAAA,CAAK2mD,aAAA,GAAgB;UAyBjB,SAAS5nD,EAAcA,CAAA;YAOnB,IANA,KAAKw8B,KAAA,GAAQ,IACb,KAAK1yB,MAAA,GAAS,IACd,KAAKsI,SAAA,GAAY,IACjB,KAAKk3C,cAAA,GAAiB,IACtB,KAAKnvB,IAAA,GAAO,IACZ,KAAKkH,WAAA,GAAc,IACfrhC,CAAA,EACA,KAAK,IAAIC,CAAA,GAAO4C,MAAA,CAAO6N,IAAA,CAAK1Q,CAAA,GAAaS,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAK6B,MAAA,IAAUrB,CAAA,EACpC,QAAvBT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,OAChB,KAAKR,CAAA,CAAKQ,CAAA,KAAMT,CAAA,CAAWC,CAAA,CAAKQ,CAAA,GAChD;UAAA;UA8cA,OAtcAT,CAAA,CAAc6kD,SAAA,CAAU7gD,IAAA,GAAO,IAQ/BhE,CAAA,CAAc6kD,SAAA,CAAUroB,KAAA,GAAQ/xB,CAAA,CAAMy6C,UAAA,EAQtCllD,CAAA,CAAc6kD,SAAA,CAAU/6C,MAAA,GAASW,CAAA,CAAMy6C,UAAA,EAQvCllD,CAAA,CAAc6kD,SAAA,CAAUzyC,SAAA,GAAY3H,CAAA,CAAMy6C,UAAA,EAQ1CllD,CAAA,CAAc6kD,SAAA,CAAUyE,cAAA,GAAiB7+C,CAAA,CAAMy6C,UAAA,EAQ/CllD,CAAA,CAAc6kD,SAAA,CAAU1qB,IAAA,GAAO1vB,CAAA,CAAMy6C,UAAA,EAQrCllD,CAAA,CAAc6kD,SAAA,CAAUna,SAAA,GAAY,IAQpC1qC,CAAA,CAAc6kD,SAAA,CAAUxjB,WAAA,GAAc52B,CAAA,CAAMy6C,UAAA,EAQ5CllD,CAAA,CAAc6kD,SAAA,CAAUvjB,MAAA,GAAS,IAUjCthC,CAAA,CAAcy/B,MAAA,GAAS,UAAgBx/B,CAAA;YACnC,OAAO,IAAID,CAAA,CAAcC,CAAA,CAC7B;UAAA,GAWAD,CAAA,CAAckP,MAAA,GAAS,UAAgBlP,CAAA,EAASC,CAAA;YAK5C,IAJKA,CAAA,KACDA,CAAA,GAASyD,CAAA,CAAQ+7B,MAAA,KACD,QAAhBz/B,CAAA,CAAQgE,IAAA,IAAgBnB,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,WAC5DC,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQgE,IAAA,GACvC,QAAjBhE,CAAA,CAAQw8B,KAAA,IAAiBx8B,CAAA,CAAQw8B,KAAA,CAAM16B,MAAA,EACvC,KAAK,IAAIrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQw8B,KAAA,CAAM16B,MAAA,IAAUrB,CAAA,EACxCR,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQw8B,KAAA,CAAM/7B,CAAA;YACtE,IAAsB,QAAlBT,CAAA,CAAQ8J,MAAA,IAAkB9J,CAAA,CAAQ8J,MAAA,CAAOhI,MAAA,EACzC,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQ8J,MAAA,CAAOhI,MAAA,IAAUrB,CAAA,EACzCR,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQ8J,MAAA,CAAOrJ,CAAA;YACvE,IAAyB,QAArBT,CAAA,CAAQoS,SAAA,IAAqBpS,CAAA,CAAQoS,SAAA,CAAUtQ,MAAA,EAC/C,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQoS,SAAA,CAAUtQ,MAAA,IAAUrB,CAAA,EAC5CR,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQoS,SAAA,CAAU3R,CAAA;YAC1E,IAAoB,QAAhBT,CAAA,CAAQm6B,IAAA,IAAgBn6B,CAAA,CAAQm6B,IAAA,CAAKr4B,MAAA,EACrC,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQm6B,IAAA,CAAKr4B,MAAA,IAAUrB,CAAA,EACvC4K,CAAA,CAAMxH,IAAA,CAAKw3B,SAAA,CAAUnsB,MAAA,CAAOlP,CAAA,CAAQm6B,IAAA,CAAK15B,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA;YAGtG,IAFyB,QAArBxlD,CAAA,CAAQ0qC,SAAA,IAAqB7nC,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,gBACjEC,CAAA,CAAOklD,MAAA,CAA8B,IAAIC,MAAA,CAAOplD,CAAA,CAAQ0qC,SAAA,GACjC,QAAvB1qC,CAAA,CAAQqhC,WAAA,IAAuBrhC,CAAA,CAAQqhC,WAAA,CAAYv/B,MAAA,EACnD,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQqhC,WAAA,CAAYv/B,MAAA,IAAUrB,CAAA,EAC9C4K,CAAA,CAAMxH,IAAA,CAAK8jD,kBAAA,CAAmBz4C,MAAA,CAAOlP,CAAA,CAAQqhC,WAAA,CAAY5gC,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA8B,IAAII,IAAA,IAAQC,MAAA;YAGtH,IAFsB,QAAlBxlD,CAAA,CAAQshC,MAAA,IAAkBz+B,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAS,aAC9DC,CAAA,CAAOklD,MAAA,CAA+B,IAAIC,MAAA,CAAOplD,CAAA,CAAQshC,MAAA,GAC/B,QAA1BthC,CAAA,CAAQspD,cAAA,IAA0BtpD,CAAA,CAAQspD,cAAA,CAAexnD,MAAA,EACzD,KAASrB,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAQspD,cAAA,CAAexnD,MAAA,IAAUrB,CAAA,EACjD4K,CAAA,CAAMxH,IAAA,CAAKC,cAAA,CAAeoL,MAAA,CAAOlP,CAAA,CAAQspD,cAAA,CAAe7oD,CAAA,GAAIR,CAAA,CAAOklD,MAAA,CAA+B,IAAII,IAAA,IAAQC,MAAA;YACtH,OAAOvlD,CACX;UAAA,GAWAD,CAAA,CAAc4lD,eAAA,GAAkB,UAAyB5lD,CAAA,EAASC,CAAA;YAC9D,OAAO,KAAKiP,MAAA,CAAOlP,CAAA,EAASC,CAAA,EAAQulD,MAAA,EACxC;UAAA,GAaAxlD,CAAA,CAAcmP,MAAA,GAAS,UAAgBnP,CAAA,EAAQC,CAAA;YACrCD,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAASsD,CAAA,CAAQm8B,MAAA,CAAOz/B,CAAA;YAE5B,KADA,IAAIS,CAAA,QAAiB,MAAXR,CAAA,GAAuBD,CAAA,CAAO6lD,GAAA,GAAM7lD,CAAA,CAAO8lD,GAAA,GAAM7lD,CAAA,EAAQO,CAAA,GAAU,IAAI6K,CAAA,CAAMxH,IAAA,CAAK+jD,aAAA,IACrF5nD,CAAA,CAAO8lD,GAAA,GAAMrlD,CAAA,GAAK;cACrB,IAAIC,CAAA,GAAMV,CAAA,CAAOmlD,MAAA;cACjB,QAAQzkD,CAAA,KAAQ;gBAChB,KAAK;kBACGF,CAAA,CAAQwD,IAAA,GAAOhE,CAAA,CAAOolD,MAAA;kBACtB;gBAER,KAAK;kBACS5kD,CAAA,CAAQg8B,KAAA,IAASh8B,CAAA,CAAQg8B,KAAA,CAAM16B,MAAA,KACjCtB,CAAA,CAAQg8B,KAAA,GAAQ,KACpBh8B,CAAA,CAAQg8B,KAAA,CAAMx1B,IAAA,CAAKhH,CAAA,CAAOolD,MAAA;kBAC1B;gBAER,KAAK;kBACS5kD,CAAA,CAAQsJ,MAAA,IAAUtJ,CAAA,CAAQsJ,MAAA,CAAOhI,MAAA,KACnCtB,CAAA,CAAQsJ,MAAA,GAAS,KACrBtJ,CAAA,CAAQsJ,MAAA,CAAO9C,IAAA,CAAKhH,CAAA,CAAOolD,MAAA;kBAC3B;gBAER,KAAK;kBACS5kD,CAAA,CAAQ4R,SAAA,IAAa5R,CAAA,CAAQ4R,SAAA,CAAUtQ,MAAA,KACzCtB,CAAA,CAAQ4R,SAAA,GAAY,KACxB5R,CAAA,CAAQ4R,SAAA,CAAUpL,IAAA,CAAKhH,CAAA,CAAOolD,MAAA;kBAC9B;gBAER,KAAK;kBACS5kD,CAAA,CAAQ8oD,cAAA,IAAkB9oD,CAAA,CAAQ8oD,cAAA,CAAexnD,MAAA,KACnDtB,CAAA,CAAQ8oD,cAAA,GAAiB,KAC7B9oD,CAAA,CAAQ8oD,cAAA,CAAetiD,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAKC,cAAA,CAAeqL,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBAC5E;gBAER,KAAK;kBACS3kD,CAAA,CAAQ25B,IAAA,IAAQ35B,CAAA,CAAQ25B,IAAA,CAAKr4B,MAAA,KAC/BtB,CAAA,CAAQ25B,IAAA,GAAO,KACnB35B,CAAA,CAAQ25B,IAAA,CAAKnzB,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAKw3B,SAAA,CAAUlsB,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBAC7D;gBAER,KAAK;kBACG3kD,CAAA,CAAQkqC,SAAA,GAAY1qC,CAAA,CAAOolD,MAAA;kBAC3B;gBAER,KAAK;kBACS5kD,CAAA,CAAQ6gC,WAAA,IAAe7gC,CAAA,CAAQ6gC,WAAA,CAAYv/B,MAAA,KAC7CtB,CAAA,CAAQ6gC,WAAA,GAAc,KAC1B7gC,CAAA,CAAQ6gC,WAAA,CAAYr6B,IAAA,CAAKqE,CAAA,CAAMxH,IAAA,CAAK8jD,kBAAA,CAAmBx4C,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA;kBAC7E;gBAER,KAAK;kBACG3kD,CAAA,CAAQ8gC,MAAA,GAASthC,CAAA,CAAOolD,MAAA;kBACxB;gBAER;kBACIplD,CAAA,CAAO+lD,QAAA,CAAe,IAANrlD,CAAA;cAAA;YAGxB;YACA,OAAOF,CACX;UAAA,GAYAR,CAAA,CAAcgmD,eAAA,GAAkB,UAAyBhmD,CAAA;YAGrD,OAFMA,CAAA,YAAkBsD,CAAA,KACpBtD,CAAA,GAAS,IAAIsD,CAAA,CAAQtD,CAAA,IAClB,KAAKmP,MAAA,CAAOnP,CAAA,EAAQA,CAAA,CAAOmlD,MAAA,GACtC;UAAA,GAUAnlD,CAAA,CAAcimD,MAAA,GAAS,UAAgBjmD,CAAA;YACnC,IAAuB,mBAAZA,CAAA,IAAoC,SAAZA,CAAA,EAC/B,OAAO;YACX,IAAoB,QAAhBA,CAAA,CAAQgE,IAAA,IAAgBhE,CAAA,CAAQmlB,cAAA,CAAe,YAC1C1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQgE,IAAA,GACxB,OAAO;YACf,IAAqB,QAAjBhE,CAAA,CAAQw8B,KAAA,IAAiBx8B,CAAA,CAAQmlB,cAAA,CAAe,UAAU;cAC1D,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQw8B,KAAA,GACvB,OAAO;cACX,KAAK,IAAIv8B,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQw8B,KAAA,CAAM16B,MAAA,IAAU7B,CAAA,EACxC,KAAKwK,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQw8B,KAAA,CAAMv8B,CAAA,IAC9B,OAAO,0BACnB;YAAA;YACA,IAAsB,QAAlBD,CAAA,CAAQ8J,MAAA,IAAkB9J,CAAA,CAAQmlB,cAAA,CAAe,WAAW;cAC5D,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQ8J,MAAA,GACvB,OAAO;cACX,KAAS7J,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQ8J,MAAA,CAAOhI,MAAA,IAAU7B,CAAA,EACzC,KAAKwK,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQ8J,MAAA,CAAO7J,CAAA,IAC/B,OAAO,2BACnB;YAAA;YACA,IAAyB,QAArBD,CAAA,CAAQoS,SAAA,IAAqBpS,CAAA,CAAQmlB,cAAA,CAAe,cAAc;cAClE,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQoS,SAAA,GACvB,OAAO;cACX,KAASnS,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQoS,SAAA,CAAUtQ,MAAA,IAAU7B,CAAA,EAC5C,KAAKwK,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQoS,SAAA,CAAUnS,CAAA,IAClC,OAAO,8BACnB;YAAA;YACA,IAA8B,QAA1BD,CAAA,CAAQspD,cAAA,IAA0BtpD,CAAA,CAAQmlB,cAAA,CAAe,mBAAmB;cAC5E,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQspD,cAAA,GACvB,OAAO;cACX,KAASrpD,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQspD,cAAA,CAAexnD,MAAA,IAAU7B,CAAA,EAEjD,IADIQ,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAKC,cAAA,CAAemiD,MAAA,CAAOjmD,CAAA,CAAQspD,cAAA,CAAerpD,CAAA,IAEhE,OAAO,oBAAoBQ,CAEvC;YAAA;YACA,IAAoB,QAAhBT,CAAA,CAAQm6B,IAAA,IAAgBn6B,CAAA,CAAQmlB,cAAA,CAAe,SAAS;cACxD,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQm6B,IAAA,GACvB,OAAO;cACX,KAASl6B,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQm6B,IAAA,CAAKr4B,MAAA,IAAU7B,CAAA,EAEvC,IADIQ,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAKw3B,SAAA,CAAU4qB,MAAA,CAAOjmD,CAAA,CAAQm6B,IAAA,CAAKl6B,CAAA,IAEjD,OAAO,UAAUQ,CAE7B;YAAA;YACA,IAAyB,QAArBT,CAAA,CAAQ0qC,SAAA,IAAqB1qC,CAAA,CAAQmlB,cAAA,CAAe,iBAC/C1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQ0qC,SAAA,GACxB,OAAO;YACf,IAA2B,QAAvB1qC,CAAA,CAAQqhC,WAAA,IAAuBrhC,CAAA,CAAQmlB,cAAA,CAAe,gBAAgB;cACtE,KAAKnf,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAQqhC,WAAA,GACvB,OAAO;cACX,KAASphC,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAQqhC,WAAA,CAAYv/B,MAAA,IAAU7B,CAAA,EAAG;gBACjD,IAAIQ,CAAA;gBACJ,IADIA,CAAA,GAAQ4K,CAAA,CAAMxH,IAAA,CAAK8jD,kBAAA,CAAmB1B,MAAA,CAAOjmD,CAAA,CAAQqhC,WAAA,CAAYphC,CAAA,IAEjE,OAAO,iBAAiBQ,CAChC;cAAA;YACJ;YACA,OAAsB,QAAlBT,CAAA,CAAQshC,MAAA,IAAkBthC,CAAA,CAAQmlB,cAAA,CAAe,cAC5C1a,CAAA,CAAMy7C,QAAA,CAASlmD,CAAA,CAAQshC,MAAA,IACjB,4BACR,IACX;UAAA,GAUAthC,CAAA,CAAcmmD,UAAA,GAAa,UAAoBnmD,CAAA;YAC3C,IAAIA,CAAA,YAAkBqL,CAAA,CAAMxH,IAAA,CAAK+jD,aAAA,EAC7B,OAAO5nD,CAAA;YACX,IAAIC,CAAA,GAAU,IAAIoL,CAAA,CAAMxH,IAAA,CAAK+jD,aAAA;YAG7B,IAFmB,QAAf5nD,CAAA,CAAOgE,IAAA,KACP/D,CAAA,CAAQ+D,IAAA,GAAOoiD,MAAA,CAAOpmD,CAAA,CAAOgE,IAAA,IAC7BhE,CAAA,CAAOw8B,KAAA,EAAO;cACd,KAAKx2B,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOw8B,KAAA,GACtB,MAAMza,SAAA,CAAU;cACpB9hB,CAAA,CAAQu8B,KAAA,GAAQ;cAChB,KAAK,IAAI/7B,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOw8B,KAAA,CAAM16B,MAAA,IAAUrB,CAAA,EACvCR,CAAA,CAAQu8B,KAAA,CAAM/7B,CAAA,IAAK2lD,MAAA,CAAOpmD,CAAA,CAAOw8B,KAAA,CAAM/7B,CAAA,EAC/C;YAAA;YACA,IAAIT,CAAA,CAAO8J,MAAA,EAAQ;cACf,KAAK9D,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAO8J,MAAA,GACtB,MAAMiY,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQ6J,MAAA,GAAS,IACRrJ,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAO8J,MAAA,CAAOhI,MAAA,IAAUrB,CAAA,EACxCR,CAAA,CAAQ6J,MAAA,CAAOrJ,CAAA,IAAK2lD,MAAA,CAAOpmD,CAAA,CAAO8J,MAAA,CAAOrJ,CAAA,EACjD;YAAA;YACA,IAAIT,CAAA,CAAOoS,SAAA,EAAW;cAClB,KAAKpM,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOoS,SAAA,GACtB,MAAM2P,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQmS,SAAA,GAAY,IACX3R,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOoS,SAAA,CAAUtQ,MAAA,IAAUrB,CAAA,EAC3CR,CAAA,CAAQmS,SAAA,CAAU3R,CAAA,IAAK2lD,MAAA,CAAOpmD,CAAA,CAAOoS,SAAA,CAAU3R,CAAA,EACvD;YAAA;YACA,IAAIT,CAAA,CAAOspD,cAAA,EAAgB;cACvB,KAAKtjD,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOspD,cAAA,GACtB,MAAMvnC,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQqpD,cAAA,GAAiB,IAChB7oD,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOspD,cAAA,CAAexnD,MAAA,IAAUrB,CAAA,EAAG;gBACnD,IAAwC,mBAA7BT,CAAA,CAAOspD,cAAA,CAAe7oD,CAAA,GAC7B,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQqpD,cAAA,CAAe7oD,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAKC,cAAA,CAAeqiD,UAAA,CAAWnmD,CAAA,CAAOspD,cAAA,CAAe7oD,CAAA,EAC3F;cAAA;YACJ;YACA,IAAIT,CAAA,CAAOm6B,IAAA,EAAM;cACb,KAAKn0B,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOm6B,IAAA,GACtB,MAAMpY,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQk6B,IAAA,GAAO,IACN15B,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOm6B,IAAA,CAAKr4B,MAAA,IAAUrB,CAAA,EAAG;gBACzC,IAA8B,mBAAnBT,CAAA,CAAOm6B,IAAA,CAAK15B,CAAA,GACnB,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQk6B,IAAA,CAAK15B,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAKw3B,SAAA,CAAU8qB,UAAA,CAAWnmD,CAAA,CAAOm6B,IAAA,CAAK15B,CAAA,EAClE;cAAA;YACJ;YAGA,IAFwB,QAApBT,CAAA,CAAO0qC,SAAA,KACPzqC,CAAA,CAAQyqC,SAAA,GAAY0b,MAAA,CAAOpmD,CAAA,CAAO0qC,SAAA,IAClC1qC,CAAA,CAAOqhC,WAAA,EAAa;cACpB,KAAKr7B,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,CAAOqhC,WAAA,GACtB,MAAMtf,SAAA,CAAU;cAEpB,KADA9hB,CAAA,CAAQohC,WAAA,GAAc,IACb5gC,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOqhC,WAAA,CAAYv/B,MAAA,IAAUrB,CAAA,EAAG;gBAChD,IAAqC,mBAA1BT,CAAA,CAAOqhC,WAAA,CAAY5gC,CAAA,GAC1B,MAAMshB,SAAA,CAAU;gBACpB9hB,CAAA,CAAQohC,WAAA,CAAY5gC,CAAA,IAAK4K,CAAA,CAAMxH,IAAA,CAAK8jD,kBAAA,CAAmBxB,UAAA,CAAWnmD,CAAA,CAAOqhC,WAAA,CAAY5gC,CAAA,EACzF;cAAA;YACJ;YAGA,OAFqB,QAAjBT,CAAA,CAAOshC,MAAA,KACPrhC,CAAA,CAAQqhC,MAAA,GAAS8kB,MAAA,CAAOpmD,CAAA,CAAOshC,MAAA,IAC5BrhC,CACX;UAAA,GAWAD,CAAA,CAAcumD,QAAA,GAAW,UAAkBvmD,CAAA,EAASC,CAAA;YAC3CA,CAAA,KACDA,CAAA,GAAU,CAAC;YACf,IAAIQ,CAAA,GAAS,CAAC;YAgBd,KAfIR,CAAA,CAAQumD,MAAA,IAAUvmD,CAAA,CAAQwmD,QAAA,MAC1BhmD,CAAA,CAAO+7B,KAAA,GAAQ,IACf/7B,CAAA,CAAOqJ,MAAA,GAAS,IAChBrJ,CAAA,CAAO2R,SAAA,GAAY,IACnB3R,CAAA,CAAO05B,IAAA,GAAO,IACd15B,CAAA,CAAO4gC,WAAA,GAAc,IACrB5gC,CAAA,CAAO6oD,cAAA,GAAiB,KAExBrpD,CAAA,CAAQwmD,QAAA,KACRhmD,CAAA,CAAOuD,IAAA,GAAO,IACdvD,CAAA,CAAOiqC,SAAA,GAAY,IACnBjqC,CAAA,CAAO6gC,MAAA,GAAS,KAEA,QAAhBthC,CAAA,CAAQgE,IAAA,IAAgBhE,CAAA,CAAQmlB,cAAA,CAAe,YAC/C1kB,CAAA,CAAOuD,IAAA,GAAOhE,CAAA,CAAQgE,IAAA,GACtBhE,CAAA,CAAQw8B,KAAA,IAASx8B,CAAA,CAAQw8B,KAAA,CAAM16B,MAAA,EAAQ;cACvCrB,CAAA,CAAO+7B,KAAA,GAAQ;cACf,KAAK,IAAIh8B,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQw8B,KAAA,CAAM16B,MAAA,IAAUtB,CAAA,EACxCC,CAAA,CAAO+7B,KAAA,CAAMh8B,CAAA,IAAKR,CAAA,CAAQw8B,KAAA,CAAMh8B,CAAA,CACxC;YAAA;YACA,IAAIR,CAAA,CAAQ8J,MAAA,IAAU9J,CAAA,CAAQ8J,MAAA,CAAOhI,MAAA,EAEjC,KADArB,CAAA,CAAOqJ,MAAA,GAAS,IACPtJ,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQ8J,MAAA,CAAOhI,MAAA,IAAUtB,CAAA,EACzCC,CAAA,CAAOqJ,MAAA,CAAOtJ,CAAA,IAAKR,CAAA,CAAQ8J,MAAA,CAAOtJ,CAAA;YAE1C,IAAIR,CAAA,CAAQoS,SAAA,IAAapS,CAAA,CAAQoS,SAAA,CAAUtQ,MAAA,EAEvC,KADArB,CAAA,CAAO2R,SAAA,GAAY,IACV5R,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQoS,SAAA,CAAUtQ,MAAA,IAAUtB,CAAA,EAC5CC,CAAA,CAAO2R,SAAA,CAAU5R,CAAA,IAAKR,CAAA,CAAQoS,SAAA,CAAU5R,CAAA;YAEhD,IAAIR,CAAA,CAAQm6B,IAAA,IAAQn6B,CAAA,CAAQm6B,IAAA,CAAKr4B,MAAA,EAE7B,KADArB,CAAA,CAAO05B,IAAA,GAAO,IACL35B,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQm6B,IAAA,CAAKr4B,MAAA,IAAUtB,CAAA,EACvCC,CAAA,CAAO05B,IAAA,CAAK35B,CAAA,IAAK6K,CAAA,CAAMxH,IAAA,CAAKw3B,SAAA,CAAUkrB,QAAA,CAASvmD,CAAA,CAAQm6B,IAAA,CAAK35B,CAAA,GAAIP,CAAA;YAIxE,IAFyB,QAArBD,CAAA,CAAQ0qC,SAAA,IAAqB1qC,CAAA,CAAQmlB,cAAA,CAAe,iBACpD1kB,CAAA,CAAOiqC,SAAA,GAAY1qC,CAAA,CAAQ0qC,SAAA,GAC3B1qC,CAAA,CAAQqhC,WAAA,IAAerhC,CAAA,CAAQqhC,WAAA,CAAYv/B,MAAA,EAE3C,KADArB,CAAA,CAAO4gC,WAAA,GAAc,IACZ7gC,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQqhC,WAAA,CAAYv/B,MAAA,IAAUtB,CAAA,EAC9CC,CAAA,CAAO4gC,WAAA,CAAY7gC,CAAA,IAAK6K,CAAA,CAAMxH,IAAA,CAAK8jD,kBAAA,CAAmBpB,QAAA,CAASvmD,CAAA,CAAQqhC,WAAA,CAAY7gC,CAAA,GAAIP,CAAA;YAI/F,IAFsB,QAAlBD,CAAA,CAAQshC,MAAA,IAAkBthC,CAAA,CAAQmlB,cAAA,CAAe,cACjD1kB,CAAA,CAAO6gC,MAAA,GAASthC,CAAA,CAAQshC,MAAA,GACxBthC,CAAA,CAAQspD,cAAA,IAAkBtpD,CAAA,CAAQspD,cAAA,CAAexnD,MAAA,EAEjD,KADArB,CAAA,CAAO6oD,cAAA,GAAiB,IACf9oD,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAQspD,cAAA,CAAexnD,MAAA,IAAUtB,CAAA,EACjDC,CAAA,CAAO6oD,cAAA,CAAe9oD,CAAA,IAAK6K,CAAA,CAAMxH,IAAA,CAAKC,cAAA,CAAeyiD,QAAA,CAASvmD,CAAA,CAAQspD,cAAA,CAAe9oD,CAAA,GAAIP,CAAA;YAEjG,OAAOQ,CACX;UAAA,GASAT,CAAA,CAAc6kD,SAAA,CAAUiC,MAAA,GAAS;YAC7B,OAAO,KAAKlkD,WAAA,CAAY2jD,QAAA,CAAS,MAAMrlD,CAAA,CAAUsjD,IAAA,CAAKuC,aAAA,CAC1D;UAAA,GAUA/mD,CAAA,CAAcgnD,UAAA,GAAa,UAAoBhnD,CAAA;YAI3C,YAHsB,MAAlBA,CAAA,KACAA,CAAA,GAAgB,wBAEbA,CAAA,GAAgB,qBAC3B;UAAA,GAEOA,CACV;QAAA,CAnfoB,IAqfdiB,CAAA,GAGXjB,CAAA,CAAOE,OAAA,GAAUmL,C;;;QCz+OjB,IAAIk+C,UAAA;UAAW/oD,CAAA,IAAG+oD,UAAA,GAAW,sBAAoBx3B,QAAA,IAAUA,QAAA,CAAS2rB,aAAA,GAAc3rB,QAAA,CAAS2rB,aAAA,CAAcC,GAAA,QAAI,GAAO,sBAAoB6L,UAAA,KAAaD,UAAA,GAAWA,UAAA,IAAYC,UAAA,GAAY,UAASxpD,CAAA,GAAE,CAAC;YAAG,SAASC,EAAA;cAAI,OAAOgX,CAAA,CAAE2X,MAAA,IAAQvX,CAAA,CAAEuX,MAAA,IAAQ66B,CAAA,IAAIpyC,CAAC;YAAA;YAAC,SAAS7W,EAAA;cAAI,OAAOyW,CAAA,CAAE2X,MAAA,IAAQvX,CAAA,CAAEuX,MAAA,IAAQ66B,CAAA,IAAI9oD,CAAC;YAAA;YAAC,SAASD,EAAA;cAAI,OAAOuW,CAAA,CAAE2X,MAAA,IAAQvX,CAAA,CAAEuX,MAAA,IAAQ66B,CAAA,IAAIC,CAAC;YAAA;YAAC,SAASzoD,EAAA;cAAI,OAAOgW,CAAA,CAAE2X,MAAA,IAAQvX,CAAA,CAAEuX,MAAA,IAAQ66B,CAAA,IAAIE,CAAC;YAAA;YAAC,SAASzoD,EAAA;cAAI,OAAO+V,CAAA,CAAE2X,MAAA,IAAQvX,CAAA,CAAEuX,MAAA,IAAQ66B,CAAA,IAAIG,CAAC;YAAA;YAAC,IAAItmD,CAAA;cAAEI,CAAA;cAAE+G,CAAA,GAAEzK,CAAA;YAAEyK,CAAA,CAAEo/C,KAAA,GAAM,IAAIvnD,OAAA,CAAQ,CAAEtC,CAAA,EAAEC,CAAA;cAAKqD,CAAA,GAAEtD,CAAA,EAAE0D,CAAA,GAAEzD,CAAE;YAAA;YAAG,IAAIoL,CAAA;cAAEC,CAAA;cAAEC,CAAA;cAAEhF,CAAA,GAAE1D,MAAA,CAAOC,MAAA,CAAO,CAAC,GAAE2H,CAAA;cAAGiB,CAAA,GAAE;cAAiBlF,CAAA,GAAEqF,CAAC7L,CAAA,EAAEC,CAAA;gBAAK,MAAMA,CAAA;cAAA;cAAG2L,CAAA,GAAE,mBAAiBg4C,MAAA;cAAO/3C,CAAA,GAAE,qBAAmBi+C,aAAA;cAAc/9C,CAAA,GAAE,mBAAiB6sC,OAAA,IAAS,mBAAiBA,OAAA,CAAQn2C,QAAA,IAAU,mBAAiBm2C,OAAA,CAAQn2C,QAAA,CAAS03B,IAAA;cAAKnuB,CAAA,GAAEvB,CAAA,CAAEs/C,sBAAA,KAAwB;cAAG99C,CAAA,GAAE;YAAG,SAASE,EAAEnM,CAAA;cAAG,OAAOyK,CAAA,CAAEu4C,UAAA,GAAWv4C,CAAA,CAAEu4C,UAAA,CAAWhjD,CAAA,EAAEiM,CAAA,IAAGA,CAAA,GAAEjM,CAAC;YAAA;YAAC,IAAG+L,CAAA,EAAE;cAAC,IAAIM,CAAA,GAAE5L,CAAA,CAAQ;gBAAMiW,CAAA,GAAEjW,CAAA,CAAQ;cAAQ,IAAIR,CAAA;cAAEgM,CAAA,GAAEJ,CAAA,GAAE6K,CAAA,CAAEszC,OAAA,CAAQ/9C,CAAA,IAAG,MAAIo3C,SAAA,GAAU,KAAIh4C,CAAA,GAAE9E,CAACvG,CAAA,EAAEC,CAAA,MAAKD,CAAA,GAAEA,CAAA,CAAEiqD,UAAA,CAAW,aAAW,IAAI/G,GAAA,CAAIljD,CAAA,IAAG0W,CAAA,CAAEwzC,SAAA,CAAUlqD,CAAA,GAAGqM,CAAA,CAAE89C,YAAA,CAAanqD,CAAA,EAAEC,CAAA,QAAE,IAAO,UAASsL,CAAA,GAAEvL,CAAA,MAAKA,CAAA,GAAEqL,CAAA,CAAErL,CAAA,GAAE,IAAK4uB,MAAA,KAAS5uB,CAAA,GAAE,IAAIyP,UAAA,CAAWzP,CAAA,IAAIA,CAAA,GAAGsL,CAAA,GAAED,CAACrL,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,IAAE;gBAAMR,CAAA,GAAEA,CAAA,CAAEiqD,UAAA,CAAW,aAAW,IAAI/G,GAAA,CAAIljD,CAAA,IAAG0W,CAAA,CAAEwzC,SAAA,CAAUlqD,CAAA,GAAGqM,CAAA,CAAEysC,QAAA,CAAS94C,CAAA,EAAEQ,CAAA,QAAE,IAAO,QAAO,CAAER,CAAA,EAAEU,CAAA;kBAAKV,CAAA,GAAES,CAAA,CAAET,CAAA,IAAGC,CAAA,CAAEO,CAAA,GAAEE,CAAA,CAAEkuB,MAAA,GAAOluB,CAAA,CAAG;gBAAA,EAAC;cAAA,IAAI+J,CAAA,CAAE2/C,WAAA,IAAa,IAAExR,OAAA,CAAQyR,IAAA,CAAKvoD,MAAA,KAAS4J,CAAA,GAAEktC,OAAA,CAAQyR,IAAA,CAAK,GAAGh6C,OAAA,CAAQ,OAAM,OAAMuoC,OAAA,CAAQyR,IAAA,CAAKn9C,KAAA,CAAM,IAAG1G,CAAA,GAAEqF,CAAC7L,CAAA,EAAEC,CAAA;gBAAK,MAAM24C,OAAA,CAAQ0R,QAAA,GAAStqD,CAAA,EAAEC,CAAA;cAAA,GAAGwK,CAAA,CAAE8/C,OAAA,GAAQ,MAAI;cAA6B;gBAAItqD,CAAA,GAAEQ,CAAA,CAAQ,KAAiB;cAAA,CAAC,QAAMT,CAAA;gBAAG,MAAMs+B,OAAA,CAAQjT,KAAA,CAAM,4GAA2GrrB,CAAC;cAAA;cAACwqD,MAAA,CAAOC,MAAA,GAAOxqD,CAAA,CAAEwqD,MAAM;YAAA,QAAM7+C,CAAA,IAAGC,CAAA,MAAKA,CAAA,GAAEI,CAAA,GAAE1L,IAAA,CAAK+rB,QAAA,CAASo+B,IAAA,GAAK,sBAAoB34B,QAAA,IAAUA,QAAA,CAAS2rB,aAAA,KAAgBzxC,CAAA,GAAE8lB,QAAA,CAAS2rB,aAAA,CAAcC,GAAA,GAAK4L,UAAA,KAAat9C,CAAA,GAAEs9C,UAAA,GAAYt9C,CAAA,GAAE,MAAIA,CAAA,CAAEG,OAAA,CAAQ,WAASH,CAAA,CAAE4xC,MAAA,CAAO,GAAE5xC,CAAA,CAAEoE,OAAA,CAAQ,UAAS,IAAIytC,WAAA,CAAY,OAAK,KAAG,IAAG/xC,CAAA,KAAIV,CAAA,GAAErL,CAAA;cAAI,IAAIC,CAAA,GAAE,IAAI0qD,cAAA;cAAe,OAAO1qD,CAAA,CAAE2qD,IAAA,CAAK,OAAM5qD,CAAA,GAAE,IAAIC,CAAA,CAAE4qD,IAAA,CAAK,OAAM5qD,CAAA,CAAE6qD,YAAA;YAAA,GAAcj/C,CAAA,KAAIN,CAAA,GAAEvL,CAAA;cAAI,IAAIC,CAAA,GAAE,IAAI0qD,cAAA;cAAe,OAAO1qD,CAAA,CAAE2qD,IAAA,CAAK,OAAM5qD,CAAA,GAAE,IAAIC,CAAA,CAAE8qD,YAAA,GAAa,eAAc9qD,CAAA,CAAE4qD,IAAA,CAAK,OAAM,IAAIp7C,UAAA,CAAWxP,CAAA,CAAE+qD,QAAA,CAAQ;YAAA,IAAI1/C,CAAA,GAAED,CAACrL,CAAA,EAAEC,CAAA,EAAEQ,CAAA;cAAK,IAAID,CAAA,GAAE,IAAImqD,cAAA;cAAenqD,CAAA,CAAEoqD,IAAA,CAAK,OAAM5qD,CAAA,GAAE,IAAIQ,CAAA,CAAEuqD,YAAA,GAAa,eAAcvqD,CAAA,CAAEyqD,MAAA,GAAO;gBAAK,OAAKzqD,CAAA,CAAEu/C,MAAA,IAAQ,KAAGv/C,CAAA,CAAEu/C,MAAA,IAAQv/C,CAAA,CAAEwqD,QAAA,GAAS/qD,CAAA,CAAEO,CAAA,CAAEwqD,QAAA,IAAUvqD,CAAA,EAAE;cAAA,GAAGD,CAAA,CAAE0qD,OAAA,GAAQzqD,CAAA,EAAED,CAAA,CAAEqqD,IAAA,CAAK,KAAI;YAAA;YAAK9+C,CAAA,IAAG,sBAAoB80B,WAAA,KAAc2pB,MAAA,CAAO3pB,WAAA,GAAYpgC,CAAA,OAAAogC,WAAA;YAAmC,IAAIlqB,CAAA,GAAE2nB,OAAA,CAAQ/jB,GAAA,CAAIqkB,IAAA,CAAKN,OAAA;cAAS1nB,CAAA,GAAE0nB,OAAA,CAAQjT,KAAA,CAAMuT,IAAA,CAAKN,OAAA;YAASvyB,CAAA,KAAI4K,CAAA,GAAEw0C,CAAA,GAAInrD,CAAA,KAAIqM,CAAA,CAAE++C,SAAA,CAAU,GAAEprD,CAAA,CAAEoD,IAAA,CAAK,OAAK,OAAMwT,CAAA,GAAEvK,CAAA,GAAIrM,CAAA,KAAIqM,CAAA,CAAE++C,SAAA,CAAU,GAAEprD,CAAA,CAAEoD,IAAA,CAAK,OAAK;YAAO,IAAIyT,CAAA;cAAEC,CAAA,GAAErM,CAAA,CAAE4gD,KAAA,IAAO10C,CAAA;cAAEI,CAAA,GAAEtM,CAAA,CAAE6gD,QAAA,IAAU10C,CAAA;YAAE/T,MAAA,CAAOC,MAAA,CAAO2H,CAAA,EAAElE,CAAA,GAAGA,CAAA,GAAE,MAAKkE,CAAA,CAAE2/C,WAAA,KAAc1+C,CAAA,GAAEjB,CAAA,CAAE2/C,WAAA,GAAa3/C,CAAA,CAAE8gD,IAAA,KAAO/kD,CAAA,GAAEiE,CAAA,CAAE8gD,IAAA,GAAM9gD,CAAA,CAAE+gD,UAAA,KAAa30C,CAAA,GAAEpM,CAAA,CAAE+gD,UAAA;YAAY,IAAIx0C,CAAA,GAAEvM,CAAA,CAAEghD,aAAA,KAAe;YAAG,mBAAiB3I,WAAA,IAAa4I,EAAA,CAAG;YAAmC,IAAIz0C,CAAA;cAAEC,CAAA;cAAEC,CAAA;cAAEC,CAAA;cAAEC,CAAA;cAAE1W,CAAA;cAAE+oD,CAAA;cAAEC,CAAA;cAAEC,CAAA;cAAEuB,CAAA,IAAE;YAAG,SAAS1B,EAAA;cAAI,IAAIzpD,CAAA,GAAEiX,CAAA,CAAE2X,MAAA;cAAOnkB,CAAA,CAAEkhD,KAAA,GAAMt0C,CAAA,GAAE,IAAIuZ,SAAA,CAAU5wB,CAAA,GAAGyK,CAAA,CAAEmhD,MAAA,GAAO,IAAIj7B,UAAA,CAAW3wB,CAAA,GAAGyK,CAAA,CAAEo3C,MAAA,GAAO6H,CAAA,GAAE,IAAI/iC,UAAA,CAAW3mB,CAAA,GAAGyK,CAAA,CAAE+2C,MAAA,GAAO7gD,CAAA,GAAE,IAAI8O,UAAA,CAAWzP,CAAA,GAAGyK,CAAA,CAAEohD,OAAA,GAAQ,IAAIh7B,WAAA,CAAY7wB,CAAA,GAAGyK,CAAA,CAAE23C,OAAA,GAAQuH,CAAA,GAAE,IAAIn6C,WAAA,CAAYxP,CAAA,GAAGyK,CAAA,CAAEqhD,OAAA,GAAQ,IAAIl3C,YAAA,CAAa5U,CAAA,GAAGyK,CAAA,CAAEshD,OAAA,GAAQnC,CAAA,GAAE,IAAI94B,YAAA,CAAa9wB,CAAA,CAAE;YAAA;YAAC,IAAIgsD,CAAA,GAAEvhD,CAAA,CAAEwhD,cAAA,IAAgB;YAAS,IAAG,WAASD,CAAA,IAAGN,EAAA,CAAG,0DAAwDM,CAAA,GAAE,2BAA0BhgD,CAAA,EAAEiL,CAAA,GAAExM,CAAA,CAAEyhD,UAAA,MAAgB,IAAGzhD,CAAA,CAAEyhD,UAAA,EAAWj1C,CAAA,GAAExM,CAAA,CAAEyhD,UAAA,MAAgB,OAAMj1C,CAAA,GAAE,IAAI6rC,WAAA,CAAYqJ,MAAA,CAAO;cAACC,OAAA,EAAQJ,CAAA,GAAE;cAAMK,OAAA,EAAQ;cAAMC,MAAA,GAAO;YAAA,IAAM19B,MAAA,YAAkB+zB,iBAAA,GAAmB,MAAM5rC,CAAA,CAAE,gOAA+NhL,CAAA,IAAGgL,CAAA,CAAE,8GAA6G1S,KAAA,CAAM;YAAcolD,CAAA,IAAIuC,CAAA,GAAE/0C,CAAA,CAAE2X,MAAA,CAAOE,UAAA;YAAW,IAAIy9B,CAAA;cAAEC,CAAA,GAAE;cAAGC,CAAA,GAAE;cAAGC,CAAA,GAAE;cAAGC,CAAA,GAAE;YAAE,SAASC,EAAA;cAAI,OAAO51C,CAAA,IAAG,IAAE21C,CAAC;YAAA;YAAC,IAAIE,CAAA;cAAEC,CAAA;cAAEC,CAAA,GAAE;cAAEC,CAAA,GAAE;cAAKhP,CAAA,GAAE;YAAK,SAASiP,EAAA;cAAIF,CAAA,IAAItiD,CAAA,CAAEyiD,sBAAA,IAAwBziD,CAAA,CAAEyiD,sBAAA,CAAuBH,CAAA,CAAE;YAAA;YAAC,SAASI,GAAA;cAAI,IAAGJ,CAAA,IAAItiD,CAAA,CAAEyiD,sBAAA,IAAwBziD,CAAA,CAAEyiD,sBAAA,CAAuBH,CAAA,GAAG,KAAGA,CAAA,KAAI,SAAOC,CAAA,KAAII,aAAA,CAAcJ,CAAA,GAAGA,CAAA,GAAE,OAAMhP,CAAA,GAAG;gBAAC,IAAIh+C,CAAA,GAAEg+C,CAAA;gBAAEA,CAAA,GAAE,MAAKh+C,CAAA,EAAG;cAAA;YAAC;YAAC,SAAS0rD,GAAG1rD,CAAA;cAAG,MAAMyK,CAAA,CAAE4iD,OAAA,IAAS5iD,CAAA,CAAE4iD,OAAA,CAAQrtD,CAAA,GAAG+W,CAAA,CAAE/W,CAAA,GAAE,aAAWA,CAAA,GAAE,MAAKmrD,CAAA,IAAE,GAAG/zC,CAAA,GAAE,GAAEpX,CAAA,GAAE,IAAI8iD,WAAA,CAAYwK,YAAA,CAAattD,CAAA,GAAE,6CAA4C0D,CAAA,CAAE1D,CAAA,GAAGA,CAAC;YAAA;YAAC,SAASutD,GAAGvtD,CAAA;cAAG,OAAOA,CAAA,CAAEiqD,UAAA,CAAW,wCAAwC;YAAA;YAAC,SAASuD,GAAGxtD,CAAA;cAAG,IAAGA,CAAA,IAAG6sD,CAAA,IAAGh2C,CAAA,EAAE,OAAO,IAAIpH,UAAA,CAAWoH,CAAA;cAAG,IAAGtL,CAAA,EAAE,OAAOA,CAAA,CAAEvL,CAAA;cAAG,MAAK,iDAAiD;YAAA;YAAC,SAASytD,GAAGztD,CAAA,EAAEC,CAAA,EAAEQ,CAAA;cAAG,OAAO,UAAST,CAAA;gBAAG,KAAI6W,CAAA,KAAIjL,CAAA,IAAGC,CAAA,GAAG;kBAAC,IAAG,qBAAmBktC,KAAA,KAAQ/4C,CAAA,CAAEiqD,UAAA,CAAW,YAAW,OAAOlR,KAAA,CAAM/4C,CAAA,EAAE;oBAAC0tD,WAAA,EAAY;kBAAA,GAAgBjtB,IAAA,CAAMxgC,CAAA;oBAAI,KAAIA,CAAA,CAAE0tD,EAAA,EAAG,MAAK,yCAAuC3tD,CAAA,GAAE;oBAAI,OAAOC,CAAA,CAAE+4C,WAAA,EAAc;kBAAA,GAAG4U,KAAA,CAAM,MAAKJ,EAAA,CAAGxtD,CAAA;kBAAK,IAAGsL,CAAA,EAAE,OAAO,IAAIhJ,OAAA,CAAQ,CAAErC,CAAA,EAAEQ,CAAA;oBAAK6K,CAAA,CAAEtL,CAAA,EAAGA,CAAA,IAAGC,CAAA,CAAE,IAAIwP,UAAA,CAAWzP,CAAA,IAAKS,CAAA,CAAG;kBAAA,EAAE;gBAAA;gBAAC,OAAO6B,OAAA,CAAQC,OAAA,GAAUk+B,IAAA,CAAK,MAAK+sB,EAAA,CAAGxtD,CAAA,EAAI;cAAA,CAA9V,CAAgWA,CAAA,EAAGygC,IAAA,CAAMzgC,CAAA,IAAG8iD,WAAA,CAAY+K,WAAA,CAAY7tD,CAAA,EAAEC,CAAA,GAAKwgC,IAAA,CAAMzgC,CAAA,IAAGA,CAAA,EAAIygC,IAAA,CAAKhgC,CAAA,EAAGT,CAAA;gBAAI+W,CAAA,CAAE,4CAA0C/W,CAAA,GAAG0rD,EAAA,CAAG1rD,CAAA,CAAG;cAAA,EAAE;YAAA;YAAC,SAAS8tD,GAAG9tD,CAAA;cAAG,KAAKgE,IAAA,GAAK,cAAa,KAAK+pD,OAAA,GAAQ,gCAAgC/tD,CAAA,KAAK,KAAK+/C,MAAA,GAAO//C,CAAC;YAAA;YAAC,SAASguD,GAAGhuD,CAAA;cAAGA,CAAA,CAAE+9C,SAAA,IAAY/9C,CAAA,CAAEi+C,SAAA,GAAU,QAAM;YAAA;YAAC,SAASgQ,GAAGjuD,CAAA;cAAA,CAAIA,CAAA,GAAEkuD,EAAA,CAAGC,EAAA,CAAGnuD,CAAA,MAAK0rD,EAAA,IAAKwC,EAAA,CAAGE,EAAA,CAAGpuD,CAAA,CAAE;YAAA;YAAC,SAASquD,GAAGruD,CAAA;cAAG,IAAIC,CAAA,GAAEiuD,EAAA,CAAGI,EAAA;cAAK,KAAIruD,CAAA,EAAE,OAAO;cAAEiuD,EAAA,CAAGK,EAAA,CAAGvnD,IAAA,CAAK/G,CAAA,GAAGiuD,EAAA,CAAGC,EAAA,CAAGnuD,CAAA,CAAEwuD,EAAA,IAAIvuD,CAAA,EAAEA,CAAA,CAAEuuD,EAAA,GAAGxuD,CAAA,CAAEwuD,EAAA;cAAG,IAAI/tD,CAAA,GAAE;gBAACguD,GAAA,EAAI;gBAAMC,aAAA,EAAc1uD,CAAA,CAAE2uD,EAAA;gBAAGC,GAAA,EAAI5uD,CAAA,CAAE6uD,EAAA;gBAAGC,WAAA,EAAY9uD,CAAA,CAAEwuD;cAAA;cAAI,OAAOziD,CAAA,IAAG9L,CAAA,CAAE8uD,KAAA,IAAQ9uD,CAAA,CAAEk+C,WAAA,CAAY19C,CAAA,EAAET,CAAA,CAAEgvD,EAAA,GAAI,CAAC;YAAA;YAACzB,EAAA,CAAGV,CAAA,GAAE,8BAA4BA,CAAA,GAAE1gD,CAAA,CAAE0gD,CAAA;YAAI,IAAIoC,EAAA,GAAG,sBAAoB7R,WAAA,GAAY,IAAIA,WAAA,CAAY,eAAQ;cAAO8R,EAAA,GAAGC,CAACnvD,CAAA,EAAEC,CAAA,EAAEQ,CAAA;gBAAK,IAAID,CAAA,IAAGP,CAAA,MAAK,KAAGQ,CAAA;gBAAE,KAAIA,CAAA,GAAER,CAAA,EAAED,CAAA,CAAES,CAAA,OAAMA,CAAA,IAAGD,CAAA,MAAMC,CAAA;gBAAE,IAAG,KAAGA,CAAA,GAAER,CAAA,IAAGD,CAAA,CAAE4uB,MAAA,IAAQqgC,EAAA,EAAG,OAAOA,EAAA,CAAG9/C,MAAA,CAAOnP,CAAA,CAAE4uB,MAAA,YAAkB+zB,iBAAA,GAAkB3iD,CAAA,CAAEkN,KAAA,CAAMjN,CAAA,EAAEQ,CAAA,IAAGT,CAAA,CAAE6U,QAAA,CAAS5U,CAAA,EAAEQ,CAAA;gBAAI,KAAID,CAAA,GAAE,IAAGP,CAAA,GAAEQ,CAAA,GAAG;kBAAC,IAAIC,CAAA,GAAEV,CAAA,CAAEC,CAAA;kBAAK,IAAG,MAAIS,CAAA,EAAE;oBAAC,IAAIO,CAAA,GAAE,KAAGjB,CAAA,CAAEC,CAAA;oBAAK,IAAG,QAAM,MAAIS,CAAA,GAAGF,CAAA,IAAG4lD,MAAA,CAAOgJ,YAAA,EAAc,KAAG1uD,CAAA,KAAI,IAAEO,CAAA,OAAO;sBAAC,IAAIC,CAAA,GAAE,KAAGlB,CAAA,CAAEC,CAAA;sBAAK,SAAOS,CAAA,GAAE,QAAM,MAAIA,CAAA,KAAI,KAAGA,CAAA,KAAI,KAAGO,CAAA,IAAG,IAAEC,CAAA,IAAG,IAAER,CAAA,KAAI,KAAGO,CAAA,IAAG,KAAGC,CAAA,IAAG,IAAE,KAAGlB,CAAA,CAAEC,CAAA,OAAMO,CAAA,IAAG4lD,MAAA,CAAOgJ,YAAA,CAAa1uD,CAAA,KAAIA,CAAA,IAAG,OAAMF,CAAA,IAAG4lD,MAAA,CAAOgJ,YAAA,CAAa,QAAM1uD,CAAA,IAAG,IAAG,QAAM,OAAKA,CAAA,EAAG;oBAAA;kBAAC,OAAMF,CAAA,IAAG4lD,MAAA,CAAOgJ,YAAA,CAAa1uD,CAAA,CAAE;gBAAA;gBAAC,OAAOF,CAAA;cAAA;cAAG6uD,EAAA,GAAGH,CAAClvD,CAAA,EAAEC,CAAA,MAAKD,CAAA,MAAK,KAAGkvD,EAAA,CAAG1uD,CAAA,IAAIR,CAAA,EAAEC,CAAA,IAAG;YAAG,SAASqvD,GAAGtvD,CAAA;cAAG,IAAGgM,CAAA,EAAE,OAAOujD,EAAA,CAAG,GAAE,GAAEvvD,CAAA;cAAGoX,CAAA,GAAEpX,CAAA,EAAE4sD,CAAA,OAAMsB,EAAA,CAAGsB,EAAA,IAAK/kD,CAAA,CAAEglD,MAAA,IAAQhlD,CAAA,CAAEglD,MAAA,CAAOzvD,CAAA,GAAGmrD,CAAA,IAAE,IAAI3kD,CAAA,CAAExG,CAAA,EAAE,IAAI8tD,EAAA,CAAG9tD,CAAA,EAAG;YAAA;YAAC,IAAImvD,EAAA,GAAGnvD,CAAA;gBAAI,IAAGoX,CAAA,GAAEpX,CAAA,EAAEgM,CAAA,EAAE,MAAM0jD,EAAA,CAAG1vD,CAAA,GAAG;gBAASsvD,EAAA,CAAGtvD,CAAA,CAAC;cAAA;cAAGkuD,EAAA,GAAG;gBAACyB,EAAA,EAAG;gBAAGpB,EAAA,EAAG;gBAAGqB,EAAA,EAAG;gBAAGzB,EAAA,EAAG,CAAC;gBAAE0B,EAAA,EAAG,SAAAA,CAAA;kBAAW7jD,CAAA,GAAEkiD,EAAA,CAAG4B,EAAA,KAAK5B,EAAA,CAAG6B,EAAA,EAAI;gBAAA;gBAAEA,EAAA,EAAG,SAAAA,CAAA;kBAAWvD,CAAA,CAAE1Q,OAAA,CAAQ;oBAAMmR,CAAA,IAAIiB,EAAA,CAAG7pB,EAAA,CAAG,MAAK8oB,EAAA,GAAM;kBAAA,EAAE;gBAAA;gBAAE2C,EAAA,EAAG,SAAAA,CAAA;kBAAW5B,EAAA,CAAG8B,qBAAA,GAAsB9B,EAAA,CAAG+B,EAAA,EAAG/B,EAAA,CAAGgC,aAAA,GAAchC,EAAA,CAAGiC,EAAA,EAAGjC,EAAA,CAAGkC,aAAA,GAAclC,EAAA,CAAGmC,EAAA,EAAGr5C,CAAA,IAAE,CAAE;gBAAA;gBAAEq5C,EAAA,EAAG,SAAAA,CAASrwD,CAAA;kBAAGoX,CAAA,GAAEpX,CAAC;gBAAA;gBAAEswD,EAAA,EAAG,CAAC;gBAAoBd,EAAA,EAAG,SAAAA,CAAA;kBAAW,KAAI,IAAIxvD,CAAA,IAAKkuD,EAAA,CAAGK,EAAA,EAAGP,EAAA,CAAGhuD,CAAA;kBAAG,KAAIA,CAAA,IAAKkuD,EAAA,CAAGyB,EAAA,EAAG3B,EAAA,CAAGhuD,CAAA;kBAAGkuD,EAAA,CAAGyB,EAAA,GAAG,IAAGzB,EAAA,CAAGK,EAAA,GAAG,IAAGL,EAAA,CAAGC,EAAA,GAAG,EAAE;gBAAA;gBAAEC,EAAA,EAAG,SAAAA,CAASpuD,CAAA;kBAAG,IAAIC,CAAA,GAAED,CAAA,CAAEwuD,EAAA;kBAAA,OAAUN,EAAA,CAAGC,EAAA,CAAGluD,CAAA,GAAGiuD,EAAA,CAAGyB,EAAA,CAAG3oD,IAAA,CAAKhH,CAAA,GAAGkuD,EAAA,CAAGK,EAAA,CAAG99B,MAAA,CAAOy9B,EAAA,CAAGK,EAAA,CAAGniD,OAAA,CAAQpM,CAAA,GAAG,IAAGA,CAAA,CAAEwuD,EAAA,GAAG,GAAE+B,EAAA,CAAGtwD,CAAA,CAAE;gBAAA;gBAAEgwD,EAAA,EAAG,SAAAA,CAAA,GAAW;gBAAEE,EAAA,EAAG,SAAAA,CAAA;kBAAWjC,EAAA,CAAG0B,EAAA,CAAG/kD,OAAA,CAAS7K,CAAA,IAAGA,CAAA,GAAK;gBAAA;gBAAEwwD,EAAA,EAAGxwD,CAAA,IAAG,IAAIsC,OAAA,CAASrC,CAAA;kBAAID,CAAA,CAAEi+C,SAAA,GAAUx9C,CAAA;oBAAI,IAAID,CAAA,IAAGC,CAAA,GAAEA,CAAA,CAAEgjB,IAAA,EAAMgrC,GAAA;oBAAI,IAAGhuD,CAAA,CAAEgwD,YAAA,IAAchwD,CAAA,CAAEgwD,YAAA,IAAcC,EAAA,IAAK;sBAAC,IAAIhwD,CAAA,GAAEwtD,EAAA,CAAGC,EAAA,CAAG1tD,CAAA,CAAEkwD,EAAA;sBAAIjwD,CAAA,GAAEA,CAAA,CAAEy9C,WAAA,CAAY19C,CAAA,EAAEA,CAAA,CAAEmwD,YAAA,IAAc75C,CAAA,CAAE,4CAA0CvW,CAAA,GAAE,yBAAuBC,CAAA,CAAEgwD,YAAA,GAAa,sCAAsC;oBAAA,OAAK,mBAAiBjwD,CAAA,GAAEqwD,EAAA,KAAK,kBAAgBrwD,CAAA,GAAE6tD,EAAA,CAAG5tD,CAAA,IAAG,oBAAkBD,CAAA,GAAEytD,EAAA,CAAGxtD,CAAA,CAAEqwD,MAAA,IAAQ,iBAAetwD,CAAA,IAAGC,CAAA,GAAEA,CAAA,CAAEqwD,MAAA,EAAOtwD,CAAA,GAAE0tD,EAAA,CAAGC,EAAA,CAAG1tD,CAAA,UAAUytD,EAAA,CAAGC,EAAA,CAAG1tD,CAAA,GAAGutD,EAAA,CAAGxtD,CAAA,GAAG+vD,EAAA,CAAG9vD,CAAA,GAAGytD,EAAA,CAAGK,EAAA,CAAG99B,MAAA,CAAOy9B,EAAA,CAAGK,EAAA,CAAGniD,OAAA,CAAQ5L,CAAA,GAAG,IAAGA,CAAA,CAAEguD,EAAA,GAAG,KAAG,mBAAiBhuD,CAAA,GAAE0tD,EAAA,CAAGC,EAAA,CAAG1tD,CAAA,CAAEqwD,MAAA,EAAQ3S,WAAA,CAAY;sBAACsQ,GAAA,EAAI;oBAAA,KAAW,aAAWjuD,CAAA,IAAGR,CAAA,CAAE+wD,MAAA,IAAO,GAAG9wD,CAAA,CAAED,CAAA,KAAI,YAAUQ,CAAA,GAAEwwD,KAAA,CAAM,YAAUvwD,CAAA,CAAEwwD,QAAA,GAAS,OAAKxwD,CAAA,CAAEywD,IAAA,IAAM,mBAAiBzwD,CAAA,CAAE0wD,MAAA,GAAOnxD,CAAA,CAAEm+C,WAAA,CAAY19C,CAAA,IAAG,kBAAgBD,CAAA,GAAEiK,CAAA,CAAEhK,CAAA,CAAE2wD,OAAA,KAAY3wD,CAAA,CAAE4wD,IAAA,IAAM7wD,CAAA,IAAGuW,CAAA,CAAE,oCAAkCvW,CAAA,CAAC;kBAAA,GAAGR,CAAA,CAAEkrD,OAAA,GAAQlrD,CAAA;oBAAI,MAAM+W,CAAA,CAAE,2BAAyB/W,CAAA,CAAEsxD,QAAA,GAAS,MAAItxD,CAAA,CAAEuxD,MAAA,GAAO,OAAKvxD,CAAA,CAAE+tD,OAAA,GAAS/tD,CAAA;kBAAA,GAAG+L,CAAA,KAAI/L,CAAA,CAAEwxD,EAAA,CAAG,WAAU,UAAUvxD,CAAA;oBAAGD,CAAA,CAAEi+C,SAAA,CAAU;sBAACx6B,IAAA,EAAKxjB;oBAAA,EAAI;kBAAA,IAAGD,CAAA,CAAEwxD,EAAA,CAAG,SAAQ,UAAUvxD,CAAA;oBAAGD,CAAA,CAAEkrD,OAAA,CAAQjrD,CAAA,CAAG;kBAAA;kBAAI,IAAIQ,CAAA;oBAAED,CAAA,GAAE;kBAAG,KAAIC,CAAA,IAAI,CAAC,UAAS,WAAU,SAAQ,aAAYgK,CAAA,CAAE0a,cAAA,CAAe1kB,CAAA,KAAID,CAAA,CAAEwG,IAAA,CAAKvG,CAAA;kBAAGT,CAAA,CAAEm+C,WAAA,CAAY;oBAACsQ,GAAA,EAAI;oBAAOgD,QAAA,EAASjxD,CAAA;oBAAEkxD,SAAA,EAAUjnD,CAAA,CAAE24C,mBAAA,IAAqBmG,UAAA;oBAAW2C,UAAA,EAAWj1C,CAAA;oBAAE06C,UAAA,EAAWx6C;kBAAA,EAAI;gBAAA;gBAAGktB,EAAA,EAAG,SAAAA,CAASrkC,CAAA;kBAAGA,CAAA,EAAG;gBAAA;gBAAE4xD,EAAA,EAAG,SAAAA,CAAA;kBAAW,IAAI5xD,CAAA,GAAEmM,CAAA,CAAE;kBAA+BnM,CAAA,GAAE,IAAIyqD,MAAA,CAAOzqD,CAAA,GAAGkuD,EAAA,CAAGyB,EAAA,CAAG3oD,IAAA,CAAKhH,CAAA,CAAE;gBAAA;gBAAEsuD,EAAA,EAAG,SAAAA,CAAA;kBAAW,OAAO,KAAGJ,EAAA,CAAGyB,EAAA,CAAG7tD,MAAA,KAASosD,EAAA,CAAG0D,EAAA,IAAK1D,EAAA,CAAGsC,EAAA,CAAGtC,EAAA,CAAGyB,EAAA,CAAG,MAAKzB,EAAA,CAAGyB,EAAA,CAAGx/B,GAAA,EAAK;gBAAA;cAAA;YAAG1lB,CAAA,CAAE84C,OAAA,GAAQ2K,EAAA;YAAG,IAAI2D,EAAA,GAAG7xD,CAAA;cAAI,OAAK,IAAEA,CAAA,CAAE8B,MAAA,GAAQ9B,CAAA,CAAEw9C,KAAA,EAAF,CAAU/yC,CAAA,CAAC;YAAA;YAAG,SAASilD,GAAG1vD,CAAA;cAAG,IAAGgM,CAAA,EAAE,OAAOujD,EAAA,CAAG,GAAE,GAAEvvD,CAAA;cAAGmvD,EAAA,CAAGnvD,CAAA,CAAE;YAAA;YAACyK,CAAA,CAAEqnD,mBAAA,GAAoB;cAAW,IAAI9xD,CAAA,GAAE0wD,EAAA;gBAAKzwD,CAAA,GAAES,CAAA,GAAIV,CAAA,GAAE,MAAI,MAAI;cAAGA,CAAA,GAAEU,CAAA,GAAIV,CAAA,GAAE,MAAI,MAAI,IAAG+xD,EAAA,CAAG9xD,CAAA,EAAEA,CAAA,GAAED,CAAA,GAAGgyD,EAAA,CAAG/xD,CAAA,CAAE;YAAA;YAAE,IAAIgyD,EAAA,GAAG;YAAG,SAASC,GAAGlyD,CAAA;cAAG,KAAKmyD,EAAA,GAAGnyD,CAAA,GAAE,IAAG,KAAKoyD,EAAA,GAAG,UAASpyD,CAAA;gBAAGiB,CAAA,GAAI,KAAKkxD,EAAA,GAAG,KAAG,MAAI,KAAGnyD,CAAC;cAAA,GAAE,KAAKqyD,EAAA,GAAG,UAASryD,CAAA;gBAAGiB,CAAA,GAAI,KAAKkxD,EAAA,GAAG,KAAG,MAAI,KAAGnyD,CAAC;cAAA,GAAE,KAAK6vD,EAAA,GAAG,UAAS7vD,CAAA,EAAEC,CAAA;gBAAG,KAAKqyD,EAAA,IAAK,KAAKF,EAAA,CAAGpyD,CAAA,GAAG,KAAKqyD,EAAA,CAAGpyD,CAAA,CAAE;cAAA,GAAE,KAAKqyD,EAAA,GAAG;gBAAWrxD,CAAA,GAAI,KAAKkxD,EAAA,GAAG,MAAI,MAAI,KAAG,CAAC;cAAA,CAAC;YAAA;YAAC,SAASI,GAAGvyD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA;cAAG,OAAOwL,CAAA,GAAEujD,EAAA,CAAG,GAAE,GAAEvvD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,IAAGgyD,EAAA,CAAGxyD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,CAAE;YAAA;YAAC,SAASgyD,GAAGxyD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA;cAAG,IAAGR,CAAA,MAAK,GAAEC,CAAA,MAAK,GAAEQ,CAAA,MAAK,GAAED,CAAA,MAAK,GAAE,sBAAoBmiD,iBAAA,EAAkB,OAAO5rC,CAAA,CAAE,wFAAuF;cAAE,IAAIrW,CAAA,GAAE;cAAG,OAAOsL,CAAA,IAAG,MAAItL,CAAA,CAAEoB,MAAA,GAAOywD,EAAA,CAAGvyD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,KAAIR,CAAA,GAAE;gBAAC2uD,EAAA,EAAGluD,CAAA;gBAAE+tD,EAAA,EAAGxuD,CAAA;gBAAE6uD,EAAA,EAAGruD,CAAA;gBAAEwuD,EAAA,EAAGtuD;cAAA,GAAGsL,CAAA,IAAGhM,CAAA,CAAEyyD,EAAA,GAAG,eAActU,WAAA,CAAYn+C,CAAA,EAAEU,CAAA,GAAG,KAAG2tD,EAAA,CAAGruD,CAAA,EAAG;YAAA;YAAC,SAAS0yD,GAAG1yD,CAAA,EAAEC,CAAA,EAAEQ,CAAA;cAAG,OAAOuL,CAAA,GAAEujD,EAAA,CAAG,GAAE,GAAEvvD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,IAAG,CAAC;YAAA;YAAC,SAASkyD,GAAG3yD,CAAA,EAAEC,CAAA;cAAG,IAAG+L,CAAA,EAAE,OAAOujD,EAAA,CAAG,GAAE,GAAEvvD,CAAA,EAAEC,CAAA,CAAE;YAAA;YAACwK,CAAA,CAAEmoD,gBAAA,GAAiB,UAAS5yD,CAAA,EAAEC,CAAA;cAAG,IAAIQ,CAAA,GAAEwxD,EAAA,CAAGjyD,CAAA;cAAGS,CAAA,KAAIT,CAAA,IAAGiyD,EAAA,CAAGnwD,MAAA,KAASmwD,EAAA,CAAGnwD,MAAA,GAAO9B,CAAA,GAAE,IAAGiyD,EAAA,CAAGjyD,CAAA,IAAGS,CAAA,GAAE8rD,CAAA,CAAE/nD,GAAA,CAAIxE,CAAA,IAAIA,CAAA,GAAES,CAAA,CAAER,CAAA,GAAG2sD,CAAA,KAAIsB,EAAA,CAAGmC,EAAA,CAAGrwD,CAAA,IAAG6yD,EAAA,CAAG7yD,CAAA,CAAE;YAAA;YAAE,IAAI8yD,EAAA,GAAG9yD,CAAA;gBAAI,KAAI,IAAIC,CAAA,GAAE,GAAEQ,CAAA,GAAE,GAAEA,CAAA,GAAET,CAAA,CAAE8B,MAAA,IAASrB,CAAA,EAAE;kBAAC,IAAID,CAAA,GAAER,CAAA,CAAE+yD,UAAA,CAAWtyD,CAAA;kBAAG,OAAKD,CAAA,GAAEP,CAAA,KAAI,QAAMO,CAAA,GAAEP,CAAA,IAAG,IAAE,SAAOO,CAAA,IAAG,SAAOA,CAAA,IAAGP,CAAA,IAAG,KAAIQ,CAAA,IAAGR,CAAA,IAAG,CAAC;gBAAA;gBAAC,OAAOA,CAAA;cAAA;cAAG+yD,EAAA,GAAGnC,CAAC7wD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA;gBAAK,MAAK,IAAEA,CAAA,GAAG,OAAO;gBAAE,IAAIE,CAAA,GAAED,CAAA,MAAK;gBAAED,CAAA,GAAEC,CAAA,GAAED,CAAA,GAAE;gBAAE,KAAI,IAAIS,CAAA,GAAE,GAAEA,CAAA,GAAEjB,CAAA,CAAE8B,MAAA,IAASb,CAAA,EAAE;kBAAC,IAAIC,CAAA,GAAElB,CAAA,CAAE+yD,UAAA,CAAW9xD,CAAA;kBAAG,IAAG,SAAOC,CAAA,IAAG,SAAOA,CAAA,KAAIA,CAAA,GAAE,UAAQ,OAAKA,CAAA,KAAI,MAAI,OAAKlB,CAAA,CAAE+yD,UAAA,GAAa9xD,CAAA,IAAI,OAAKC,CAAA,EAAE;oBAAC,IAAGT,CAAA,IAAGD,CAAA,EAAE;oBAAMP,CAAA,CAAEQ,CAAA,OAAM,KAAGS,CAAC;kBAAA,OAAK;oBAAC,IAAG,QAAMA,CAAA,EAAE;sBAAC,IAAGT,CAAA,GAAE,KAAGD,CAAA,EAAE;sBAAMP,CAAA,CAAEQ,CAAA,OAAM,KAAG,MAAIS,CAAA,IAAG,CAAC;oBAAA,OAAK;sBAAC,IAAG,SAAOA,CAAA,EAAE;wBAAC,IAAGT,CAAA,GAAE,KAAGD,CAAA,EAAE;wBAAMP,CAAA,CAAEQ,CAAA,OAAM,KAAG,MAAIS,CAAA,IAAG,EAAE;sBAAA,OAAK;wBAAC,IAAGT,CAAA,GAAE,KAAGD,CAAA,EAAE;wBAAMP,CAAA,CAAEQ,CAAA,OAAM,KAAG,MAAIS,CAAA,IAAG,IAAGjB,CAAA,CAAEQ,CAAA,OAAM,KAAG,MAAIS,CAAA,IAAG,KAAG,EAAE;sBAAA;sBAACjB,CAAA,CAAEQ,CAAA,OAAM,KAAG,MAAIS,CAAA,IAAG,IAAE,EAAE;oBAAA;oBAACjB,CAAA,CAAEQ,CAAA,OAAM,KAAG,MAAI,KAAGS,CAAC;kBAAA;gBAAC;gBAAC,OAAOjB,CAAA,CAAEQ,CAAA,KAAI,KAAG,GAAEA,CAAA,GAAEC,CAAA;cAAA;cAAGuyD,EAAA,GAAGN,CAAC3yD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,KAAIuyD,EAAA,CAAGhzD,CAAA,EAAEQ,CAAA,IAAIP,CAAA,EAAEQ,CAAA;YAAG,SAASyyD,GAAGlzD,CAAA,EAAEC,CAAA;cAAG,IAAG+L,CAAA,EAAE,OAAOujD,EAAA,CAAG,GAAE,GAAEvvD,CAAA,EAAEC,CAAA,CAAE;YAAA;YAAC,SAASkzD,GAAGnzD,CAAA,EAAEC,CAAA,EAAEQ,CAAA;cAAG,IAAGuL,CAAA,EAAE,OAAOujD,EAAA,CAAG,GAAE,GAAEvvD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,CAAE;YAAA;YAAC,SAAS2yD,GAAGpzD,CAAA,EAAEC,CAAA,EAAEQ,CAAA;cAAG,OAAOuL,CAAA,GAAEujD,EAAA,CAAG,GAAE,GAAEvvD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,IAAG,CAAC;YAAA;YAAC,SAAS4yD,GAAGrzD,CAAA,EAAEC,CAAA;cAAG,IAAG+L,CAAA,EAAE,OAAOujD,EAAA,CAAG,GAAE,GAAEvvD,CAAA,EAAEC,CAAA,CAAE;YAAA;YAAC,SAASqzD,GAAGtzD,CAAA,EAAEC,CAAA,EAAEQ,CAAA;cAAG,IAAGuL,CAAA,EAAE,OAAOujD,EAAA,CAAG,IAAG,GAAEvvD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,CAAE;YAAA;YAAC,SAAS8yD,GAAGvzD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA;cAAG,IAAGwL,CAAA,EAAE,OAAOujD,EAAA,CAAG,IAAG,GAAEvvD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,CAAE;YAAA;YAAC,SAASgzD,GAAGxzD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA;cAAG,IAAGwL,CAAA,EAAE,OAAOujD,EAAA,CAAG,IAAG,GAAEvvD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,CAAE;YAAA;YAAC,SAASizD,GAAGzzD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA;cAAG,IAAGwL,CAAA,EAAE,OAAOujD,EAAA,CAAG,IAAG,GAAEvvD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,CAAE;YAAA;YAAC,SAASkzD,GAAG1zD,CAAA;cAAG,IAAGgM,CAAA,EAAE,OAAOujD,EAAA,CAAG,IAAG,GAAEvvD,CAAA,CAAE;YAAA;YAAC,SAAS2zD,GAAG3zD,CAAA,EAAEC,CAAA;cAAG,IAAG+L,CAAA,EAAE,OAAOujD,EAAA,CAAG,IAAG,GAAEvvD,CAAA,EAAEC,CAAA,CAAE;YAAA;YAAC,SAAS2zD,GAAG5zD,CAAA,EAAEC,CAAA,EAAEQ,CAAA;cAAG,IAAGuL,CAAA,EAAE,OAAOujD,EAAA,CAAG,IAAG,GAAEvvD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,CAAE;YAAA;YAAC,IAAIozD,EAAA,GAAG7zD,CAAA;cAAI,KAAImrD,CAAA,EAAE;gBAAI,IAAGnrD,CAAA,KAAK4sD,CAAA,IAAI;kBAAI5gD,CAAA,GAAE6mD,EAAA,CAAGz7C,CAAA,IAAG+3C,EAAA,CAAG/3C,CAAA,CAAE;gBAAA,CAAC,QAAMpX,CAAA;kBAAGA,CAAA,YAAa8tD,EAAA,IAAI,YAAU9tD,CAAA,IAAGwG,CAAA,CAAE,GAAExG,CAAA,CAAE;gBAAA;cAAC,CAAC,QAAMA,CAAA;gBAAGA,CAAA,YAAa8tD,EAAA,IAAI,YAAU9tD,CAAA,IAAGwG,CAAA,CAAE,GAAExG,CAAA,CAAE;cAAA;YAAA;YAAG,SAAS8zD,GAAG9zD,CAAA;cAAGA,CAAA,MAAK,GAAE,qBAAmB+zD,OAAA,CAAQC,EAAA,KAAKD,OAAA,CAAQC,EAAA,CAAGtzD,CAAA,IAAIV,CAAA,IAAG,GAAEA,CAAA,EAAGmkB,KAAA,CAAMsc,IAAA,CAAKowB,EAAA,GAAI7wD,CAAA,IAAG,KAAI+zD,OAAA,CAAQE,KAAA,CAAMvzD,CAAA,IAAIV,CAAA,IAAG,GAAE,GAAG;YAAA;YAAC,SAAS6wD,GAAA;cAAK,IAAI7wD,CAAA,GAAE0wD,EAAA;cAAK1wD,CAAA,KAAI8zD,EAAA,CAAG9zD,CAAA,GAAG6zD,EAAA,CAAG,MAAKK,EAAA,IAAO;YAAA;YAACzpD,CAAA,CAAE0pD,iCAAA,GAAkCL,EAAA,EAAGrpD,CAAA,CAAE2pD,YAAA,GAAavD,EAAA;YAAG,IAAIwD,EAAA,GAAGr0D,CAAA,IAAG,KAAGA,CAAA,GAAE,MAAI,KAAGA,CAAA,GAAE,OAAK,KAAGA,CAAA,GAAE;cAAKs0D,EAAA,GAAG,CAAC,GAAE,IAAG,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI;cAAKC,EAAA,GAAG,CAAC,GAAE,IAAG,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI;YAAK,SAASC,GAAGx0D,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAEE,CAAA,EAAEO,CAAA,EAAEC,CAAA,EAAEoC,CAAA;cAAG,OAAO0I,CAAA,GAAEujD,EAAA,CAAG,IAAG,GAAEvvD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAEE,CAAA,EAAEO,CAAA,EAAEC,CAAA,EAAEoC,CAAA,KAAI,EAAE;YAAA;YAAC,SAASmxD,GAAGz0D,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAEE,CAAA,EAAEO,CAAA,EAAEC,CAAA;cAAG,IAAG8K,CAAA,EAAE,OAAOujD,EAAA,CAAG,IAAG,GAAEvvD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAEE,CAAA,EAAEO,CAAA,EAAEC,CAAA,CAAE;YAAA;YAAC,IAAIwzD,EAAA,GAAG10D,CAAA;gBAAI,IAAIC,CAAA,GAAE6yD,EAAA,CAAG9yD,CAAA,IAAG;kBAAES,CAAA,GAAEk0D,EAAA,CAAG10D,CAAA;gBAAG,OAAOQ,CAAA,IAAGwyD,EAAA,CAAGjzD,CAAA,EAAES,CAAA,EAAER,CAAA,GAAGQ,CAAA;cAAA;cAAGm0D,EAAA,GAAG50D,CAAA;gBAAI,IAAIC,CAAA,GAAE40D,EAAA;gBAAK,OAAO70D,CAAA,GAAEA,CAAA,IAAIgyD,EAAA,CAAG/xD,CAAA,GAAGD,CAAA;cAAA;YAAG,SAASuvD,GAAGvvD,CAAA,EAAEC,CAAA;cAAG,IAAIQ,CAAA,GAAEq0D,SAAA,CAAUhzD,MAAA,GAAO;gBAAEtB,CAAA,GAAEs0D,SAAA;cAAU,OAAOF,EAAA,CAAG;gBAAM,KAAI,IAAIl0D,CAAA,GAAEq0D,EAAA,CAAG,IAAEt0D,CAAA,GAAGQ,CAAA,GAAEP,CAAA,IAAG,GAAE4C,CAAA,GAAE,GAAEA,CAAA,GAAE7C,CAAA,EAAE6C,CAAA,IAAI;kBAAC,IAAII,CAAA,GAAElD,CAAA,CAAE,IAAE8C,CAAA;kBAAGpC,CAAA,GAAID,CAAA,GAAEqC,CAAA,KAAI,KAAGI,CAAC;gBAAA;gBAAC,OAAOsxD,EAAA,CAAGh1D,CAAA,EAAES,CAAA,EAAEC,CAAA,EAAET,CAAA,CAAG;cAAA,EAAE;YAAA;YAAC,IAAIg1D,EAAA;cAAGC,EAAA,GAAG;cAAGC,EAAA,GAAG,CAAC;cAAEC,EAAA,GAAGH,CAAA;gBAAK,KAAIA,EAAA,EAAG;kBAAC,IAAIj1D,CAAA;oBAAEC,CAAA,GAAE;sBAACo1D,IAAA,EAAK;sBAAWC,OAAA,EAAQ;sBAAWC,IAAA,EAAK;sBAAIC,GAAA,EAAI;sBAAIC,IAAA,EAAK;sBAAiBC,IAAA,GAAM,mBAAiB9zD,SAAA,IAAWA,SAAA,CAAU+zD,SAAA,IAAW/zD,SAAA,CAAU+zD,SAAA,CAAU,MAAI,KAAKtlD,OAAA,CAAQ,KAAI,OAAK;sBAASpE,CAAA,EAAEP,CAAA,IAAG;oBAAA;kBAAkB,KAAI1L,CAAA,IAAKm1D,EAAA,OAAG,MAASA,EAAA,CAAGn1D,CAAA,WAAUC,CAAA,CAAED,CAAA,IAAGC,CAAA,CAAED,CAAA,IAAGm1D,EAAA,CAAGn1D,CAAA;kBAAG,IAAIS,CAAA,GAAE;kBAAG,KAAIT,CAAA,IAAKC,CAAA,EAAEQ,CAAA,CAAEuG,IAAA,CAAK,GAAGhH,CAAA,IAAKC,CAAA,CAAED,CAAA;kBAAMi1D,EAAA,GAAGx0D,CAAC;gBAAA;gBAAC,OAAOw0D,EAAA;cAAA;YAAI,SAASW,GAAG51D,CAAA,EAAES,CAAA;cAAG,IAAGuL,CAAA,EAAE,OAAOujD,EAAA,CAAG,IAAG,GAAEvvD,CAAA,EAAES,CAAA;cAAGT,CAAA,MAAK,GAAES,CAAA,MAAK;cAAE,IAAID,CAAA,GAAE;cAAE,OAAO40D,EAAA,GAAKvqD,OAAA,CAAQ,UAAUnK,CAAA,EAAEQ,CAAA;gBAAG,IAAIoC,CAAA,GAAE7C,CAAA,GAAED,CAAA;gBAAE,KAAIU,CAAA,GAAED,CAAA,GAAIjB,CAAA,GAAE,IAAEkB,CAAA,IAAG,MAAI,KAAGoC,CAAA,EAAEA,CAAA,GAAE,GAAEA,CAAA,GAAE5C,CAAA,CAAEoB,MAAA,IAASwB,CAAA,EAAErD,CAAA,GAAIiB,CAAA,MAAK,MAAI,KAAGR,CAAA,CAAEqyD,UAAA,CAAWzvD,CAAA;gBAAGrD,CAAA,GAAIiB,CAAA,IAAG,MAAI,KAAG,GAAEV,CAAA,IAAGE,CAAA,CAAEoB,MAAA,GAAO,CAAE;cAAA,IAAG,CAAC;YAAA;YAAC,SAAS+zD,GAAG71D,CAAA,EAAEC,CAAA;cAAG,IAAG+L,CAAA,EAAE,OAAOujD,EAAA,CAAG,IAAG,GAAEvvD,CAAA,EAAEC,CAAA;cAAGD,CAAA,MAAK,GAAEC,CAAA,MAAK;cAAE,IAAIQ,CAAA,GAAE20D,EAAA;cAAKn0D,CAAA,GAAIjB,CAAA,IAAG,MAAI,KAAGS,CAAA,CAAEqB,MAAA;cAAO,IAAItB,CAAA,GAAE;cAAE,OAAOC,CAAA,CAAEoK,OAAA,CAAQ,UAAU7K,CAAA;gBAAGQ,CAAA,IAAGR,CAAA,CAAE8B,MAAA,GAAO,CAAE;cAAA,IAAGb,CAAA,GAAIhB,CAAA,IAAG,MAAI,KAAGO,CAAA,EAAE,CAAC;YAAA;YAAC,SAASs1D,GAAG91D,CAAA;cAAG,OAAOgM,CAAA,GAAEujD,EAAA,CAAG,IAAG,GAAEvvD,CAAA,IAAG,EAAE;YAAA;YAAC,SAAS+1D,GAAG/1D,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA;cAAG,OAAOwL,CAAA,GAAEujD,EAAA,CAAG,IAAG,GAAEvvD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,IAAG,EAAE;YAAA;YAAC,SAASw1D,GAAGh2D,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAEE,CAAA;cAAG,OAAOsL,CAAA,GAAEujD,EAAA,CAAG,IAAG,GAAEvvD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAEE,CAAA,IAAG,EAAE;YAAA;YAAC,IAAIu1D,EAAA,GAAG,CAAC,MAAK,IAAG;YAAI,SAASC,GAAGl2D,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAEC,CAAA;cAAG,IAAGsL,CAAA,EAAE,OAAOujD,EAAA,CAAG,IAAG,GAAEvvD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAEC,CAAA;cAAGT,CAAA,MAAK,GAAEQ,CAAA,MAAK,GAAEC,CAAA,MAAK;cAAE,KAAI,IAAIQ,CAAA,GAAE,GAAEoC,CAAA,GAAE,GAAEA,CAAA,GAAE7C,CAAA,EAAE6C,CAAA,IAAI;gBAAC,IAAII,CAAA,GAAEzC,CAAA,GAAIhB,CAAA,IAAG,MAAI;kBAAGwK,CAAA,GAAExJ,CAAA,GAAIhB,CAAA,GAAE,KAAG,MAAI;gBAAGA,CAAA,IAAG;gBAAE,KAAI,IAAIoL,CAAA,GAAE,GAAEA,CAAA,GAAEZ,CAAA,EAAEY,CAAA,IAAI;kBAAC,IAAIC,CAAA,GAAE9K,CAAA,GAAIkD,CAAA,GAAE2H,CAAA,KAAI;oBAAGE,CAAA,GAAE0qD,EAAA,CAAGj2D,CAAA;kBAAG,MAAIsL,CAAA,IAAG,OAAKA,CAAA,KAAI,MAAItL,CAAA,GAAE8W,CAAA,GAAEC,CAAA,EAAGm4C,EAAA,CAAG3jD,CAAA,EAAE,KAAIA,CAAA,CAAEzJ,MAAA,GAAO,KAAGyJ,CAAA,CAAEvE,IAAA,CAAKsE,CAAA,CAAE;gBAAA;gBAACpK,CAAA,IAAGuJ,CAAC;cAAA;cAAC,OAAOxJ,CAAA,GAAIP,CAAA,IAAG,MAAI,KAAGQ,CAAA,EAAE,CAAC;YAAA;YAAC,IAAIi1D,EAAA,GAAGn2D,CAAA,KAAIm2D,EAAA,GAAG;gBAAM,IAAG,mBAAiBC,MAAA,IAAQ,qBAAmBA,MAAA,CAAOC,eAAA,EAAgB,OAAOr2D,CAAA,KAAIA,CAAA,CAAE+D,GAAA,CAAIqyD,MAAA,CAAOC,eAAA,CAAgB,IAAI5mD,UAAA,CAAWzP,CAAA,CAAE8uB,UAAA,KAAc9uB,CAAA;gBAAG,IAAG+L,CAAA,EAAE;kBAAI,IAAI/L,CAAA,GAAES,CAAA,CAAQ;kBAAU,IAAGT,CAAA,CAAEs2D,cAAA,EAAe,OAAOr2D,CAAA,IAAGD,CAAA,CAAEs2D,cAAA,CAAer2D,CAAA;kBAAG,IAAIA,CAAA,GAAED,CAAA,CAAEu2D,WAAA;kBAAY,OAAOv2D,CAAA,KAAIA,CAAA,CAAE+D,GAAA,CAAI9D,CAAA,CAAED,CAAA,CAAE8uB,UAAA,IAAa9uB,CAAA,CAAE;gBAAA,CAAC,QAAMA,CAAA,GAAG;gBAAC0rD,EAAA,CAAG,mBAAoB;cAAA,GAAnU,GAAwU1rD,CAAA;cAAGw2D,EAAA,GAAG,CAAC,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG;cAAIC,EAAA,GAAG,CAAC,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG;cAAIC,EAAA,GAAGA,CAAC12D,CAAA,EAAES,CAAA;gBAAKR,CAAA,GAAI8D,GAAA,CAAI/D,CAAA,EAAES,CAAA,KAAI,EAAC;cAAA;YAAG,SAASk2D,GAAG32D,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA;cAAG,SAASS,EAAEjB,CAAA,EAAEC,CAAA,EAAEQ,CAAA;gBAAG,KAAIT,CAAA,GAAE,mBAAiBA,CAAA,GAAEA,CAAA,CAAEu2B,QAAA,KAAWv2B,CAAA,IAAG,IAAGA,CAAA,CAAE8B,MAAA,GAAO7B,CAAA,GAAGD,CAAA,GAAES,CAAA,CAAE,KAAGT,CAAA;gBAAE,OAAOA,CAAC;cAAA;cAAC,SAASkB,EAAElB,CAAA,EAAEC,CAAA;gBAAG,OAAOgB,CAAA,CAAEjB,CAAA,EAAEC,CAAA,EAAE,IAAI;cAAA;cAAC,SAASqD,EAAEtD,CAAA,EAAEC,CAAA;gBAAG,SAASQ,EAAET,CAAA;kBAAG,OAAO,IAAEA,CAAA,IAAG,IAAE,IAAEA,CAAA,GAAE,IAAE,CAAC;gBAAA;gBAAC,IAAIQ,CAAA;gBAAE,OAAO,OAAKA,CAAA,GAAEC,CAAA,CAAET,CAAA,CAAE42D,WAAA,KAAc32D,CAAA,CAAE22D,WAAA,QAAiB,OAAKp2D,CAAA,GAAEC,CAAA,CAAET,CAAA,CAAE62D,QAAA,KAAW52D,CAAA,CAAE42D,QAAA,SAAer2D,CAAA,GAAEC,CAAA,CAAET,CAAA,CAAE82D,OAAA,KAAU72D,CAAA,CAAE62D,OAAA,MAAYt2D,CAAC;cAAA;cAAC,SAASkD,EAAE1D,CAAA;gBAAG,QAAOA,CAAA,CAAE+2D,MAAA;kBAAU,KAAK;oBAAE,OAAO,IAAIl4B,IAAA,CAAK7+B,CAAA,CAAE42D,WAAA,KAAc,GAAE,IAAG;kBAAI,KAAK;oBAAE,OAAO52D,CAAA;kBAAE,KAAK;oBAAE,OAAO,IAAI6+B,IAAA,CAAK7+B,CAAA,CAAE42D,WAAA,IAAc,GAAE;kBAAG,KAAK;oBAAE,OAAO,IAAI/3B,IAAA,CAAK7+B,CAAA,CAAE42D,WAAA,IAAc,GAAE;kBAAG,KAAK;oBAAE,OAAO,IAAI/3B,IAAA,CAAK7+B,CAAA,CAAE42D,WAAA,IAAc,GAAE;kBAAG,KAAK;oBAAE,OAAO,IAAI/3B,IAAA,CAAK7+B,CAAA,CAAE42D,WAAA,KAAc,GAAE,IAAG;kBAAI,KAAK;oBAAE,OAAO,IAAI/3B,IAAA,CAAK7+B,CAAA,CAAE42D,WAAA,KAAc,GAAE,IAAG;gBAAA;cAAI;cAAC,SAASnsD,EAAEzK,CAAA;gBAAG,IAAIC,CAAA,GAAED,CAAA,CAAEg3D,EAAA;gBAAG,KAAIh3D,CAAA,GAAE,IAAI6+B,IAAA,CAAK,IAAIA,IAAA,CAAK7+B,CAAA,CAAEi3D,EAAA,GAAG,MAAK,GAAE,GAAGC,OAAA,KAAW,IAAEj3D,CAAA,GAAG;kBAAC,IAAIQ,CAAA,GAAET,CAAA,CAAE62D,QAAA;oBAAWr2D,CAAA,IAAG6zD,EAAA,CAAGr0D,CAAA,CAAE42D,WAAA,MAAeJ,EAAA,GAAGC,EAAA,EAAIh2D,CAAA;kBAAG,MAAKR,CAAA,GAAEO,CAAA,GAAER,CAAA,CAAE82D,OAAA,KAAW;oBAAC92D,CAAA,CAAEm3D,OAAA,CAAQn3D,CAAA,CAAE82D,OAAA,KAAU72D,CAAA;oBAAG;kBAAK;kBAACA,CAAA,IAAGO,CAAA,GAAER,CAAA,CAAE82D,OAAA,KAAU,GAAE92D,CAAA,CAAEm3D,OAAA,CAAQ,IAAG,KAAG12D,CAAA,GAAET,CAAA,CAAEo3D,QAAA,CAAS32D,CAAA,GAAE,MAAIT,CAAA,CAAEo3D,QAAA,CAAS,IAAGp3D,CAAA,CAAEq3D,WAAA,CAAYr3D,CAAA,CAAE42D,WAAA,KAAc,GAAG;gBAAA;gBAAC,OAAOn2D,CAAA,GAAE,IAAIo+B,IAAA,CAAK7+B,CAAA,CAAE42D,WAAA,KAAc,GAAE,GAAE,IAAG32D,CAAA,GAAEyD,CAAA,CAAE,IAAIm7B,IAAA,CAAK7+B,CAAA,CAAE42D,WAAA,IAAc,GAAE,KAAIn2D,CAAA,GAAEiD,CAAA,CAAEjD,CAAA,GAAG,KAAG6C,CAAA,CAAErD,CAAA,EAAED,CAAA,IAAG,KAAGsD,CAAA,CAAE7C,CAAA,EAAET,CAAA,IAAGA,CAAA,CAAE42D,WAAA,KAAc,IAAE52D,CAAA,CAAE42D,WAAA,KAAc52D,CAAA,CAAE42D,WAAA,KAAc,CAAC;cAAA;cAAC52D,CAAA,MAAK,GAAEC,CAAA,MAAK,GAAEQ,CAAA,MAAK,GAAED,CAAA,MAAK;cAAE,IAAI6K,CAAA,GAAE3K,CAAA,GAAIF,CAAA,GAAE,MAAI,MAAI;cAAG,KAAI,IAAI8K,CAAA,IAAK9K,CAAA,GAAE;gBAAC82D,EAAA,EAAG52D,CAAA,GAAIF,CAAA,IAAG,MAAI;gBAAG+2D,EAAA,EAAG72D,CAAA,GAAIF,CAAA,GAAE,KAAG,MAAI;gBAAGg3D,EAAA,EAAG92D,CAAA,GAAIF,CAAA,GAAE,KAAG,MAAI;gBAAGi3D,EAAA,EAAG/2D,CAAA,GAAIF,CAAA,GAAE,MAAI,MAAI;gBAAGk3D,EAAA,EAAGh3D,CAAA,GAAIF,CAAA,GAAE,MAAI,MAAI;gBAAGy2D,EAAA,EAAGv2D,CAAA,GAAIF,CAAA,GAAE,MAAI,MAAI;gBAAGm3D,EAAA,EAAGj3D,CAAA,GAAIF,CAAA,GAAE,MAAI,MAAI;gBAAGw2D,EAAA,EAAGt2D,CAAA,GAAIF,CAAA,GAAE,MAAI,MAAI;gBAAGo3D,EAAA,EAAGl3D,CAAA,GAAIF,CAAA,GAAE,MAAI,MAAI;gBAAGq3D,EAAA,EAAGn3D,CAAA,GAAIF,CAAA,GAAE,MAAI,MAAI;gBAAGs3D,EAAA,EAAGzsD,CAAA,GAAEgkD,EAAA,CAAGhkD,CAAA,IAAG;cAAA,GAAI5K,CAAA,GAAE4uD,EAAA,CAAG5uD,CAAA,GAAG4K,CAAA,GAAE;gBAAC,MAAK;gBAAuB,MAAK;gBAAW,MAAK;gBAAW,MAAK;gBAAK,MAAK;gBAAc,MAAK;gBAAQ,MAAK;gBAAW,MAAK;gBAAW,MAAK;gBAAW,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAW,OAAM;gBAAW,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;cAAA,GAAM5K,CAAA,GAAEA,CAAA,CAAE4P,OAAA,CAAQ,IAAIC,MAAA,CAAOhF,CAAA,EAAE,MAAKD,CAAA,CAAEC,CAAA;cAAI,IAAIC,CAAA,GAAE,2DAA2DyE,KAAA,CAAM;gBAAKzJ,CAAA,GAAE,wFAAwFyJ,KAAA,CAAM;cAAK,KAAI1E,CAAA,IAAKD,CAAA,GAAE;gBAAC,MAAKrL,CAAA,IAAGuL,CAAA,CAAEvL,CAAA,CAAE23D,EAAA,EAAIx1B,SAAA,CAAU,GAAE;gBAAG,MAAKniC,CAAA,IAAGuL,CAAA,CAAEvL,CAAA,CAAE23D,EAAA;gBAAI,MAAK33D,CAAA,IAAGuG,CAAA,CAAEvG,CAAA,CAAE03D,EAAA,EAAIv1B,SAAA,CAAU,GAAE;gBAAG,MAAKniC,CAAA,IAAGuG,CAAA,CAAEvG,CAAA,CAAE03D,EAAA;gBAAI,MAAK13D,CAAA,IAAGkB,CAAA,EAAGlB,CAAA,CAAEi3D,EAAA,GAAG,QAAM,MAAI,GAAE;gBAAG,MAAKj3D,CAAA,IAAGkB,CAAA,CAAElB,CAAA,CAAEy3D,EAAA,EAAG;gBAAG,MAAKz3D,CAAA,IAAGiB,CAAA,CAAEjB,CAAA,CAAEy3D,EAAA,EAAG,GAAE;gBAAK,MAAKz3D,CAAA,IAAGyK,CAAA,CAAEzK,CAAA,EAAGu2B,QAAA,GAAW4L,SAAA,CAAU;gBAAG,MAAKniC,CAAA,IAAGyK,CAAA,CAAEzK,CAAA;gBAAG,MAAKA,CAAA,IAAGkB,CAAA,CAAElB,CAAA,CAAEw3D,EAAA,EAAG;gBAAG,MAAKx3D,CAAA,KAAI,MAAIA,CAAA,GAAEA,CAAA,CAAEw3D,EAAA,IAAIx3D,CAAA,GAAE,KAAG,KAAGA,CAAA,KAAIA,CAAA,IAAG,KAAIkB,CAAA,CAAElB,CAAA,EAAE;gBAAI,MAAKA,CAAA;kBAAI,KAAI,IAAIC,CAAA,GAAE,GAAEQ,CAAA,GAAE,GAAEA,CAAA,IAAGT,CAAA,CAAE03D,EAAA,GAAG,GAAEz3D,CAAA,KAAIo0D,EAAA,CAAGr0D,CAAA,CAAEi3D,EAAA,GAAG,QAAMT,EAAA,GAAGC,EAAA,EAAIh2D,CAAA;kBAAM,OAAOS,CAAA,CAAElB,CAAA,CAAEy3D,EAAA,GAAGx3D,CAAA,EAAE,EAAC;gBAAA;gBAAG,MAAKD,CAAA,IAAGkB,CAAA,CAAElB,CAAA,CAAE03D,EAAA,GAAG,GAAE;gBAAG,MAAK13D,CAAA,IAAGkB,CAAA,CAAElB,CAAA,CAAEu3D,EAAA,EAAG;gBAAG,MAAKQ,CAAA,KAAI;gBAAK,MAAK/3D,CAAA,IAAG,KAAGA,CAAA,CAAEw3D,EAAA,IAAI,KAAGx3D,CAAA,CAAEw3D,EAAA,GAAG,OAAK;gBAAK,MAAKx3D,CAAA,IAAGkB,CAAA,CAAElB,CAAA,CAAEs3D,EAAA,EAAG;gBAAG,MAAKU,CAAA,KAAI;gBAAK,MAAKh4D,CAAA,IAAGA,CAAA,CAAE23D,EAAA,IAAI;gBAAE,MAAK33D,CAAA,IAAGkB,CAAA,CAAEc,IAAA,CAAKoX,KAAA,EAAOpZ,CAAA,CAAEg3D,EAAA,GAAG,IAAEh3D,CAAA,CAAE23D,EAAA,IAAI,IAAG;gBAAG,MAAK33D,CAAA;kBAAI,IAAIC,CAAA,GAAE+B,IAAA,CAAKoX,KAAA,EAAOpZ,CAAA,CAAEg3D,EAAA,GAAG,KAAGh3D,CAAA,CAAE23D,EAAA,GAAG,KAAG,KAAG;kBAAG,IAAG,MAAI33D,CAAA,CAAE23D,EAAA,GAAG,MAAI33D,CAAA,CAAEg3D,EAAA,GAAG,KAAG,KAAG/2D,CAAA,IAAIA,CAAA,EAAE,MAAIA,CAAA,KAAI,MAAIQ,CAAA,IAAGT,CAAA,CAAE23D,EAAA,GAAG,MAAI33D,CAAA,CAAEg3D,EAAA,IAAI,MAAI,KAAGv2D,CAAA,IAAG4zD,EAAA,CAAGr0D,CAAA,CAAEi3D,EAAA,MAAMh3D,CAAA,GAAE,SAAQ;oBAACA,CAAA,GAAE;oBAAG,IAAIQ,CAAA,IAAGT,CAAA,CAAE23D,EAAA,GAAG,IAAE33D,CAAA,CAAEg3D,EAAA,GAAG,KAAG;oBAAA,CAAG,KAAGv2D,CAAA,IAAG,KAAGA,CAAA,IAAG4zD,EAAA,CAAGr0D,CAAA,CAAEi3D,EAAA,GAAG,MAAI,OAAKh3D,CAAA,EAAG;kBAAA;kBAAC,OAAOiB,CAAA,CAAEjB,CAAA,EAAE,EAAC;gBAAA;gBAAG,MAAKD,CAAA,IAAGA,CAAA,CAAE23D,EAAA;gBAAG,MAAK33D,CAAA,IAAGkB,CAAA,CAAEc,IAAA,CAAKoX,KAAA,EAAOpZ,CAAA,CAAEg3D,EAAA,GAAG,KAAGh3D,CAAA,CAAE23D,EAAA,GAAG,KAAG,KAAG,IAAG;gBAAG,MAAK33D,CAAA,KAAIA,CAAA,CAAEi3D,EAAA,GAAG,MAAM1gC,QAAA,GAAW4L,SAAA,CAAU;gBAAG,MAAKniC,CAAA,IAAGA,CAAA,CAAEi3D,EAAA,GAAG;gBAAK,MAAKj3D,CAAA;kBAAI,IAAIC,CAAA,GAAE,MAAID,CAAA,GAAEA,CAAA,CAAE63D,EAAA;kBAAI,OAAO73D,CAAA,GAAEgC,IAAA,CAAKuV,GAAA,CAAIvX,CAAA,IAAG,KAAIC,CAAA,GAAE,MAAI,OAAKmmD,MAAA,CAAO,UAAQpmD,CAAA,GAAE,KAAG,MAAIA,CAAA,GAAE,KAAKkN,KAAA,EAAO,EAAC;gBAAA;gBAAG,MAAKlN,CAAA,IAAGA,CAAA,CAAE83D,EAAA;gBAAG,MAAKG,CAAA,KAAI;cAAA,GAAKx3D,CAAA,GAAEA,CAAA,CAAE4P,OAAA,CAAQ,OAAM,SAAQhF,CAAA,EAAE5K,CAAA,CAAEy3D,QAAA,CAAS5sD,CAAA,MAAK7K,CAAA,GAAEA,CAAA,CAAE4P,OAAA,CAAQ,IAAIC,MAAA,CAAOhF,CAAA,EAAE,MAAKD,CAAA,CAAEC,CAAA,EAAG9K,CAAA;cAAK,OAAO8K,CAAA,GAAE,UAAStL,CAAA;gBAAG,IAAIC,CAAA,GAAE+F,KAAA,CAAM8sD,EAAA,CAAG9yD,CAAA,IAAG;gBAAG,OAAOgzD,EAAA,CAAGhzD,CAAA,EAAEC,CAAA,EAAE,GAAEA,CAAA,CAAE6B,MAAA,GAAQ7B,CAAC;cAAA,CAA5D,CAA8DQ,CAAA,GAAEA,CAAA,CAAE4P,OAAA,CAAQ,SAAQ,OAAM/E,CAAA,CAAExJ,MAAA,GAAO7B,CAAA,GAAE,KAAGy2D,EAAA,CAAGprD,CAAA,EAAEtL,CAAA,GAAGsL,CAAA,CAAExJ,MAAA,GAAO,EAAE;YAAA;YAACosD,EAAA,CAAG2B,EAAA;YAAK,IAAIsI,EAAA,GAAG,CAAC,MAAK7I,EAAA,EAAGI,EAAA,EAAG6C,EAAA,EAAGG,EAAA,EAAGC,EAAA,EAAGO,EAAA,EAAGC,EAAA,EAAGC,EAAA,EAAGC,EAAA,EAAGC,EAAA,EAAGC,EAAA,EAAGC,EAAA,EAAGC,EAAA,EAAGC,EAAA,EAAGC,EAAA,EAAGC,EAAA,EAAGY,EAAA,EAAGC,EAAA,EAAGmB,EAAA,EAAGC,EAAA,EAAGC,EAAA,EAAGC,EAAA,EAAGC,EAAA,EAAGE,EAAA;cAAIkC,EAAA,GAAG;gBAACxsD,CAAA,EAAE,SAAAA,CAAS5L,CAAA,EAAEC,CAAA,EAAEQ,CAAA;kBAAG,MAAM,IAAIyxD,EAAA,CAAGlyD,CAAA,MAAK,GAAG6vD,EAAA,CAAG5vD,CAAA,KAAI,GAAEQ,CAAA,KAAI,IAAGT,CAAC;gBAAA;gBAAEqX,CAAA,EAAE,SAAAA,CAASrX,CAAA;kBAAGq4D,EAAA,CAAGr4D,CAAA,KAAI,IAAG6L,CAAA,EAAE,IAAGD,CAAA,EAAE,SAAO,IAAIsiD,EAAA,CAAGiC,EAAA,EAAI;gBAAA;gBAAEh5C,CAAA,EAAE,SAAAA,CAASnX,CAAA;kBAAGA,CAAA,MAAK,GAAEgM,CAAA,GAAEmyC,WAAA,CAAY;oBAACsQ,GAAA,EAAI;oBAAgBqC,MAAA,EAAO9wD;kBAAA,KAAIiuD,EAAA,CAAGjuD,CAAA,CAAE;gBAAA;gBAAE+W,CAAA,EAAEy7C,EAAA;gBAAG9mD,CAAA,EAAEgnD,EAAA;gBAAGrmD,CAAA,EAAEsmD,EAAA;gBAAG37C,CAAA,EAAEk8C,EAAA;gBAAGzG,CAAA,EAAE0G,EAAA;gBAAG1J,CAAA,EAAE2J,EAAA;gBAAGzyD,CAAA,EAAE0yD,EAAA;gBAAGrG,CAAA,EAAEsG,EAAA;gBAAGrG,CAAA,EAAEsG,EAAA;gBAAG7yD,CAAA,EAAE8yD,EAAA;gBAAGp8C,CAAA,EAAEq8C,EAAA;gBAAG9J,CAAA,EAAE+J,EAAA;gBAAG98C,CAAA,EAAE+8C,EAAA;gBAAG18C,CAAA,EAAE28C,EAAA;gBAAGhH,CAAA,EAAEA,CAAA,MAAI;gBAAG/1C,CAAA,EAAE,SAAAA,CAAS7W,CAAA,EAAEC,CAAA;kBAAA,CAAID,CAAA,MAAK,MAAIC,CAAA,KAAI,IAAEixB,UAAA,CAAW,MAAK2/B,EAAA,MAAO7kD,CAAA,GAAEmyC,WAAA,CAAY;oBAACsS,YAAA,EAAazwD,CAAA;oBAAEyuD,GAAA,EAAI;kBAAA,MAAkBzuD,CAAA,GAAEkuD,EAAA,CAAGC,EAAA,CAAGnuD,CAAA,MAAKA,CAAA,CAAEm+C,WAAA,CAAY;oBAACsQ,GAAA,EAAI;kBAAA,EAAgB;gBAAA;gBAAE/E,CAAA,EAAE,SAAAA,CAAA;kBAAW,QAAO,CAAC;gBAAA;gBAAEyB,CAAA,EAAE2I,EAAA;gBAAGxoD,CAAA,EAAE,SAAAA,CAAStL,CAAA;kBAAG+L,CAAA,IAAGmiD,EAAA,CAAGC,EAAA,CAAGnuD,CAAA,KAAI,GAAGs4D,GAAA,EAAK;gBAAA;gBAAEr4D,CAAA,EAAE,SAAAA,CAASD,CAAA,EAAEC,CAAA,EAAEQ,CAAA;kBAAGT,CAAA,GAAEC,CAAA,GAAE,YAAU,IAAE,YAAUD,CAAA,IAAGA,CAAA,KAAI,KAAG,aAAWC,CAAA,GAAEs4D,GAAA,EAAI93D,CAAA,MAAK,GAAET,CAAA,GAAE,IAAI6+B,IAAA,CAAK,MAAI7+B,CAAA,GAAGU,CAAA,GAAID,CAAA,IAAG,MAAI,KAAGT,CAAA,CAAEw4D,aAAA,IAAgB93D,CAAA,GAAID,CAAA,GAAE,KAAG,MAAI,KAAGT,CAAA,CAAEy4D,aAAA,IAAgB/3D,CAAA,GAAID,CAAA,GAAE,KAAG,MAAI,KAAGT,CAAA,CAAE04D,WAAA,IAAch4D,CAAA,GAAID,CAAA,GAAE,MAAI,MAAI,KAAGT,CAAA,CAAE24D,UAAA,IAAaj4D,CAAA,GAAID,CAAA,GAAE,MAAI,MAAI,KAAGT,CAAA,CAAE44D,WAAA,IAAcl4D,CAAA,GAAID,CAAA,GAAE,MAAI,MAAI,KAAGT,CAAA,CAAE64D,cAAA,KAAiB,MAAKn4D,CAAA,GAAID,CAAA,GAAE,MAAI,MAAI,KAAGT,CAAA,CAAE84D,SAAA,IAAY94D,CAAA,IAAGA,CAAA,CAAEk3D,OAAA,KAAUr4B,IAAA,CAAKk6B,GAAA,CAAI/4D,CAAA,CAAE64D,cAAA,IAAiB,GAAE,GAAE,GAAE,GAAE,GAAE,MAAI,QAAM,GAAEn4D,CAAA,GAAID,CAAA,GAAE,MAAI,MAAI,KAAGT,CAAC;gBAAA;gBAAE0D,CAAA,EAAE,SAAAA,CAAS1D,CAAA,EAAEC,CAAA,EAAEQ,CAAA;kBAAGT,CAAA,GAAEC,CAAA,GAAE,YAAU,IAAE,YAAUD,CAAA,IAAGA,CAAA,KAAI,KAAG,aAAWC,CAAA,GAAEs4D,GAAA,EAAI93D,CAAA,MAAK,GAAET,CAAA,GAAE,IAAI6+B,IAAA,CAAK,MAAI7+B,CAAA,GAAGU,CAAA,GAAID,CAAA,IAAG,MAAI,KAAGT,CAAA,CAAEg5D,UAAA,IAAat4D,CAAA,GAAID,CAAA,GAAE,KAAG,MAAI,KAAGT,CAAA,CAAEi5D,UAAA,IAAav4D,CAAA,GAAID,CAAA,GAAE,KAAG,MAAI,KAAGT,CAAA,CAAEk5D,QAAA,IAAWx4D,CAAA,GAAID,CAAA,GAAE,MAAI,MAAI,KAAGT,CAAA,CAAE82D,OAAA,IAAUp2D,CAAA,GAAID,CAAA,GAAE,MAAI,MAAI,KAAGT,CAAA,CAAE62D,QAAA,IAAWn2D,CAAA,GAAID,CAAA,GAAE,MAAI,MAAI,KAAGT,CAAA,CAAE42D,WAAA,KAAc,MAAKl2D,CAAA,GAAID,CAAA,GAAE,MAAI,MAAI,KAAGT,CAAA,CAAE+2D,MAAA,IAAS92D,CAAA,IAAGo0D,EAAA,CAAGr0D,CAAA,CAAE42D,WAAA,MAAetC,EAAA,GAAGC,EAAA,EAAIv0D,CAAA,CAAE62D,QAAA,MAAY72D,CAAA,CAAE82D,OAAA,KAAU,IAAE,GAAEp2D,CAAA,GAAID,CAAA,GAAE,MAAI,MAAI,KAAGR,CAAA,EAAES,CAAA,GAAID,CAAA,GAAE,MAAI,MAAI,MAAI,KAAGT,CAAA,CAAEm5D,iBAAA,IAAoBl5D,CAAA,GAAE,IAAI4+B,IAAA,CAAK7+B,CAAA,CAAE42D,WAAA,IAAc,GAAE,GAAGuC,iBAAA;kBAAoB,IAAI34D,CAAA,GAAE,IAAIq+B,IAAA,CAAK7+B,CAAA,CAAE42D,WAAA,IAAc,GAAE,GAAGuC,iBAAA;kBAAoBn5D,CAAA,GAAE,KAAGC,CAAA,IAAGO,CAAA,IAAGR,CAAA,CAAEm5D,iBAAA,MAAqBn3D,IAAA,CAAKC,GAAA,CAAIzB,CAAA,EAAEP,CAAA,IAAIS,CAAA,GAAID,CAAA,GAAE,MAAI,MAAI,KAAGT,CAAC;gBAAA;gBAAEgM,CAAA,EAAE,SAAAA,CAAShM,CAAA;kBAAGA,CAAA,MAAK;kBAAE,IAAIC,CAAA,GAAE,IAAI4+B,IAAA,CAAKn+B,CAAA,GAAIV,CAAA,GAAE,MAAI,MAAI,KAAG,MAAKU,CAAA,GAAIV,CAAA,GAAE,MAAI,MAAI,IAAGU,CAAA,GAAIV,CAAA,GAAE,MAAI,MAAI,IAAGU,CAAA,GAAIV,CAAA,GAAE,KAAG,MAAI,IAAGU,CAAA,GAAIV,CAAA,GAAE,KAAG,MAAI,IAAGU,CAAA,GAAIV,CAAA,IAAG,MAAI,IAAG;oBAAGS,CAAA,GAAEC,CAAA,GAAIV,CAAA,GAAE,MAAI,MAAI;oBAAGQ,CAAA,GAAEP,CAAA,CAAEk5D,iBAAA;oBAAoBl4D,CAAA,GAAE,IAAI49B,IAAA,CAAK5+B,CAAA,CAAE22D,WAAA,IAAc,GAAE,GAAGuC,iBAAA;oBAAoBj4D,CAAA,GAAE,IAAI29B,IAAA,CAAK5+B,CAAA,CAAE22D,WAAA,IAAc,GAAE,GAAGuC,iBAAA;oBAAoB71D,CAAA,GAAEtB,IAAA,CAAKC,GAAA,CAAIf,CAAA,EAAED,CAAA;kBAAG,OAAO,IAAER,CAAA,GAAEC,CAAA,GAAIV,CAAA,GAAE,MAAI,MAAI,KAAG0B,MAAA,CAAOT,CAAA,IAAGC,CAAA,IAAGoC,CAAA,IAAG9C,CAAA,IAAG,IAAEC,CAAA,KAAI6C,CAAA,IAAG9C,CAAA,MAAKS,CAAA,GAAEe,IAAA,CAAKwnB,GAAA,CAAItoB,CAAA,EAAED,CAAA,GAAGhB,CAAA,CAAEm5D,OAAA,CAAQn5D,CAAA,CAAEi3D,OAAA,KAAU,QAAM,IAAEz2D,CAAA,GAAE6C,CAAA,GAAErC,CAAA,IAAGT,CAAA,KAAKE,CAAA,GAAIV,CAAA,GAAE,MAAI,MAAI,KAAGC,CAAA,CAAE82D,MAAA,IAASt2D,CAAA,IAAG4zD,EAAA,CAAGp0D,CAAA,CAAE22D,WAAA,MAAetC,EAAA,GAAGC,EAAA,EAAIt0D,CAAA,CAAE42D,QAAA,MAAY52D,CAAA,CAAE62D,OAAA,KAAU,IAAE,GAAEp2D,CAAA,GAAIV,CAAA,GAAE,MAAI,MAAI,KAAGS,CAAA,EAAEC,CAAA,GAAIV,CAAA,IAAG,MAAI,KAAGC,CAAA,CAAE+4D,UAAA,IAAat4D,CAAA,GAAIV,CAAA,GAAE,KAAG,MAAI,KAAGC,CAAA,CAAEg5D,UAAA,IAAav4D,CAAA,GAAIV,CAAA,GAAE,KAAG,MAAI,KAAGC,CAAA,CAAEi5D,QAAA,IAAWx4D,CAAA,GAAIV,CAAA,GAAE,MAAI,MAAI,KAAGC,CAAA,CAAE62D,OAAA,IAAUp2D,CAAA,GAAIV,CAAA,GAAE,MAAI,MAAI,KAAGC,CAAA,CAAE42D,QAAA,IAAWn2D,CAAA,GAAIV,CAAA,GAAE,MAAI,MAAI,KAAGC,CAAA,CAAEo5D,OAAA,IAAUr5D,CAAA,GAAEC,CAAA,CAAEi3D,OAAA,KAAU,KAAIoC,EAAA,EAAIxM,CAAA,GAAE9sD,CAAA,EAAE,MAAIgC,IAAA,CAAKuV,GAAA,CAAIu1C,CAAA,IAAG,IAAEA,CAAA,IAAG9qD,IAAA,CAAKoX,KAAA,CAAM0zC,CAAA,GAAE,gBAAc,OAAK9qD,IAAA,CAAKE,IAAA,EAAM4qD,CAAA,OAAMA,CAAA,KAAI,MAAI,gBAAc,IAAE,KAAI9sD,CAAA,KAAI,CAAC;gBAAA;gBAAEQ,CAAA,EAAEg0D,EAAA;gBAAGlxD,CAAA,EAAEmxD,EAAA;gBAAGjI,CAAA,EAAE,SAAAA,CAASxsD,CAAA,EAAEC,CAAA,EAAEQ,CAAA;kBAAG,SAASD,EAAER,CAAA;oBAAG,QAAOA,CAAA,GAAEA,CAAA,CAAEu5D,YAAA,GAAeC,KAAA,CAAM,wBAAsBx5D,CAAA,CAAE,KAAG,KAAK;kBAAA;kBAACA,CAAA,MAAK,GAAEC,CAAA,MAAK,GAAEQ,CAAA,MAAK;kBAAE,IAAIS,CAAA,GAAE,IAAK29B,IAAA,GAAM+3B,WAAA;oBAActzD,CAAA,GAAE,IAAIu7B,IAAA,CAAK39B,CAAA,EAAE,GAAE;oBAAGwC,CAAA,GAAE,IAAIm7B,IAAA,CAAK39B,CAAA,EAAE,GAAE;kBAAGA,CAAA,GAAEoC,CAAA,CAAE61D,iBAAA;kBAAoB,IAAI1uD,CAAA,GAAE/G,CAAA,CAAEy1D,iBAAA;oBAAoB9tD,CAAA,GAAErJ,IAAA,CAAKwnB,GAAA,CAAItoB,CAAA,EAAEuJ,CAAA;kBAAGxJ,CAAA,GAAIjB,CAAA,IAAG,MAAI,KAAG,KAAGqL,CAAA,EAAE3K,CAAA,GAAIT,CAAA,IAAG,MAAI,KAAGyB,MAAA,CAAOR,CAAA,IAAGuJ,CAAA,GAAGzK,CAAA,GAAEQ,CAAA,CAAE8C,CAAA,GAAGrD,CAAA,GAAEO,CAAA,CAAEkD,CAAA,GAAG1D,CAAA,GAAE00D,EAAA,CAAG10D,CAAA,GAAGC,CAAA,GAAEy0D,EAAA,CAAGz0D,CAAA,GAAGwK,CAAA,GAAEvJ,CAAA,IAAGD,CAAA,GAAIR,CAAA,IAAG,MAAI,KAAGT,CAAA,EAAEiB,CAAA,GAAIR,CAAA,GAAE,KAAG,MAAI,KAAGR,CAAA,KAAIgB,CAAA,GAAIR,CAAA,IAAG,MAAI,KAAGR,CAAA,EAAEgB,CAAA,GAAIR,CAAA,GAAE,KAAG,MAAI,KAAGT,CAAA,CAAE;gBAAA;gBAAEqL,CAAA,EAAEA,CAAA;kBAAKqgD,EAAA,CAAG,GAAE;gBAAA;gBAAGjhD,CAAA,EAAE,SAAAA,CAAA,GAAW;gBAAExJ,CAAA,EAAE,SAAAA,CAAA;kBAAW,OAAO49B,IAAA,CAAKwB,GAAA,EAAK;gBAAA;gBAAEksB,CAAA,EAAEA,CAAA;kBAAK,MAAMI,CAAA,IAAG,GAAE;gBAAA;gBAAUX,CAAA,EAAE,SAAAA,CAAA;kBAAW,OAAO,UAAU;gBAAA;gBAAEhsD,CAAA,EAAEA,CAAA,KAAI6gC,WAAA,CAAY44B,UAAA,GAAW54B,WAAA,CAAYR,GAAA;gBAAM95B,CAAA,EAAE,SAAAA,CAAA;kBAAW,OAAOwF,CAAA,GAAEtL,CAAA,OAAAoB,IAAA,GAAqBC,MAAA,GAAOF,SAAA,CAAUG,mBAAmB;gBAAA;gBAAEgrD,CAAA,EAAE,SAAAA,CAAS/sD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA;kBAAG,KAAI0tD,EAAA,CAAGwL,EAAA,GAAGz5D,CAAA,KAAI,GAAEi1D,EAAA,CAAGpzD,MAAA,GAAOrB,CAAA,EAAER,CAAA,GAAEO,CAAA,KAAI,KAAG,GAAEA,CAAA,GAAE,GAAEA,CAAA,GAAEC,CAAA,EAAED,CAAA,IAAI00D,EAAA,CAAG10D,CAAA,IAAGU,CAAA,GAAIjB,CAAA,GAAEO,CAAA,KAAI;kBAAG,OAAO23D,EAAA,CAAGn4D,CAAA,EAAG25D,KAAA,CAAM,MAAKzE,EAAA,CAAG;gBAAA;gBAAEnpD,CAAA,EAAE,SAAAA,CAAS/L,CAAA;kBAAGA,CAAA,MAAK;kBAAE,IAAIC,CAAA,GAAEO,CAAA,GAAIsB,MAAA;kBAAO,IAAG9B,CAAA,IAAGC,CAAA,IAAG,aAAWD,CAAA,EAAE,QAAM;kBAAG,KAAI,IAAIS,CAAA,GAAE,GAAE,KAAGA,CAAA,EAAEA,CAAA,IAAG,GAAE;oBAAC,IAAIC,CAAA,GAAET,CAAA,IAAG,IAAE,KAAGQ,CAAA;oBAAGC,CAAA,GAAEsB,IAAA,CAAKC,GAAA,CAAIvB,CAAA,EAAEV,CAAA,GAAE;oBAAW,IAAIiB,CAAA,GAAEe,IAAA;oBAAKtB,CAAA,GAAEsB,IAAA,CAAKwnB,GAAA,CAAIxpB,CAAA,EAAEU,CAAA;oBAAGV,CAAA,EAAE;sBAACiB,CAAA,GAAEA,CAAA,CAAEgB,GAAA,CAAImjB,IAAA,CAAKnkB,CAAA,EAAE,YAAWP,CAAA,IAAG,QAAMA,CAAA,GAAE,SAAO,SAAOuW,CAAA,CAAE2X,MAAA,CAAOE,UAAA,GAAW,UAAQ;sBAAG;wBAAI7X,CAAA,CAAE2iD,IAAA,CAAK34D,CAAA,GAAGwoD,CAAA;wBAAI,IAAIvoD,CAAA,GAAE;wBAAE,MAAMlB,CAAC;sBAAA,CAAC,QAAMA,CAAA,GAAG;sBAACkB,CAAA,QAAE,CAAM;oBAAA;oBAAC,IAAGA,CAAA,EAAE,QAAM,CAAE;kBAAA;kBAAC,QAAM,CAAE;gBAAA;gBAAEyV,CAAA,EAAEi/C,EAAA;gBAAG9+C,CAAA,EAAE++C,EAAA;gBAAGjM,CAAA,EAAEuF,EAAA;gBAAG3oD,CAAA,EAAEsvD,EAAA;gBAAGr1D,CAAA,EAAEs1D,EAAA;gBAAG5pD,CAAA,EAAE6pD,EAAA;gBAAGnqD,CAAA,EAAEqqD,EAAA;gBAAGx/C,CAAA,EAAE,SAAAA,CAAS1W,CAAA,EAAEC,CAAA;kBAAG,OAAOD,CAAA,MAAK,GAAEC,CAAA,MAAK,GAAEk2D,EAAA,CAAG31D,CAAA,GAAIqU,QAAA,CAAS7U,CAAA,KAAI,GAAEA,CAAA,GAAEC,CAAA,KAAI,KAAI,CAAC;gBAAA;gBAAEiB,CAAA,EAAE+V,CAAA,IAAGxM,CAAA,CAAEyhD,UAAA;gBAAWQ,CAAA,EAAEiK,EAAA;gBAAGprD,CAAA,EAAE,SAAAA,CAASvL,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA;kBAAG,OAAOm2D,EAAA,CAAG32D,CAAA,KAAI,GAAEC,CAAA,KAAI,GAAEQ,CAAA,KAAI,GAAED,CAAA,KAAI,EAAE;gBAAA;cAAA;YAAA,CAAI;cAAW,SAASR,EAAEA,CAAA,EAAEC,CAAA;gBAAG,OAAOD,CAAA,GAAEA,CAAA,CAAEE,OAAA,EAAQgX,CAAA,GAAElX,CAAA,GAAE,UAASA,CAAA;kBAAG,IAAIC,CAAA,GAAED,CAAA,IAAG,MAAIA,CAAA,OAAM;oBAAES,CAAA,GAAET,CAAA,IAAGC,CAAA,IAAGD,CAAA,CAAEC,CAAA,MAAK;kBAAE,QAAOD,CAAA,GAAE6C,MAAA,CAAOC,MAAA,CAAO,CAAC,GAAE9C,CAAA,GAAI65D,gBAAA,GAAiB55D,CAAA,CAAED,CAAA,CAAE65D,gBAAA,GAAkB75D,CAAA,CAAE85D,YAAA,GAAa75D,CAAA,CAAED,CAAA,CAAE85D,YAAA,GAAc95D,CAAA,CAAE+5D,MAAA,GAAOt5D,CAAA,CAAET,CAAA,CAAE+5D,MAAA,GAAQ/5D,CAAA,CAAE0hD,SAAA,GAAUzhD,CAAA,CAAED,CAAA,CAAE0hD,SAAA,GAAW1hD,CAAA,CAAE2hD,UAAA,GAAWlhD,CAAA,CAAET,CAAA,CAAE2hD,UAAA,GAAY3hD,CAAC;gBAAA,CAAtO,CAAwOA,CAAA,GAAGkuD,EAAA,CAAG0B,EAAA,CAAG5oD,IAAA,CAAKkQ,CAAA,CAAE8iD,EAAA,GAAIzN,CAAA,GAAEr1C,CAAA,CAAE+iD,EAAA,EAAGxN,CAAA,CAAE3Q,OAAA,CAAQ5kC,CAAA,CAAEy1C,CAAA,GAAGx1C,CAAA,GAAElX,CAAA,EAAEktD,EAAA,IAAIntD,CAAC;cAAA;cAAC,IAAIC,CAAA,GAAE;gBAACiB,CAAA,EAAEk3D;cAAA;cAAI,IAAGnL,CAAA,IAAIxiD,CAAA,CAAEyvD,eAAA,EAAgB;gBAAI,OAAOzvD,CAAA,CAAEyvD,eAAA,CAAgBj6D,CAAA,EAAED,CAAA,CAAE;cAAA,CAAC,QAAMA,CAAA;gBAAG+W,CAAA,CAAE,wDAAsD/W,CAAA,GAAG0D,CAAA,CAAE1D,CAAA,CAAE;cAAA;cAAA,CAAC,UAAUA,CAAA,EAAEC,CAAA;gBAAG,IAAIQ,CAAA,GAAEosD,CAAA;gBAAE,OAAOh2C,CAAA,IAAG,qBAAmBisC,WAAA,CAAYqX,oBAAA,IAAsB5M,EAAA,CAAG9sD,CAAA,KAAIA,CAAA,CAAEwpD,UAAA,CAAW,cAAYl+C,CAAA,IAAG,qBAAmBgtC,KAAA,GAAM0U,EAAA,CAAGhtD,CAAA,EAAET,CAAA,EAAEC,CAAA,IAAG84C,KAAA,CAAMt4C,CAAA,EAAE;kBAACitD,WAAA,EAAY;gBAAA,GAAgBjtB,IAAA,CAAMjgC,CAAA,IAAGsiD,WAAA,CAAYqX,oBAAA,CAAqB35D,CAAA,EAAER,CAAA,EAAGygC,IAAA,CAAKxgC,CAAA,EAAE,UAAUO,CAAA;kBAAG,OAAOuW,CAAA,CAAE,oCAAkCvW,CAAA,GAAGuW,CAAA,CAAE,8CAA6C02C,EAAA,CAAGhtD,CAAA,EAAET,CAAA,EAAEC,CAAA,CAAG;gBAAA,GAAK;cAAA,GAAEA,CAAA,EAAE,UAAUA,CAAA;gBAAGD,CAAA,CAAEC,CAAA,CAAEm6D,QAAA,EAASn6D,CAAA,CAAEE,MAAA,CAAQ;cAAA,GAAGytD,KAAA,CAAMlqD,CAAA,CAAE;YAAA,CAAl4B,IAAs4B+G,CAAA,CAAE62C,QAAA,GAAS,CAACthD,CAAA,EAAEC,CAAA,MAAKwK,CAAA,CAAE62C,QAAA,GAASpqC,CAAA,CAAE21C,CAAA,EAAG7sD,CAAA,EAAEC,CAAA,GAAGwK,CAAA,CAAEk5C,gBAAA,GAAiB,CAAC3jD,CAAA,EAAEC,CAAA,MAAKwK,CAAA,CAAEk5C,gBAAA,GAAiBzsC,CAAA,CAAE41C,CAAA,EAAG9sD,CAAA,EAAEC,CAAA,GAAGwK,CAAA,CAAEg2C,wBAAA,GAAyB,CAACzgD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAEE,CAAA,EAAEO,CAAA,EAAEC,CAAA,EAAEoC,CAAA,EAAEI,CAAA,EAAE2H,CAAA,MAAKZ,CAAA,CAAEg2C,wBAAA,GAAyBvpC,CAAA,CAAE8mC,CAAA,EAAGh+C,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAEE,CAAA,EAAEO,CAAA,EAAEC,CAAA,EAAEoC,CAAA,EAAEI,CAAA,EAAE2H,CAAA,GAAGZ,CAAA,CAAEs2C,2BAAA,GAA4B,CAAC/gD,CAAA,EAAEC,CAAA,MAAKwK,CAAA,CAAEs2C,2BAAA,GAA4B7pC,CAAA,CAAEjL,CAAA,EAAGjM,CAAA,EAAEC,CAAA,GAAGwK,CAAA,CAAEo2C,yBAAA,GAA0B,CAAC7gD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,MAAKgK,CAAA,CAAEo2C,yBAAA,GAA0B3pC,CAAA,CAAEA,CAAA,EAAGlX,CAAA,EAAEC,CAAA,EAAEQ,CAAA,GAAGgK,CAAA,CAAEu2C,yBAAA,GAA0BhhD,CAAA,KAAIyK,CAAA,CAAEu2C,yBAAA,GAA0B9pC,CAAA,CAAEmjD,EAAA,EAAIr6D,CAAA,GAAGyK,CAAA,CAAEg3C,iBAAA,GAAkB,CAACzhD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,MAAKgK,CAAA,CAAEg3C,iBAAA,GAAkBvqC,CAAA,CAAEojD,EAAA,EAAIt6D,CAAA,EAAEC,CAAA,EAAEQ,CAAA,GAAGgK,CAAA,CAAE03C,kBAAA,GAAmBniD,CAAA,KAAIyK,CAAA,CAAE03C,kBAAA,GAAmBjrC,CAAA,CAAEqjD,EAAA,EAAIv6D,CAAA,GAAGyK,CAAA,CAAEm3C,uBAAA,GAAwB,CAAC5hD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,MAAKgK,CAAA,CAAEm3C,uBAAA,GAAwB1qC,CAAA,CAAEsjD,EAAA,EAAIx6D,CAAA,EAAEC,CAAA,EAAEQ,CAAA,GAAGgK,CAAA,CAAEs3C,gBAAA,GAAiB,CAAC/hD,CAAA,EAAEC,CAAA,MAAKwK,CAAA,CAAEs3C,gBAAA,GAAiB7qC,CAAA,CAAEujD,EAAA,EAAIz6D,CAAA,EAAEC,CAAA,GAAGwK,CAAA,CAAEw3C,iBAAA,GAAkB,CAACjiD,CAAA,EAAEC,CAAA,MAAKwK,CAAA,CAAEw3C,iBAAA,GAAkB/qC,CAAA,CAAEwjD,EAAA,EAAI16D,CAAA,EAAEC,CAAA,GAAGwK,CAAA,CAAEy3C,QAAA,GAASliD,CAAA,KAAIyK,CAAA,CAAEy3C,QAAA,GAAShrC,CAAA,CAAEyjD,EAAA,EAAI36D,CAAA,GAAGyK,CAAA,CAAE43C,gBAAA,GAAiB,CAACriD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAEE,CAAA,MAAK+J,CAAA,CAAE43C,gBAAA,GAAiBnrC,CAAA,CAAE0jD,EAAA,EAAI56D,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAEE,CAAA,GAAG+J,CAAA,CAAE+3C,iBAAA,GAAkB,CAACxiD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAEE,CAAA,MAAK+J,CAAA,CAAE+3C,iBAAA,GAAkBtrC,CAAA,CAAE2jD,EAAA,EAAI76D,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAEE,CAAA,GAAG+J,CAAA,CAAEg4C,iBAAA,GAAkBziD,CAAA,KAAIyK,CAAA,CAAEg4C,iBAAA,GAAkBvrC,CAAA,CAAE4jD,EAAA,EAAI96D,CAAA,GAAGyK,CAAA,CAAE80C,oBAAA,GAAqB,CAACv/C,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,MAAKiK,CAAA,CAAE80C,oBAAA,GAAqBroC,CAAA,CAAE6jD,EAAA,EAAI/6D,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,GAAGiK,CAAA,CAAEm1C,qBAAA,GAAsB,CAAC5/C,CAAA,EAAEC,CAAA,EAAEQ,CAAA,MAAKgK,CAAA,CAAEm1C,qBAAA,GAAsB1oC,CAAA,CAAE8jD,EAAA,EAAIh7D,CAAA,EAAEC,CAAA,EAAEQ,CAAA,GAAGgK,CAAA,CAAEo1C,qBAAA,GAAsB7/C,CAAA,KAAIyK,CAAA,CAAEo1C,qBAAA,GAAsB3oC,CAAA,CAAE+jD,EAAA,EAAIj7D,CAAA,GAAGyK,CAAA,CAAE63C,OAAA,GAAQ,CAACtiD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAEE,CAAA,EAAEO,CAAA,EAAEC,CAAA,EAAEoC,CAAA,MAAKmH,CAAA,CAAE63C,OAAA,GAAQprC,CAAA,CAAEgkD,EAAA,EAAIl7D,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAEE,CAAA,EAAEO,CAAA,EAAEC,CAAA,EAAEoC,CAAA,GAAGmH,CAAA,CAAEi4C,gBAAA,GAAiB1iD,CAAA,KAAIyK,CAAA,CAAEi4C,gBAAA,GAAiBxrC,CAAA,CAAEikD,EAAA,EAAIn7D,CAAA;YAAG,IAAI0wD,EAAA,GAAGjmD,CAAA,CAAE2wD,aAAA,GAAc,OAAK1K,EAAA,GAAGjmD,CAAA,CAAE2wD,aAAA,GAAclkD,CAAA,CAAEmkD,EAAA;cAAM1G,EAAA,GAAGlqD,CAAA,CAAE82C,OAAA,GAAQvhD,CAAA,KAAI20D,EAAA,GAAGlqD,CAAA,CAAE82C,OAAA,GAAQrqC,CAAA,CAAEokD,EAAA,EAAIt7D,CAAA;YAAGyK,CAAA,CAAEq1C,KAAA,GAAM9/C,CAAA,KAAIyK,CAAA,CAAEq1C,KAAA,GAAM5oC,CAAA,CAAEqkD,EAAA,EAAIv7D,CAAA,GAAGyK,CAAA,CAAE+wD,qBAAA,GAAsB,OAAK/wD,CAAA,CAAE+wD,qBAAA,GAAsBtkD,CAAA,CAAE8iD,EAAA;YAAM,IAAI3B,EAAA,GAAG5tD,CAAA,CAAEgxD,wBAAA,GAAyB,CAACz7D,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAEE,CAAA,EAAEO,CAAA,MAAKo3D,EAAA,GAAG5tD,CAAA,CAAEgxD,wBAAA,GAAyBvkD,CAAA,CAAEwkD,EAAA,EAAI17D,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAEE,CAAA,EAAEO,CAAA;YAAGwJ,CAAA,CAAEkxD,2BAAA,GAA4B,OAAKlxD,CAAA,CAAEkxD,2BAAA,GAA4BzkD,CAAA,CAAE0kD,EAAA;YAAM,IAAIC,EAAA;cAAG7G,EAAA,GAAGoD,CAACp4D,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,MAAKw0D,EAAA,GAAG99C,CAAA,CAAE4kD,EAAA,EAAI97D,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA;cAAG+vD,EAAA,GAAGvwD,CAAA,KAAIuwD,EAAA,GAAGr5C,CAAA,CAAE6kD,EAAA,EAAI/7D,CAAA;cAAG6yD,EAAA,GAAGpoD,CAAA,CAAEuxD,wBAAA,GAAyBh8D,CAAA,KAAI6yD,EAAA,GAAGpoD,CAAA,CAAEuxD,wBAAA,GAAyB9kD,CAAA,CAAE+kD,EAAA,EAAIj8D,CAAA;cAAGk0D,EAAA,GAAGzpD,CAAA,CAAEyxD,0BAAA,GAA2B,OAAKhI,EAAA,GAAGzpD,CAAA,CAAEyxD,0BAAA,GAA2BhlD,CAAA,CAAEilD,EAAA;cAAM7C,EAAA,GAAGt5D,CAAA,KAAIs5D,EAAA,GAAGpiD,CAAA,CAAEklD,EAAA,EAAIp8D,CAAA;cAAG+xD,EAAA,GAAGuH,CAACt5D,CAAA,EAAEC,CAAA,MAAK8xD,EAAA,GAAG76C,CAAA,CAAEmlD,EAAA,EAAIr8D,CAAA,EAAEC,CAAA;cAAG40D,EAAA,GAAG9C,CAAA,MAAK8C,EAAA,GAAG39C,CAAA,CAAEolD,EAAA;cAAMtK,EAAA,GAAGhyD,CAAA,KAAIgyD,EAAA,GAAG96C,CAAA,CAAEqlD,EAAA,EAAIv8D,CAAA;cAAG+0D,EAAA,GAAG/0D,CAAA,KAAI+0D,EAAA,GAAG79C,CAAA,CAAEslD,EAAA,EAAIx8D,CAAA;YAAG,SAASy8D,GAAA;cAAK,SAASz8D,EAAA;gBAAI,KAAI67D,EAAA,KAAKA,EAAA,IAAG,GAAGpxD,CAAA,CAAEiyD,SAAA,IAAU,IAAIvR,CAAA,MAAKn/C,CAAA,IAAG6lD,EAAA,CAAGpF,CAAA,GAAGnpD,CAAA,CAAEmH,CAAA,GAAGA,CAAA,CAAEkyD,oBAAA,IAAsBlyD,CAAA,CAAEkyD,oBAAA,KAAwB3wD,CAAA,GAAG;kBAAC,IAAGvB,CAAA,CAAEmyD,OAAA,EAAQ,KAAI,qBAAmBnyD,CAAA,CAAEmyD,OAAA,KAAUnyD,CAAA,CAAEmyD,OAAA,GAAQ,CAACnyD,CAAA,CAAEmyD,OAAA,IAAUnyD,CAAA,CAAEmyD,OAAA,CAAQ96D,MAAA,GAAQ;oBAAC,IAAI9B,CAAA,GAAEyK,CAAA,CAAEmyD,OAAA,CAAQpf,KAAA;oBAAQkP,CAAA,CAAE5Q,OAAA,CAAQ97C,CAAA,CAAE;kBAAA;kBAAC6xD,EAAA,CAAGnF,CAAA,CAAE;gBAAA;cAAC;cAAC,MAAK,IAAEK,CAAA,GAAG,IAAG/gD,CAAA,EAAE1I,CAAA,CAAEmH,CAAA,GAAGuB,CAAA,IAAG6lD,EAAA,CAAGpF,CAAA,GAAGoQ,WAAA,CAAYpyD,CAAA,OAAO;gBAAC,IAAGA,CAAA,CAAEqyD,MAAA,EAAO,KAAI,qBAAmBryD,CAAA,CAAEqyD,MAAA,KAASryD,CAAA,CAAEqyD,MAAA,GAAO,CAACryD,CAAA,CAAEqyD,MAAA,IAASryD,CAAA,CAAEqyD,MAAA,CAAOh7D,MAAA,GAAQ0qD,CAAA,CAAE1Q,OAAA,CAAQrxC,CAAA,CAAEqyD,MAAA,CAAOtf,KAAA;gBAASqU,EAAA,CAAGrF,CAAA,GAAG,IAAEO,CAAA,KAAItiD,CAAA,CAAEsyD,SAAA,IAAWtyD,CAAA,CAAEsyD,SAAA,CAAU,eAAc7rC,UAAA,CAAW;kBAAYA,UAAA,CAAW;oBAAYzmB,CAAA,CAAEsyD,SAAA,CAAU,GAAI;kBAAA,GAAE,IAAG/8D,CAAA,EAAI;gBAAA,GAAE,MAAIA,CAAA,GAAI;cAAA;YAAC;YAAC,IAAGyK,CAAA,CAAEuyD,gBAAA,GAAiBpQ,CAAA,EAAEniD,CAAA,CAAEyhD,UAAA,GAAWj1C,CAAA,EAAExM,CAAA,CAAEk3C,UAAA,GAAWoT,EAAA,EAAGtqD,CAAA,CAAEi3C,SAAA,GAAUmT,EAAA,EAAGpqD,CAAA,CAAEq3C,YAAA,GAAakQ,EAAA,EAAGvnD,CAAA,CAAEu3C,YAAA,GAAaqN,EAAA,EAAG5kD,CAAA,CAAEi5C,YAAA,GAAauP,EAAA,EAAGxoD,CAAA,CAAEg5C,eAAA,GAAgBqP,EAAA,EAAGroD,CAAA,CAAEwyD,UAAA,GAAWnP,EAAA,EAAGrjD,CAAA,CAAE84C,OAAA,GAAQ2K,EAAA,EAAGlQ,CAAA,GAAE,SAASh+C,EAAA;cAAI67D,EAAA,IAAIY,EAAA,IAAKZ,EAAA,KAAK7d,CAAA,GAAEh+C,CAAA,CAAE;YAAA,GAAEyK,CAAA,CAAEyyD,OAAA,EAAQ,KAAI,qBAAmBzyD,CAAA,CAAEyyD,OAAA,KAAUzyD,CAAA,CAAEyyD,OAAA,GAAQ,CAACzyD,CAAA,CAAEyyD,OAAA,IAAU,IAAEzyD,CAAA,CAAEyyD,OAAA,CAAQp7D,MAAA,GAAQ2I,CAAA,CAAEyyD,OAAA,CAAQ/sC,GAAA,EAAV;YAAkB,OAAOssC,EAAA,IAAKz8D,CAAA,CAAE6pD,KAAK;UAAA;QAAqD7pD,CAAA,CAAOE,OAAA,GAAQM,C;;;QCC3ptB,IACM+oD,UAAA;UADF/oD,CAAA,IACE+oD,UAAA,GAAiC,sBAAbx3B,QAAA,IAA4BA,QAAA,CAAS2rB,aAAA,GAAgB3rB,QAAA,CAAS2rB,aAAA,CAAcC,GAAA,QAAM,GAChF,sBAAf6L,UAAA,KAA4BD,UAAA,GAAaA,UAAA,IAAcC,UAAA,GAC3D,UACAxpD,CAAA,GAAY,CAAC;YAEtB,IAAgBC,CAAA;cAAGO,CAAA;cAAfE,CAAA,GAAEV,CAAA;YAAeU,CAAA,CAAEmpD,KAAA,GAAM,IAAIvnD,OAAA,CAAQ,CAACtC,CAAA,EAAES,CAAA;cAAKR,CAAA,GAAGD,CAAA,EAAEQ,CAAA,GAAEC,CAAA;YAAA;YAAI,IAA2OQ,CAAA;cAAEC,CAAA;cAAEoC,CAAA;cAA3OI,CAAA,GAAGb,MAAA,CAAOC,MAAA,CAAO,CAAC,GAAEpC,CAAA;cAAG+J,CAAA,GAAE;cAAiBY,CAAA,GAAEuhD,CAAC5sD,CAAA,EAAEC,CAAA;gBAAK,MAAMA,CAAC;cAAA;cAAGqL,CAAA,GAAG,mBAAiBs4C,MAAA;cAAOr4C,CAAA,GAAE,qBAAmBu+C,aAAA;cAAcvjD,CAAA,GAAE,mBAAiBqyC,OAAA,IAAS,mBAAiBA,OAAA,CAAQn2C,QAAA,IAAU,mBAAiBm2C,OAAA,CAAQn2C,QAAA,CAAS03B,IAAA;cAAKzuB,CAAA,GAAE;YACpS,IAAGnF,CAAA,EAAE;cAAC,IAAIC,CAAA,GAAG/F,CAAA,CAAQ;gBAAMmL,CAAA,GAAEnL,CAAA,CAAQ;cAAQiL,CAAA,GAAEH,CAAA,GAAEK,CAAA,CAAEo+C,OAAA,CAAQt+C,CAAA,IAAG,MAAI23C,SAAA,GAAU,KAAIpiD,CAAA,GAAE4V,CAAC7W,CAAA,EAAEC,CAAA,MAAKD,CAAA,GAAEA,CAAA,CAAEiqD,UAAA,CAAW,aAAW,IAAI/G,GAAA,CAAIljD,CAAA,IAAG4L,CAAA,CAAEs+C,SAAA,CAAUlqD,CAAA,GAAUwG,CAAA,CAAG2jD,YAAA,CAAanqD,CAAA,EAAEC,CAAA,QAAE,IAAO,UAASqD,CAAA,GAAEtD,CAAA,MAAIA,CAAA,GAAEiB,CAAA,CAAEjB,CAAA,GAAE,IAAM4uB,MAAA,KAAS5uB,CAAA,GAAE,IAAIyP,UAAA,CAAWzP,CAAA,IAAWA,CAAA,GAAGkB,CAAA,GAAE8qD,CAAChsD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,IAAE;gBAAMR,CAAA,GAAEA,CAAA,CAAEiqD,UAAA,CAAW,aAAW,IAAI/G,GAAA,CAAIljD,CAAA,IAAG4L,CAAA,CAAEs+C,SAAA,CAAUlqD,CAAA,GAAGwG,CAAA,CAAGsyC,QAAA,CAAS94C,CAAA,EAAEQ,CAAA,QAAE,IAAO,QAAO,CAACR,CAAA,EAAEU,CAAA;kBAAKV,CAAA,GAAES,CAAA,CAAET,CAAA,IAAGC,CAAA,CAAEO,CAAA,GAAEE,CAAA,CAAEkuB,MAAA,GAAOluB,CAAA,CAAC;gBAAA,EAAE;cAAA,IAAIA,CAAA,CAAE0pD,WAAA,IAAa,IAAExR,OAAA,CAAQyR,IAAA,CAAKvoD,MAAA,KAAS2I,CAAA,GAAEmuC,OAAA,CAAQyR,IAAA,CAAK,GAAGh6C,OAAA,CAAQ,OAAM,OAAMuoC,OAAA,CAAQyR,IAAA,CAAKn9C,KAAA,CAAM,IAAG7B,CAAA,GAAEuhD,CAAC5sD,CAAA,EAAEC,CAAA;gBAC/d,MADoe24C,OAAA,CAAQ0R,QAAA,GAC9etqD,CAAA,EAAQC,CAAC;cAAA,GAAGS,CAAA,CAAE6pD,OAAA,GAAQ,MAAI,4BAA4B;YAAA,QAASj/C,CAAA,IAAIC,CAAA,MAAEA,CAAA,GAAEG,CAAA,GAAEnL,IAAA,CAAK+rB,QAAA,CAASo+B,IAAA,GAAK,sBAAoB34B,QAAA,IAAUA,QAAA,CAAS2rB,aAAA,KAAgBhyC,CAAA,GAAEqmB,QAAA,CAAS2rB,aAAA,CAAcC,GAAA,GAAK4L,UAAA,KAAa79C,CAAA,GAAE69C,UAAA,GAAmC79C,CAAA,GAAvB,MAAIA,CAAA,CAAEU,OAAA,CAAQ,WAAWV,CAAA,CAAEmyC,MAAA,CAAO,GAAEnyC,CAAA,CAAE2E,OAAA,CAAQ,UAAS,IAAIytC,WAAA,CAAY,OAAK,KAAK,IAAG78C,CAAA,GAAEjB,CAAA;cAAI,IAAIC,CAAA,GAAE,IAAI0qD,cAAA;cAA+C,OAAhC1qD,CAAA,CAAE2qD,IAAA,CAAK,OAAM5qD,CAAA,GAAE,IAAIC,CAAA,CAAE4qD,IAAA,CAAK,OAAa5qD,CAAA,CAAE6qD,YAAA;YAAA,GAAcv/C,CAAA,KAAIjI,CAAA,GAAEtD,CAAA;cAAI,IAAIC,CAAA,GAAE,IAAI0qD,cAAA;cAA4E,OAA7D1qD,CAAA,CAAE2qD,IAAA,CAAK,OAAM5qD,CAAA,GAAE,IAAIC,CAAA,CAAE8qD,YAAA,GAAa,eAAc9qD,CAAA,CAAE4qD,IAAA,CAAK,OAAa,IAAIp7C,UAAA,CAAWxP,CAAA,CAAE+qD,QAAA,CAAQ;YAAA,IACtf9pD,CAAA,GAAE8qD,CAAChsD,CAAA,EAAEC,CAAA,EAAEQ,CAAA;cAAK,IAAID,CAAA,GAAE,IAAImqD,cAAA;cAAenqD,CAAA,CAAEoqD,IAAA,CAAK,OAAM5qD,CAAA,GAAE,IAAIQ,CAAA,CAAEuqD,YAAA,GAAa,eAAcvqD,CAAA,CAAEyqD,MAAA,GAAO;gBAAK,OAAKzqD,CAAA,CAAEu/C,MAAA,IAAQ,KAAGv/C,CAAA,CAAEu/C,MAAA,IAAQv/C,CAAA,CAAEwqD,QAAA,GAAS/qD,CAAA,CAAEO,CAAA,CAAEwqD,QAAA,IAAUvqD,CAAA,EAAE;cAAA,GAAGD,CAAA,CAAE0qD,OAAA,GAAQzqD,CAAA,EAAED,CAAA,CAAEqqD,IAAA,CAAK,KAAI;YAAA;YAAG,IAAwKh/C,CAAA;cAApKE,CAAA,GAAGrL,CAAA,CAAE2qD,KAAA,IAAO/sB,OAAA,CAAQ/jB,GAAA,CAAIqkB,IAAA,CAAKN,OAAA;cAAStyB,CAAA,GAAEtL,CAAA,CAAE4qD,QAAA,IAAUhtB,OAAA,CAAQjT,KAAA,CAAMuT,IAAA,CAAKN,OAAA;YAASz7B,MAAA,CAAOC,MAAA,CAAOpC,CAAA,EAAEgD,CAAA,GAAIA,CAAA,GAAG,MAAKhD,CAAA,CAAE0pD,WAAA,KAAc3/C,CAAA,GAAE/J,CAAA,CAAE0pD,WAAA,GAAa1pD,CAAA,CAAE6qD,IAAA,KAAOlgD,CAAA,GAAE3K,CAAA,CAAE6qD,IAAA,GAAY7qD,CAAA,CAAE8qD,UAAA,KAAa3/C,CAAA,GAAEnL,CAAA,CAAE8qD,UAAA;YAAY,IAAIv/C,CAAA,GAAcvL,CAAA,CAAE+qD,aAAA,KAAe;YAAG,mBAAiB3I,WAAA,IAAa8G,CAAA,CAAE;YACtc,IAAIz9C,CAAA;cAAEE,CAAA;cAAOqK,CAAA;cAAEC,CAAA;cAAEC,CAAA;cAAEC,CAAA;cAAXC,CAAA,IAAE;YAAW,SAASC,EAAA;cAAK,IAAI/W,CAAA,GAAEmM,CAAA,CAAEyiB,MAAA;cAAOluB,CAAA,CAAEirD,KAAA,GAAMj1C,CAAA,GAAE,IAAIka,SAAA,CAAU5wB,CAAA,GAAGU,CAAA,CAAEkrD,MAAA,GAAO,IAAIj7B,UAAA,CAAW3wB,CAAA,GAAGU,CAAA,CAAEmhD,MAAA,GAAOjrC,CAAA,GAAE,IAAI+P,UAAA,CAAW3mB,CAAA,GAAGU,CAAA,CAAE8gD,MAAA,GAAO7qC,CAAA,GAAE,IAAIlH,UAAA,CAAWzP,CAAA,GAAGU,CAAA,CAAEmrD,OAAA,GAAQ,IAAIh7B,WAAA,CAAY7wB,CAAA,GAAGU,CAAA,CAAE0hD,OAAA,GAAQvrC,CAAA,GAAE,IAAIrH,WAAA,CAAYxP,CAAA,GAAGU,CAAA,CAAEorD,OAAA,GAAQ,IAAIl3C,YAAA,CAAa5U,CAAA,GAAGU,CAAA,CAAEqrD,OAAA,GAAQ,IAAIj7B,YAAA,CAAa9wB,CAAA,CAAE;YAAA;YAAC,IAAIgX,CAAA,GAAG;cAAGC,CAAA,GAAG;cAAGC,CAAA,GAAG;YAAG,SAASC,EAAA;cAAK,IAAInX,CAAA,GAAEU,CAAA,CAAEo8D,MAAA,CAAOtf,KAAA;cAAQxmC,CAAA,CAAG8kC,OAAA,CAAQ97C,CAAA,CAAE;YAAA;YAAC,IACnHoX,CAAA;cAEkIC,CAAA;cAHX1W,CAAA,GAAE;cAAE+oD,CAAA,GAAE;cAAKC,CAAA,GAAE;YACpX,SAASC,EAAE5pD,CAAA;cAA4I,MAAtIU,CAAA,CAAE2sD,OAAA,IAAQ3sD,CAAA,CAAE2sD,OAAA,CAAQrtD,CAAA,GAAsBgM,CAAA,CAAnBhM,CAAA,GAAE,aAAWA,CAAA,GAAE,MAAS8W,CAAA,IAAE,GAAG9W,CAAA,GAAE,IAAI8iD,WAAA,CAAYwK,YAAA,CAAattD,CAAA,GAAE,6CAA4CQ,CAAA,CAAER,CAAA,GAASA,CAAE;YAAA;YAAC,SAASmrD,EAAGnrD,CAAA;cAAG,OAAOA,CAAA,CAAEiqD,UAAA,CAAW,wCAAwC;YAAA;YAAyB,KAAIkB,CAAA,CAAtB/zC,CAAA,GAAE,kBAA0B;cAAC,IAAIqyC,CAAA,GAAGryC,CAAA;cAAEA,CAAA,GAAE1W,CAAA,CAAEsiD,UAAA,GAAWtiD,CAAA,CAAEsiD,UAAA,CAAWyG,CAAA,EAAG/9C,CAAA,IAAGA,CAAA,GAAE+9C,CAAE;YAAA;YAAC,SAASuC,EAAGhsD,CAAA;cAAG,IAAGA,CAAA,IAAGoX,CAAA,IAAGvL,CAAA,EAAE,OAAO,IAAI4D,UAAA,CAAW5D,CAAA;cAAG,IAAGvI,CAAA,EAAE,OAAOA,CAAA,CAAEtD,CAAA;cAAG,MAAK,iDAAkD;YAAA;YACjG,SAASusD,EAAGvsD,CAAA,EAAEC,CAAA,EAAEQ,CAAA;cAAG,OAA5W,UAAYT,CAAA;gBAAG,KAAI6L,CAAA,KAAIP,CAAA,IAAIC,CAAA,GAAG;kBAAC,IAAG,qBAAmBwtC,KAAA,KAAQ/4C,CAAA,CAAEiqD,UAAA,CAAW,YAAW,OAAOlR,KAAA,CAAM/4C,CAAA,EAAE;oBAAC0tD,WAAA,EAAY;kBAAA,GAAgBjtB,IAAA,CAAKxgC,CAAA;oBAAI,KAAIA,CAAA,CAAE0tD,EAAA,EAAG,MAAK,yCAAuC3tD,CAAA,GAAE;oBAAI,OAAOC,CAAA,CAAE+4C,WAAA,EAAY;kBAAA,GAAI4U,KAAA,CAAM,MAAI5B,CAAA,CAAGhsD,CAAA;kBAAI,IAAGkB,CAAA,EAAE,OAAO,IAAIoB,OAAA,CAAQ,CAACrC,CAAA,EAAEQ,CAAA;oBAAKS,CAAA,CAAElB,CAAA,EAAEA,CAAA,IAAGC,CAAA,CAAE,IAAIwP,UAAA,CAAWzP,CAAA,IAAIS,CAAA,CAAC;kBAAA,EAAG;gBAAA;gBAAC,OAAO6B,OAAA,CAAQC,OAAA,GAAUk+B,IAAA,CAAK,MAAIurB,CAAA,CAAGhsD,CAAA,EAAG;cAAA,CAA2B,CAAGA,CAAA,EAAGygC,IAAA,CAAKzgC,CAAA,IAAG8iD,WAAA,CAAY+K,WAAA,CAAY7tD,CAAA,EAAEC,CAAA,GAAIwgC,IAAA,CAAKzgC,CAAA,IAAGA,CAAA,EAAGygC,IAAA,CAAKhgC,CAAA,EAAET,CAAA;gBAAIgM,CAAA,CAAE,4CAA0ChM,CAAA,GAAG4pD,CAAA,CAAE5pD,CAAA,CAAC;cAAA,EAAG;YAAA;YACtH,SAASwsD,EAAGxsD,CAAA;cAAG,KAAKgE,IAAA,GAAK,cAAa,KAAK+pD,OAAA,GAAQ,gCAAgC/tD,CAAA,KAAK,KAAK+/C,MAAA,GAAO//C,CAAC;YAAA;YAAC,IAAIysD,CAAA,GAAEzsD,CAAA;cAAI,OAAK,IAAEA,CAAA,CAAE8B,MAAA,GAAQ9B,CAAA,CAAEw9C,KAAA,EAAF,CAAU98C,CAAA,CAAC;YAAA;YAChgB,SAASgsD,EAAG1sD,CAAA;cAAG,KAAKs7D,EAAA,GAAGt7D,CAAA,GAAE,IAAG,KAAK47D,EAAA,GAAG,UAAS57D,CAAA;gBAAG6W,CAAA,CAAE,KAAKykD,EAAA,GAAG,KAAG,MAAI,KAAGt7D,CAAC;cAAA,GAAE,KAAK07D,EAAA,GAAG,UAAS17D,CAAA;gBAAG6W,CAAA,CAAE,KAAKykD,EAAA,GAAG,KAAG,MAAI,KAAGt7D,CAAC;cAAA,GAAE,KAAKg6D,EAAA,GAAG,UAASh6D,CAAA,EAAEC,CAAA;gBAAG,KAAKg6D,EAAA,IAAK,KAAK2B,EAAA,CAAG57D,CAAA,GAAG,KAAK07D,EAAA,CAAGz7D,CAAA,CAAE;cAAA,GAAE,KAAKg6D,EAAA,GAAG;gBAAWpjD,CAAA,CAAE,KAAKykD,EAAA,GAAG,MAAI,MAAI,KAAG,CAAC;cAAA,CAAC;YAAA;YACnN,IAGiJ3O,CAAA;cAHnIC,CAAA,GAAG,sBAAoBxP,WAAA,GAAY,IAAIA,WAAA,CAAY,eAAQ;cAAOyP,CAAA,GAAG+O,CAAC57D,CAAA,EAAEC,CAAA,EAAEQ,CAAA;gBAAY,IAAID,CAAA,IAAXP,CAAA,MAAK,KAAUQ,CAAA;gBAAE,KAAIA,CAAA,GAAER,CAAA,EAAED,CAAA,CAAES,CAAA,OAAMA,CAAA,IAAGD,CAAA,MAAMC,CAAA;gBAAE,IAAG,KAAGA,CAAA,GAAER,CAAA,IAAGD,CAAA,CAAE4uB,MAAA,IAAQg+B,CAAA,EAAG,OAAOA,CAAA,CAAGz9C,MAAA,CAAOnP,CAAA,CAAE6U,QAAA,CAAS5U,CAAA,EAAEQ,CAAA;gBAAI,KAAID,CAAA,GAAE,IAAGP,CAAA,GAAEQ,CAAA,GAAG;kBAAC,IAAIC,CAAA,GAAEV,CAAA,CAAEC,CAAA;kBAAK,IAAK,MAAFS,CAAA,EAAM;oBAAC,IAAIO,CAAA,GAAS,KAAPjB,CAAA,CAAEC,CAAA;oBAAQ,IAAG,QAAQ,MAAFS,CAAA,GAAOF,CAAA,IAAG4lD,MAAA,CAAOgJ,YAAA,EAAgB,KAAF1uD,CAAA,KAAO,IAAEO,CAAA,OAAO;sBAAC,IAAIC,CAAA,GAAS,KAAPlB,CAAA,CAAEC,CAAA;sBAAwE,SAAhES,CAAA,GAAE,QAAQ,MAAFA,CAAA,KAAU,KAAFA,CAAA,KAAO,KAAGO,CAAA,IAAG,IAAEC,CAAA,IAAK,IAAFR,CAAA,KAAM,KAAGO,CAAA,IAAG,KAAGC,CAAA,IAAG,IAAS,KAAPlB,CAAA,CAAEC,CAAA,OAAgBO,CAAA,IAAG4lD,MAAA,CAAOgJ,YAAA,CAAa1uD,CAAA,KAAIA,CAAA,IAAG,OAAMF,CAAA,IAAG4lD,MAAA,CAAOgJ,YAAA,CAAa,QAAM1uD,CAAA,IAAG,IAAG,QAAQ,OAAFA,CAAA,EAAQ;oBAAA;kBAAC,OAAMF,CAAA,IAAG4lD,MAAA,CAAOgJ,YAAA,CAAa1uD,CAAA,CAAE;gBAAA;gBAAC,OAAOF,CAAA;cAAA;cACvgBssD,CAAA,GAAErD,CAACzpD,CAAA,EAAEC,CAAA,MAAKD,CAAA,MAAK,KAAG6sD,CAAA,CAAGl2C,CAAA,EAAE3W,CAAA,EAAEC,CAAA,IAAG;cAAG8sD,CAAA,GAAE/sD,CAAA;gBAAI,KAAI,IAAIC,CAAA,GAAE,GAAEQ,CAAA,GAAE,GAAEA,CAAA,GAAET,CAAA,CAAE8B,MAAA,IAASrB,CAAA,EAAE;kBAAC,IAAID,CAAA,GAAER,CAAA,CAAE+yD,UAAA,CAAWtyD,CAAA;kBAAG,OAAKD,CAAA,GAAEP,CAAA,KAAI,QAAMO,CAAA,GAAEP,CAAA,IAAG,IAAE,SAAOO,CAAA,IAAG,SAAOA,CAAA,IAAGP,CAAA,IAAG,KAAIQ,CAAA,IAAGR,CAAA,IAAG,CAAC;gBAAA;gBAAC,OAAOA,CAAA;cAAA;cAAG+sD,CAAA,GAAEL,CAAC3sD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA;gBAAY,MAAK,IAAEA,CAAA,GAAG,OAAO;gBAAE,IAAIE,CAAA,GAA9BD,CAAA,MAAK;gBAA6BD,CAAA,GAAEC,CAAA,GAAED,CAAA,GAAE;gBAAE,KAAI,IAAIS,CAAA,GAAE,GAAEA,CAAA,GAAEjB,CAAA,CAAE8B,MAAA,IAASb,CAAA,EAAE;kBAAC,IAAIC,CAAA,GAAElB,CAAA,CAAE+yD,UAAA,CAAW9xD,CAAA;kBAAgF,IAA1E,SAAOC,CAAA,IAAG,SAAOA,CAAA,KAA2BA,CAAA,GAAE,UAAU,OAAFA,CAAA,KAAS,MAAM,OAA3ClB,CAAA,CAAE+yD,UAAA,GAAa9xD,CAAA,IAAoC,OAAKC,CAAA,EAAE;oBAAC,IAAGT,CAAA,IAAGD,CAAA,EAAE;oBAAMP,CAAA,CAAEQ,CAAA,OAAM,KAAGS,CAAC;kBAAA,OAAK;oBAAC,IAAG,QAAMA,CAAA,EAAE;sBAAC,IAAGT,CAAA,GAAE,KAAGD,CAAA,EAAE;sBAAMP,CAAA,CAAEQ,CAAA,OAAM,KAAG,MAAIS,CAAA,IAAG,CAAC;oBAAA,OAAK;sBAAC,IAAG,SAAOA,CAAA,EAAE;wBAAC,IAAGT,CAAA,GAAE,KAAGD,CAAA,EAAE;wBAAMP,CAAA,CAAEQ,CAAA,OAAM,KAAG,MAAIS,CAAA,IAAG,EAAE;sBAAA,OAAK;wBAAC,IAAGT,CAAA,GAAE,KACnfD,CAAA,EAAE;wBAAMP,CAAA,CAAEQ,CAAA,OAAM,KAAG,MAAIS,CAAA,IAAG,IAAGjB,CAAA,CAAEQ,CAAA,OAAM,KAAG,MAAIS,CAAA,IAAG,KAAG,EAAE;sBAAA;sBAACjB,CAAA,CAAEQ,CAAA,OAAM,KAAG,MAAIS,CAAA,IAAG,IAAE,EAAE;oBAAA;oBAACjB,CAAA,CAAEQ,CAAA,OAAM,KAAG,MAAM,KAAFS,CAAI;kBAAA;gBAAC;gBAAY,OAAXjB,CAAA,CAAEQ,CAAA,KAAI,KAAG,GAASA,CAAA,GAAEC,CAAA;cAAA;cAAGs9C,CAAA,GAAEh+C,CAAA,IAAG,KAAIA,CAAA,GAAE,MAAI,KAAIA,CAAA,GAAE,OAAK,KAAIA,CAAA,GAAE;cAAKitD,CAAA,GAAG,CAAC,GAAE,IAAG,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI;cAAKE,EAAA,GAAG,CAAC,GAAE,IAAG,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI;cAAKzB,EAAA,GAAG1rD,CAAA;gBAAI,IAAIC,CAAA,GAAE8sD,CAAA,CAAE/sD,CAAA,IAAG;kBAAES,CAAA,GAAEyuD,EAAA,CAAGjvD,CAAA;gBAAiB,OAAdQ,CAAA,IAAGusD,CAAA,CAAEhtD,CAAA,EAAE2W,CAAA,EAAElW,CAAA,EAAER,CAAA,GAAUQ,CAAA;cAAA;cAAG8sD,EAAA,GAAE,CAAC;cAAEC,EAAA,GAAGgP,CAAA;gBAAK,KAAI7P,CAAA,EAAG;kBAAC,IACjS3sD,CAAA;oBADqSC,CAAA,GAAE;sBAACo1D,IAAA,EAAK;sBAAWC,OAAA,EAAQ;sBAAWC,IAAA,EAAK;sBAAIC,GAAA,EAAI;sBAAIC,IAAA,EAAK;sBAAiBC,IAAA,GAAM,mBAAiB9zD,SAAA,IAAWA,SAAA,CAAU+zD,SAAA,IAAW/zD,SAAA,CAAU+zD,SAAA,CAAU,MAAI,KAAKtlD,OAAA,CAAQ,KACnf,OAAK;sBAASpE,CAAA,EAAExB,CAAA,IAAG;oBAAA;kBAAoB,KAAIzK,CAAA,IAAKutD,EAAA,OAAE,MAASA,EAAA,CAAEvtD,CAAA,WAAUC,CAAA,CAAED,CAAA,IAAGC,CAAA,CAAED,CAAA,IAAGutD,EAAA,CAAEvtD,CAAA;kBAAG,IAAIS,CAAA,GAAE;kBAAG,KAAIT,CAAA,IAAKC,CAAA,EAAEQ,CAAA,CAAEuG,IAAA,CAAK,GAAGhH,CAAA,IAAKC,CAAA,CAAED,CAAA;kBAAM2sD,CAAA,GAAGlsD,CAAC;gBAAA;gBAAC,OAAOksD,CAAA;cAAA;cAAOc,EAAA,GAAG,CAAC,MAAK,IAAG;cAAmSK,EAAA,GAAG9tD,CAAA,KAAI8tD,EAAA,GAAnS;gBAAK,IAAG,mBAAiBsI,MAAA,IAAQ,qBAAmBA,MAAA,CAAOC,eAAA,EAAgB,OAAOr2D,CAAA,IAAGo2D,MAAA,CAAOC,eAAA,CAAgBr2D,CAAA;gBAAG,IAAGuG,CAAA,EAAE;kBAAI,IAAIvG,CAAA,GAAES,CAAA,CAAQ;kBAAU,IAAGT,CAAA,CAAEs2D,cAAA,EAAe,OAAOr2D,CAAA,IAAGD,CAAA,CAAEs2D,cAAA,CAAer2D,CAAA;kBAAG,IAAIA,CAAA,GAAED,CAAA,CAAEu2D,WAAA;kBAAY,OAAOv2D,CAAA,KAAIA,CAAA,CAAE+D,GAAA,CAAI9D,CAAA,CAAED,CAAA,CAAE8uB,UAAA,IAAa9uB,CAAA,CAAE;gBAAA,CAAC,QAAMA,CAAA,GAAG;gBAAC4pD,CAAA,CAAE,mBAAkB;cAAA,GAAa,GAAM5pD,CAAA;cAAGguD,EAAA,GAAG,CAAC,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAClf,IAAG,IAAG;cAAIC,EAAA,GAAG,CAAC,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG;YAC/C,SAASI,GAAGruD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA;cAAG,SAASE,EAAEV,CAAA,EAAEC,CAAA,EAAEQ,CAAA;gBAAG,KAAIT,CAAA,GAAE,mBAAiBA,CAAA,GAAEA,CAAA,CAAEu2B,QAAA,KAAWv2B,CAAA,IAAG,IAAGA,CAAA,CAAE8B,MAAA,GAAO7B,CAAA,GAAGD,CAAA,GAAES,CAAA,CAAE,KAAGT,CAAA;gBAAE,OAAOA,CAAC;cAAA;cAAC,SAASiB,EAAEjB,CAAA,EAAEC,CAAA;gBAAG,OAAOS,CAAA,CAAEV,CAAA,EAAEC,CAAA,EAAE,IAAI;cAAA;cAAC,SAASiB,EAAElB,CAAA,EAAEC,CAAA;gBAAG,SAASQ,EAAET,CAAA;kBAAI,OAAO,IAAEA,CAAA,IAAI,IAAE,IAAEA,CAAA,GAAG,IAAE,CAAC;gBAAA;gBAAC,IAAIQ,CAAA;gBAAmH,OAAjH,OAAKA,CAAA,GAAEC,CAAA,CAAET,CAAA,CAAE42D,WAAA,KAAc32D,CAAA,CAAE22D,WAAA,QAAiB,OAAKp2D,CAAA,GAAEC,CAAA,CAAET,CAAA,CAAE62D,QAAA,KAAW52D,CAAA,CAAE42D,QAAA,SAAer2D,CAAA,GAAEC,CAAA,CAAET,CAAA,CAAE82D,OAAA,KAAU72D,CAAA,CAAE62D,OAAA,MAAmBt2D,CAAC;cAAA;cAAC,SAAS8C,EAAEtD,CAAA;gBAAG,QAAOA,CAAA,CAAE+2D,MAAA;kBAAU,KAAK;oBAAE,OAAO,IAAIl4B,IAAA,CAAK7+B,CAAA,CAAE42D,WAAA,KAAc,GAAE,IAAG;kBAAI,KAAK;oBAAE,OAAO52D,CAAA;kBAAE,KAAK;oBAAE,OAAO,IAAI6+B,IAAA,CAAK7+B,CAAA,CAAE42D,WAAA,IAAc,GAAE;kBAAG,KAAK;oBAAE,OAAO,IAAI/3B,IAAA,CAAK7+B,CAAA,CAAE42D,WAAA,IAChf,GAAE;kBAAG,KAAK;oBAAE,OAAO,IAAI/3B,IAAA,CAAK7+B,CAAA,CAAE42D,WAAA,IAAc,GAAE;kBAAG,KAAK;oBAAE,OAAO,IAAI/3B,IAAA,CAAK7+B,CAAA,CAAE42D,WAAA,KAAc,GAAE,IAAG;kBAAI,KAAK;oBAAE,OAAO,IAAI/3B,IAAA,CAAK7+B,CAAA,CAAE42D,WAAA,KAAc,GAAE,IAAG;gBAAA;cAAI;cAAC,SAASlzD,EAAE1D,CAAA;gBAAG,IAAIC,CAAA,GAAED,CAAA,CAAEi7D,EAAA;gBAAG,KAAIj7D,CAAA,GAAE,IAAI6+B,IAAA,CAAK,IAAKA,IAAA,CAAK7+B,CAAA,CAAEk7D,EAAA,GAAG,MAAK,GAAE,GAAIhE,OAAA,KAAW,IAAEj3D,CAAA,GAAG;kBAAC,IAAIQ,CAAA,GAAET,CAAA,CAAE62D,QAAA;oBAAWr2D,CAAA,IAAGw9C,CAAA,CAAEh+C,CAAA,CAAE42D,WAAA,MAAe5I,EAAA,GAAGC,EAAA,EAAIxtD,CAAA;kBAAG,MAAGR,CAAA,GAAEO,CAAA,GAAER,CAAA,CAAE82D,OAAA,KAAoH;oBAAC92D,CAAA,CAAEm3D,OAAA,CAAQn3D,CAAA,CAAE82D,OAAA,KAAU72D,CAAA;oBAAG;kBAAK;kBAAzIA,CAAA,IAAGO,CAAA,GAAER,CAAA,CAAE82D,OAAA,KAAU,GAAE92D,CAAA,CAAEm3D,OAAA,CAAQ,IAAG,KAAG12D,CAAA,GAAET,CAAA,CAAEo3D,QAAA,CAAS32D,CAAA,GAAE,MAAIT,CAAA,CAAEo3D,QAAA,CAAS,IAAGp3D,CAAA,CAAEq3D,WAAA,CAAYr3D,CAAA,CAAE42D,WAAA,KAAc,GAAwC;gBAAA;gBACxa,OADyan2D,CAAA,GAAE,IAAIo+B,IAAA,CAAK7+B,CAAA,CAAE42D,WAAA,KAAc,GAAE,GAAE,IAAG32D,CAAA,GAAEqD,CAAA,CAAE,IAAIu7B,IAAA,CAAK7+B,CAAA,CAAE42D,WAAA,IACve,GAAE,KAAIn2D,CAAA,GAAE6C,CAAA,CAAE7C,CAAA,GAAU,KAAGS,CAAA,CAAEjB,CAAA,EAAED,CAAA,IAAG,KAAGkB,CAAA,CAAET,CAAA,EAAET,CAAA,IAAGA,CAAA,CAAE42D,WAAA,KAAc,IAAE52D,CAAA,CAAE42D,WAAA,KAAc52D,CAAA,CAAE42D,WAAA,KAAc,CAAC;cAAA;cAAC52D,CAAA,MAAK,GAAEC,CAAA,MAAK,GAAEQ,CAAA,MAAK;cAAS,IAAIgK,CAAA,GAAEmM,CAAA,CAAI,MAAjBpW,CAAA,MAAK,MAAgB,MAAI;cACyE,KAAI,IAAI6K,CAAA,IAD9E7K,CAAA,GAAE;gBAACy7D,EAAA,EAAGrlD,CAAA,CAAEpW,CAAA,IAAG,MAAI;gBAAGu7D,EAAA,EAAGnlD,CAAA,CAAEpW,CAAA,GAAE,KAAG,MAAI;gBAAG26D,EAAA,EAAGvkD,CAAA,CAAEpW,CAAA,GAAE,KAAG,MAAI;gBAAG+6D,EAAA,EAAG3kD,CAAA,CAAEpW,CAAA,GAAE,MAAI,MAAI;gBAAG66D,EAAA,EAAGzkD,CAAA,CAAEpW,CAAA,GAAE,MAAI,MAAI;gBAAG06D,EAAA,EAAGtkD,CAAA,CAAEpW,CAAA,GAAE,MAAI,MAAI;gBAAGo6D,EAAA,EAAGhkD,CAAA,CAAEpW,CAAA,GAAE,MAAI,MAAI;gBAAGy6D,EAAA,EAAGrkD,CAAA,CAAEpW,CAAA,GAAE,MAAI,MAAI;gBAAG47D,EAAA,EAAGxlD,CAAA,CAAEpW,CAAA,GAAE,MAAI,MAAI;gBAAGs7D,EAAA,EAAGllD,CAAA,CAAEpW,CAAA,GAAE,MAAI,MAAI;gBAAG27D,EAAA,EAAG1xD,CAAA,GAAEqiD,CAAA,CAAEriD,CAAA,IAAG;cAAA,GAAIhK,CAAA,GAAEqsD,CAAA,CAAErsD,CAAA,GAAGgK,CAAA,GAAE;gBAAC,MAAK;gBAAuB,MAAK;gBAAW,MAAK;gBAAW,MAAK;gBAAK,MAAK;gBAAc,MAAK;gBAAQ,MAAK;gBAAW,MAAK;gBAAW,MAAK;gBAAW,OAAM;gBACnf,OAAM;gBAAK,OAAM;gBAAW,OAAM;gBAAW,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;gBAAK,OAAM;cAAA,GAAqBhK,CAAA,GAAEA,CAAA,CAAE4P,OAAA,CAAQ,IAAIC,MAAA,CAAOjF,CAAA,EAAE,MAAKZ,CAAA,CAAEY,CAAA;cAAI,IAAIC,CAAA,GAAG,2DAA2D0E,KAAA,CAAM;gBAAKzE,CAAA,GAAG,wFAAwFyE,KAAA,CAAM;cAE2D,KAAI3E,CAAA,IAF1DZ,CAAA,GAAE;gBAAC,MAAKzK,CAAA,IAAGsL,CAAA,CAAGtL,CAAA,CAAE46D,EAAA,EAAIz4B,SAAA,CAAU,GAAE;gBAAG,MAAKniC,CAAA,IAAGsL,CAAA,CAAGtL,CAAA,CAAE46D,EAAA;gBAAI,MAAK56D,CAAA,IAClfuL,CAAA,CAAGvL,CAAA,CAAEq7D,EAAA,EAAIl5B,SAAA,CAAU,GAAE;gBAAG,MAAKniC,CAAA,IAAGuL,CAAA,CAAGvL,CAAA,CAAEq7D,EAAA;gBAAI,MAAKr7D,CAAA,IAAGiB,CAAA,EAAGjB,CAAA,CAAEk7D,EAAA,GAAG,QAAM,MAAI,GAAE;gBAAG,MAAKl7D,CAAA,IAAGiB,CAAA,CAAEjB,CAAA,CAAEu7D,EAAA,EAAG;gBAAG,MAAKv7D,CAAA,IAAGU,CAAA,CAAEV,CAAA,CAAEu7D,EAAA,EAAG,GAAE;gBAAK,MAAKv7D,CAAA,IAAG0D,CAAA,CAAE1D,CAAA,EAAGu2B,QAAA,GAAW4L,SAAA,CAAU;gBAAG,MAAKniC,CAAA,IAAG0D,CAAA,CAAE1D,CAAA;gBAAG,MAAKA,CAAA,IAAGiB,CAAA,CAAEjB,CAAA,CAAEm7D,EAAA,EAAG;gBAAG,MAAKn7D,CAAA,KAAW,MAAPA,CAAA,GAAEA,CAAA,CAAEm7D,EAAA,IAAQn7D,CAAA,GAAE,KAAG,KAAGA,CAAA,KAAIA,CAAA,IAAG,KAAWiB,CAAA,CAAEjB,CAAA,EAAE;gBAAI,MAAKA,CAAA;kBAAI,KAAI,IAAIC,CAAA,GAAE,GAAEQ,CAAA,GAAE,GAAEA,CAAA,IAAGT,CAAA,CAAEq7D,EAAA,GAAG,GAAEp7D,CAAA,KAAI+9C,CAAA,CAAEh+C,CAAA,CAAEk7D,EAAA,GAAG,QAAMlN,EAAA,GAAGC,EAAA,EAAIxtD,CAAA;kBAAM,OAAOQ,CAAA,CAAEjB,CAAA,CAAEu7D,EAAA,GAAGt7D,CAAA,EAAE,EAAC;gBAAA;gBAAG,MAAKD,CAAA,IAAGiB,CAAA,CAAEjB,CAAA,CAAEq7D,EAAA,GAAG,GAAE;gBAAG,MAAKr7D,CAAA,IAAGiB,CAAA,CAAEjB,CAAA,CAAE+7D,EAAA,EAAG;gBAAG,MAAKhE,CAAA,KAAI;gBAAK,MAAK/3D,CAAA,IAAG,KAAGA,CAAA,CAAEm7D,EAAA,IAAI,KAAGn7D,CAAA,CAAEm7D,EAAA,GAAG,OAAK;gBAAK,MAAKn7D,CAAA,IAAGiB,CAAA,CAAEjB,CAAA,CAAEi8D,EAAA,EAAG;gBAAG,MAAKjE,CAAA,KAAI;gBAAK,MAAKh4D,CAAA,IAAGA,CAAA,CAAE46D,EAAA,IAAI;gBAAE,MAAK56D,CAAA,IAAGiB,CAAA,CAAEe,IAAA,CAAKoX,KAAA,EAAOpZ,CAAA,CAAEi7D,EAAA,GAAG,IAAEj7D,CAAA,CAAE46D,EAAA,IAAI,IAAG;gBAAG,MAAK56D,CAAA;kBACpf,IAAIC,CAAA,GAAE+B,IAAA,CAAKoX,KAAA,EAAOpZ,CAAA,CAAEi7D,EAAA,GAAG,KAAGj7D,CAAA,CAAE46D,EAAA,GAAG,KAAG,KAAG;kBAA+B,IAA5B,MAAI56D,CAAA,CAAE46D,EAAA,GAAG,MAAI56D,CAAA,CAAEi7D,EAAA,GAAG,KAAG,KAAGh7D,CAAA,IAAOA,CAAA,EAAE,MAAIA,CAAA,KAAwB,MAApBQ,CAAA,IAAGT,CAAA,CAAE46D,EAAA,GAAG,MAAI56D,CAAA,CAAEi7D,EAAA,IAAI,MAAQ,KAAGx6D,CAAA,IAAGu9C,CAAA,CAAEh+C,CAAA,CAAEk7D,EAAA,MAAMj7D,CAAA,GAAE,SAAQ;oBAACA,CAAA,GAAE;oBAAG,IAAIQ,CAAA,IAAGT,CAAA,CAAE46D,EAAA,GAAG,IAAE56D,CAAA,CAAEi7D,EAAA,GAAG,KAAG;oBAAA,CAAG,KAAGx6D,CAAA,IAAG,KAAGA,CAAA,IAAGu9C,CAAA,CAAEh+C,CAAA,CAAEk7D,EAAA,GAAG,MAAI,OAAKj7D,CAAA,EAAG;kBAAA;kBAAC,OAAOgB,CAAA,CAAEhB,CAAA,EAAE,EAAC;gBAAA;gBAAG,MAAKD,CAAA,IAAGA,CAAA,CAAE46D,EAAA;gBAAG,MAAK56D,CAAA,IAAGiB,CAAA,CAAEe,IAAA,CAAKoX,KAAA,EAAOpZ,CAAA,CAAEi7D,EAAA,GAAG,KAAGj7D,CAAA,CAAE46D,EAAA,GAAG,KAAG,KAAG,IAAG;gBAAG,MAAK56D,CAAA,KAAIA,CAAA,CAAEk7D,EAAA,GAAG,MAAM3kC,QAAA,GAAW4L,SAAA,CAAU;gBAAG,MAAKniC,CAAA,IAAGA,CAAA,CAAEk7D,EAAA,GAAG;gBAAK,MAAKl7D,CAAA;kBAAW,IAAIC,CAAA,GAAE,MAAbD,CAAA,GAAEA,CAAA,CAAE87D,EAAA;kBAA+B,OAAjB97D,CAAA,GAAEgC,IAAA,CAAKuV,GAAA,CAAIvX,CAAA,IAAG,KAAUC,CAAA,GAAE,MAAI,OAAKmmD,MAAA,CAAO,UAAQpmD,CAAA,GAAE,KAAG,MAAIA,CAAA,GAAE,KAAKkN,KAAA,EAAO,EAAC;gBAAA;gBAAG,MAAKlN,CAAA,IAAGA,CAAA,CAAEm8D,EAAA;gBAAG,MAAKlE,CAAA,KAAI;cAAA,GAAKx3D,CAAA,GAAEA,CAAA,CAAE4P,OAAA,CAAQ,OAAM,SAAqB5F,CAAA,EAAEhK,CAAA,CAAEy3D,QAAA,CAAS7sD,CAAA,MACpgB5K,CAAA,GAAEA,CAAA,CAAE4P,OAAA,CAAQ,IAAIC,MAAA,CAAOjF,CAAA,EAAE,MAAKZ,CAAA,CAAEY,CAAA,EAAG7K,CAAA;cAAsC,OAAR6K,CAAA,GAPf,UAAYrL,CAAA;gBAAG,IAAIC,CAAA,GAAE+F,KAAA,CAAM+mD,CAAA,CAAE/sD,CAAA,IAAG;gBAAqB,OAAlBgtD,CAAA,CAAEhtD,CAAA,EAAEC,CAAA,EAAE,GAAEA,CAAA,CAAE6B,MAAA,GAAe7B,CAAC;cAAA,CAO5C,CAA3BQ,CAAA,GAAEA,CAAA,CAAE4P,OAAA,CAAQ,SAAQ,OAAgBhF,CAAA,CAAEvJ,MAAA,GAAO7B,CAAA,GAAS,KAAEyW,CAAA,CAAE3S,GAAA,CAAIsH,CAAA,EAAErL,CAAA,KAAI,IAAUqL,CAAA,CAAEvJ,MAAA,GAAO,EAAC;YAAA;YACjI,IAAImtD,EAAA,GAAG;cAAC/tD,CAAA,EAAE,SAAAA,CAASlB,CAAA,EAAEC,CAAA,EAAEQ,CAAA;gBAAgD,MAAtC,IAAKisD,CAAA,CAAZ1sD,CAAA,MAAK,GAAcg6D,EAAA,CAAG/5D,CAAA,KAAI,GAAEQ,CAAA,KAAI,IAAMT,CAAgB;cAAA;cAAEA,CAAA,EAAE,SAAAA,CAAA;gBAAW,OAAO,CAAC;cAAA;cAAE+W,CAAA,EAAE,SAAAA,CAAA,GAAW;cAAEhL,CAAA,EAAE,SAAAA,CAAA,GAAW;cAAE8K,CAAA,EAAE,SAAAA,CAAA,GAAW;cAAEk2C,CAAA,EAAE,SAAAA,CAAA;gBAAW,OAAO,CAAC;cAAA;cAAEN,CAAA,EAAE,SAAAA,CAAA,GAAW;cAAET,CAAA,EAAE,SAAAA,CAAA,GAAW;cAAE50C,CAAA,EAAE,SAAAA,CAAA,GAAW;cAAE5Q,CAAA,EAAE,SAAAA,CAAA,GAAW;cAAEgmD,CAAA,EAAE,SAAAA,CAAA,GAAW;cAAErgD,CAAA,EAAE,SAAAA,CAAA,GAAW;cAAEugD,CAAA,EAAE,SAAAA,CAAA,GAAW;cAAEh2C,CAAA,EAAE,SAAAA,CAAA,GAAW;cAAES,CAAA,EAAEA,CAAA,MAAI;cAAG1W,CAAA,EAAE,SAAAA,CAAST,CAAA,EAAEC,CAAA,EAAEQ,CAAA;gBAAGT,CAAA,GAAEC,CAAA,GAAE,YAAU,IAAE,YAAUD,CAAA,IAAGA,CAAA,KAAI,KAAG,aAAWC,CAAA,GAAEs4D,GAAA,EAAI93D,CAAA,MAAK,GAAET,CAAA,GAAE,IAAI6+B,IAAA,CAAK,MAAI7+B,CAAA,GAAG4W,CAAA,CAAEnW,CAAA,IAAG,MAAI,KAAGT,CAAA,CAAEw4D,aAAA,IAAgB5hD,CAAA,CAAEnW,CAAA,GAAE,KAAG,MAAI,KAAGT,CAAA,CAAEy4D,aAAA,IAAgB7hD,CAAA,CAAEnW,CAAA,GAAE,KAAG,MAAI,KAAGT,CAAA,CAAE04D,WAAA,IAAc9hD,CAAA,CAAEnW,CAAA,GAAE,MAAI,MAClf,KAAGT,CAAA,CAAE24D,UAAA,IAAa/hD,CAAA,CAAEnW,CAAA,GAAE,MAAI,MAAI,KAAGT,CAAA,CAAE44D,WAAA,IAAchiD,CAAA,CAAEnW,CAAA,GAAE,MAAI,MAAI,KAAGT,CAAA,CAAE64D,cAAA,KAAiB,MAAKjiD,CAAA,CAAEnW,CAAA,GAAE,MAAI,MAAI,KAAGT,CAAA,CAAE84D,SAAA,IAAYliD,CAAA,CAAEnW,CAAA,GAAE,MAAI,MAAI,MAAIT,CAAA,CAAEk3D,OAAA,KAAUr4B,IAAA,CAAKk6B,GAAA,CAAI/4D,CAAA,CAAE64D,cAAA,IAAiB,GAAE,GAAE,GAAE,GAAE,GAAE,MAAI,QAAM,CAAC;cAAA;cAAEn4D,CAAA,EAAE,SAAAA,CAASV,CAAA,EAAEC,CAAA,EAAEQ,CAAA;gBAAGT,CAAA,GAAEC,CAAA,GAAE,YAAU,IAAE,YAAUD,CAAA,IAAGA,CAAA,KAAI,KAAG,aAAWC,CAAA,GAAEs4D,GAAA,EAAI93D,CAAA,MAAK,GAAET,CAAA,GAAE,IAAI6+B,IAAA,CAAK,MAAI7+B,CAAA,GAAG4W,CAAA,CAAEnW,CAAA,IAAG,MAAI,KAAGT,CAAA,CAAEg5D,UAAA,IAAapiD,CAAA,CAAEnW,CAAA,GAAE,KAAG,MAAI,KAAGT,CAAA,CAAEi5D,UAAA,IAAariD,CAAA,CAAEnW,CAAA,GAAE,KAAG,MAAI,KAAGT,CAAA,CAAEk5D,QAAA,IAAWtiD,CAAA,CAAEnW,CAAA,GAAE,MAAI,MAAI,KAAGT,CAAA,CAAE82D,OAAA,IAAUlgD,CAAA,CAAEnW,CAAA,GAAE,MAAI,MAAI,KAAGT,CAAA,CAAE62D,QAAA,IAAWjgD,CAAA,CAAEnW,CAAA,GAAE,MAAI,MAAI,KAAGT,CAAA,CAAE42D,WAAA,KAAc,MAAKhgD,CAAA,CAAEnW,CAAA,GAAE,MAAI,MAAI,KAAGT,CAAA,CAAE+2D,MAAA,IAASngD,CAAA,CAAEnW,CAAA,GAAE,MAAI,MACpf,MAAIu9C,CAAA,CAAEh+C,CAAA,CAAE42D,WAAA,MAAe3J,CAAA,GAAGE,EAAA,EAAIntD,CAAA,CAAE62D,QAAA,MAAY72D,CAAA,CAAE82D,OAAA,KAAU,IAAE,GAAElgD,CAAA,CAAEnW,CAAA,GAAE,MAAI,MAAI,MAAK,KAAGT,CAAA,CAAEm5D,iBAAA,IAAqBl5D,CAAA,GAAE,IAAK4+B,IAAA,CAAK7+B,CAAA,CAAE42D,WAAA,IAAc,GAAE,GAAIuC,iBAAA;gBAAoB,IAAI34D,CAAA,GAAE,IAAKq+B,IAAA,CAAK7+B,CAAA,CAAE42D,WAAA,IAAc,GAAE,GAAIuC,iBAAA;gBAAoBviD,CAAA,CAAEnW,CAAA,GAAE,MAAI,MAAI,KAAgD,KAA5CR,CAAA,IAAGO,CAAA,IAAGR,CAAA,CAAEm5D,iBAAA,MAAqBn3D,IAAA,CAAKC,GAAA,CAAIzB,CAAA,EAAEP,CAAA,EAAK;cAAA;cAAEqL,CAAA,EAAE,SAAAA,CAAStL,CAAA;gBAAGA,CAAA,MAAK;gBAAE,IAAIC,CAAA,GAAE,IAAI4+B,IAAA,CAAKjoB,CAAA,CAAE5W,CAAA,GAAE,MAAI,MAAI,KAAG,MAAK4W,CAAA,CAAE5W,CAAA,GAAE,MAAI,MAAI,IAAG4W,CAAA,CAAE5W,CAAA,GAAE,MAAI,MAAI,IAAG4W,CAAA,CAAE5W,CAAA,GAAE,KAAG,MAAI,IAAG4W,CAAA,CAAE5W,CAAA,GAAE,KAAG,MAAI,IAAG4W,CAAA,CAAE5W,CAAA,IAAG,MAAI,IAAG;kBAAGS,CAAA,GAAEmW,CAAA,CAAE5W,CAAA,GAAE,MAAI,MAAI;kBAAGQ,CAAA,GAAEP,CAAA,CAAEk5D,iBAAA;kBAAoBz4D,CAAA,GAAE,IAAKm+B,IAAA,CAAK5+B,CAAA,CAAE22D,WAAA,IAAc,GAAE,GAAIuC,iBAAA;kBAClel4D,CAAA,GAAE,IAAK49B,IAAA,CAAK5+B,CAAA,CAAE22D,WAAA,IAAc,GAAE,GAAIuC,iBAAA;kBAAoBj4D,CAAA,GAAEc,IAAA,CAAKC,GAAA,CAAIhB,CAAA,EAAEP,CAAA;gBAA0Y,OAAvY,IAAED,CAAA,GAAEmW,CAAA,CAAE5W,CAAA,GAAE,MAAI,MAAI,KAAG0B,MAAA,CAAOhB,CAAA,IAAGO,CAAA,IAAGC,CAAA,IAAGV,CAAA,IAAG,IAAEC,CAAA,KAAIS,CAAA,IAAGV,CAAA,MAAKE,CAAA,GAAEsB,IAAA,CAAKwnB,GAAA,CAAIvoB,CAAA,EAAEP,CAAA,GAAGT,CAAA,CAAEm5D,OAAA,CAAQn5D,CAAA,CAAEi3D,OAAA,KAAU,QAAM,IAAEz2D,CAAA,GAAES,CAAA,GAAER,CAAA,IAAGF,CAAA,KAAKoW,CAAA,CAAE5W,CAAA,GAAE,MAAI,MAAI,KAAGC,CAAA,CAAE82D,MAAA,IAASngD,CAAA,CAAE5W,CAAA,GAAE,MAAI,MAAI,MAAIg+C,CAAA,CAAE/9C,CAAA,CAAE22D,WAAA,MAAe3J,CAAA,GAAGE,EAAA,EAAIltD,CAAA,CAAE42D,QAAA,MAAY52D,CAAA,CAAE62D,OAAA,KAAU,IAAE,GAAElgD,CAAA,CAAE5W,CAAA,IAAG,MAAI,KAAGC,CAAA,CAAE+4D,UAAA,IAAapiD,CAAA,CAAE5W,CAAA,GAAE,KAAG,MAAI,KAAGC,CAAA,CAAEg5D,UAAA,IAAariD,CAAA,CAAE5W,CAAA,GAAE,KAAG,MAAI,KAAGC,CAAA,CAAEi5D,QAAA,IAAWtiD,CAAA,CAAE5W,CAAA,GAAE,MAAI,MAAI,KAAGC,CAAA,CAAE62D,OAAA,IAAUlgD,CAAA,CAAE5W,CAAA,GAAE,MAAI,MAAI,KAAGC,CAAA,CAAE42D,QAAA,IAAWjgD,CAAA,CAAE5W,CAAA,GAAE,MAAI,MAAI,KAAGC,CAAA,CAAEo5D,OAAA,IAAUr5D,CAAA,GAAEC,CAAA,CAAEi3D,OAAA,KAAU,KAAW5H,EAAA,EAAIj4C,CAAA,GAAErX,CAAA,EAAE,MAAIgC,IAAA,CAAKuV,GAAA,CAAIF,CAAA,IAAG,IAAEA,CAAA,IAAGrV,IAAA,CAAKoX,KAAA,CAAM/B,CAAA,GAC5f,gBAAc,OAAKrV,IAAA,CAAKE,IAAA,EAAMmV,CAAA,OAAMA,CAAA,KAAI,MAAI,gBAAc,IAAE,KAAIrX,CAAA,KAAI,CAAC;cAAA;cAAEyK,CAAA,EAAE,SAAAA,CAAA;gBAAW,QAAO,EAAE;cAAA;cAAEoB,CAAA,EAAE,SAAAA,CAAA,GAAW;cAAEnI,CAAA,EAAE,SAAAA,CAAS1D,CAAA,EAAEC,CAAA,EAAEQ,CAAA;gBAAG,SAASD,EAAER,CAAA;kBAAG,QAAOA,CAAA,GAAEA,CAAA,CAAEu5D,YAAA,GAAeC,KAAA,CAAM,wBAAsBx5D,CAAA,CAAE,KAAG,KAAK;gBAAA;gBAACS,CAAA,MAAK;gBAAE,IAAIC,CAAA,GAAE,IAAKm+B,IAAA,GAAM+3B,WAAA;kBAAc31D,CAAA,GAAE,IAAI49B,IAAA,CAAKn+B,CAAA,EAAE,GAAE;kBAAGQ,CAAA,GAAE,IAAI29B,IAAA,CAAKn+B,CAAA,EAAE,GAAE;gBAAGA,CAAA,GAAEO,CAAA,CAAEk4D,iBAAA;gBAAoB,IAAI71D,CAAA,GAAEpC,CAAA,CAAEi4D,iBAAA;gBAAoBtiD,CAAA,CAAE7W,CAAA,KAAI,KAAG,MAAI,KAAG,KAAGgC,IAAA,CAAKwnB,GAAA,CAAI9oB,CAAA,EAAE4C,CAAA,GAAGsT,CAAA,CAAE3W,CAAA,KAAI,KAAG,MAAI,KAAGyB,MAAA,CAAOhB,CAAA,IAAG4C,CAAA,GAAGtD,CAAA,GAAEQ,CAAA,CAAES,CAAA,GAAGhB,CAAA,GAAEO,CAAA,CAAEU,CAAA,GAAGlB,CAAA,GAAE0rD,EAAA,CAAG1rD,CAAA,GAAGC,CAAA,GAAEyrD,EAAA,CAAGzrD,CAAA,GAAGqD,CAAA,GAAE5C,CAAA,IAAGmW,CAAA,CAAEpW,CAAA,IAAG,MAAI,KAAGT,CAAA,EAAE6W,CAAA,CAAEpW,CAAA,GAAE,KAAG,MAAI,KAAGR,CAAA,KAAI4W,CAAA,CAAEpW,CAAA,IAAG,MAAI,KAAGR,CAAA,EAAE4W,CAAA,CAAEpW,CAAA,GAAE,KAAG,MAAI,KAAGT,CAAA,CAAE;cAAA;cAAEuL,CAAA,EAAEA,CAAA;gBAAKq+C,CAAA,CAAE,GAAE;cAAA;cACzfl+C,CAAA,EAAE,SAAAA,CAAA;gBAAW,OAAOmzB,IAAA,CAAKwB,GAAA,EAAK;cAAA;cAAEr0B,CAAA,EAAE,SAAAA,CAAA;gBAAW,OAAO,UAAU;cAAA;cAAEJ,CAAA,EAAEA,CAAA,KAAIi1B,WAAA,CAAYR,GAAA;cAAM2sB,CAAA,EAAE,SAAAA,CAAShtD,CAAA,EAAEC,CAAA,EAAEQ,CAAA;gBAAU,OAAPR,CAAA,MAAK,GAAS0W,CAAA,CAAEwmD,UAAA,CAAWn9D,CAAA,KAAI,MAAI,GAAEC,CAAA,KAAI,GAAEA,CAAA,IAAGQ,CAAA,KAAI,OAAK,EAAE;cAAA;cAAER,CAAA,EAAE,SAAAA,CAASD,CAAA;gBAAGA,CAAA,MAAK;gBAAE,IAAIC,CAAA,GAAE0W,CAAA,CAAE7U,MAAA;gBAAO,IAAG,aAAW9B,CAAA,EAAE,QAAM;gBAAG,KAAI,IAAIS,CAAA,GAAE,GAAE,KAAGA,CAAA,EAAEA,CAAA,IAAG,GAAE;kBAAC,IAAID,CAAA,GAAEP,CAAA,IAAG,IAAE,KAAGQ,CAAA;kBAAGD,CAAA,GAAEwB,IAAA,CAAKC,GAAA,CAAIzB,CAAA,EAAER,CAAA,GAAE;kBAAW,IAAIU,CAAA,GAAEsB,IAAA;kBAAKxB,CAAA,GAAEwB,IAAA,CAAKwnB,GAAA,CAAIxpB,CAAA,EAAEQ,CAAA;kBAAGR,CAAA,EAAE;oBAACU,CAAA,GAAEA,CAAA,CAAEuB,GAAA,CAAImjB,IAAA,CAAK1kB,CAAA,EAAE,YAAWF,CAAA,IAAG,QAAMA,CAAA,GAAE,SAAO,SAAO2L,CAAA,CAAEyiB,MAAA,CAAOE,UAAA,GAAW,UAAQ;oBAAG;sBAAI3iB,CAAA,CAAEytD,IAAA,CAAKl5D,CAAA,GAAGqW,CAAA;sBAAK,IAAI9V,CAAA,GAAE;sBAAE,MAAMjB,CAAC;oBAAA,CAAC,QAAMA,CAAA,GAAG;oBAACiB,CAAA,QAAE,CAAM;kBAAA;kBAAC,IAAGA,CAAA,EAAE,QAAM,CAAE;gBAAA;gBAAC,QAAM,CAAE;cAAA;cAAEgW,CAAA,EAAE,SAAAA,CAASjX,CAAA,EAAEC,CAAA;gBAAGD,CAAA,MAClf,GAAEC,CAAA,MAAK;gBAAE,IAAIQ,CAAA,GAAE;gBAA8I,OAA5I+sD,EAAA,GAAK3iD,OAAA,CAAQ,UAASrK,CAAA,EAAEE,CAAA;kBAAG,IAAIO,CAAA,GAAEhB,CAAA,GAAEQ,CAAA;kBAAsB,KAApBC,CAAA,GAAEmW,CAAA,CAAE7W,CAAA,GAAE,IAAEU,CAAA,IAAG,MAAI,KAAGO,CAAA,EAAMA,CAAA,GAAE,GAAEA,CAAA,GAAET,CAAA,CAAEsB,MAAA,IAASb,CAAA,EAAEyV,CAAA,CAAEhW,CAAA,MAAK,MAAI,KAAGF,CAAA,CAAEuyD,UAAA,CAAW9xD,CAAA;kBAAGyV,CAAA,CAAEhW,CAAA,IAAG,MAAI,KAAG,GAAED,CAAA,IAAGD,CAAA,CAAEsB,MAAA,GAAO,CAAC;gBAAA,IAAU,CAAC;cAAA;cAAEkV,CAAA,EAAE,SAAAA,CAAShX,CAAA,EAAEC,CAAA;gBAAGD,CAAA,MAAK,GAAEC,CAAA,MAAK;gBAAE,IAAIQ,CAAA,GAAE+sD,EAAA;gBAAK32C,CAAA,CAAE7W,CAAA,IAAG,MAAI,KAAGS,CAAA,CAAEqB,MAAA;gBAAO,IAAItB,CAAA,GAAE;gBAAsD,OAApDC,CAAA,CAAEoK,OAAA,CAAQ,UAAS7K,CAAA;kBAAGQ,CAAA,IAAGR,CAAA,CAAE8B,MAAA,GAAO,CAAC;gBAAA,IAAG+U,CAAA,CAAE5W,CAAA,IAAG,MAAI,KAAGO,CAAA,EAAS,CAAC;cAAA;cAAE8C,CAAA,EAAEtD,CAAA;gBAAQiM,CAAA,KAAkBvL,CAAA,CAAE+uD,MAAA,IAAO/uD,CAAA,CAAE+uD,MAAA,CAAOzvD,CAAA,GAAG8W,CAAA,IAAE,IAAGzL,CAAA,CAAErL,CAAA,EAAE,IAAIwsD,CAAA,CAAGxsD,CAAA,EAAE;cAAA;cAAGuG,CAAA,EAAEA,CAAA,KAAI;cAAGqjD,CAAA,EAAE,SAAAA,CAAA;gBAAW,OAAO,EAAE;cAAA;cAAEgD,CAAA,EAAE,SAAAA,CAAA;gBAAW,OAAO,EAAE;cAAA;cAAE3rD,CAAA,EAAE,SAAAA,CAASjB,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA;gBAAGP,CAAA,MAAK,GAAEQ,CAAA,MAAK,GAAED,CAAA,MAAK;gBAAE,KAAI,IAAIE,CAAA,GAAE,GAAEO,CAAA,GAAE,GAAEA,CAAA,GAAER,CAAA,EAAEQ,CAAA,IAAI;kBAAC,IAAIC,CAAA,GAAE2V,CAAA,CAAE5W,CAAA,IACpf,MAAI;oBAAGqD,CAAA,GAAEuT,CAAA,CAAE5W,CAAA,GAAE,KAAG,MAAI;kBAAGA,CAAA,IAAG;kBAAE,KAAI,IAAIyD,CAAA,GAAE,GAAEA,CAAA,GAAEJ,CAAA,EAAEI,CAAA,IAAI;oBAAC,IAAI+G,CAAA,GAAEkM,CAAA,CAAEzV,CAAA,GAAEwC,CAAA,KAAI;sBAAG2H,CAAA,GAAEoiD,EAAA,CAAGztD,CAAA;oBAAG,MAAIyK,CAAA,IAAG,OAAKA,CAAA,KAAI,MAAIzK,CAAA,GAAE+L,CAAA,GAAGC,CAAA,EAAG6gD,CAAA,CAAGxhD,CAAA,EAAE,KAAIA,CAAA,CAAEvJ,MAAA,GAAO,KAAGuJ,CAAA,CAAErE,IAAA,CAAKyD,CAAA,CAAE;kBAAA;kBAAC/J,CAAA,IAAG4C,CAAC;gBAAA;gBAAe,OAAduT,CAAA,CAAErW,CAAA,IAAG,MAAI,KAAGE,CAAA,EAAS,CAAC;cAAA;cAAEF,CAAA,EAAE,SAAAA,CAASR,CAAA,EAAEC,CAAA;gBAA8C,OAA3CD,CAAA,MAAK,GAAE8tD,EAAA,CAAGn3C,CAAA,CAAE9B,QAAA,CAAS7U,CAAA,KAAI,GAAEA,CAAA,IAAGC,CAAA,KAAI,OAAK,KAAW,CAAC;cAAA;cAAE0pD,CAAA,EAAE0E,EAAA;cAAGhjD,CAAA,EAAE,SAAAA,CAASrL,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA;gBAAG,OAAO6tD,EAAA,CAAGruD,CAAA,KAAI,GAAEC,CAAA,KAAI,GAAEQ,CAAA,KAAI,GAAED,CAAA,KAAI,EAAE;cAAA;YAAA;YAAA,CAClS;cAAY,SAASR,EAAEA,CAAA;gBAA8G,IAA3GA,CAAA,GAAEA,CAAA,CAAEE,OAAA,EAAQmM,CAAA,GAAErM,CAAA,GAIxC,UAAYA,CAAA;kBAAyB,IAAIC,CAAA,GAAED,CAAA,IAAG,MAAIA,CAAA,OAAM;oBAAES,CAAA,GAAET,CAAA,IAAGC,CAAA,IAAGD,CAAA,CAAEC,CAAA,MAAK;kBAAwH,QAAlLD,CAAA,GAAE6C,MAAA,CAAOC,MAAA,CAAO,CAAC,GAAE9C,CAAA,GAA2C65D,gBAAA,GAAiB55D,CAAA,CAAED,CAAA,CAAE65D,gBAAA,GAAkB75D,CAAA,CAAE+5D,MAAA,GAAOt5D,CAAA,CAAET,CAAA,CAAE+5D,MAAA,GAAQ/5D,CAAA,CAAE0hD,SAAA,GAAUzhD,CAAA,CAAED,CAAA,CAAE0hD,SAAA,GAAW1hD,CAAA,CAAE2hD,UAAA,GAAWlhD,CAAA,CAAET,CAAA,CAAE2hD,UAAA,GAAmB3hD,CAAC;gBAAA,CAJ/J,CAAGA,CAAA,GAAGmM,CAAA,GAAEE,CAAA,CAAEq9C,CAAA,EAAE3yC,CAAA,IAAKE,CAAA,CAAG6kC,OAAA,CAAQzvC,CAAA,CAAE8+C,CAAA,GAAGxqD,CAAA,IAAID,CAAA,CAAEwsD,sBAAA,IAAwBxsD,CAAA,CAAEwsD,sBAAA,CAAuBvsD,CAAA,GAAM,KAAGA,CAAA,KAAI,SAAO+oD,CAAA,KAAI0D,aAAA,CAAc1D,CAAA,GAAGA,CAAA,GAAE,OAAMC,CAAA,GAAG;kBAAC,IAAI1pD,CAAA,GAAE0pD,CAAA;kBAAEA,CAAA,GAAE,MAAK1pD,CAAA,EAAG;gBAAA;gBAAC,OAAOD,CAAC;cAAA;cAAC,IAAIC,CAAA,GAAE;gBAACiB,CAAA,EAAE+tD;cAAA;cAA8D,IAA1DtuD,CAAA,IAAID,CAAA,CAAEwsD,sBAAA,IAAwBxsD,CAAA,CAAEwsD,sBAAA,CAAuBvsD,CAAA,GAAMD,CAAA,CAAEw5D,eAAA,EAAgB;gBAAI,OAAOx5D,CAAA,CAAEw5D,eAAA,CAAgBj6D,CAAA,EAAED,CAAA,CAAE;cAAA,CAAC,QAAMA,CAAA;gBAAGgM,CAAA,CAAE,wDAAsDhM,CAAA,GAAGQ,CAAA,CAAER,CAAA,CAAE;cAAA;cAAA,CAtBzZ,UAAYA,CAAA,EAAEC,CAAA;gBAAG,IAAIQ,CAAA,GAAE2W,CAAA;gBAAE,OAAOvL,CAAA,IAAG,qBAAmBi3C,WAAA,CAAYqX,oBAAA,IAAsBhP,CAAA,CAAG1qD,CAAA,KAAIA,CAAA,CAAEwpD,UAAA,CAAW,cAAY1jD,CAAA,IAAG,qBAAmBwyC,KAAA,GAAMwT,CAAA,CAAG9rD,CAAA,EAAET,CAAA,EAAEC,CAAA,IAAG84C,KAAA,CAAMt4C,CAAA,EAAE;kBAACitD,WAAA,EAAY;gBAAA,GAAgBjtB,IAAA,CAAKjgC,CAAA,IAAGsiD,WAAA,CAAYqX,oBAAA,CAAqB35D,CAAA,EAAER,CAAA,EAAGygC,IAAA,CAAKxgC,CAAA,EAAE,UAASO,CAAA;kBAAyF,OAAtFwL,CAAA,CAAE,oCAAkCxL,CAAA,GAAGwL,CAAA,CAAE,8CAAoDugD,CAAA,CAAG9rD,CAAA,EAAET,CAAA,EAAEC,CAAA,CAAE;gBAAA,GAAG;cAAA,GAsBgDA,CAAA,EAAE,UAASA,CAAA;gBAAGD,CAAA,CAAEC,CAAA,CAAEm6D,QAAA,CAAS;cAAA,GAAGxM,KAAA,CAAMptD,CAAA,CAAY;YAAA,CAA7c,IACAE,CAAA,CAAE4gD,QAAA,GAAS,CAACthD,CAAA,EAAEC,CAAA,MAAKS,CAAA,CAAE4gD,QAAA,GAASj1C,CAAA,CAAEgL,CAAA,EAAGrX,CAAA,EAAEC,CAAA,GAAGS,CAAA,CAAEijD,gBAAA,GAAiB,CAAC3jD,CAAA,EAAEC,CAAA,MAAKS,CAAA,CAAEijD,gBAAA,GAAiBt3C,CAAA,CAAEsK,CAAA,EAAG3W,CAAA,EAAEC,CAAA,GAAGS,CAAA,CAAE+/C,wBAAA,GAAyB,CAACzgD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAES,CAAA,EAAEC,CAAA,EAAEoC,CAAA,EAAEI,CAAA,EAAE+G,CAAA,EAAEY,CAAA,MAAK3K,CAAA,CAAE+/C,wBAAA,GAAyBp0C,CAAA,CAAEyK,CAAA,EAAG9W,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAES,CAAA,EAAEC,CAAA,EAAEoC,CAAA,EAAEI,CAAA,EAAE+G,CAAA,EAAEY,CAAA,GAAG3K,CAAA,CAAEqgD,2BAAA,GAA4B,CAAC/gD,CAAA,EAAEC,CAAA,MAAKS,CAAA,CAAEqgD,2BAAA,GAA4B10C,CAAA,CAAE4gD,CAAA,EAAGjtD,CAAA,EAAEC,CAAA,GAAGS,CAAA,CAAEmgD,yBAAA,GAA0B,CAAC7gD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,MAAKC,CAAA,CAAEmgD,yBAAA,GAA0Bx0C,CAAA,CAAE1L,CAAA,EAAGX,CAAA,EAAEC,CAAA,EAAEQ,CAAA,GAAGC,CAAA,CAAEsgD,yBAAA,GAA0BhhD,CAAA,KAAIU,CAAA,CAAEsgD,yBAAA,GAA0B30C,CAAA,CAAEuK,CAAA,EAAG5W,CAAA,GAAGU,CAAA,CAAE+gD,iBAAA,GAAkB,CAACzhD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,MAAKC,CAAA,CAAE+gD,iBAAA,GAAkBp1C,CAAA,CAAEA,CAAA,EAAGrM,CAAA,EAAEC,CAAA,EAAEQ,CAAA,GACneC,CAAA,CAAEyhD,kBAAA,GAAmBniD,CAAA,KAAIU,CAAA,CAAEyhD,kBAAA,GAAmB91C,CAAA,CAAEo9C,CAAA,EAAGzpD,CAAA,GAAGU,CAAA,CAAEkhD,uBAAA,GAAwB,CAAC5hD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,MAAKC,CAAA,CAAEkhD,uBAAA,GAAwBv1C,CAAA,CAAEkgD,CAAA,EAAGvsD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,GAAGC,CAAA,CAAEqhD,gBAAA,GAAiB,CAAC/hD,CAAA,EAAEC,CAAA,MAAKS,CAAA,CAAEqhD,gBAAA,GAAiB11C,CAAA,CAAEsgD,CAAA,EAAG3sD,CAAA,EAAEC,CAAA,GAAGS,CAAA,CAAEuhD,iBAAA,GAAkB,CAACjiD,CAAA,EAAEC,CAAA,MAAKS,CAAA,CAAEuhD,iBAAA,GAAkB51C,CAAA,CAAEwgD,CAAA,EAAG7sD,CAAA,EAAEC,CAAA,GAAGS,CAAA,CAAEwhD,QAAA,GAASliD,CAAA,KAAIU,CAAA,CAAEwhD,QAAA,GAAS71C,CAAA,CAAEygD,CAAA,EAAG9sD,CAAA,GAAGU,CAAA,CAAE2hD,gBAAA,GAAiB,CAACriD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAES,CAAA,MAAKP,CAAA,CAAE2hD,gBAAA,GAAiBh2C,CAAA,CAAE2xC,CAAA,EAAGh+C,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAES,CAAA,GAAGP,CAAA,CAAE8hD,iBAAA,GAAkB,CAACxiD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAES,CAAA,MAAKP,CAAA,CAAE8hD,iBAAA,GAAkBn2C,CAAA,CAAEJ,CAAA,EAAGjM,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAES,CAAA,GAAGP,CAAA,CAAE+hD,iBAAA,GAAkBziD,CAAA,KAAIU,CAAA,CAAE+hD,iBAAA,GAAkBp2C,CAAA,CAAE6K,CAAA,EAAGlX,CAAA,GAC/cU,CAAA,CAAE6+C,oBAAA,GAAqB,CAACv/C,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,MAAKE,CAAA,CAAE6+C,oBAAA,GAAqBlzC,CAAA,CAAEguD,EAAA,EAAIr6D,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,GAAGE,CAAA,CAAEk/C,qBAAA,GAAsB,CAAC5/C,CAAA,EAAEC,CAAA,EAAEQ,CAAA,MAAKC,CAAA,CAAEk/C,qBAAA,GAAsBvzC,CAAA,CAAEiuD,EAAA,EAAIt6D,CAAA,EAAEC,CAAA,EAAEQ,CAAA,GAAGC,CAAA,CAAEm/C,qBAAA,GAAsB7/C,CAAA,KAAIU,CAAA,CAAEm/C,qBAAA,GAAsBxzC,CAAA,CAAEkuD,EAAA,EAAIv6D,CAAA,GAAGU,CAAA,CAAE4hD,OAAA,GAAQ,CAACtiD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAES,CAAA,EAAEC,CAAA,EAAEoC,CAAA,EAAEI,CAAA,MAAKhD,CAAA,CAAE4hD,OAAA,GAAQj2C,CAAA,CAAEmuD,EAAA,EAAIx6D,CAAA,EAAEC,CAAA,EAAEQ,CAAA,EAAED,CAAA,EAAES,CAAA,EAAEC,CAAA,EAAEoC,CAAA,EAAEI,CAAA,GAAGhD,CAAA,CAAEgiD,gBAAA,GAAiB1iD,CAAA,KAAIU,CAAA,CAAEgiD,gBAAA,GAAiBr2C,CAAA,CAAEouD,EAAA,EAAIz6D,CAAA;YAAG,IAAIkvD,EAAA,GAAGxuD,CAAA,CAAE6gD,OAAA,GAAQvhD,CAAA,KAAIkvD,EAAA,GAAGxuD,CAAA,CAAE6gD,OAAA,GAAQl1C,CAAA,CAAEquD,EAAA,EAAI16D,CAAA;YAAGU,CAAA,CAAEo/C,KAAA,GAAM9/C,CAAA,KAAIU,CAAA,CAAEo/C,KAAA,GAAMzzC,CAAA,CAAEsuD,EAAA,EAAI36D,CAAA;YAAG,IAChEqvD,EAAA;cADoEC,EAAA,GAAGtvD,CAAA,KAAIsvD,EAAA,GAAGjjD,CAAA,CAAEwuD,EAAA,EAAI76D,CAAA;cAAGmvD,EAAA,GAAGU,CAAA,MAAKV,EAAA,GAAG9iD,CAAA,CAAEyuD,EAAA;cAAM5M,EAAA,GAAGluD,CAAA,KAAIkuD,EAAA,GAAG7hD,CAAA,CAAE0uD,EAAA,EAAI/6D,CAAA;cAAG6xD,EAAA,GAAG7xD,CAAA,KAAI6xD,EAAA,GAAGxlD,CAAA,CAAE2uD,EAAA,EAAIh7D,CAAA;YAEpd,SAAS0vD,GAAA;cAAK,SAAS1vD,EAAA;gBAAI,KAAIqvD,EAAA,KAAIA,EAAA,IAAE,GAAG3uD,CAAA,CAAEg8D,SAAA,IAAU,IAAI5lD,CAAA,GAAG;kBAAgE,IAA/D21C,CAAA,CAAEx1C,CAAA,GAAIhX,CAAA,CAAGS,CAAA,GAAMA,CAAA,CAAEi8D,oBAAA,IAAqBj8D,CAAA,CAAEi8D,oBAAA,IAA0Bj8D,CAAA,CAAEk8D,OAAA,EAAQ,KAAI,qBAAmBl8D,CAAA,CAAEk8D,OAAA,KAAUl8D,CAAA,CAAEk8D,OAAA,GAAQ,CAACl8D,CAAA,CAAEk8D,OAAA,IAAUl8D,CAAA,CAAEk8D,OAAA,CAAQ96D,MAAA,GAAQ;oBAAC,IAAI9B,CAAA,GAAEU,CAAA,CAAEk8D,OAAA,CAAQpf,KAAA;oBAAQtmC,CAAA,CAAG4kC,OAAA,CAAQ97C,CAAA,CAAE;kBAAA;kBAACysD,CAAA,CAAEv1C,CAAA,CAAG;gBAAA;cAAC;cAAC,MAAK,IAAEvW,CAAA,GAAG;gBAAC,IAAGD,CAAA,CAAEo8D,MAAA,EAAO,KAAI,qBAAmBp8D,CAAA,CAAEo8D,MAAA,KAASp8D,CAAA,CAAEo8D,MAAA,GAAO,CAACp8D,CAAA,CAAEo8D,MAAA,IAASp8D,CAAA,CAAEo8D,MAAA,CAAOh7D,MAAA,GAAQqV,CAAA;gBAAKs1C,CAAA,CAAEz1C,CAAA,GAAI,IAAErW,CAAA,KAAID,CAAA,CAAEq8D,SAAA,IAAWr8D,CAAA,CAAEq8D,SAAA,CAAU,eAAc7rC,UAAA,CAAW;kBAAWA,UAAA,CAAW;oBAAWxwB,CAAA,CAAEq8D,SAAA,CAAU,GAAG;kBAAA,GAAE,IAAG/8D,CAAA,EAAG;gBAAA,GAAE,MAAIA,CAAA,GAAI;cAAA;YAAC;YACve,IAF0MU,CAAA,CAAEihD,UAAA,GAAWkQ,EAAA,EAAGnxD,CAAA,CAAEghD,SAAA,GAAUyN,EAAA,EAAGzuD,CAAA,CAAEohD,YAAA,GAAaoM,EAAA,EAAGxtD,CAAA,CAAEshD,YAAA,GAAa8K,CAAA,EAAEpsD,CAAA,CAAEgjD,YAAA,GAAa,CAAC1jD,CAAA,EAAEC,CAAA,EAAEQ,CAAA,KAAIusD,CAAA,CAAEhtD,CAAA,EAAE2W,CAAA,EAAE1W,CAAA,EAAEQ,CAAA,GAAGC,CAAA,CAAE+iD,eAAA,GAAgBsJ,CAAA,EAAQpD,CAAA,GAAE,SAAS3pD,EAAA;cAAKqvD,EAAA,IAAGK,EAAA,IAAKL,EAAA,KAAI1F,CAAA,GAAE3pD,CAAA,CAAG;YAAA,GAEvWU,CAAA,CAAEw8D,OAAA,EAAQ,KAAI,qBAAmBx8D,CAAA,CAAEw8D,OAAA,KAAUx8D,CAAA,CAAEw8D,OAAA,GAAQ,CAACx8D,CAAA,CAAEw8D,OAAA,IAAU,IAAEx8D,CAAA,CAAEw8D,OAAA,CAAQp7D,MAAA,GAAQpB,CAAA,CAAEw8D,OAAA,CAAQ/sC,GAAA,EAAV;YAGzF,OAH2Gu/B,EAAA,IAGpG1vD,CAAA,CAAU6pD,KAGnB;UAAA;QAGE7pD,CAAA,CAAOE,OAAA,GAAUM,C;;;;;QClDnBR,CAAA,CAAOE,OAAA,GAmBP,UAAmBF,CAAA,EAAIC,CAAA;UAKnB,KAJA,IAAIQ,CAAA,GAAU,IAAIuF,KAAA,CAAM8uD,SAAA,CAAUhzD,MAAA,GAAS,IACvCtB,CAAA,GAAU,GACVE,CAAA,GAAU,GACVO,CAAA,IAAU,GACPP,CAAA,GAAQo0D,SAAA,CAAUhzD,MAAA,GACrBrB,CAAA,CAAOD,CAAA,MAAYs0D,SAAA,CAAUp0D,CAAA;UACjC,OAAO,IAAI4B,OAAA,CAAQ,UAAkB5B,CAAA,EAASQ,CAAA;YAC1CT,CAAA,CAAOD,CAAA,IAAU,UAAkBR,CAAA;cAC/B,IAAIiB,CAAA,EAEA,IADAA,CAAA,IAAU,GACNjB,CAAA,EACAkB,CAAA,CAAOlB,CAAA,OACN;gBAGD,KAFA,IAAIC,CAAA,GAAS,IAAI+F,KAAA,CAAM8uD,SAAA,CAAUhzD,MAAA,GAAS,IACtCrB,CAAA,GAAS,GACNA,CAAA,GAASR,CAAA,CAAO6B,MAAA,GACnB7B,CAAA,CAAOQ,CAAA,MAAYq0D,SAAA,CAAUr0D,CAAA;gBACjCC,CAAA,CAAQi5D,KAAA,CAAM,MAAM15D,CAAA,CACxB;cAAA;YAER;YACA;cACID,CAAA,CAAG25D,KAAA,CAAM15D,CAAA,IAAO,MAAMQ,CAAA,CAC1B;YAAA,CAAE,QAAOT,CAAA;cACDiB,CAAA,KACAA,CAAA,IAAU,GACVC,CAAA,CAAOlB,CAAA,EAEf;YAAA;UACJ,EACJ;QAAA,C;;;;;QC5CA,IAAIS,CAAA,GAASR,CAAA;QAObQ,CAAA,CAAOqB,MAAA,GAAS,UAAgB9B,CAAA;UAC5B,IAAIC,CAAA,GAAID,CAAA,CAAO8B,MAAA;UACf,KAAK7B,CAAA,EACD,OAAO;UAEX,KADA,IAAIQ,CAAA,GAAI,KACCR,CAAA,GAAI,IAAI,KAA0B,QAArBD,CAAA,CAAOmxB,MAAA,CAAOlxB,CAAA,MAC9BQ,CAAA;UACN,OAAOuB,IAAA,CAAKE,IAAA,CAAqB,IAAhBlC,CAAA,CAAO8B,MAAA,IAAc,IAAIrB,CAC9C;QAAA;QASA,KANA,IAAID,CAAA,GAAM,IAAIwF,KAAA,CAAM,KAGhBtF,CAAA,GAAM,IAAIsF,KAAA,CAAM,MAGX/E,CAAA,GAAI,GAAGA,CAAA,GAAI,KAChBP,CAAA,CAAIF,CAAA,CAAIS,CAAA,IAAKA,CAAA,GAAI,KAAKA,CAAA,GAAI,KAAKA,CAAA,GAAI,KAAKA,CAAA,GAAI,KAAKA,CAAA,GAAI,KAAKA,CAAA,GAAI,IAAIA,CAAA,GAAI,KAAK,MAAMA,CAAA;QASrFR,CAAA,CAAOyO,MAAA,GAAS,UAAgBlP,CAAA,EAAQC,CAAA,EAAOQ,CAAA;UAM3C,KALA,IAIIC,CAAA,EAJAO,CAAA,GAAQ,MACRC,CAAA,GAAQ,IACRoC,CAAA,GAAI,GACJI,CAAA,GAAI,GAEDzD,CAAA,GAAQQ,CAAA,GAAK;YAChB,IAAIgK,CAAA,GAAIzK,CAAA,CAAOC,CAAA;YACf,QAAQyD,CAAA;cACJ,KAAK;gBACDxC,CAAA,CAAMoC,CAAA,MAAO9C,CAAA,CAAIiK,CAAA,IAAK,IACtB/J,CAAA,IAAS,IAAJ+J,CAAA,KAAU,GACf/G,CAAA,GAAI;gBACJ;cACJ,KAAK;gBACDxC,CAAA,CAAMoC,CAAA,MAAO9C,CAAA,CAAIE,CAAA,GAAI+J,CAAA,IAAK,IAC1B/J,CAAA,IAAS,KAAJ+J,CAAA,KAAW,GAChB/G,CAAA,GAAI;gBACJ;cACJ,KAAK;gBACDxC,CAAA,CAAMoC,CAAA,MAAO9C,CAAA,CAAIE,CAAA,GAAI+J,CAAA,IAAK,IAC1BvJ,CAAA,CAAMoC,CAAA,MAAO9C,CAAA,CAAQ,KAAJiK,CAAA,GACjB/G,CAAA,GAAI;YAAA;YAGRJ,CAAA,GAAI,UACHrC,CAAA,KAAUA,CAAA,GAAQ,KAAK+F,IAAA,CAAKo/C,MAAA,CAAOgJ,YAAA,CAAauK,KAAA,CAAMvT,MAAA,EAAQllD,CAAA,IAC/DoC,CAAA,GAAI,EAEZ;UAAA;UAOA,OANII,CAAA,KACAxC,CAAA,CAAMoC,CAAA,MAAO9C,CAAA,CAAIE,CAAA,GACjBQ,CAAA,CAAMoC,CAAA,MAAO,IACH,MAANI,CAAA,KACAxC,CAAA,CAAMoC,CAAA,MAAO,MAEjBrC,CAAA,IACIqC,CAAA,IACArC,CAAA,CAAM+F,IAAA,CAAKo/C,MAAA,CAAOgJ,YAAA,CAAauK,KAAA,CAAMvT,MAAA,EAAQllD,CAAA,CAAMgM,KAAA,CAAM,GAAG5J,CAAA,KACzDrC,CAAA,CAAMmC,IAAA,CAAK,OAEfgjD,MAAA,CAAOgJ,YAAA,CAAauK,KAAA,CAAMvT,MAAA,EAAQllD,CAAA,CAAMgM,KAAA,CAAM,GAAG5J,CAAA,EAC5D;QAAA;QAEA,IAAIpC,CAAA,GAAkB;QAUtBT,CAAA,CAAO0O,MAAA,GAAS,UAAgBnP,CAAA,EAAQC,CAAA,EAAQQ,CAAA;UAI5C,KAHA,IAEID,CAAA,EAFAS,CAAA,GAAQR,CAAA,EACR6C,CAAA,GAAI,GAECI,CAAA,GAAI,GAAGA,CAAA,GAAI1D,CAAA,CAAO8B,MAAA,GAAS;YAChC,IAAI2I,CAAA,GAAIzK,CAAA,CAAO+yD,UAAA,CAAWrvD,CAAA;YAC1B,IAAU,OAAN+G,CAAA,IAAYnH,CAAA,GAAI,GAChB;YACJ,SAAqB,OAAhBmH,CAAA,GAAI/J,CAAA,CAAI+J,CAAA,IACT,MAAMpG,KAAA,CAAMnD,CAAA;YAChB,QAAQoC,CAAA;cACJ,KAAK;gBACD9C,CAAA,GAAIiK,CAAA,EACJnH,CAAA,GAAI;gBACJ;cACJ,KAAK;gBACDrD,CAAA,CAAOQ,CAAA,MAAYD,CAAA,IAAK,KAAS,KAAJiK,CAAA,KAAW,GACxCjK,CAAA,GAAIiK,CAAA,EACJnH,CAAA,GAAI;gBACJ;cACJ,KAAK;gBACDrD,CAAA,CAAOQ,CAAA,OAAiB,KAAJD,CAAA,KAAW,KAAS,KAAJiK,CAAA,KAAW,GAC/CjK,CAAA,GAAIiK,CAAA,EACJnH,CAAA,GAAI;gBACJ;cACJ,KAAK;gBACDrD,CAAA,CAAOQ,CAAA,OAAiB,IAAJD,CAAA,KAAU,IAAIiK,CAAA,EAClCnH,CAAA,GAAI;YAAA;UAGhB;UACA,IAAU,MAANA,CAAA,EACA,MAAMe,KAAA,CAAMnD,CAAA;UAChB,OAAOT,CAAA,GAASQ,CACpB;QAAA,GAOAR,CAAA,CAAO28D,IAAA,GAAO,UAAcp9D,CAAA;UACxB,OAAO,mEAAmEo9D,IAAA,CAAKp9D,CAAA,CACnF;QAAA,C;;;;;QCjIA,SAASC,EAAA;UAOL,KAAKo9D,UAAA,GAAa,CAAC,CACvB;QAAA;QAhBAr9D,CAAA,CAAOE,OAAA,GAAUD,CAAA,EAyBjBA,CAAA,CAAa4kD,SAAA,CAAU2M,EAAA,GAAK,UAAYxxD,CAAA,EAAKC,CAAA,EAAIQ,CAAA;UAK7C,QAJC,KAAK48D,UAAA,CAAWr9D,CAAA,MAAS,KAAKq9D,UAAA,CAAWr9D,CAAA,IAAO,KAAKgH,IAAA,CAAK;YACvDs2D,EAAA,EAAMr9D,CAAA;YACNm/B,GAAA,EAAM3+B,CAAA,IAAO;UAAA,IAEV,IACX;QAAA,GAQAR,CAAA,CAAa4kD,SAAA,CAAU0Y,GAAA,GAAM,UAAav9D,CAAA,EAAKC,CAAA;UAC3C,SAAY,MAARD,CAAA,EACA,KAAKq9D,UAAA,GAAa,CAAC,OAEnB,SAAW,MAAPp9D,CAAA,EACA,KAAKo9D,UAAA,CAAWr9D,CAAA,IAAO,QAGvB,KADA,IAAIS,CAAA,GAAY,KAAK48D,UAAA,CAAWr9D,CAAA,GACvBQ,CAAA,GAAI,GAAGA,CAAA,GAAIC,CAAA,CAAUqB,MAAA,GACtBrB,CAAA,CAAUD,CAAA,EAAG88D,EAAA,KAAOr9D,CAAA,GACpBQ,CAAA,CAAUgwB,MAAA,CAAOjwB,CAAA,EAAG,OAElBA,CAAA;UAGlB,OAAO,IACX;QAAA,GAQAP,CAAA,CAAa4kD,SAAA,CAAU2Y,IAAA,GAAO,UAAcx9D,CAAA;UACxC,IAAIC,CAAA,GAAY,KAAKo9D,UAAA,CAAWr9D,CAAA;UAChC,IAAIC,CAAA,EAAW;YAGX,KAFA,IAAIQ,CAAA,GAAO,IACPD,CAAA,GAAI,GACDA,CAAA,GAAIs0D,SAAA,CAAUhzD,MAAA,GACjBrB,CAAA,CAAKuG,IAAA,CAAK8tD,SAAA,CAAUt0D,CAAA;YACxB,KAAKA,CAAA,GAAI,GAAGA,CAAA,GAAIP,CAAA,CAAU6B,MAAA,GACtB7B,CAAA,CAAUO,CAAA,EAAG88D,EAAA,CAAG3D,KAAA,CAAM15D,CAAA,CAAUO,CAAA,IAAK4+B,GAAA,EAAK3+B,CAAA,CAClD;UAAA;UACA,OAAO,IACX;QAAA,C;;;;;QCYA,SAASR,EAAQD,CAAA;UAwNb,OArN4B,sBAAjB4U,YAAA,GAA8B;YAErC,IAAI3U,CAAA,GAAM,IAAI2U,YAAA,CAAa,EAAG;cAC1BnU,CAAA,GAAM,IAAIgP,UAAA,CAAWxP,CAAA,CAAI2uB,MAAA;cACzBpuB,CAAA,GAAiB,QAAXC,CAAA,CAAI;YAEd,SAASC,EAAmBV,CAAA,EAAKQ,CAAA,EAAKE,CAAA;cAClCT,CAAA,CAAI,KAAKD,CAAA,EACTQ,CAAA,CAAIE,CAAA,IAAWD,CAAA,CAAI,IACnBD,CAAA,CAAIE,CAAA,GAAM,KAAKD,CAAA,CAAI,IACnBD,CAAA,CAAIE,CAAA,GAAM,KAAKD,CAAA,CAAI,IACnBD,CAAA,CAAIE,CAAA,GAAM,KAAKD,CAAA,CAAI,EACvB;YAAA;YAEA,SAASQ,EAAmBjB,CAAA,EAAKQ,CAAA,EAAKE,CAAA;cAClCT,CAAA,CAAI,KAAKD,CAAA,EACTQ,CAAA,CAAIE,CAAA,IAAWD,CAAA,CAAI,IACnBD,CAAA,CAAIE,CAAA,GAAM,KAAKD,CAAA,CAAI,IACnBD,CAAA,CAAIE,CAAA,GAAM,KAAKD,CAAA,CAAI,IACnBD,CAAA,CAAIE,CAAA,GAAM,KAAKD,CAAA,CAAI,EACvB;YAAA;YAOA,SAASS,EAAkBlB,CAAA,EAAKQ,CAAA;cAK5B,OAJAC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GACbC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GAAM,IACnBC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GAAM,IACnBC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GAAM,IACZP,CAAA,CAAI,EACf;YAAA;YAEA,SAASqD,EAAkBtD,CAAA,EAAKQ,CAAA;cAK5B,OAJAC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GACbC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GAAM,IACnBC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GAAM,IACnBC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GAAM,IACZP,CAAA,CAAI,EACf;YAAA;YAlBAD,CAAA,CAAQy9D,YAAA,GAAej9D,CAAA,GAAKE,CAAA,GAAqBO,CAAA,EAEjDjB,CAAA,CAAQ09D,YAAA,GAAel9D,CAAA,GAAKS,CAAA,GAAqBP,CAAA,EAmBjDV,CAAA,CAAQ29D,WAAA,GAAcn9D,CAAA,GAAKU,CAAA,GAAoBoC,CAAA,EAE/CtD,CAAA,CAAQ49D,WAAA,GAAcp9D,CAAA,GAAK8C,CAAA,GAAoBpC,CAGlD;UAAA,CAjDwC,KAiD9B;YAEP,SAASjB,EAAmBD,CAAA,EAAWC,CAAA,EAAKQ,CAAA,EAAKD,CAAA;cAC7C,IAAIE,CAAA,GAAOT,CAAA,GAAM,IAAI,IAAI;cAGzB,IAFIS,CAAA,KACAT,CAAA,IAAOA,CAAA,GACC,MAARA,CAAA,EACAD,CAAA,CAAU,IAAIC,CAAA,GAAM,IAAmB,IAAqB,YAAYQ,CAAA,EAAKD,CAAA,OAC5E,IAAI4hC,KAAA,CAAMniC,CAAA,GACXD,CAAA,CAAU,YAAYS,CAAA,EAAKD,CAAA,OAC1B,IAAIP,CAAA,GAAM,sBACXD,CAAA,EAAWU,CAAA,IAAQ,KAAK,gBAAgB,GAAGD,CAAA,EAAKD,CAAA,OAC/C,IAAIP,CAAA,GAAM,uBACXD,CAAA,EAAWU,CAAA,IAAQ,KAAKsB,IAAA,CAAK67D,KAAA,CAAM59D,CAAA,GAAM,2BAA4B,GAAGQ,CAAA,EAAKD,CAAA,OAC5E;gBACD,IAAIS,CAAA,GAAWe,IAAA,CAAKoX,KAAA,CAAMpX,IAAA,CAAKuY,GAAA,CAAIta,CAAA,IAAO+B,IAAA,CAAK87D,GAAA;gBAE/C99D,CAAA,EAAWU,CAAA,IAAQ,KAAKO,CAAA,GAAW,OAAO,KAD0B,UAArDe,IAAA,CAAK67D,KAAA,CAAM59D,CAAA,GAAM+B,IAAA,CAAKmZ,GAAA,CAAI,IAAIla,CAAA,IAAY,cACI,GAAGR,CAAA,EAAKD,CAAA,CACzE;cAAA;YACJ;YAKA,SAASU,EAAkBlB,CAAA,EAAUC,CAAA,EAAKQ,CAAA;cACtC,IAAID,CAAA,GAAOR,CAAA,CAASC,CAAA,EAAKQ,CAAA;gBACrBC,CAAA,GAAsB,KAAdF,CAAA,IAAQ,MAAU;gBAC1BS,CAAA,GAAWT,CAAA,KAAS,KAAK;gBACzBU,CAAA,GAAkB,UAAPV,CAAA;cACf,OAAoB,QAAbS,CAAA,GACDC,CAAA,GACAq3D,GAAA,GACA73D,CAAA,IAAO,SACM,MAAbO,CAAA,GACO,uBAAPP,CAAA,GAA+BQ,CAAA,GAC/BR,CAAA,GAAOsB,IAAA,CAAKmZ,GAAA,CAAI,GAAGla,CAAA,GAAW,QAAQC,CAAA,GAAW,QAC3D;YAAA;YAfAlB,CAAA,CAAQy9D,YAAA,GAAex9D,CAAA,CAAmB2+B,IAAA,CAAK,MAAMn+B,CAAA,GACrDT,CAAA,CAAQ09D,YAAA,GAAez9D,CAAA,CAAmB2+B,IAAA,CAAK,MAAMp+B,CAAA,GAgBrDR,CAAA,CAAQ29D,WAAA,GAAcz8D,CAAA,CAAkB09B,IAAA,CAAK,MAAMl+B,CAAA,GACnDV,CAAA,CAAQ49D,WAAA,GAAc18D,CAAA,CAAkB09B,IAAA,CAAK,MAAM39B,CAAA,CAEtD;UAAA,CAzCU,IA4CiB,sBAAjB6vB,YAAA,GAA8B;YAErC,IAAI7wB,CAAA,GAAM,IAAI6wB,YAAA,CAAa,EAAE;cACzBrwB,CAAA,GAAM,IAAIgP,UAAA,CAAWxP,CAAA,CAAI2uB,MAAA;cACzBpuB,CAAA,GAAiB,QAAXC,CAAA,CAAI;YAEd,SAASC,EAAoBV,CAAA,EAAKQ,CAAA,EAAKE,CAAA;cACnCT,CAAA,CAAI,KAAKD,CAAA,EACTQ,CAAA,CAAIE,CAAA,IAAWD,CAAA,CAAI,IACnBD,CAAA,CAAIE,CAAA,GAAM,KAAKD,CAAA,CAAI,IACnBD,CAAA,CAAIE,CAAA,GAAM,KAAKD,CAAA,CAAI,IACnBD,CAAA,CAAIE,CAAA,GAAM,KAAKD,CAAA,CAAI,IACnBD,CAAA,CAAIE,CAAA,GAAM,KAAKD,CAAA,CAAI,IACnBD,CAAA,CAAIE,CAAA,GAAM,KAAKD,CAAA,CAAI,IACnBD,CAAA,CAAIE,CAAA,GAAM,KAAKD,CAAA,CAAI,IACnBD,CAAA,CAAIE,CAAA,GAAM,KAAKD,CAAA,CAAI,EACvB;YAAA;YAEA,SAASQ,EAAoBjB,CAAA,EAAKQ,CAAA,EAAKE,CAAA;cACnCT,CAAA,CAAI,KAAKD,CAAA,EACTQ,CAAA,CAAIE,CAAA,IAAWD,CAAA,CAAI,IACnBD,CAAA,CAAIE,CAAA,GAAM,KAAKD,CAAA,CAAI,IACnBD,CAAA,CAAIE,CAAA,GAAM,KAAKD,CAAA,CAAI,IACnBD,CAAA,CAAIE,CAAA,GAAM,KAAKD,CAAA,CAAI,IACnBD,CAAA,CAAIE,CAAA,GAAM,KAAKD,CAAA,CAAI,IACnBD,CAAA,CAAIE,CAAA,GAAM,KAAKD,CAAA,CAAI,IACnBD,CAAA,CAAIE,CAAA,GAAM,KAAKD,CAAA,CAAI,IACnBD,CAAA,CAAIE,CAAA,GAAM,KAAKD,CAAA,CAAI,EACvB;YAAA;YAOA,SAASS,EAAmBlB,CAAA,EAAKQ,CAAA;cAS7B,OARAC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GACbC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GAAM,IACnBC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GAAM,IACnBC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GAAM,IACnBC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GAAM,IACnBC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GAAM,IACnBC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GAAM,IACnBC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GAAM,IACZP,CAAA,CAAI,EACf;YAAA;YAEA,SAASqD,EAAmBtD,CAAA,EAAKQ,CAAA;cAS7B,OARAC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GACbC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GAAM,IACnBC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GAAM,IACnBC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GAAM,IACnBC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GAAM,IACnBC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GAAM,IACnBC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GAAM,IACnBC,CAAA,CAAI,KAAKT,CAAA,CAAIQ,CAAA,GAAM,IACZP,CAAA,CAAI,EACf;YAAA;YA1BAD,CAAA,CAAQ+9D,aAAA,GAAgBv9D,CAAA,GAAKE,CAAA,GAAsBO,CAAA,EAEnDjB,CAAA,CAAQg+D,aAAA,GAAgBx9D,CAAA,GAAKS,CAAA,GAAsBP,CAAA,EA2BnDV,CAAA,CAAQi+D,YAAA,GAAez9D,CAAA,GAAKU,CAAA,GAAqBoC,CAAA,EAEjDtD,CAAA,CAAQk+D,YAAA,GAAe19D,CAAA,GAAK8C,CAAA,GAAqBpC,CAGpD;UAAA,CAjEwC,KAiE9B;YAEP,SAASjB,EAAoBD,CAAA,EAAWC,CAAA,EAAMQ,CAAA,EAAMD,CAAA,EAAKE,CAAA,EAAKO,CAAA;cAC1D,IAAIC,CAAA,GAAOV,CAAA,GAAM,IAAI,IAAI;cAGzB,IAFIU,CAAA,KACAV,CAAA,IAAOA,CAAA,GACC,MAARA,CAAA,EACAR,CAAA,CAAU,GAAGU,CAAA,EAAKO,CAAA,GAAMhB,CAAA,GACxBD,CAAA,CAAU,IAAIQ,CAAA,GAAM,IAAmB,IAAqB,YAAYE,CAAA,EAAKO,CAAA,GAAMR,CAAA,OAChF,IAAI2hC,KAAA,CAAM5hC,CAAA,GACbR,CAAA,CAAU,GAAGU,CAAA,EAAKO,CAAA,GAAMhB,CAAA,GACxBD,CAAA,CAAU,YAAYU,CAAA,EAAKO,CAAA,GAAMR,CAAA,OAC9B,IAAID,CAAA,GAAM,uBACbR,CAAA,CAAU,GAAGU,CAAA,EAAKO,CAAA,GAAMhB,CAAA,GACxBD,CAAA,EAAWkB,CAAA,IAAQ,KAAK,gBAAgB,GAAGR,CAAA,EAAKO,CAAA,GAAMR,CAAA,OACnD;gBACH,IAAI6C,CAAA;gBACJ,IAAI9C,CAAA,GAAM,wBAENR,CAAA,EADAsD,CAAA,GAAW9C,CAAA,GAAM,YACM,GAAGE,CAAA,EAAKO,CAAA,GAAMhB,CAAA,GACrCD,CAAA,EAAWkB,CAAA,IAAQ,KAAKoC,CAAA,GAAW,gBAAgB,GAAG5C,CAAA,EAAKO,CAAA,GAAMR,CAAA,OAC9D;kBACH,IAAIiD,CAAA,GAAW1B,IAAA,CAAKoX,KAAA,CAAMpX,IAAA,CAAKuY,GAAA,CAAI/Z,CAAA,IAAOwB,IAAA,CAAK87D,GAAA;kBAC9B,SAAbp6D,CAAA,KACAA,CAAA,GAAW,OAEf1D,CAAA,CAAqB,oBADrBsD,CAAA,GAAW9C,CAAA,GAAMwB,IAAA,CAAKmZ,GAAA,CAAI,IAAIzX,CAAA,OACY,GAAGhD,CAAA,EAAKO,CAAA,GAAMhB,CAAA,GACxDD,CAAA,EAAWkB,CAAA,IAAQ,KAAKwC,CAAA,GAAW,QAAQ,KAAgB,UAAXJ,CAAA,GAAqB,aAAa,GAAG5C,CAAA,EAAKO,CAAA,GAAMR,CAAA,CACpG;gBAAA;cACJ;YACJ;YAKA,SAASS,EAAmBlB,CAAA,EAAUC,CAAA,EAAMQ,CAAA,EAAMD,CAAA,EAAKE,CAAA;cACnD,IAAIO,CAAA,GAAKjB,CAAA,CAASQ,CAAA,EAAKE,CAAA,GAAMT,CAAA;gBACzBiB,CAAA,GAAKlB,CAAA,CAASQ,CAAA,EAAKE,CAAA,GAAMD,CAAA;gBACzB6C,CAAA,GAAoB,KAAZpC,CAAA,IAAM,MAAU;gBACxBwC,CAAA,GAAWxC,CAAA,KAAO,KAAK;gBACvBuJ,CAAA,GAAW,cAAmB,UAALvJ,CAAA,IAAgBD,CAAA;cAC7C,OAAoB,SAAbyC,CAAA,GACD+G,CAAA,GACA8tD,GAAA,GACAj1D,CAAA,IAAO,SACM,MAAbI,CAAA,GACO,SAAPJ,CAAA,GAAgBmH,CAAA,GAChBnH,CAAA,GAAOtB,IAAA,CAAKmZ,GAAA,CAAI,GAAGzX,CAAA,GAAW,SAAS+G,CAAA,GAAW,iBAC5D;YAAA;YAhBAzK,CAAA,CAAQ+9D,aAAA,GAAgB99D,CAAA,CAAoB2+B,IAAA,CAAK,MAAMn+B,CAAA,EAAa,GAAG,IACvET,CAAA,CAAQg+D,aAAA,GAAgB/9D,CAAA,CAAoB2+B,IAAA,CAAK,MAAMp+B,CAAA,EAAa,GAAG,IAiBvER,CAAA,CAAQi+D,YAAA,GAAe/8D,CAAA,CAAmB09B,IAAA,CAAK,MAAMl+B,CAAA,EAAY,GAAG,IACpEV,CAAA,CAAQk+D,YAAA,GAAeh9D,CAAA,CAAmB09B,IAAA,CAAK,MAAM39B,CAAA,EAAY,GAAG,EAEvE;UAAA,CArDU,IAuDJjB,CACX;QAAA;QAIA,SAASS,EAAYT,CAAA,EAAKC,CAAA,EAAKQ,CAAA;UAC3BR,CAAA,CAAIQ,CAAA,IAAyB,MAAbT,CAAA,EAChBC,CAAA,CAAIQ,CAAA,GAAM,KAAMT,CAAA,KAAQ,IAAK,KAC7BC,CAAA,CAAIQ,CAAA,GAAM,KAAMT,CAAA,KAAQ,KAAK,KAC7BC,CAAA,CAAIQ,CAAA,GAAM,KAAMT,CAAA,KAAQ,EAC5B;QAAA;QAEA,SAASQ,EAAYR,CAAA,EAAKC,CAAA,EAAKQ,CAAA;UAC3BR,CAAA,CAAIQ,CAAA,IAAYT,CAAA,KAAQ,IACxBC,CAAA,CAAIQ,CAAA,GAAM,KAAMT,CAAA,KAAQ,KAAK,KAC7BC,CAAA,CAAIQ,CAAA,GAAM,KAAMT,CAAA,KAAQ,IAAK,KAC7BC,CAAA,CAAIQ,CAAA,GAAM,KAAmB,MAAbT,CACpB;QAAA;QAEA,SAASU,EAAWV,CAAA,EAAKC,CAAA;UACrB,QAAQD,CAAA,CAAIC,CAAA,IACJD,CAAA,CAAIC,CAAA,GAAM,MAAM,IAChBD,CAAA,CAAIC,CAAA,GAAM,MAAM,KAChBD,CAAA,CAAIC,CAAA,GAAM,MAAM,QAAQ,CACpC;QAAA;QAEA,SAASgB,EAAWjB,CAAA,EAAKC,CAAA;UACrB,QAAQD,CAAA,CAAIC,CAAA,KAAY,KAChBD,CAAA,CAAIC,CAAA,GAAM,MAAM,KAChBD,CAAA,CAAIC,CAAA,GAAM,MAAM,IAChBD,CAAA,CAAIC,CAAA,GAAM,QAAQ,CAC9B;QAAA;QA5UAD,CAAA,CAAOE,OAAA,GAAUD,CAAA,CAAQA,CAAA,C;;;;;QCOzB,SAASk+D,QAAQC,UAAA;UACb;YACI,IAAIC,GAAA,GAAMC,IAAA,CAAK,QAAQjuD,OAAA,CAAQ,KAAI,MAAzB,CAAgC+tD,UAAA;YAC1C,IAAIC,GAAA,KAAQA,GAAA,CAAIv8D,MAAA,IAAUe,MAAA,CAAO6N,IAAA,CAAK2tD,GAAA,EAAKv8D,MAAA,GACvC,OAAOu8D,GACf;UAAA,CAAE,QAAOr+D,CAAA,GAAI;UACb,OAAO,IACX;QAAA;QAfAG,MAAA,CAAOD,OAAA,GAAUi+D,O;;;;;QCAjBn+D,CAAA,CAAOE,OAAA,GA6BP,UAAcF,CAAA,EAAOC,CAAA,EAAOQ,CAAA;UACxB,IAAID,CAAA,GAASC,CAAA,IAAQ;YACjBC,CAAA,GAASF,CAAA,KAAS;YAClBS,CAAA,GAAS;YACTC,CAAA,GAASV,CAAA;UACb,OAAO,UAAoBC,CAAA;YACvB,IAAIA,CAAA,GAAO,KAAKA,CAAA,GAAOC,CAAA,EACnB,OAAOV,CAAA,CAAMS,CAAA;YACbS,CAAA,GAAST,CAAA,GAAOD,CAAA,KAChBS,CAAA,GAAOjB,CAAA,CAAMQ,CAAA,GACbU,CAAA,GAAS;YAEb,IAAIoC,CAAA,GAAMrD,CAAA,CAAMmlB,IAAA,CAAKnkB,CAAA,EAAMC,CAAA,EAAQA,CAAA,IAAUT,CAAA;YAG7C,OAFa,IAATS,CAAA,KACAA,CAAA,GAAwB,KAAL,IAATA,CAAA,IACPoC,CACX;UAAA,CACJ;QAAA,C;;;;;QCxCA,IAAI7C,CAAA,GAAOR,CAAA;QAOXQ,CAAA,CAAKqB,MAAA,GAAS,UAAqB9B,CAAA;UAG/B,KAFA,IAAIC,CAAA,GAAM,GACNQ,CAAA,GAAI,GACCD,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAO8B,MAAA,IAAUtB,CAAA,GACjCC,CAAA,GAAIT,CAAA,CAAO+yD,UAAA,CAAWvyD,CAAA,KACd,MACJP,CAAA,IAAO,IACFQ,CAAA,GAAI,OACTR,CAAA,IAAO,IACe,UAAZ,QAAJQ,CAAA,KAAkE,UAAZ,QAA3BT,CAAA,CAAO+yD,UAAA,CAAWvyD,CAAA,GAAI,SACrDA,CAAA,EACFP,CAAA,IAAO,KAEPA,CAAA,IAAO;UAEf,OAAOA,CACX;QAAA,GASAQ,CAAA,CAAK89D,IAAA,GAAO,UAAmBv+D,CAAA,EAAQC,CAAA,EAAOQ,CAAA;UAE1C,IADUA,CAAA,GAAMR,CAAA,GACN,GACN,OAAO;UAKX,KAJA,IAGIO,CAAA,EAHAE,CAAA,GAAQ,MACRO,CAAA,GAAQ,IACRC,CAAA,GAAI,GAEDjB,CAAA,GAAQQ,CAAA,IACXD,CAAA,GAAIR,CAAA,CAAOC,CAAA,OACH,MACJgB,CAAA,CAAMC,CAAA,MAAOV,CAAA,GACRA,CAAA,GAAI,OAAOA,CAAA,GAAI,MACpBS,CAAA,CAAMC,CAAA,OAAY,KAAJV,CAAA,KAAW,IAAsB,KAAlBR,CAAA,CAAOC,CAAA,MAC/BO,CAAA,GAAI,OAAOA,CAAA,GAAI,OACpBA,CAAA,KAAU,IAAJA,CAAA,KAAU,MAAwB,KAAlBR,CAAA,CAAOC,CAAA,QAAkB,MAAwB,KAAlBD,CAAA,CAAOC,CAAA,QAAkB,IAAsB,KAAlBD,CAAA,CAAOC,CAAA,OAAiB,OAC1GgB,CAAA,CAAMC,CAAA,MAAO,SAAUV,CAAA,IAAK,KAC5BS,CAAA,CAAMC,CAAA,MAAO,SAAc,OAAJV,CAAA,KAEvBS,CAAA,CAAMC,CAAA,OAAY,KAAJV,CAAA,KAAW,MAAwB,KAAlBR,CAAA,CAAOC,CAAA,QAAkB,IAAsB,KAAlBD,CAAA,CAAOC,CAAA,KACnEiB,CAAA,GAAI,UACHR,CAAA,KAAUA,CAAA,GAAQ,KAAKsG,IAAA,CAAKo/C,MAAA,CAAOgJ,YAAA,CAAauK,KAAA,CAAMvT,MAAA,EAAQnlD,CAAA,IAC/DC,CAAA,GAAI;UAGZ,OAAIR,CAAA,IACIQ,CAAA,IACAR,CAAA,CAAMsG,IAAA,CAAKo/C,MAAA,CAAOgJ,YAAA,CAAauK,KAAA,CAAMvT,MAAA,EAAQnlD,CAAA,CAAMiM,KAAA,CAAM,GAAGhM,CAAA,KACzDR,CAAA,CAAM0C,IAAA,CAAK,OAEfgjD,MAAA,CAAOgJ,YAAA,CAAauK,KAAA,CAAMvT,MAAA,EAAQnlD,CAAA,CAAMiM,KAAA,CAAM,GAAGhM,CAAA,EAC5D;QAAA,GASAT,CAAA,CAAK+9D,KAAA,GAAQ,UAAoBx+D,CAAA,EAAQC,CAAA,EAAQQ,CAAA;UAI7C,KAHA,IACID,CAAA,EACAE,CAAA,EAFAO,CAAA,GAAQR,CAAA,EAGHS,CAAA,GAAI,GAAGA,CAAA,GAAIlB,CAAA,CAAO8B,MAAA,IAAUZ,CAAA,GACjCV,CAAA,GAAKR,CAAA,CAAO+yD,UAAA,CAAW7xD,CAAA,KACd,MACLjB,CAAA,CAAOQ,CAAA,MAAYD,CAAA,GACZA,CAAA,GAAK,QACZP,CAAA,CAAOQ,CAAA,MAAYD,CAAA,IAAM,IAAU,KACnCP,CAAA,CAAOQ,CAAA,MAAuB,KAAXD,CAAA,GAAgB,OACV,UAAZ,QAALA,CAAA,KAA0E,UAAZ,SAAjCE,CAAA,GAAKV,CAAA,CAAO+yD,UAAA,CAAW7xD,CAAA,GAAI,QAChEV,CAAA,GAAK,UAAiB,OAALA,CAAA,KAAgB,OAAY,OAALE,CAAA,KACtCQ,CAAA,EACFjB,CAAA,CAAOQ,CAAA,MAAYD,CAAA,IAAM,KAAU,KACnCP,CAAA,CAAOQ,CAAA,MAAYD,CAAA,IAAM,KAAK,KAAK,KACnCP,CAAA,CAAOQ,CAAA,MAAYD,CAAA,IAAM,IAAK,KAAK,KACnCP,CAAA,CAAOQ,CAAA,MAAuB,KAAXD,CAAA,GAAgB,QAEnCP,CAAA,CAAOQ,CAAA,MAAYD,CAAA,IAAM,KAAU,KACnCP,CAAA,CAAOQ,CAAA,MAAYD,CAAA,IAAM,IAAK,KAAK,KACnCP,CAAA,CAAOQ,CAAA,MAAuB,KAAXD,CAAA,GAAgB;UAG3C,OAAOC,CAAA,GAASQ,CACpB;QAAA,C;;;;;QCvGAhB,CAAA,CAAQw+D,UAAA,IAAa;QACrB,IAAIh+D,CAAA,GAAsB;UACtB,SAAST,EAAKC,CAAA;YACV,KAAKA,CAAA,EACD,MAAM,IAAI8hB,SAAA,CAAU;YAExB,KAAKoC,KAAA,GAAQnkB,CAAA,CAAK0+D,KAAA,EACdz+D,CAAA,IAAQD,CAAA,CAAK2+D,MAAA,CAAO1+D,CAAA,MACpB,KAAKkkB,KAAA,GAAQlkB,CAAA,CAErB;UAAA;UA2CA,OA1CAD,CAAA,CAAK2+D,MAAA,GAAS,UAAU1+D,CAAA;YACpB,IAAIQ,CAAA,GAAQR,CAAA,CAAKs2B,QAAA;YACjB,OAAOt2B,CAAA,KAASA,CAAA,YAAgBD,CAAA,IAAQA,CAAA,CAAK4+D,SAAA,CAAUxB,IAAA,CAAK38D,CAAA,EAChE;UAAA,GACAT,CAAA,CAAKy/B,MAAA,GAAS;YACV,OAAO,IAAIz/B,CAAA,CAAK,CAACA,CAAA,CAAK6+D,GAAA,CAAI,IAAI7+D,CAAA,CAAK6+D,GAAA,CAAI,IAAI7+D,CAAA,CAAK6+D,GAAA,CAAI,IAAI7+D,CAAA,CAAK6+D,GAAA,CAAI,IAAI7+D,CAAA,CAAK6+D,GAAA,CAAI,IAAIz7D,IAAA,CAAK,KAC3F;UAAA,GACApD,CAAA,CAAK8+D,WAAA,GAAc;YACf,OAAO,IAAI9+D,CAAA,CAAK,YACpB;UAAA,GACAA,CAAA,CAAKqN,KAAA,GAAQ,UAAUpN,CAAA;YACnB,OAAO,IAAID,CAAA,CAAKC,CAAA,CACpB;UAAA,GACAD,CAAA,CAAK++D,GAAA,GAAM;YACP,OAAO,CAAC/+D,CAAA,CAAK6+D,GAAA,CAAI,IAAI7+D,CAAA,CAAK6+D,GAAA,CAAI,IAAI7+D,CAAA,CAAK6+D,GAAA,CAAI,IAAI7+D,CAAA,CAAK6+D,GAAA,CAAI,IAAI7+D,CAAA,CAAK6+D,GAAA,CAAI,IAAIz7D,IAAA,CAAK,IAClF;UAAA,GACApD,CAAA,CAAK6+D,GAAA,GAAM,UAAU7+D,CAAA;YAEjB,KADA,IAAIC,CAAA,GAAM,IACDQ,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,EAAOS,CAAA,IAEvBR,CAAA,KAA+B,SAArB,IAAI+B,IAAA,CAAKg9D,MAAA,MAAuB,GAAGzoC,QAAA,CAAS,IAAI4L,SAAA,CAAU;YAExE,OAAOliC,CACX;UAAA,GACAD,CAAA,CAAK6kD,SAAA,CAAUoa,MAAA,GAAS,UAAUh/D,CAAA;YAG9B,OAAOD,CAAA,CAAK2+D,MAAA,CAAO1+D,CAAA,KAAU,KAAKkkB,KAAA,KAAUlkB,CAAA,CAAMs2B,QAAA,EACtD;UAAA,GACAv2B,CAAA,CAAK6kD,SAAA,CAAUqa,OAAA,GAAU;YACrB,OAAO,KAAK/6C,KAAA,KAAUnkB,CAAA,CAAK0+D,KAC/B;UAAA,GACA1+D,CAAA,CAAK6kD,SAAA,CAAUtuB,QAAA,GAAW;YACtB,OAAO,KAAKpS,KAChB;UAAA,GACAnkB,CAAA,CAAK6kD,SAAA,CAAUiC,MAAA,GAAS;YACpB,OAAO;cACH3iC,KAAA,EAAO,KAAKA;YAAA,CAEpB;UAAA,GACAnkB,CAAA,CAAK4+D,SAAA,GAAY,IAAItuD,MAAA,CAAO,kEAAkE,MAC9FtQ,CAAA,CAAK0+D,KAAA,GAAQ,wCACN1+D,CACX;QAAA,CArDyB;QAsDzBC,CAAA,CAAQ45C,IAAA,GAAOp5C,C;;;;;QCrDfT,CAAA,CAAOE,OAAA,GAAUO,CAAA,CAAjB,K;;;;;QCFA,IAAID,CAAA,GAAWP,CAAA;QA2Bf,SAASS,EAAA;UACLF,CAAA,CAASgkD,IAAA,CAAK2a,UAAA,IACd3+D,CAAA,CAAS+jD,MAAA,CAAO4a,UAAA,CAAW3+D,CAAA,CAAS4+D,YAAA,GACpC5+D,CAAA,CAAS8jD,MAAA,CAAO6a,UAAA,CAAW3+D,CAAA,CAAS6+D,YAAA,CACxC;QAAA;QAvBA7+D,CAAA,CAASwT,KAAA,GAAQ,WAGjBxT,CAAA,CAAS+jD,MAAA,GAAe9jD,CAAA,CAAQ,OAChCD,CAAA,CAAS4+D,YAAA,GAAe3+D,CAAA,CAAQ,OAChCD,CAAA,CAAS8jD,MAAA,GAAe7jD,CAAA,CAAQ,OAChCD,CAAA,CAAS6+D,YAAA,GAAe5+D,CAAA,CAAQ,MAGhCD,CAAA,CAASgkD,IAAA,GAAe/jD,CAAA,CAAQ,OAChCD,CAAA,CAAS8+D,GAAA,GAAe7+D,CAAA,CAAQ,OAChCD,CAAA,CAASikD,KAAA,GAAehkD,CAAA,CAAQ,OAChCD,CAAA,CAAS++D,SAAA,GAAe7+D,CAAA,EAcxBA,CAAA,E;;;;;QClCAV,CAAA,CAAOE,OAAA,GAAUwD,CAAA;QAEjB,IAEIlD,CAAA;UAFAE,CAAA,GAAYD,CAAA,CAAQ;UAIpBQ,CAAA,GAAYP,CAAA,CAAK2lD,QAAA;UACjBnlD,CAAA,GAAYR,CAAA,CAAK8+D,IAAA;QAGrB,SAASl8D,EAAgBtD,CAAA,EAAQC,CAAA;UAC7B,OAAO85C,UAAA,CAAW,yBAAyB/5C,CAAA,CAAO8lD,GAAA,GAAM,SAAS7lD,CAAA,IAAe,KAAK,QAAQD,CAAA,CAAO6lD,GAAA,CACxG;QAAA;QAQA,SAASniD,EAAO1D,CAAA;UAMZ,KAAKy/D,GAAA,GAAMz/D,CAAA,EAMX,KAAK8lD,GAAA,GAAM,GAMX,KAAKD,GAAA,GAAM7lD,CAAA,CAAO8B,MACtB;QAAA;QAEA,IA4CQ2I,CAAA;UA5CJY,CAAA,GAAqC,sBAAfoE,UAAA,GACpB,UAA4BzP,CAAA;YAC1B,IAAIA,CAAA,YAAkByP,UAAA,IAAczJ,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,GAC9C,OAAO,IAAI0D,CAAA,CAAO1D,CAAA;YACtB,MAAMqE,KAAA,CAAM,iBAChB;UAAA,IAEE,UAAsBrE,CAAA;YACpB,IAAIgG,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,GACd,OAAO,IAAI0D,CAAA,CAAO1D,CAAA;YACtB,MAAMqE,KAAA,CAAM,iBAChB;UAAA;UAEAiH,CAAA,GAAS,SAAAm0B,CAAA;YACT,OAAO/+B,CAAA,CAAKg/D,MAAA,GACN,UAA6B1/D,CAAA;cAC3B,QAAQ0D,CAAA,CAAO+7B,MAAA,GAAS,UAAuBz/B,CAAA;gBAC3C,OAAOU,CAAA,CAAKg/D,MAAA,CAAOC,QAAA,CAAS3/D,CAAA,IACtB,IAAIQ,CAAA,CAAaR,CAAA,IAEjBqL,CAAA,CAAarL,CAAA,CACvB;cAAA,GAAGA,CAAA,CACP;YAAA,IAEEqL,CACV;UAAA;QAuDA,SAASE,EAAA;UAEL,IAAIvL,CAAA,GAAO,IAAIiB,CAAA,CAAS,GAAG;YACvBhB,CAAA,GAAI;UACR,MAAI,KAAK4lD,GAAA,GAAM,KAAKC,GAAA,GAAM,IAanB;YACH,OAAO7lD,CAAA,GAAI,KAAKA,CAAA,EAAG;cAEf,IAAI,KAAK6lD,GAAA,IAAO,KAAKD,GAAA,EACjB,MAAMviD,CAAA,CAAgB;cAG1B,IADAtD,CAAA,CAAK4/D,EAAA,IAAM5/D,CAAA,CAAK4/D,EAAA,IAA2B,MAArB,KAAKH,GAAA,CAAI,KAAK3Z,GAAA,MAAmB,IAAJ7lD,CAAA,MAAW,GAC1D,KAAKw/D,GAAA,CAAI,KAAK3Z,GAAA,MAAS,KACvB,OAAO9lD,CACf;YAAA;YAGA,OADAA,CAAA,CAAK4/D,EAAA,IAAM5/D,CAAA,CAAK4/D,EAAA,IAA6B,MAAvB,KAAKH,GAAA,CAAI,KAAK3Z,GAAA,QAAqB,IAAJ7lD,CAAA,MAAW,GACzDD,CACX;UAAA;UAzBI,OAAOC,CAAA,GAAI,KAAKA,CAAA,EAGZ,IADAD,CAAA,CAAK4/D,EAAA,IAAM5/D,CAAA,CAAK4/D,EAAA,IAA2B,MAArB,KAAKH,GAAA,CAAI,KAAK3Z,GAAA,MAAmB,IAAJ7lD,CAAA,MAAW,GAC1D,KAAKw/D,GAAA,CAAI,KAAK3Z,GAAA,MAAS,KACvB,OAAO9lD,CAAA;UAKf,IAFAA,CAAA,CAAK4/D,EAAA,IAAM5/D,CAAA,CAAK4/D,EAAA,IAA2B,MAArB,KAAKH,GAAA,CAAI,KAAK3Z,GAAA,MAAe,QAAQ,GAC3D9lD,CAAA,CAAK6/D,EAAA,IAAM7/D,CAAA,CAAK6/D,EAAA,IAA2B,MAArB,KAAKJ,GAAA,CAAI,KAAK3Z,GAAA,MAAgB,OAAO,GACvD,KAAK2Z,GAAA,CAAI,KAAK3Z,GAAA,MAAS,KACvB,OAAO9lD,CAAA;UAgBf,IAfIC,CAAA,GAAI,GAeJ,KAAK4lD,GAAA,GAAM,KAAKC,GAAA,GAAM;YACtB,OAAO7lD,CAAA,GAAI,KAAKA,CAAA,EAGZ,IADAD,CAAA,CAAK6/D,EAAA,IAAM7/D,CAAA,CAAK6/D,EAAA,IAA2B,MAArB,KAAKJ,GAAA,CAAI,KAAK3Z,GAAA,MAAmB,IAAJ7lD,CAAA,GAAQ,OAAO,GAC9D,KAAKw/D,GAAA,CAAI,KAAK3Z,GAAA,MAAS,KACvB,OAAO9lD,CAAA;UAAA,OAGf,OAAOC,CAAA,GAAI,KAAKA,CAAA,EAAG;YAEf,IAAI,KAAK6lD,GAAA,IAAO,KAAKD,GAAA,EACjB,MAAMviD,CAAA,CAAgB;YAG1B,IADAtD,CAAA,CAAK6/D,EAAA,IAAM7/D,CAAA,CAAK6/D,EAAA,IAA2B,MAArB,KAAKJ,GAAA,CAAI,KAAK3Z,GAAA,MAAmB,IAAJ7lD,CAAA,GAAQ,OAAO,GAC9D,KAAKw/D,GAAA,CAAI,KAAK3Z,GAAA,MAAS,KACvB,OAAO9lD,CACf;UAAA;UAGJ,MAAMqE,KAAA,CAAM,0BAChB;QAAA;QAiCA,SAASkC,EAAgBvG,CAAA,EAAKC,CAAA;UAC1B,QAAQD,CAAA,CAAIC,CAAA,GAAM,KACVD,CAAA,CAAIC,CAAA,GAAM,MAAM,IAChBD,CAAA,CAAIC,CAAA,GAAM,MAAM,KAChBD,CAAA,CAAIC,CAAA,GAAM,MAAM,QAAQ,CACpC;QAAA;QA8BA,SAASyL,EAAA;UAGL,IAAI,KAAKo6C,GAAA,GAAM,IAAI,KAAKD,GAAA,EACpB,MAAMviD,CAAA,CAAgB,MAAM;UAEhC,OAAO,IAAIrC,CAAA,CAASsF,CAAA,CAAgB,KAAKk5D,GAAA,EAAK,KAAK3Z,GAAA,IAAO,IAAIv/C,CAAA,CAAgB,KAAKk5D,GAAA,EAAK,KAAK3Z,GAAA,IAAO,GACxG;QAAA;QA5KApiD,CAAA,CAAO+7B,MAAA,GAASn0B,CAAA,IAEhB5H,CAAA,CAAOmhD,SAAA,CAAUib,MAAA,GAASp/D,CAAA,CAAKsF,KAAA,CAAM6+C,SAAA,CAAUhwC,QAAA,IAAuCnU,CAAA,CAAKsF,KAAA,CAAM6+C,SAAA,CAAU33C,KAAA,EAO3GxJ,CAAA,CAAOmhD,SAAA,CAAUM,MAAA,IACT16C,CAAA,GAAQ,YACL;UACuD,IAA1DA,CAAA,IAAuC,MAArB,KAAKg1D,GAAA,CAAI,KAAK3Z,GAAA,OAAuB,GAAO,KAAK2Z,GAAA,CAAI,KAAK3Z,GAAA,MAAS,KAAK,OAAOr7C,CAAA;UACvC,IAA1DA,CAAA,IAASA,CAAA,IAA8B,MAArB,KAAKg1D,GAAA,CAAI,KAAK3Z,GAAA,MAAgB,OAAO,GAAO,KAAK2Z,GAAA,CAAI,KAAK3Z,GAAA,MAAS,KAAK,OAAOr7C,CAAA;UACvC,IAA1DA,CAAA,IAASA,CAAA,IAA8B,MAArB,KAAKg1D,GAAA,CAAI,KAAK3Z,GAAA,MAAe,QAAQ,GAAO,KAAK2Z,GAAA,CAAI,KAAK3Z,GAAA,MAAS,KAAK,OAAOr7C,CAAA;UACvC,IAA1DA,CAAA,IAASA,CAAA,IAA8B,MAArB,KAAKg1D,GAAA,CAAI,KAAK3Z,GAAA,MAAe,QAAQ,GAAO,KAAK2Z,GAAA,CAAI,KAAK3Z,GAAA,MAAS,KAAK,OAAOr7C,CAAA;UACvC,IAA1DA,CAAA,IAASA,CAAA,IAA+B,KAAtB,KAAKg1D,GAAA,CAAI,KAAK3Z,GAAA,MAAe,QAAQ,GAAO,KAAK2Z,GAAA,CAAI,KAAK3Z,GAAA,MAAS,KAAK,OAAOr7C,CAAA;UAGjG,KAAK,KAAKq7C,GAAA,IAAO,KAAK,KAAKD,GAAA,EAEvB,MADA,KAAKC,GAAA,GAAM,KAAKD,GAAA,EACVviD,CAAA,CAAgB,MAAM;UAEhC,OAAOmH,CACX;QAAA,IAOJ/G,CAAA,CAAOmhD,SAAA,CAAUa,KAAA,GAAQ;UACrB,OAAuB,IAAhB,KAAKP,MAAA,EAChB;QAAA,GAMAzhD,CAAA,CAAOmhD,SAAA,CAAUkb,MAAA,GAAS;UACtB,IAAI//D,CAAA,GAAQ,KAAKmlD,MAAA;UACjB,OAAOnlD,CAAA,KAAU,MAAc,IAARA,CAAA,IAAa,CACxC;QAAA,GAoFA0D,CAAA,CAAOmhD,SAAA,CAAUmb,IAAA,GAAO;UACpB,OAAyB,MAAlB,KAAK7a,MAAA,EAChB;QAAA,GAaAzhD,CAAA,CAAOmhD,SAAA,CAAUob,OAAA,GAAU;UAGvB,IAAI,KAAKna,GAAA,GAAM,IAAI,KAAKD,GAAA,EACpB,MAAMviD,CAAA,CAAgB,MAAM;UAEhC,OAAOiD,CAAA,CAAgB,KAAKk5D,GAAA,EAAK,KAAK3Z,GAAA,IAAO,EACjD;QAAA,GAMApiD,CAAA,CAAOmhD,SAAA,CAAUqb,QAAA,GAAW;UAGxB,IAAI,KAAKpa,GAAA,GAAM,IAAI,KAAKD,GAAA,EACpB,MAAMviD,CAAA,CAAgB,MAAM;UAEhC,OAAkD,IAA3CiD,CAAA,CAAgB,KAAKk5D,GAAA,EAAK,KAAK3Z,GAAA,IAAO,EACjD;QAAA,GAkCApiD,CAAA,CAAOmhD,SAAA,CAAUQ,KAAA,GAAQ;UAGrB,IAAI,KAAKS,GAAA,GAAM,IAAI,KAAKD,GAAA,EACpB,MAAMviD,CAAA,CAAgB,MAAM;UAEhC,IAAItD,CAAA,GAAQU,CAAA,CAAK2kD,KAAA,CAAMsY,WAAA,CAAY,KAAK8B,GAAA,EAAK,KAAK3Z,GAAA;UAElD,OADA,KAAKA,GAAA,IAAO,GACL9lD,CACX;QAAA,GAOA0D,CAAA,CAAOmhD,SAAA,CAAU0D,MAAA,GAAS;UAGtB,IAAI,KAAKzC,GAAA,GAAM,IAAI,KAAKD,GAAA,EACpB,MAAMviD,CAAA,CAAgB,MAAM;UAEhC,IAAItD,CAAA,GAAQU,CAAA,CAAK2kD,KAAA,CAAM4Y,YAAA,CAAa,KAAKwB,GAAA,EAAK,KAAK3Z,GAAA;UAEnD,OADA,KAAKA,GAAA,IAAO,GACL9lD,CACX;QAAA,GAMA0D,CAAA,CAAOmhD,SAAA,CAAU5Z,KAAA,GAAQ;UACrB,IAAIjrC,CAAA,GAAS,KAAKmlD,MAAA;YACdllD,CAAA,GAAS,KAAK6lD,GAAA;YACdrlD,CAAA,GAAS,KAAKqlD,GAAA,GAAM9lD,CAAA;UAGxB,IAAIS,CAAA,GAAM,KAAKolD,GAAA,EACX,MAAMviD,CAAA,CAAgB,MAAMtD,CAAA;UAGhC,OADA,KAAK8lD,GAAA,IAAO9lD,CAAA,EACRgG,KAAA,CAAM+oB,OAAA,CAAQ,KAAK0wC,GAAA,IACZ,KAAKA,GAAA,CAAIvyD,KAAA,CAAMjN,CAAA,EAAOQ,CAAA,IAC1BR,CAAA,KAAUQ,CAAA,GACX,IAAI,KAAKg/D,GAAA,CAAI78D,WAAA,CAAY,KACzB,KAAKk9D,MAAA,CAAO16C,IAAA,CAAK,KAAKq6C,GAAA,EAAKx/D,CAAA,EAAOQ,CAAA,CAC5C;QAAA,GAMAiD,CAAA,CAAOmhD,SAAA,CAAUO,MAAA,GAAS;UACtB,IAAIplD,CAAA,GAAQ,KAAKirC,KAAA;UACjB,OAAO/pC,CAAA,CAAKq9D,IAAA,CAAKv+D,CAAA,EAAO,GAAGA,CAAA,CAAM8B,MAAA,CACrC;QAAA,GAOA4B,CAAA,CAAOmhD,SAAA,CAAUsb,IAAA,GAAO,UAAcngE,CAAA;UAClC,IAAsB,mBAAXA,CAAA,EAAqB;YAE5B,IAAI,KAAK8lD,GAAA,GAAM9lD,CAAA,GAAS,KAAK6lD,GAAA,EACzB,MAAMviD,CAAA,CAAgB,MAAMtD,CAAA;YAChC,KAAK8lD,GAAA,IAAO9lD,CAChB;UAAA,OACI;YAEI,IAAI,KAAK8lD,GAAA,IAAO,KAAKD,GAAA,EACjB,MAAMviD,CAAA,CAAgB;UAAA,SACE,MAAvB,KAAKm8D,GAAA,CAAI,KAAK3Z,GAAA;UAE3B,OAAO,IACX;QAAA,GAOApiD,CAAA,CAAOmhD,SAAA,CAAUkB,QAAA,GAAW,UAAS/lD,CAAA;UACjC,QAAQA,CAAA;YACJ,KAAK;cACD,KAAKmgE,IAAA;cACL;YACJ,KAAK;cACD,KAAKA,IAAA,CAAK;cACV;YACJ,KAAK;cACD,KAAKA,IAAA,CAAK,KAAKhb,MAAA;cACf;YACJ,KAAK;cACD,OAA0C,MAAlCnlD,CAAA,GAA2B,IAAhB,KAAKmlD,MAAA,MACpB,KAAKY,QAAA,CAAS/lD,CAAA;cAElB;YACJ,KAAK;cACD,KAAKmgE,IAAA,CAAK;cACV;YAGJ;cACI,MAAM97D,KAAA,CAAM,uBAAuBrE,CAAA,GAAW,gBAAgB,KAAK8lD,GAAA;UAAA;UAE3E,OAAO,IACX;QAAA,GAEApiD,CAAA,CAAOy7D,UAAA,GAAa,UAASn/D,CAAA;UACzBQ,CAAA,GAAeR,CAAA,EACf0D,CAAA,CAAO+7B,MAAA,GAASn0B,CAAA,IAChB9K,CAAA,CAAa2+D,UAAA;UAEb,IAAIl/D,CAAA,GAAKS,CAAA,CAAKu7C,IAAA,GAAO,WAAsC;UAC3Dv7C,CAAA,CAAK0/D,KAAA,CAAM18D,CAAA,CAAOmhD,SAAA,EAAW;YAEzBS,KAAA,EAAO,SAAAA,CAAA;cACH,OAAO/5C,CAAA,CAAe6Z,IAAA,CAAK,MAAMnlB,CAAA,GAAI,EACzC;YAAA;YAEAuoD,MAAA,EAAQ,SAAAA,CAAA;cACJ,OAAOj9C,CAAA,CAAe6Z,IAAA,CAAK,MAAMnlB,CAAA,GAAI,EACzC;YAAA;YAEAogE,MAAA,EAAQ,SAAAA,CAAA;cACJ,OAAO90D,CAAA,CAAe6Z,IAAA,CAAK,MAAMk7C,QAAA,GAAWrgE,CAAA,GAAI,EACpD;YAAA;YAEAsgE,OAAA,EAAS,SAAAA,CAAA;cACL,OAAO70D,CAAA,CAAY0Z,IAAA,CAAK,MAAMnlB,CAAA,GAAI,EACtC;YAAA;YAEAugE,QAAA,EAAU,SAAAA,CAAA;cACN,OAAO90D,CAAA,CAAY0Z,IAAA,CAAK,MAAMnlB,CAAA,GAAI,EACtC;YAAA;UAAA,EAGR;QAAA,C;;;;;QCzZAD,CAAA,CAAOE,OAAA,GAAUe,CAAA;QAGjB,IAAIT,CAAA,GAASC,CAAA,CAAQ;QAAA,CACpBQ,CAAA,CAAa4jD,SAAA,GAAYhiD,MAAA,CAAO48B,MAAA,CAAOj/B,CAAA,CAAOqkD,SAAA,GAAYjiD,WAAA,GAAc3B,CAAA;QAEzE,IAAIP,CAAA,GAAOD,CAAA,CAAQ;QASnB,SAASQ,EAAajB,CAAA;UAClBQ,CAAA,CAAO4kB,IAAA,CAAK,MAAMplB,CAAA,CAOtB;QAAA;QAEAiB,CAAA,CAAak+D,UAAA,GAAa;UAElBz+D,CAAA,CAAKg/D,MAAA,KACLz+D,CAAA,CAAa4jD,SAAA,CAAUib,MAAA,GAASp/D,CAAA,CAAKg/D,MAAA,CAAO7a,SAAA,CAAU33C,KAAA,CAC9D;QAAA,GAMAjM,CAAA,CAAa4jD,SAAA,CAAUO,MAAA,GAAS;UAC5B,IAAIplD,CAAA,GAAM,KAAKmlD,MAAA;UACf,OAAO,KAAKsa,GAAA,CAAIgB,SAAA,GACV,KAAKhB,GAAA,CAAIgB,SAAA,CAAU,KAAK3a,GAAA,EAAK,KAAKA,GAAA,GAAM9jD,IAAA,CAAKC,GAAA,CAAI,KAAK6jD,GAAA,GAAM9lD,CAAA,EAAK,KAAK6lD,GAAA,KACtE,KAAK4Z,GAAA,CAAIlpC,QAAA,CAAS,SAAS,KAAKuvB,GAAA,EAAK,KAAKA,GAAA,GAAM9jD,IAAA,CAAKC,GAAA,CAAI,KAAK6jD,GAAA,GAAM9lD,CAAA,EAAK,KAAK6lD,GAAA,EACxF;QAAA,GASA5kD,CAAA,CAAak+D,UAAA,E;;;;;QCjDbn/D,CAAA,CAAOE,OAAA,GAAU,CAAC,C;;;;;QCKRD,CAAA,CA6BNygE,OAAA,GAAUjgE,CAAA,CAAQ,K;;;;;QClCtBT,CAAA,CAAOE,OAAA,GAAUQ,CAAA;QAEjB,IAAIF,CAAA,GAAOC,CAAA,CAAQ;QAsCnB,SAASC,EAAQV,CAAA,EAASC,CAAA,EAAkBQ,CAAA;UAExC,IAAuB,qBAAZT,CAAA,EACP,MAAM+hB,SAAA,CAAU;UAEpBvhB,CAAA,CAAKmgE,YAAA,CAAav7C,IAAA,CAAK,OAMvB,KAAKw7C,OAAA,GAAU5gE,CAAA,EAMf,KAAK6gE,gBAAA,GAAmBC,OAAA,CAAQ7gE,CAAA,GAMhC,KAAK8gE,iBAAA,GAAoBD,OAAA,CAAQrgE,CAAA,CACrC;QAAA;QAAA,CA3DCC,CAAA,CAAQmkD,SAAA,GAAYhiD,MAAA,CAAO48B,MAAA,CAAOj/B,CAAA,CAAKmgE,YAAA,CAAa9b,SAAA,GAAYjiD,WAAA,GAAclC,CAAA,EAwE/EA,CAAA,CAAQmkD,SAAA,CAAUmc,OAAA,GAAU,SAAShhE,EAAQC,CAAA,EAAQQ,CAAA,EAAaC,CAAA,EAAcO,CAAA,EAASC,CAAA;UAErF,KAAKD,CAAA,EACD,MAAM8gB,SAAA,CAAU;UAEpB,IAAIze,CAAA,GAAO;UACX,KAAKpC,CAAA,EACD,OAAOV,CAAA,CAAKygE,SAAA,CAAUjhE,CAAA,EAASsD,CAAA,EAAMrD,CAAA,EAAQQ,CAAA,EAAaC,CAAA,EAAcO,CAAA;UAE5E,IAAKqC,CAAA,CAAKs9D,OAAA,EAKV;YACI,OAAOt9D,CAAA,CAAKs9D,OAAA,CACR3gE,CAAA,EACAQ,CAAA,CAAY6C,CAAA,CAAKu9D,gBAAA,GAAmB,oBAAoB,UAAU5/D,CAAA,EAASi2B,MAAA,IAC3E,UAAqBl3B,CAAA,EAAKS,CAAA;cAEtB,IAAIT,CAAA,EAEA,OADAsD,CAAA,CAAKk6D,IAAA,CAAK,SAASx9D,CAAA,EAAKC,CAAA,GACjBiB,CAAA,CAASlB,CAAA;cAGpB,IAAiB,SAAbS,CAAA,EAAJ;gBAKA,MAAMA,CAAA,YAAoBC,CAAA,GACtB;kBACID,CAAA,GAAWC,CAAA,CAAa4C,CAAA,CAAKy9D,iBAAA,GAAoB,oBAAoB,UAAUtgE,CAAA,CACnF;gBAAA,CAAE,QAAOT,CAAA;kBAEL,OADAsD,CAAA,CAAKk6D,IAAA,CAAK,SAASx9D,CAAA,EAAKC,CAAA,GACjBiB,CAAA,CAASlB,CAAA,CACpB;gBAAA;gBAIJ,OADAsD,CAAA,CAAKk6D,IAAA,CAAK,QAAQ/8D,CAAA,EAAUR,CAAA,GACrBiB,CAAA,CAAS,MAAMT,CAAA,CAZtB;cAAA;cAFI6C,CAAA,CAAK+7B,GAAA,EAAqB,EAelC;YAAA,EAER;UAAA,CAAE,QAAOr/B,CAAA;YAGL,OAFAsD,CAAA,CAAKk6D,IAAA,CAAK,SAASx9D,CAAA,EAAKC,CAAA,QACxBixB,UAAA,CAAW;cAAahwB,CAAA,CAASlB,CAAA,CAAM;YAAA,GAAG,EAE9C;UAAA,OArCIkxB,UAAA,CAAW;YAAahwB,CAAA,CAASmD,KAAA,CAAM,iBAAmB;UAAA,GAAG,EAsCrE;QAAA,GAOA3D,CAAA,CAAQmkD,SAAA,CAAUxlB,GAAA,GAAM,UAAar/B,CAAA;UAOjC,OANI,KAAK4gE,OAAA,KACA5gE,CAAA,IACD,KAAK4gE,OAAA,CAAQ,MAAM,MAAM,OAC7B,KAAKA,OAAA,GAAU,MACf,KAAKpD,IAAA,CAAK,OAAOD,GAAA,KAEd,IACX;QAAA,C;;;;;QC5IAv9D,CAAA,CAAOE,OAAA,GAAUQ,CAAA;QAEjB,IAAIF,CAAA,GAAOC,CAAA,CAAQ;QAUnB,SAASC,EAASV,CAAA,EAAIC,CAAA;UASlB,KAAK2/D,EAAA,GAAK5/D,CAAA,KAAO,GAMjB,KAAK6/D,EAAA,GAAK5/D,CAAA,KAAO,CACrB;QAAA;QAOA,IAAIgB,CAAA,GAAOP,CAAA,CAASwgE,IAAA,GAAO,IAAIxgE,CAAA,CAAS,GAAG;QAE3CO,CAAA,CAAK25C,QAAA,GAAW;UAAa,OAAO,CAAG;QAAA,GACvC35C,CAAA,CAAKkgE,QAAA,GAAWlgE,CAAA,CAAKq/D,QAAA,GAAW;UAAa,OAAO,IAAM;QAAA,GAC1Dr/D,CAAA,CAAKa,MAAA,GAAS;UAAa,OAAO,CAAG;QAAA;QAOrC,IAAIZ,CAAA,GAAWR,CAAA,CAAS0gE,QAAA,GAAW;QAOnC1gE,CAAA,CAAS2gE,UAAA,GAAa,UAAoBrhE,CAAA;UACtC,IAAc,MAAVA,CAAA,EACA,OAAOiB,CAAA;UACX,IAAIhB,CAAA,GAAOD,CAAA,GAAQ;UACfC,CAAA,KACAD,CAAA,IAASA,CAAA;UACb,IAAIS,CAAA,GAAKT,CAAA,KAAU;YACfQ,CAAA,IAAMR,CAAA,GAAQS,CAAA,IAAM,eAAe;UAUvC,OATIR,CAAA,KACAO,CAAA,IAAMA,CAAA,KAAO,GACbC,CAAA,IAAMA,CAAA,KAAO,KACPA,CAAA,GAAK,eACPA,CAAA,GAAK,KACCD,CAAA,GAAK,eACPA,CAAA,GAAK,MAGV,IAAIE,CAAA,CAASD,CAAA,EAAID,CAAA,CAC5B;QAAA,GAOAE,CAAA,CAAS0e,IAAA,GAAO,UAAcpf,CAAA;UAC1B,IAAqB,mBAAVA,CAAA,EACP,OAAOU,CAAA,CAAS2gE,UAAA,CAAWrhE,CAAA;UAC/B,IAAIQ,CAAA,CAAK0lD,QAAA,CAASlmD,CAAA,GAAQ;YAEtB,KAAIQ,CAAA,CAAKy7C,IAAA,EAGL,OAAOv7C,CAAA,CAAS2gE,UAAA,CAAWn/B,QAAA,CAASliC,CAAA,EAAO;YAF3CA,CAAA,GAAQQ,CAAA,CAAKy7C,IAAA,CAAKqlB,UAAA,CAAWthE,CAAA,CAGrC;UAAA;UACA,OAAOA,CAAA,CAAMm8C,GAAA,IAAOn8C,CAAA,CAAMo8C,IAAA,GAAO,IAAI17C,CAAA,CAASV,CAAA,CAAMm8C,GAAA,KAAQ,GAAGn8C,CAAA,CAAMo8C,IAAA,KAAS,KAAKn7C,CACvF;QAAA,GAOAP,CAAA,CAASmkD,SAAA,CAAUjK,QAAA,GAAW,UAAkB56C,CAAA;UAC5C,KAAKA,CAAA,IAAY,KAAK6/D,EAAA,KAAO,IAAI;YAC7B,IAAI5/D,CAAA,GAAgB,KAAV,KAAK2/D,EAAA,KAAW;cACtBn/D,CAAA,IAAM,KAAKo/D,EAAA,KAAW;YAG1B,OAFK5/D,CAAA,KACDQ,CAAA,GAAKA,CAAA,GAAK,MAAM,MACXR,CAAA,GAAU,aAALQ,CAAA,CAClB;UAAA;UACA,OAAO,KAAKm/D,EAAA,GAAe,aAAV,KAAKC,EAC1B;QAAA,GAOAn/D,CAAA,CAASmkD,SAAA,CAAU0c,MAAA,GAAS,UAAgBvhE,CAAA;UACxC,OAAOQ,CAAA,CAAKy7C,IAAA,GACN,IAAIz7C,CAAA,CAAKy7C,IAAA,CAAe,IAAV,KAAK2jB,EAAA,EAAkB,IAAV,KAAKC,EAAA,EAAQiB,OAAA,CAAQ9gE,CAAA,KAEhD;YAAEm8C,GAAA,EAAe,IAAV,KAAKyjB,EAAA;YAAQxjB,IAAA,EAAgB,IAAV,KAAKyjB,EAAA;YAAQxjB,QAAA,EAAUykB,OAAA,CAAQ9gE,CAAA;UAAA,CACnE;QAAA;QAEA,IAAIsD,CAAA,GAAa8iD,MAAA,CAAOvB,SAAA,CAAUkO,UAAA;QAOlCryD,CAAA,CAAS8gE,QAAA,GAAW,UAAkBxhE,CAAA;UAClC,OAAIA,CAAA,KAASkB,CAAA,GACFD,CAAA,GACJ,IAAIP,CAAA,EACL4C,CAAA,CAAW8hB,IAAA,CAAKplB,CAAA,EAAM,KACtBsD,CAAA,CAAW8hB,IAAA,CAAKplB,CAAA,EAAM,MAAM,IAC5BsD,CAAA,CAAW8hB,IAAA,CAAKplB,CAAA,EAAM,MAAM,KAC5BsD,CAAA,CAAW8hB,IAAA,CAAKplB,CAAA,EAAM,MAAM,QAAQ,IAEpCsD,CAAA,CAAW8hB,IAAA,CAAKplB,CAAA,EAAM,KACtBsD,CAAA,CAAW8hB,IAAA,CAAKplB,CAAA,EAAM,MAAM,IAC5BsD,CAAA,CAAW8hB,IAAA,CAAKplB,CAAA,EAAM,MAAM,KAC5BsD,CAAA,CAAW8hB,IAAA,CAAKplB,CAAA,EAAM,MAAM,QAAQ,EAE9C;QAAA,GAMAU,CAAA,CAASmkD,SAAA,CAAU4c,MAAA,GAAS;UACxB,OAAOrb,MAAA,CAAOgJ,YAAA,CACO,MAAjB,KAAKwQ,EAAA,EACL,KAAKA,EAAA,KAAO,IAAK,KACjB,KAAKA,EAAA,KAAO,KAAK,KACjB,KAAKA,EAAA,KAAO,IACK,MAAjB,KAAKC,EAAA,EACL,KAAKA,EAAA,KAAO,IAAK,KACjB,KAAKA,EAAA,KAAO,KAAK,KACjB,KAAKA,EAAA,KAAO,GAEpB;QAAA,GAMAn/D,CAAA,CAASmkD,SAAA,CAAUsc,QAAA,GAAW;UAC1B,IAAInhE,CAAA,GAAS,KAAK6/D,EAAA,IAAM;UAGxB,OAFA,KAAKA,EAAA,KAAQ,KAAKA,EAAA,IAAM,IAAI,KAAKD,EAAA,KAAO,MAAM5/D,CAAA,MAAU,GACxD,KAAK4/D,EAAA,IAAQ,KAAKA,EAAA,IAAM,IAAsB5/D,CAAA,MAAU,GACjD,IACX;QAAA,GAMAU,CAAA,CAASmkD,SAAA,CAAUyb,QAAA,GAAW;UAC1B,IAAItgE,CAAA,KAAmB,IAAV,KAAK4/D,EAAA;UAGlB,OAFA,KAAKA,EAAA,KAAQ,KAAKA,EAAA,KAAO,IAAI,KAAKC,EAAA,IAAM,MAAM7/D,CAAA,MAAU,GACxD,KAAK6/D,EAAA,IAAQ,KAAKA,EAAA,KAAO,IAAqB7/D,CAAA,MAAU,GACjD,IACX;QAAA,GAMAU,CAAA,CAASmkD,SAAA,CAAU/iD,MAAA,GAAS;UACxB,IAAI9B,CAAA,GAAS,KAAK4/D,EAAA;YACd3/D,CAAA,IAAS,KAAK2/D,EAAA,KAAO,KAAK,KAAKC,EAAA,IAAM,OAAO;YAC5Cp/D,CAAA,GAAS,KAAKo/D,EAAA,KAAO;UACzB,OAAiB,MAAVp/D,CAAA,GACU,MAAVR,CAAA,GACED,CAAA,GAAQ,QACNA,CAAA,GAAQ,MAAM,IAAI,IAClBA,CAAA,GAAQ,UAAU,IAAI,IACxBC,CAAA,GAAQ,QACNA,CAAA,GAAQ,MAAM,IAAI,IAClBA,CAAA,GAAQ,UAAU,IAAI,IAC1BQ,CAAA,GAAQ,MAAM,IAAI,EAC7B;QAAA,C;;;;;QCtMA,IAAID,CAAA,GAAOP,CAAA;QA2OX,SAASS,EAAMV,CAAA,EAAKC,CAAA,EAAKQ,CAAA;UACrB,KAAK,IAAID,CAAA,GAAOqC,MAAA,CAAO6N,IAAA,CAAKzQ,CAAA,GAAMS,CAAA,GAAI,GAAGA,CAAA,GAAIF,CAAA,CAAKsB,MAAA,IAAUpB,CAAA,OACnC,MAAjBV,CAAA,CAAIQ,CAAA,CAAKE,CAAA,MAAsBD,CAAA,KAC/BT,CAAA,CAAIQ,CAAA,CAAKE,CAAA,KAAMT,CAAA,CAAIO,CAAA,CAAKE,CAAA;UAChC,OAAOV,CACX;QAAA;QAmBA,SAASiB,EAASjB,CAAA;UAEd,SAASC,EAAYD,CAAA,EAASS,CAAA;YAE1B,MAAM,gBAAgBR,CAAA,GAClB,OAAO,IAAIA,CAAA,CAAYD,CAAA,EAASS,CAAA;YAKpCoC,MAAA,CAAO8lD,cAAA,CAAe,MAAM,WAAW;cAAEnkD,GAAA,EAAK,SAAAA,CAAA;gBAAa,OAAOxE,CAAS;cAAA;YAAA,IAGvEqE,KAAA,CAAMq9D,iBAAA,GACNr9D,KAAA,CAAMq9D,iBAAA,CAAkB,MAAMzhE,CAAA,IAE9B4C,MAAA,CAAO8lD,cAAA,CAAe,MAAM,SAAS;cAAExkC,KAAA,EAAO,IAAI9f,KAAA,GAAQs9D,KAAA,IAAS;YAAA,IAEnElhE,CAAA,IACAC,CAAA,CAAM,MAAMD,CAAA,CACpB;UAAA;UA2BA,OAzBAR,CAAA,CAAY4kD,SAAA,GAAYhiD,MAAA,CAAO48B,MAAA,CAAOp7B,KAAA,CAAMwgD,SAAA,EAAW;YACnDjiD,WAAA,EAAa;cACTuhB,KAAA,EAAOlkB,CAAA;cACP2hE,QAAA,GAAU;cACVC,UAAA,GAAY;cACZC,YAAA,GAAc;YAAA;YAElB99D,IAAA,EAAM;cACFQ,GAAA,EAAK,SAAAA,CAAA;gBAAiB,OAAOxE,CAAM;cAAA;cACnC+D,GAAA,OAAK;cACL89D,UAAA,GAAY;cAKZC,YAAA,GAAc;YAAA;YAElBvrC,QAAA,EAAU;cACNpS,KAAA,EAAO,SAAAA,CAAA;gBAAmB,OAAO,KAAKngB,IAAA,GAAO,OAAO,KAAK+pD,OAAS;cAAA;cAClE6T,QAAA,GAAU;cACVC,UAAA,GAAY;cACZC,YAAA,GAAc;YAAA;UAAA,IAIf7hE,CACX;QAAA;QAhTAO,CAAA,CAAKygE,SAAA,GAAYxgE,CAAA,CAAQ,OAGzBD,CAAA,CAAK8lD,MAAA,GAAS7lD,CAAA,CAAQ,OAGtBD,CAAA,CAAKmgE,YAAA,GAAelgE,CAAA,CAAQ,OAG5BD,CAAA,CAAK6kD,KAAA,GAAQ5kD,CAAA,CAAQ,MAGrBD,CAAA,CAAK29D,OAAA,GAAU19D,CAAA,CAAQ,OAGvBD,CAAA,CAAKg/D,IAAA,GAAO/+D,CAAA,CAAQ,OAGpBD,CAAA,CAAKuhE,IAAA,GAAOthE,CAAA,CAAQ,OAGpBD,CAAA,CAAK6lD,QAAA,GAAW5lD,CAAA,CAAQ,OAOxBD,CAAA,CAAKwhE,MAAA,GAASlB,OAAA,CAA0B,sBAAXtW,MAAA,IACPA,MAAA,IACAA,MAAA,CAAO5R,OAAA,IACP4R,MAAA,CAAO5R,OAAA,CAAQn2C,QAAA,IACf+nD,MAAA,CAAO5R,OAAA,CAAQn2C,QAAA,CAAS03B,IAAA,GAO9C35B,CAAA,CAAKgqD,MAAA,GAAShqD,CAAA,CAAKwhE,MAAA,IAAUxX,MAAA,IACG,sBAAX5G,MAAA,IAA0BA,MAAA,IACf,sBAAXrjD,IAAA,IAA0BA,IAAA,IACjC,MAQdC,CAAA,CAAK0kD,UAAA,GAAariD,MAAA,CAAOo/D,MAAA,GAASp/D,MAAA,CAAOo/D,MAAA,CAAO,MAAiC,IAOjFzhE,CAAA,CAAK0hE,WAAA,GAAcr/D,MAAA,CAAOo/D,MAAA,GAASp/D,MAAA,CAAOo/D,MAAA,CAAO,CAAC,KAAgC,CAAC,GAQnFzhE,CAAA,CAAKmB,SAAA,GAAYD,MAAA,CAAOC,SAAA,IAAwC,UAAmB3B,CAAA;UAC/E,OAAwB,mBAAVA,CAAA,IAAsB6mD,QAAA,CAAS7mD,CAAA,KAAUgC,IAAA,CAAKoX,KAAA,CAAMpZ,CAAA,MAAWA,CACjF;QAAA,GAOAQ,CAAA,CAAK0lD,QAAA,GAAW,UAAkBlmD,CAAA;UAC9B,OAAwB,mBAAVA,CAAA,IAAsBA,CAAA,YAAiBomD,MACzD;QAAA,GAOA5lD,CAAA,CAAK2hE,QAAA,GAAW,UAAkBniE,CAAA;UAC9B,OAAOA,CAAA,IAA0B,mBAAVA,CAC3B;QAAA,GAUAQ,CAAA,CAAK4hE,KAAA,GAQL5hE,CAAA,CAAK6hE,KAAA,GAAQ,UAAeriE,CAAA,EAAKC,CAAA;UAC7B,IAAIQ,CAAA,GAAQT,CAAA,CAAIC,CAAA;UAChB,SAAa,QAATQ,CAAA,KAAiBT,CAAA,CAAImlB,cAAA,CAAellB,CAAA,OACZ,mBAAVQ,CAAA,KAAuBuF,KAAA,CAAM+oB,OAAA,CAAQtuB,CAAA,IAASA,CAAA,CAAMqB,MAAA,GAASe,MAAA,CAAO6N,IAAA,CAAKjQ,CAAA,EAAOqB,MAAA,IAAU,EAEhH;QAAA,GAaAtB,CAAA,CAAKk/D,MAAA,GAAS;UACV;YACI,IAAI1/D,CAAA,GAASQ,CAAA,CAAK29D,OAAA,CAAQ,UAAUuB,MAAA;YAEpC,OAAO1/D,CAAA,CAAO6kD,SAAA,CAAUyd,SAAA,GAAYtiE,CAAA,GAAoC,IAC5E;UAAA,CAAE,QAAOA,CAAA;YAEL,OAAO,IACX;UAAA;QACH,CATa,IAYdQ,CAAA,CAAK+hE,YAAA,GAAe,MAGpB/hE,CAAA,CAAKgiE,mBAAA,GAAsB,MAO3BhiE,CAAA,CAAKukD,SAAA,GAAY,UAAmB/kD,CAAA;UAEhC,OAA8B,mBAAhBA,CAAA,GACRQ,CAAA,CAAKk/D,MAAA,GACDl/D,CAAA,CAAKgiE,mBAAA,CAAoBxiE,CAAA,IACzB,IAAIQ,CAAA,CAAKwF,KAAA,CAAMhG,CAAA,IACnBQ,CAAA,CAAKk/D,MAAA,GACDl/D,CAAA,CAAK+hE,YAAA,CAAaviE,CAAA,IACI,sBAAfyP,UAAA,GACHzP,CAAA,GACA,IAAIyP,UAAA,CAAWzP,CAAA,CACjC;QAAA,GAMAQ,CAAA,CAAKwF,KAAA,GAA8B,sBAAfyJ,UAAA,GAA6BA,UAAA,GAAwCzJ,KAAA,EAezFxF,CAAA,CAAKy7C,IAAA,GAAkCz7C,CAAA,CAAKgqD,MAAA,CAAOiY,OAAA,IAAsCjiE,CAAA,CAAKgqD,MAAA,CAAOiY,OAAA,CAAQxmB,IAAA,IACtEz7C,CAAA,CAAKgqD,MAAA,CAAOvO,IAAA,IACvCz7C,CAAA,CAAK29D,OAAA,CAAQ,SAOzB39D,CAAA,CAAKkiE,MAAA,GAAS,oBAOdliE,CAAA,CAAKmiE,OAAA,GAAU,yBAOfniE,CAAA,CAAKoiE,OAAA,GAAU,8CAOfpiE,CAAA,CAAKqiE,UAAA,GAAa,UAAoB7iE,CAAA;UAClC,OAAOA,CAAA,GACDQ,CAAA,CAAK6lD,QAAA,CAASjnC,IAAA,CAAKpf,CAAA,EAAOyhE,MAAA,KAC1BjhE,CAAA,CAAK6lD,QAAA,CAAS+a,QACxB;QAAA,GAQA5gE,CAAA,CAAKsiE,YAAA,GAAe,UAAsB9iE,CAAA,EAAMC,CAAA;UAC5C,IAAIQ,CAAA,GAAOD,CAAA,CAAK6lD,QAAA,CAASmb,QAAA,CAASxhE,CAAA;UAClC,OAAIQ,CAAA,CAAKy7C,IAAA,GACEz7C,CAAA,CAAKy7C,IAAA,CAAKb,QAAA,CAAS36C,CAAA,CAAKm/D,EAAA,EAAIn/D,CAAA,CAAKo/D,EAAA,EAAI5/D,CAAA,IACzCQ,CAAA,CAAKm6C,QAAA,CAASkmB,OAAA,CAAQ7gE,CAAA,EACjC;QAAA,GAiBAO,CAAA,CAAK4/D,KAAA,GAAQ1/D,CAAA,EAObF,CAAA,CAAKuiE,OAAA,GAAU,UAAiB/iE,CAAA;UAC5B,OAAOA,CAAA,CAAImxB,MAAA,CAAO,GAAG6xC,WAAA,KAAgBhjE,CAAA,CAAImiC,SAAA,CAAU,EACvD;QAAA,GA0DA3hC,CAAA,CAAKyiE,QAAA,GAAWhiE,CAAA,EAmBhBT,CAAA,CAAK0iE,aAAA,GAAgBjiE,CAAA,CAAS,kBAoB9BT,CAAA,CAAKooD,WAAA,GAAc,UAAkB5oD,CAAA;UAEjC,KADA,IAAIC,CAAA,GAAW,CAAC,GACPQ,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAW8B,MAAA,IAAUrB,CAAA,EACrCR,CAAA,CAASD,CAAA,CAAWS,CAAA,KAAM;UAO9B,OAAO;YACH,KAAK,IAAIT,CAAA,GAAO6C,MAAA,CAAO6N,IAAA,CAAK,OAAOjQ,CAAA,GAAIT,CAAA,CAAK8B,MAAA,GAAS,GAAGrB,CAAA,IAAK,KAAKA,CAAA,EAC9D,IAA0B,MAAtBR,CAAA,CAASD,CAAA,CAAKS,CAAA,WAA+B,MAAlB,KAAKT,CAAA,CAAKS,CAAA,MAAuC,SAAlB,KAAKT,CAAA,CAAKS,CAAA,IACpE,OAAOT,CAAA,CAAKS,CAAA,CACxB;UAAA,CACJ;QAAA,GAeAD,CAAA,CAAKqoD,WAAA,GAAc,UAAkB7oD,CAAA;UAQjC,OAAO,UAASC,CAAA;YACZ,KAAK,IAAIQ,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAW8B,MAAA,IAAUrB,CAAA,EACjCT,CAAA,CAAWS,CAAA,MAAOR,CAAA,WACX,KAAKD,CAAA,CAAWS,CAAA,EACnC;UAAA,CACJ;QAAA,GAkBAD,CAAA,CAAKumD,aAAA,GAAgB;UACjBL,KAAA,EAAON,MAAA;UACPO,KAAA,EAAOP,MAAA;UACPnb,KAAA,EAAOmb,MAAA;UACPQ,IAAA,GAAM;QAAA,GAIVpmD,CAAA,CAAK2+D,UAAA,GAAa;UACd,IAAIn/D,CAAA,GAASQ,CAAA,CAAKk/D,MAAA;UAEb1/D,CAAA,IAMLQ,CAAA,CAAK+hE,YAAA,GAAeviE,CAAA,CAAOof,IAAA,KAAS3P,UAAA,CAAW2P,IAAA,IAAQpf,CAAA,CAAOof,IAAA,IAE1D,UAAqBnf,CAAA,EAAOQ,CAAA;YACxB,OAAO,IAAIT,CAAA,CAAOC,CAAA,EAAOQ,CAAA,CAC7B;UAAA,GACJD,CAAA,CAAKgiE,mBAAA,GAAsBxiE,CAAA,CAAOmjE,WAAA,IAE9B,UAA4BljE,CAAA;YACxB,OAAO,IAAID,CAAA,CAAOC,CAAA,CACtB;UAAA,KAdAO,CAAA,CAAK+hE,YAAA,GAAe/hE,CAAA,CAAKgiE,mBAAA,GAAsB,IAevD;QAAA,C;;;;;QCpbAxiE,CAAA,CAAOE,OAAA,GAAUoL,CAAA;QAEjB,IAEI9K,CAAA;UAFAE,CAAA,GAAYD,CAAA,CAAQ;UAIpBQ,CAAA,GAAYP,CAAA,CAAK2lD,QAAA;UACjBnlD,CAAA,GAAYR,CAAA,CAAK4lD,MAAA;UACjBhjD,CAAA,GAAY5C,CAAA,CAAK8+D,IAAA;QAWrB,SAAS97D,EAAG1D,CAAA,EAAIC,CAAA,EAAKQ,CAAA;UAMjB,KAAK68D,EAAA,GAAKt9D,CAAA,EAMV,KAAK6lD,GAAA,GAAM5lD,CAAA,EAMX,KAAKmjE,IAAA,QAAO,GAMZ,KAAKC,GAAA,GAAM5iE,CACf;QAAA;QAGA,SAASgK,EAAA,GAAQ;QAUjB,SAASY,EAAMrL,CAAA;UAMX,KAAKsjE,IAAA,GAAOtjE,CAAA,CAAOsjE,IAAA,EAMnB,KAAKC,IAAA,GAAOvjE,CAAA,CAAOujE,IAAA,EAMnB,KAAK1d,GAAA,GAAM7lD,CAAA,CAAO6lD,GAAA,EAMlB,KAAKud,IAAA,GAAOpjE,CAAA,CAAOwjE,MACvB;QAAA;QAOA,SAASl4D,EAAA;UAML,KAAKu6C,GAAA,GAAM,GAMX,KAAKyd,IAAA,GAAO,IAAI5/D,CAAA,CAAG+G,CAAA,EAAM,GAAG,IAM5B,KAAK84D,IAAA,GAAO,KAAKD,IAAA,EAMjB,KAAKE,MAAA,GAAS,IAOlB;QAAA;QAEA,IAAIj4D,CAAA,GAAS,SAAAk0B,CAAA;UACT,OAAO/+B,CAAA,CAAKg/D,MAAA,GACN;YACE,QAAQp0D,CAAA,CAAOm0B,MAAA,GAAS;cACpB,OAAO,IAAIj/B,CACf,CADe,CACf;YAAA,IACJ;UAAA,IAEE;YACE,OAAO,IAAI8K,CACf,CADe,CACf;UAAA,CACR;QAAA;QAqCA,SAAS/E,EAAUvG,CAAA,EAAKC,CAAA,EAAKQ,CAAA;UACzBR,CAAA,CAAIQ,CAAA,IAAa,MAANT,CACf;QAAA;QAmBA,SAAS0L,EAAS1L,CAAA,EAAKC,CAAA;UACnB,KAAK4lD,GAAA,GAAM7lD,CAAA,EACX,KAAKojE,IAAA,QAAO,GACZ,KAAKC,GAAA,GAAMpjE,CACf;QAAA;QA6CA,SAASuG,EAAcxG,CAAA,EAAKC,CAAA,EAAKQ,CAAA;UAC7B,OAAOT,CAAA,CAAI6/D,EAAA,GACP5/D,CAAA,CAAIQ,CAAA,MAAkB,MAATT,CAAA,CAAI4/D,EAAA,GAAW,KAC5B5/D,CAAA,CAAI4/D,EAAA,IAAM5/D,CAAA,CAAI4/D,EAAA,KAAO,IAAI5/D,CAAA,CAAI6/D,EAAA,IAAM,QAAQ,GAC3C7/D,CAAA,CAAI6/D,EAAA,MAAQ;UAEhB,OAAO7/D,CAAA,CAAI4/D,EAAA,GAAK,MACZ3/D,CAAA,CAAIQ,CAAA,MAAkB,MAATT,CAAA,CAAI4/D,EAAA,GAAW,KAC5B5/D,CAAA,CAAI4/D,EAAA,GAAK5/D,CAAA,CAAI4/D,EAAA,KAAO;UAExB3/D,CAAA,CAAIQ,CAAA,MAAST,CAAA,CAAI4/D,EACrB;QAAA;QA0CA,SAASh0D,EAAa5L,CAAA,EAAKC,CAAA,EAAKQ,CAAA;UAC5BR,CAAA,CAAIQ,CAAA,IAA0B,MAAdT,CAAA,EAChBC,CAAA,CAAIQ,CAAA,GAAM,KAAMT,CAAA,KAAQ,IAAM,KAC9BC,CAAA,CAAIQ,CAAA,GAAM,KAAMT,CAAA,KAAQ,KAAM,KAC9BC,CAAA,CAAIQ,CAAA,GAAM,KAAMT,CAAA,KAAQ,EAC5B;QAAA;QA9JAsL,CAAA,CAAOm0B,MAAA,GAASl0B,CAAA,IAOhBD,CAAA,CAAOm4D,KAAA,GAAQ,UAAezjE,CAAA;UAC1B,OAAO,IAAIU,CAAA,CAAKsF,KAAA,CAAMhG,CAAA,CAC1B;QAAA,GAIIU,CAAA,CAAKsF,KAAA,KAAUA,KAAA,KACfsF,CAAA,CAAOm4D,KAAA,GAAQ/iE,CAAA,CAAKqhE,IAAA,CAAKz2D,CAAA,CAAOm4D,KAAA,EAAO/iE,CAAA,CAAKsF,KAAA,CAAM6+C,SAAA,CAAUhwC,QAAA,IAUhEvJ,CAAA,CAAOu5C,SAAA,CAAU6e,KAAA,GAAQ,UAAc1jE,CAAA,EAAIC,CAAA,EAAKQ,CAAA;UAG5C,OAFA,KAAK8iE,IAAA,GAAO,KAAKA,IAAA,CAAKH,IAAA,GAAO,IAAI1/D,CAAA,CAAG1D,CAAA,EAAIC,CAAA,EAAKQ,CAAA,GAC7C,KAAKolD,GAAA,IAAO5lD,CAAA,EACL,IACX;QAAA,GA6BAyL,CAAA,CAASm5C,SAAA,GAAYhiD,MAAA,CAAO48B,MAAA,CAAO/7B,CAAA,CAAGmhD,SAAA,GACtCn5C,CAAA,CAASm5C,SAAA,CAAUyY,EAAA,GAxBnB,UAAuBt9D,CAAA,EAAKC,CAAA,EAAKQ,CAAA;UAC7B,OAAOT,CAAA,GAAM,MACTC,CAAA,CAAIQ,CAAA,MAAe,MAANT,CAAA,GAAY,KACzBA,CAAA,MAAS;UAEbC,CAAA,CAAIQ,CAAA,IAAOT,CACf;QAAA,GAyBAsL,CAAA,CAAOu5C,SAAA,CAAUM,MAAA,GAAS,UAAsBnlD,CAAA;UAW5C,OARA,KAAK6lD,GAAA,KAAQ,KAAK0d,IAAA,GAAO,KAAKA,IAAA,CAAKH,IAAA,GAAO,IAAI13D,CAAA,EACzC1L,CAAA,MAAkB,KACT,MAAY,IACpBA,CAAA,GAAQ,QAAY,IACpBA,CAAA,GAAQ,UAAY,IACpBA,CAAA,GAAQ,YAAY,IACA,GAC1BA,CAAA,GAAQ6lD,GAAA,EACD,IACX;QAAA,GAQAv6C,CAAA,CAAOu5C,SAAA,CAAUa,KAAA,GAAQ,UAAqB1lD,CAAA;UAC1C,OAAOA,CAAA,GAAQ,IACT,KAAK0jE,KAAA,CAAMl9D,CAAA,EAAe,IAAIvF,CAAA,CAASogE,UAAA,CAAWrhE,CAAA,KAClD,KAAKmlD,MAAA,CAAOnlD,CAAA,CACtB;QAAA,GAOAsL,CAAA,CAAOu5C,SAAA,CAAUkb,MAAA,GAAS,UAAsB//D,CAAA;UAC5C,OAAO,KAAKmlD,MAAA,EAAQnlD,CAAA,IAAS,IAAIA,CAAA,IAAS,QAAQ,EACtD;QAAA,GAqBAsL,CAAA,CAAOu5C,SAAA,CAAU2D,MAAA,GAAS,UAAsBxoD,CAAA;UAC5C,IAAIC,CAAA,GAAOgB,CAAA,CAASme,IAAA,CAAKpf,CAAA;UACzB,OAAO,KAAK0jE,KAAA,CAAMl9D,CAAA,EAAevG,CAAA,CAAK6B,MAAA,IAAU7B,CAAA,CACpD;QAAA,GASAqL,CAAA,CAAOu5C,SAAA,CAAUS,KAAA,GAAQh6C,CAAA,CAAOu5C,SAAA,CAAU2D,MAAA,EAQ1Cl9C,CAAA,CAAOu5C,SAAA,CAAUwb,MAAA,GAAS,UAAsBrgE,CAAA;UAC5C,IAAIC,CAAA,GAAOgB,CAAA,CAASme,IAAA,CAAKpf,CAAA,EAAOmhE,QAAA;UAChC,OAAO,KAAKuC,KAAA,CAAMl9D,CAAA,EAAevG,CAAA,CAAK6B,MAAA,IAAU7B,CAAA,CACpD;QAAA,GAOAqL,CAAA,CAAOu5C,SAAA,CAAUmb,IAAA,GAAO,UAAoBhgE,CAAA;UACxC,OAAO,KAAK0jE,KAAA,CAAMn9D,CAAA,EAAW,GAAGvG,CAAA,GAAQ,IAAI,EAChD;QAAA,GAcAsL,CAAA,CAAOu5C,SAAA,CAAUob,OAAA,GAAU,UAAuBjgE,CAAA;UAC9C,OAAO,KAAK0jE,KAAA,CAAM93D,CAAA,EAAc,GAAG5L,CAAA,KAAU,EACjD;QAAA,GAQAsL,CAAA,CAAOu5C,SAAA,CAAUqb,QAAA,GAAW50D,CAAA,CAAOu5C,SAAA,CAAUob,OAAA,EAQ7C30D,CAAA,CAAOu5C,SAAA,CAAU0b,OAAA,GAAU,UAAuBvgE,CAAA;UAC9C,IAAIC,CAAA,GAAOgB,CAAA,CAASme,IAAA,CAAKpf,CAAA;UACzB,OAAO,KAAK0jE,KAAA,CAAM93D,CAAA,EAAc,GAAG3L,CAAA,CAAK2/D,EAAA,EAAI8D,KAAA,CAAM93D,CAAA,EAAc,GAAG3L,CAAA,CAAK4/D,EAAA,CAC5E;QAAA,GASAv0D,CAAA,CAAOu5C,SAAA,CAAU2b,QAAA,GAAWl1D,CAAA,CAAOu5C,SAAA,CAAU0b,OAAA,EAQ7Cj1D,CAAA,CAAOu5C,SAAA,CAAUQ,KAAA,GAAQ,UAAqBrlD,CAAA;UAC1C,OAAO,KAAK0jE,KAAA,CAAMhjE,CAAA,CAAK2kD,KAAA,CAAMoY,YAAA,EAAc,GAAGz9D,CAAA,CAClD;QAAA,GAQAsL,CAAA,CAAOu5C,SAAA,CAAU0D,MAAA,GAAS,UAAsBvoD,CAAA;UAC5C,OAAO,KAAK0jE,KAAA,CAAMhjE,CAAA,CAAK2kD,KAAA,CAAM0Y,aAAA,EAAe,GAAG/9D,CAAA,CACnD;QAAA;QAEA,IAAI6L,CAAA,GAAanL,CAAA,CAAKsF,KAAA,CAAM6+C,SAAA,CAAU9gD,GAAA,GAChC,UAAwB/D,CAAA,EAAKC,CAAA,EAAKQ,CAAA;UAChCR,CAAA,CAAI8D,GAAA,CAAI/D,CAAA,EAAKS,CAAA,CACjB;QAAA,IAEE,UAAwBT,CAAA,EAAKC,CAAA,EAAKQ,CAAA;UAChC,KAAK,IAAID,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAI8B,MAAA,IAAUtB,CAAA,EAC9BP,CAAA,CAAIQ,CAAA,GAAMD,CAAA,IAAKR,CAAA,CAAIQ,CAAA,CAC3B;QAAA;QAOJ8K,CAAA,CAAOu5C,SAAA,CAAU5Z,KAAA,GAAQ,UAAqBjrC,CAAA;UAC1C,IAAIC,CAAA,GAAMD,CAAA,CAAM8B,MAAA,KAAW;UAC3B,KAAK7B,CAAA,EACD,OAAO,KAAKyjE,KAAA,CAAMn9D,CAAA,EAAW,GAAG;UACpC,IAAI7F,CAAA,CAAKwlD,QAAA,CAASlmD,CAAA,GAAQ;YACtB,IAAIS,CAAA,GAAM6K,CAAA,CAAOm4D,KAAA,CAAMxjE,CAAA,GAAMiB,CAAA,CAAOY,MAAA,CAAO9B,CAAA;YAC3CkB,CAAA,CAAOiO,MAAA,CAAOnP,CAAA,EAAOS,CAAA,EAAK,IAC1BT,CAAA,GAAQS,CACZ;UAAA;UACA,OAAO,KAAK0kD,MAAA,CAAOllD,CAAA,EAAKyjE,KAAA,CAAM73D,CAAA,EAAY5L,CAAA,EAAKD,CAAA,CACnD;QAAA,GAOAsL,CAAA,CAAOu5C,SAAA,CAAUO,MAAA,GAAS,UAAsBplD,CAAA;UAC5C,IAAIC,CAAA,GAAMqD,CAAA,CAAKxB,MAAA,CAAO9B,CAAA;UACtB,OAAOC,CAAA,GACD,KAAKklD,MAAA,CAAOllD,CAAA,EAAKyjE,KAAA,CAAMpgE,CAAA,CAAKk7D,KAAA,EAAOv+D,CAAA,EAAKD,CAAA,IACxC,KAAK0jE,KAAA,CAAMn9D,CAAA,EAAW,GAAG,EACnC;QAAA,GAOA+E,CAAA,CAAOu5C,SAAA,CAAUU,IAAA,GAAO;UAIpB,OAHA,KAAKie,MAAA,GAAS,IAAIn4D,CAAA,CAAM,OACxB,KAAKi4D,IAAA,GAAO,KAAKC,IAAA,GAAO,IAAI7/D,CAAA,CAAG+G,CAAA,EAAM,GAAG,IACxC,KAAKo7C,GAAA,GAAM,GACJ,IACX;QAAA,GAMAv6C,CAAA,CAAOu5C,SAAA,CAAUrqB,KAAA,GAAQ;UAUrB,OATI,KAAKgpC,MAAA,IACL,KAAKF,IAAA,GAAS,KAAKE,MAAA,CAAOF,IAAA,EAC1B,KAAKC,IAAA,GAAS,KAAKC,MAAA,CAAOD,IAAA,EAC1B,KAAK1d,GAAA,GAAS,KAAK2d,MAAA,CAAO3d,GAAA,EAC1B,KAAK2d,MAAA,GAAS,KAAKA,MAAA,CAAOJ,IAAA,KAE1B,KAAKE,IAAA,GAAO,KAAKC,IAAA,GAAO,IAAI7/D,CAAA,CAAG+G,CAAA,EAAM,GAAG,IACxC,KAAKo7C,GAAA,GAAO,IAET,IACX;QAAA,GAMAv6C,CAAA,CAAOu5C,SAAA,CAAUW,MAAA,GAAS;UACtB,IAAIxlD,CAAA,GAAO,KAAKsjE,IAAA;YACZrjE,CAAA,GAAO,KAAKsjE,IAAA;YACZ9iE,CAAA,GAAO,KAAKolD,GAAA;UAOhB,OANA,KAAKrrB,KAAA,GAAQ2qB,MAAA,CAAO1kD,CAAA,GAChBA,CAAA,KACA,KAAK8iE,IAAA,CAAKH,IAAA,GAAOpjE,CAAA,CAAKojE,IAAA,EACtB,KAAKG,IAAA,GAAOtjE,CAAA,EACZ,KAAK4lD,GAAA,IAAOplD,CAAA,GAET,IACX;QAAA,GAMA6K,CAAA,CAAOu5C,SAAA,CAAU3tB,MAAA,GAAS;UAItB,KAHA,IAAIl3B,CAAA,GAAO,KAAKsjE,IAAA,CAAKF,IAAA,EACjBnjE,CAAA,GAAO,KAAK2C,WAAA,CAAY6gE,KAAA,CAAM,KAAK5d,GAAA,GACnCplD,CAAA,GAAO,GACJT,CAAA,GACHA,CAAA,CAAKs9D,EAAA,CAAGt9D,CAAA,CAAKqjE,GAAA,EAAKpjE,CAAA,EAAKQ,CAAA,GACvBA,CAAA,IAAOT,CAAA,CAAK6lD,GAAA,EACZ7lD,CAAA,GAAOA,CAAA,CAAKojE,IAAA;UAGhB,OAAOnjE,CACX;QAAA,GAEAqL,CAAA,CAAO6zD,UAAA,GAAa,UAASn/D,CAAA;UACzBQ,CAAA,GAAeR,CAAA,EACfsL,CAAA,CAAOm0B,MAAA,GAASl0B,CAAA,IAChB/K,CAAA,CAAa2+D,UAAA,EACjB;QAAA,C;;;;;QC/cAn/D,CAAA,CAAOE,OAAA,GAAUe,CAAA;QAGjB,IAAIT,CAAA,GAASC,CAAA,CAAQ;QAAA,CACpBQ,CAAA,CAAa4jD,SAAA,GAAYhiD,MAAA,CAAO48B,MAAA,CAAOj/B,CAAA,CAAOqkD,SAAA,GAAYjiD,WAAA,GAAc3B,CAAA;QAEzE,IAAIP,CAAA,GAAOD,CAAA,CAAQ;QAQnB,SAASQ,EAAA;UACLT,CAAA,CAAO4kB,IAAA,CAAK,KAChB;QAAA;QAuCA,SAASlkB,EAAkBlB,CAAA,EAAKC,CAAA,EAAKQ,CAAA;UAC7BT,CAAA,CAAI8B,MAAA,GAAS,KACbpB,CAAA,CAAK8+D,IAAA,CAAKhB,KAAA,CAAMx+D,CAAA,EAAKC,CAAA,EAAKQ,CAAA,IACrBR,CAAA,CAAIqiE,SAAA,GACTriE,CAAA,CAAIqiE,SAAA,CAAUtiE,CAAA,EAAKS,CAAA,IAEnBR,CAAA,CAAIu+D,KAAA,CAAMx+D,CAAA,EAAKS,CAAA,CACvB;QAAA;QA5CAQ,CAAA,CAAak+D,UAAA,GAAa;UAOtBl+D,CAAA,CAAawiE,KAAA,GAAQ/iE,CAAA,CAAK8hE,mBAAA,EAE1BvhE,CAAA,CAAa0iE,gBAAA,GAAmBjjE,CAAA,CAAKg/D,MAAA,IAAUh/D,CAAA,CAAKg/D,MAAA,CAAO7a,SAAA,YAAqBp1C,UAAA,IAAiD,UAAnC/O,CAAA,CAAKg/D,MAAA,CAAO7a,SAAA,CAAU9gD,GAAA,CAAIC,IAAA,GAClH,UAA8BhE,CAAA,EAAKC,CAAA,EAAKQ,CAAA;YACxCR,CAAA,CAAI8D,GAAA,CAAI/D,CAAA,EAAKS,CAAA,CAEf;UAAA,IAEE,UAA+BT,CAAA,EAAKC,CAAA,EAAKQ,CAAA;YACzC,IAAIT,CAAA,CAAI4jE,IAAA,EACN5jE,CAAA,CAAI4jE,IAAA,CAAK3jE,CAAA,EAAKQ,CAAA,EAAK,GAAGT,CAAA,CAAI8B,MAAA,OACvB,KAAK,IAAItB,CAAA,GAAI,GAAGA,CAAA,GAAIR,CAAA,CAAI8B,MAAA,GAC3B7B,CAAA,CAAIQ,CAAA,MAAST,CAAA,CAAIQ,CAAA,GACrB;UAAA,CACR;QAAA,GAMAS,CAAA,CAAa4jD,SAAA,CAAU5Z,KAAA,GAAQ,UAA4BjrC,CAAA;UACnDU,CAAA,CAAKwlD,QAAA,CAASlmD,CAAA,MACdA,CAAA,GAAQU,CAAA,CAAK6hE,YAAA,CAAaviE,CAAA,EAAO;UACrC,IAAIC,CAAA,GAAMD,CAAA,CAAM8B,MAAA,KAAW;UAI3B,OAHA,KAAKqjD,MAAA,CAAOllD,CAAA,GACRA,CAAA,IACA,KAAKyjE,KAAA,CAAMziE,CAAA,CAAa0iE,gBAAA,EAAkB1jE,CAAA,EAAKD,CAAA,GAC5C,IACX;QAAA,GAcAiB,CAAA,CAAa4jD,SAAA,CAAUO,MAAA,GAAS,UAA6BplD,CAAA;UACzD,IAAIC,CAAA,GAAMS,CAAA,CAAKg/D,MAAA,CAAO5wC,UAAA,CAAW9uB,CAAA;UAIjC,OAHA,KAAKmlD,MAAA,CAAOllD,CAAA,GACRA,CAAA,IACA,KAAKyjE,KAAA,CAAMxiE,CAAA,EAAmBjB,CAAA,EAAKD,CAAA,GAChC,IACX;QAAA,GAUAiB,CAAA,CAAak+D,UAAA,E;;;;;;;;;;;;;;;;;;;;;;QCjFbt8D,MAAA,CAAO8lD,cAAA,CAAe1oD,CAAA,EAAS,cAAc;UAAEkkB,KAAA,GAAO;QAAA,IACtDlkB,CAAA,CAAQuH,cAAA,GAAiBvH,CAAA,CAAQuC,eAAA,QAAkB;QACnD,MAAM/B,CAAA,GAAW,CAAC;UACZD,CAAA,GAA2B;QA2CjCP,CAAA,CAAQuC,eAAA,GAhCgB,CAACxC,CAAA,EAAMC,CAAA,EAASS,CAAA;UACpC,KAAIT,CAAA,IAAmC,qBAAjBA,CAAA,CAAQW,IAAA,IAA+D,qBAAjCX,CAAA,CAAQY,oBAAA,EA6BpE,MAAM,IAAIkhB,SAAA,CAAU;UA7BpB;YACI,MAAM9gB,CAAA,GAAiBR,CAAA,CAAST,CAAA;YAChC,SAAuB,MAAnBiB,CAAA,EACAR,CAAA,CAAST,CAAA,IAAQ;cAAEmH,OAAA,EAAAlH,CAAA;cAAS4jE,QAAA,EAAAnjE;YAAA,OAE3B;cAAA,IAAIO,CAAA,CAAe4iE,QAAA,GAAWnjE,CAAA,EAE/B;cAEC,IAAIO,CAAA,CAAe4iE,QAAA,KAAanjE,CAAA,IAC7BO,CAAA,CAAekG,OAAA,KAAYlH,CAAA,EAC3B,MAAM,IAAIoE,KAAA,CAAM,4BAA4BrE,CAAA,oBAAwBU,CAAA,GAE5E;YAAA;YACA,IAAIA,CAAA,IAAY,GAAG;cACf,MAAMT,CAAA,GAAIO,CAAA,CAAyB4L,OAAA,CAAQpM,CAAA;cAAA,CAChC,MAAPC,CAAA,IACAO,CAAA,CAAyBiwB,MAAA,CAAOxwB,CAAA,EAAG;cAEvC,KAAK,IAAIA,CAAA,GAAI,GAAGA,CAAA,GAAIO,CAAA,CAAyBsB,MAAA,EAAQ7B,CAAA,IACjD,IAAIQ,CAAA,CAASD,CAAA,CAAyBP,CAAA,GAAI4jE,QAAA,IAAYnjE,CAAA,EAElD,YADAF,CAAA,CAAyBiwB,MAAA,CAAOxwB,CAAA,EAAG,GAAGD,CAAA;cAI9CQ,CAAA,CAAyBwG,IAAA,CAAKhH,CAAA,CAClC;YAAA;UAEJ;QAC0C,GA6C9CC,CAAA,CAAQuH,cAAA,GAlCe,MAAOxH,CAAA;UAC1B,MAAMC,CAAA,GAAuC,MAAxBD,CAAA,CAAa8B,MAAA,GAAetB,CAAA,GAA2BR,CAAA;YACtEU,CAAA,GAAS;UACf,KAAK,MAAMV,CAAA,IAAeC,CAAA,EAAc;YACpC,MAAMA,CAAA,GAAcQ,CAAA,CAAST,CAAA;YAC7B,IAAIC,CAAA,EAAa;cACb,IAAIA,CAAA,CAAY6jE,WAAA,EACZ,OAAO7jE,CAAA,CAAYkH,OAAA;cAElB,IAAIlH,CAAA,CAAY8jE,OAAA,EACjB;cAEJ,MAAMtjE,CAAA,KAAmBR,CAAA,CAAY+jE,WAAA;cACrC;gBAMI,OALKvjE,CAAA,KACDR,CAAA,CAAY+jE,WAAA,GAAc/jE,CAAA,CAAYkH,OAAA,CAAQvG,IAAA,WAE5CX,CAAA,CAAY+jE,WAAA,EAClB/jE,CAAA,CAAY6jE,WAAA,IAAc,GACnB7jE,CAAA,CAAYkH,OACvB;cAAA,CACA,QAAO3G,CAAA;gBACEC,CAAA,IACDC,CAAA,CAAOsG,IAAA,CAAK;kBAAEhD,IAAA,EAAMhE,CAAA;kBAAau9C,GAAA,EAAK/8C;gBAAA,IAE1CP,CAAA,CAAY8jE,OAAA,IAAU,CAC1B;cAAA,CACA;gBAAA,OACW9jE,CAAA,CAAY+jE,WACvB;cAAA;YACJ;UACJ;UACA,MAAM,IAAI3/D,KAAA,CAAM,oCAAoC3D,CAAA,CAAOyC,GAAA,CAAInD,CAAA,IAAK,IAAIA,CAAA,CAAEgE,IAAA,KAAShE,CAAA,CAAEu9C,GAAA,IAAOn6C,IAAA,CAAK,QAAQ;QAAA,C;;;;;QCvF7GP,MAAA,CAAO8lD,cAAA,CAAe1oD,CAAA,EAAS,cAAc;UAAEkkB,KAAA,GAAO;QAAA,IACtDlkB,CAAA,CAAQuC,eAAA,QAAkB;QAC1B,IAAIhC,CAAA,GAAoBC,CAAA,CAAQ;QAChCoC,MAAA,CAAO8lD,cAAA,CAAe1oD,CAAA,EAAS,mBAAmB;UAAE4hE,UAAA,GAAY;UAAMr9D,GAAA,EAAK,SAAAA,CAAA;YAAc,OAAOhE,CAAA,CAAkBgC,eAAiB;UAAA;QAAA,E;;;;;QCHnIK,MAAA,CAAO8lD,cAAA,CAAe1oD,CAAA,EAAS,cAAc;UAAEkkB,KAAA,GAAO;QAAA,IACtDlkB,CAAA,CAAQmB,GAAA,QAAM;QACd,MAAMZ,CAAA,GAAeC,CAAA,CAAQ;QAC7B,IAAIC,CAAA,GAAgB;QACpBT,CAAA,CAAQmB,GAAA,GAAM;UACVC,IAAA,EAAM,CAAC;UACPiG,KAAA,EAAO,CAAC;UACR28D,MAAA,EAAQ,CAAC;UACTxhE,QAAA,EAAU;YAAEyhE,MAAA,EAAQ1jE,CAAA,CAAamC;UAAA;UAC7B,IAAAo8B,SAAS/+B,CAAA;YACT,SAAc,MAAVA,CAAA,EAAJ;cAGA,IAAqB,mBAAVA,CAAA,KAA2F,MAArE,CAAC,WAAW,QAAQ,WAAW,SAAS,SAASoM,OAAA,CAAQpM,CAAA,GACtF,MAAM,IAAIqE,KAAA,CAAM,8BAA8BrE,CAAA;cAElDU,CAAA,GAAgBV,CAJhB;YAAA;UAKJ;UACI,IAAA++B,SAAA;YACA,OAAOr+B,CACX;UAAA;QAAA,GAGJmC,MAAA,CAAO8lD,cAAA,CAAe1oD,CAAA,CAAQmB,GAAA,EAAK,YAAY;UAAEygE,UAAA,GAAY;QAAA,E;;;;;QCvB7Dh/D,MAAA,CAAO8lD,cAAA,CAAe1oD,CAAA,EAAS,cAAc;UAAEkkB,KAAA,GAAO;QAAA,IACtDlkB,CAAA,CAAQmB,GAAA,QAAM;QACd,MAAMZ,CAAA,GAAgBC,CAAA,CAAQ;QAI9BR,CAAA,CAAQmB,GAAA,GAAMZ,CAAA,CAAcY,G;;;;;QCN5B,IAAIZ,CAAA,GAAmB,QAAQ,KAAK2jE,eAAA,KAAqBthE,MAAA,CAAO48B,MAAA,GAAS,UAAUz/B,CAAA,EAAGC,CAAA,EAAGQ,CAAA,EAAGD,CAAA;YAAA,KAC7E,MAAPA,CAAA,KAAkBA,CAAA,GAAKC,CAAA;YAC3B,IAAIC,CAAA,GAAOmC,MAAA,CAAOuhE,wBAAA,CAAyBnkE,CAAA,EAAGQ,CAAA;YACzCC,CAAA,MAAS,SAASA,CAAA,IAAQT,CAAA,CAAEw+D,UAAA,GAAa/9D,CAAA,CAAKkhE,QAAA,IAAYlhE,CAAA,CAAKohE,YAAA,MAClEphE,CAAA,GAAO;cAAEmhE,UAAA,GAAY;cAAMr9D,GAAA,EAAK,SAAAA,CAAA;gBAAa,OAAOvE,CAAA,CAAEQ,CAAA,CAAI;cAAA;YAAA,IAE5DoC,MAAA,CAAO8lD,cAAA,CAAe3oD,CAAA,EAAGQ,CAAA,EAAIE,CAAA,CAChC;UAAA,IAAI,UAAUV,CAAA,EAAGC,CAAA,EAAGQ,CAAA,EAAGD,CAAA;YAAA,KACT,MAAPA,CAAA,KAAkBA,CAAA,GAAKC,CAAA,GAC3BT,CAAA,CAAEQ,CAAA,IAAMP,CAAA,CAAEQ,CAAA,CACb;UAAA;UACGC,CAAA,GAAgB,QAAQ,KAAK2jE,YAAA,IAAiB,UAASrkE,CAAA,EAAGC,CAAA;YAC1D,KAAK,IAAIQ,CAAA,IAAKT,CAAA,EAAa,cAANS,CAAA,IAAoBoC,MAAA,CAAOgiD,SAAA,CAAU1/B,cAAA,CAAeC,IAAA,CAAKnlB,CAAA,EAASQ,CAAA,KAAID,CAAA,CAAgBP,CAAA,EAASD,CAAA,EAAGS,CAAA,CAC3H;UAAA;QACAoC,MAAA,CAAO8lD,cAAA,CAAe1oD,CAAA,EAAS,cAAc;UAAEkkB,KAAA,GAAO;QAAA,IAgBtDzjB,CAAA,CAAaD,CAAA,CAAQ,OAAiBR,CAAA,GACtCS,CAAA,CAAaD,CAAA,CAAQ,OAAaR,CAAA,GAClCS,CAAA,CAAaD,CAAA,CAAQ,OAA2BR,CAAA,GAChDS,CAAA,CAAaD,CAAA,CAAQ,MAAgBR,CAAA,GACrCS,CAAA,CAAaD,CAAA,CAAQ,OAAoBR,CAAA,C;;;;;QClCzC4C,MAAA,CAAO8lD,cAAA,CAAe1oD,CAAA,EAAS,cAAc;UAAEkkB,KAAA,GAAO;QAAA,IACtDlkB,CAAA,CAAQyhC,gBAAA,QAAmB;QAC3B,MAAMlhC,CAAA,GAAoBC,CAAA,CAAQ;UAC5BC,CAAA,GAAcD,CAAA,CAAQ;QAC5B,MAAMQ,CAAA;UACF2B,YAAY5C,CAAA;YACR,KAAKoxD,OAAA,GAAUpxD,CACnB;UAAA;UACA,MAAAmU,IAAUnU,CAAA,EAAOC,CAAA,EAAMQ,CAAA;YACnB,MAAMD,CAAA,GAAU,CAAC;YACjB,IAAIS,CAAA,GAAU,CAAC;YAEf,IAAqB,mBAAVjB,CAAA,IAAgC,SAAVA,CAAA,IAAkBA,CAAA,YAAiBU,CAAA,CAAYuF,MAAA,IAAUD,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,GACpG,MAAM,IAAI+hB,SAAA,CAAU;YAExB,IAAI7gB,CAAA,IAAiB;YAErB,IAAoB,mBAATjB,CAAA,EAAmB;cAC1B,IAAa,SAATA,CAAA,EACA,MAAM,IAAI8hB,SAAA,CAAU;cAExB,IAAI9hB,CAAA,YAAgBS,CAAA,CAAYuF,MAAA,EAC5B,MAAM,IAAI8b,SAAA,CAAU;cAExB,IAAI/b,KAAA,CAAM+oB,OAAA,CAAQ9uB,CAAA,GAAO;gBACrB,IAAoB,MAAhBA,CAAA,CAAK6B,MAAA,EACL,MAAM,IAAIigB,SAAA,CAAU;gBAExB7gB,CAAA,IAAiB;gBAEjB,KAAK,MAAMlB,CAAA,IAAQC,CAAA,EAAM;kBACrB,IAAoB,mBAATD,CAAA,EACP,MAAM,IAAI+hB,SAAA,CAAU;kBAExB,KAAwC,MAApC,KAAKo2B,WAAA,CAAY/rC,OAAA,CAAQpM,CAAA,GACzB,MAAM,IAAI+5C,UAAA,CAAW,2CAA2C/5C,CAAA;kBAEpEQ,CAAA,CAAQR,CAAA,IAAQ,IACpB;gBAAA;gBACA,IAAoB,mBAATS,CAAA,IAA8B,SAATA,CAAA,EAC5BQ,CAAA,GAAUR,CAAA,MAET,SAAoB,MAATA,CAAA,EACZ,MAAM,IAAIshB,SAAA,CAAU,+BAE5B;cAAA,OACK;gBAGD,IAAI/hB,CAAA,IAAY;gBAChB,MAAMsD,CAAA,GAAWT,MAAA,CAAOI,mBAAA,CAAoBhD,CAAA;gBAC5C,KAAK,MAAMQ,CAAA,IAAQ,KAAK03C,WAAA,EACpB,KAAgC,MAA5B70C,CAAA,CAAS8I,OAAA,CAAQ3L,CAAA,GAAc;kBAC/B,MAAMQ,CAAA,GAAIhB,CAAA,CAAKQ,CAAA;kBAAA,CACL,SAANQ,CAAA,IAAcA,CAAA,YAAaP,CAAA,CAAYuF,MAAA,MACvCjG,CAAA,IAAY,GACZkB,CAAA,IAAiB,GACjBV,CAAA,CAAQC,CAAA,IAAQQ,CAAA,CAExB;gBAAA;gBAEJ,IAAIjB,CAAA;kBACA,IAAoB,mBAATS,CAAA,IAA8B,SAATA,CAAA,EAC5BQ,CAAA,GAAUR,CAAA,MAET,SAAoB,MAATA,CAAA,EACZ,MAAM,IAAIshB,SAAA,CAAU;gBAAA,OAIxB9gB,CAAA,GAAUhB,CAElB;cAAA;YACJ,OACK,SAAoB,MAATA,CAAA,EACZ,MAAM,IAAI8hB,SAAA,CAAU;YAGxB,KAAK,MAAM9hB,CAAA,IAAQ,KAAK2K,UAAA,EACpB,SAA2B,MAAhB5K,CAAA,CAAMC,CAAA,GACb,MAAM,IAAIoE,KAAA,CAAM,UAAUpE,CAAA;YAIlC,IAAIiB,CAAA,EACA,KAAK,MAAMlB,CAAA,IAAQ,KAAKm4C,WAAA,EACpB33C,CAAA,CAAQR,CAAA,IAAQ;YAIxB,MAAMsD,CAAA,SAAgB,KAAK8tD,OAAA,CAAQj9C,GAAA,CAAInU,CAAA,EAAOQ,CAAA,EAASS,CAAA;cACjDyC,CAAA,GAAc,CAAC;YACrB,KAAK,MAAM1D,CAAA,IAAOsD,CAAA,EACVT,MAAA,CAAOsiB,cAAA,CAAeC,IAAA,CAAK9hB,CAAA,EAAStD,CAAA,MACpC0D,CAAA,CAAY1D,CAAA,IAAO,IAAIU,CAAA,CAAYuF,MAAA,CAAO3C,CAAA,CAAQtD,CAAA,EAAKgF,IAAA,EAAM1B,CAAA,CAAQtD,CAAA,EAAKyjB,IAAA,EAAMngB,CAAA,CAAQtD,CAAA,EAAK6T,IAAA;YAGrG,OAAOnQ,CACX;UAAA;UACA,MAAA4gE,QAAA;YACI,OAAO,KAAKlT,OAAA,CAAQ/pD,OAAA,EACxB;UAAA;UACA,aAAAo4B,OAAoBz/B,CAAA,EAAMC,CAAA,EAAMQ,CAAA,EAAMC,CAAA;YAElC,IAAIQ,CAAA;cACAoC,CAAA,GAAU,CAAC;YACf,IAAoB,mBAATtD,CAAA;cAEP,IADAkB,CAAA,GAAuBlB,CAAA,EACH,mBAATC,CAAA,IAA8B,SAATA,CAAA,EAC5BqD,CAAA,GAAUrD,CAAA,MAET,SAAoB,MAATA,CAAA,EACZ,MAAM,IAAI8hB,SAAA,CAAU;YAAA,OAGvB,IAAI/hB,CAAA,YAAgByP,UAAA;cAErB,IADAvO,CAAA,GAAuBlB,CAAA,EACH,mBAATC,CAAA,IAA8B,SAATA,CAAA,EAC5BqD,CAAA,GAAUrD,CAAA,MAET,SAAoB,MAATA,CAAA,EACZ,MAAM,IAAI8hB,SAAA,CAAU;YAAA,OAGvB;cAAA,MAAI/hB,CAAA,YAAgBuP,WAAA,IACS,sBAAtBozC,iBAAA,IAAqC3iD,CAAA,YAAgB2iD,iBAAA,GAyC7D,MAAM,IAAI5gC,SAAA,CAAU;cAzC6D;gBACjF,MAAMvhB,CAAA,GAASR,CAAA;gBACf,IAAIiB,CAAA,GAAa;kBACbyC,CAAA,GAAa1D,CAAA,CAAK8uB,UAAA;gBACtB,IAAoB,mBAAT7uB,CAAA,IAA8B,SAATA,CAAA,EAC5BqD,CAAA,GAAUrD,CAAA,MAET,IAAoB,mBAATA,CAAA,EAAmB;kBAE/B,IADAgB,CAAA,GAAahB,CAAA,GACRyB,MAAA,CAAO6iE,aAAA,CAActjE,CAAA,GACtB,MAAM,IAAI84C,UAAA,CAAW;kBAEzB,IAAI94C,CAAA,GAAa,KAAKA,CAAA,IAAcT,CAAA,CAAOsuB,UAAA,EACvC,MAAM,IAAIirB,UAAA,CAAW,oCAAoCv5C,CAAA,CAAOsuB,UAAA;kBAGpE,IADAprB,CAAA,GAAa1D,CAAA,CAAK8uB,UAAA,GAAa7tB,CAAA,EACX,mBAATR,CAAA,EAAmB;oBAE1B,IADAiD,CAAA,GAAajD,CAAA,GACRiB,MAAA,CAAO6iE,aAAA,CAAc7gE,CAAA,GACtB,MAAM,IAAIq2C,UAAA,CAAW;oBAEzB,IAAIr2C,CAAA,IAAc,KAAKzC,CAAA,GAAayC,CAAA,GAAalD,CAAA,CAAOsuB,UAAA,EACpD,MAAM,IAAIirB,UAAA,CAAW,oCAAoCv5C,CAAA,CAAOsuB,UAAA,GAAa7tB,CAAA;oBAEjF,IAAoB,mBAATP,CAAA,IAA8B,SAATA,CAAA,EAC5B4C,CAAA,GAAU5C,CAAA,MAET,SAAoB,MAATA,CAAA,EACZ,MAAM,IAAIqhB,SAAA,CAAU,+BAE5B;kBAAA,OACK,SAAoB,MAATthB,CAAA,EACZ,MAAM,IAAIshB,SAAA,CAAU,iCAE5B;gBAAA,OACK,SAAoB,MAAT9hB,CAAA,EACZ,MAAM,IAAI8hB,SAAA,CAAU;gBAExB7gB,CAAA,GAAuB,IAAIuO,UAAA,CAAWjP,CAAA,EAAQS,CAAA,EAAYyC,CAAA,CAC9D;cAAA;YAGA;YAEA,MACMA,CAAA,IADMJ,CAAA,CAAQ68C,kBAAA,IAAsB,IACjBh9C,GAAA,CAAInD,CAAA,IAAkB,mBAANA,CAAA,GAAiBA,CAAA,GAAIA,CAAA,CAAEgE,IAAA;cAC1DyG,CAAA,UAAgB,GAAIjK,CAAA,CAAkBgH,cAAA,EAAgB9D,CAAA;cACtD2H,CAAA,SAAgBZ,CAAA,CAAQ5J,oBAAA,CAAqBK,CAAA,EAAsBoC,CAAA;YACzE,OAAO,IAAIrC,CAAA,CAAiBoK,CAAA,CAChC;UAAA;UACA+sC,eAAA;YACI,KAAKgZ,OAAA,CAAQhZ,cAAA,EACjB;UAAA;UACAC,aAAA;YACI,KAAK+Y,OAAA,CAAQ/Y,YAAA,EACjB;UAAA;UACI,IAAAztC,WAAA;YACA,OAAO,KAAKwmD,OAAA,CAAQxmD,UACxB;UAAA;UACI,IAAAutC,YAAA;YACA,OAAO,KAAKiZ,OAAA,CAAQjZ,WACxB;UAAA;QAAA;QAEJl4C,CAAA,CAAQyhC,gBAAA,GAAmBzgC,C;;;;;QC5L3B4B,MAAA,CAAO8lD,cAAA,CAAe1oD,CAAA,EAAS,cAAc;UAAEkkB,KAAA,GAAO;QAAA,IACtDlkB,CAAA,CAAQyhC,gBAAA,QAAmB;QAC3B,MAAMlhC,CAAA,GAA8BC,CAAA,CAAQ;QAE5CR,CAAA,CAAQyhC,gBAAA,GAAmBlhC,CAAA,CAA4BkhC,gB;;;;;QCJvD7+B,MAAA,CAAO8lD,cAAA,CAAe1oD,CAAA,EAAS,cAAc;UAAEkkB,KAAA,GAAO;QAAA,E;;;;;QCAtDthB,MAAA,CAAO8lD,cAAA,CAAe1oD,CAAA,EAAS,cAAc;UAAEkkB,KAAA,GAAO;QAAA,IACtDlkB,CAAA,CAAQukE,iBAAA,GAAoBvkE,CAAA,CAAQwkE,eAAA,QAAkB,GA4FtDxkE,CAAA,CAAQwkE,eAAA,GAxFgB,CAACzkE,CAAA,EAAQC,CAAA;UAC7B,MAAMQ,CAAA,GAASsxB,QAAA,CAASC,aAAA,CAAc;UACtCvxB,CAAA,CAAO6I,KAAA,GAAQtJ,CAAA,CAAO6T,IAAA,CAAK,IAC3BpT,CAAA,CAAO8I,MAAA,GAASvJ,CAAA,CAAO6T,IAAA,CAAK;UAC5B,MAAMrT,CAAA,GAAkBC,CAAA,CAAOkxB,UAAA,CAAW;UAC1C,IAAuB,QAAnBnxB,CAAA,EAAyB;YAEzB,IAAIE,CAAA,EACAO,CAAA;YAAA,KAC0B,MAA1BhB,CAAA,EAASykE,YAAA,IAAuD,WAAzBzkE,CAAA,CAAQykE,YAAA,IAC/ChkE,CAAA,GAAQV,CAAA,CAAO6T,IAAA,CAAK,IACpB5S,CAAA,GAASjB,CAAA,CAAO6T,IAAA,CAAK,OAGrBnT,CAAA,GAAQV,CAAA,CAAO6T,IAAA,CAAK,IACpB5S,CAAA,GAASjB,CAAA,CAAO6T,IAAA,CAAK;YAEzB,MAAM3S,CAAA,QAAkC,MAApBjB,CAAA,EAASiuB,MAAA,GAAuBjuB,CAAA,CAAQiuB,MAAA,GAAS;cAC/D5qB,CAAA,GAAOrD,CAAA,EAAS0kE,IAAA;YACtB,IAAIjhE,CAAA,EACA+G,CAAA;YAAA,KACS,MAATnH,CAAA,SAAoC,MAAdA,CAAA,CAAKshE,IAAA,GAC3BlhE,CAAA,GAAW,CAAC,KAAK,KAAK,KAAK,OAGA,mBAAfJ,CAAA,CAASshE,IAAA,GACjBlhE,CAAA,GAAW,CAACJ,CAAA,CAAKshE,IAAA,EAAMthE,CAAA,CAAKshE,IAAA,EAAMthE,CAAA,CAAKshE,IAAA,EAAMthE,CAAA,CAAKshE,IAAA,KAGlDlhE,CAAA,GAAW,CAACJ,CAAA,CAAKshE,IAAA,CAAK,IAAIthE,CAAA,CAAKshE,IAAA,CAAK,IAAIthE,CAAA,CAAKshE,IAAA,CAAK,IAAI,SACjC,MAAjBthE,CAAA,CAAKshE,IAAA,CAAK,OACVlhE,CAAA,CAAS,KAAKJ,CAAA,CAAKshE,IAAA,CAAK,WAIvB,MAATthE,CAAA,SAAoC,MAAdA,CAAA,CAAKqgB,IAAA,GAC3BlZ,CAAA,GAAW,CAAC,GAAG,GAAG,GAAG,KAGM,mBAAfnH,CAAA,CAASqgB,IAAA,GACjBlZ,CAAA,GAAW,CAACnH,CAAA,CAAKqgB,IAAA,EAAMrgB,CAAA,CAAKqgB,IAAA,EAAMrgB,CAAA,CAAKqgB,IAAA,EAAMrgB,CAAA,CAAKqgB,IAAA,KAGlDlZ,CAAA,GAAW,CAACnH,CAAA,CAAKqgB,IAAA,CAAK,IAAIrgB,CAAA,CAAKqgB,IAAA,CAAK,IAAIrgB,CAAA,CAAKqgB,IAAA,CAAK,IAAI,SACjC,MAAjBrgB,CAAA,CAAKqgB,IAAA,CAAK,OACVlZ,CAAA,CAAS,KAAKnH,CAAA,CAAKqgB,IAAA,CAAK;YAIpC,MAAMtY,CAAA,GAASpK,CAAA,GAASP,CAAA;YAExB,IAAI4K,CAAA,GAAiB;cAAGC,CAAA,GAAiBF,CAAA;cAAQ9E,CAAA,GAA0B,IAAT8E,CAAA;cAAYK,CAAA,IAAkB;YAE5E,WAAhBxK,CAAA,IACAoK,CAAA,GAAiB,GACjBC,CAAA,GAAiBF,CAAA,EACjB9E,CAAA,GAA0B,IAAT8E,CAAA,EACjBK,CAAA,GAA0B,IAATL,CAAA,IAEI,UAAhBnK,CAAA,IACLoK,CAAA,GAAiB,GACjBC,CAAA,GAAiBF,CAAA,EACjB9E,CAAA,GAA0B,IAAT8E,CAAA,IAEI,UAAhBnK,CAAA,KACLoK,CAAA,GAAiB,GACjB/E,CAAA,GAAiB8E,CAAA,EACjBE,CAAA,GAA0B,IAATF,CAAA;YAErB,KAAK,IAAIpL,CAAA,GAAI,GAAGA,CAAA,GAAIgB,CAAA,EAAQhB,CAAA,IACxB,KAAK,IAAIQ,CAAA,GAAI,GAAGA,CAAA,GAAIC,CAAA,EAAOD,CAAA,IAAK;cAC5B,MAAMC,CAAA,IAAKV,CAAA,CAAOyjB,IAAA,CAAKnY,CAAA,MAAoBb,CAAA,CAAS,MAAM/G,CAAA,CAAS;gBAC7DzC,CAAA,IAAKjB,CAAA,CAAOyjB,IAAA,CAAKlY,CAAA,MAAoBd,CAAA,CAAS,MAAM/G,CAAA,CAAS;gBAC7DxC,CAAA,IAAKlB,CAAA,CAAOyjB,IAAA,CAAKld,CAAA,MAAoBkE,CAAA,CAAS,MAAM/G,CAAA,CAAS;gBAC7DJ,CAAA,IAAwB,MAApBoI,CAAA,GACN,OACC1L,CAAA,CAAOyjB,IAAA,CAAK/X,CAAA,MAAoBjB,CAAA,CAAS,MAAM/G,CAAA,CAAS;cAE7DlD,CAAA,CAAgBqkE,SAAA,GAAY,UAAUnkE,CAAA,GAAI,MAAMO,CAAA,GAAI,MAAMC,CAAA,GAAI,MAAMoC,CAAA,GAAI,KACxE9C,CAAA,CAAgBskE,QAAA,CAASrkE,CAAA,EAAGR,CAAA,EAAG,GAAG,EACtC;YAAA;YAEJ,OAAOQ,CAAA,CAAOskE,SAAA,EAClB;UAAA;UAEI,MAAM,IAAI1gE,KAAA,CAAM,4BACpB;QAAA,GAmGJpE,CAAA,CAAQukE,iBAAA,GA7FkB,CAACxkE,CAAA,EAAQC,CAAA;UAC/B,MAAMQ,CAAA,GAAkBsxB,QAAA,CAASC,aAAA,CAAc,UAAUL,UAAA,CAAW;UACpE,IAAInxB,CAAA;UACJ,IAAuB,QAAnBC,CAAA,EAsFA,MAAM,IAAI4D,KAAA,CAAM;UAtFS;YAEzB,IAAI3D,CAAA,EACAO,CAAA,EACAC,CAAA;YAAA,KAC0B,MAA1BjB,CAAA,EAASykE,YAAA,IAAuD,WAAzBzkE,CAAA,CAAQykE,YAAA,IAC/ChkE,CAAA,GAAQV,CAAA,CAAO6T,IAAA,CAAK,IACpB5S,CAAA,GAASjB,CAAA,CAAO6T,IAAA,CAAK,IACrB3S,CAAA,GAAWlB,CAAA,CAAO6T,IAAA,CAAK,OAGvBnT,CAAA,GAAQV,CAAA,CAAO6T,IAAA,CAAK,IACpB5S,CAAA,GAASjB,CAAA,CAAO6T,IAAA,CAAK,IACrB3S,CAAA,GAAWlB,CAAA,CAAO6T,IAAA,CAAK;YAE3B,MAAMvQ,CAAA,QAA0B,MAAZrD,CAAA,SAA4C,MAAnBA,CAAA,CAAQiuB,MAAA,GAAuBjuB,CAAA,CAAQiuB,MAAA,GAAkB;cAChGxqB,CAAA,GAAOzD,CAAA,EAAS0kE,IAAA;YACtB,IAAIl6D,CAAA,EACAY,CAAA;YAAA,KACS,MAAT3H,CAAA,SAAoC,MAAdA,CAAA,CAAKkhE,IAAA,GAC3Bn6D,CAAA,GAAW,CAAC,KAAK,KAAK,KAAK,OAGA,mBAAf/G,CAAA,CAASkhE,IAAA,GACjBn6D,CAAA,GAAW,CAAC/G,CAAA,CAAKkhE,IAAA,EAAMlhE,CAAA,CAAKkhE,IAAA,EAAMlhE,CAAA,CAAKkhE,IAAA,EAAMlhE,CAAA,CAAKkhE,IAAA,KAGlDn6D,CAAA,GAAW,CAAC/G,CAAA,CAAKkhE,IAAA,CAAK,IAAIlhE,CAAA,CAAKkhE,IAAA,CAAK,IAAIlhE,CAAA,CAAKkhE,IAAA,CAAK,IAAI,WACjC,MAAjBlhE,CAAA,CAAKkhE,IAAA,CAAK,OACVn6D,CAAA,CAAS,KAAK/G,CAAA,CAAKkhE,IAAA,CAAK,WAIvB,MAATlhE,CAAA,SAAoC,MAAdA,CAAA,CAAKigB,IAAA,GAC3BtY,CAAA,GAAW,CAAC,GAAG,GAAG,GAAG,KAGM,mBAAf3H,CAAA,CAASigB,IAAA,GACjBtY,CAAA,GAAW,CAAC3H,CAAA,CAAKigB,IAAA,EAAMjgB,CAAA,CAAKigB,IAAA,EAAMjgB,CAAA,CAAKigB,IAAA,EAAMjgB,CAAA,CAAKigB,IAAA,KAGlDtY,CAAA,GAAW,CAAC3H,CAAA,CAAKigB,IAAA,CAAK,IAAIjgB,CAAA,CAAKigB,IAAA,CAAK,IAAIjgB,CAAA,CAAKigB,IAAA,CAAK,IAAI,SACjC,MAAjBjgB,CAAA,CAAKigB,IAAA,CAAK,OACVtY,CAAA,CAAS,KAAK3H,CAAA,CAAKigB,IAAA,CAAK;YAIpC,MAAMrY,CAAA,GAASrK,CAAA,GAASP,CAAA;YACxB,SAAgB,MAAZT,CAAA,UACuB,MAAnBA,CAAA,CAAQiuB,MAAA,IAAsC,MAAbhtB,CAAA,IAAqC,WAAnBjB,CAAA,CAAQiuB,MAAA,IAC7C,MAAbhtB,CAAA,IAAsC,UAAnBjB,CAAA,CAAQiuB,MAAA,IAAuC,UAAnBjuB,CAAA,CAAQiuB,MAAA,GACxD,MAAM,IAAI7pB,KAAA,CAAM;YAIxB,MAAMkH,CAAA,GAAO;YACb,IAAIhF,CAAA,GAAgB;cAAGmF,CAAA,GAAgB;cAAGlF,CAAA,GAAgB;cAAGoF,CAAA,GAAgB;cACzEC,CAAA,GAAiB;cAAGE,CAAA,GAAiBT,CAAA;cAAQU,CAAA,GAA0B,IAATV,CAAA;cAAYW,CAAA,IAAkB;YAE5E,WAAhB3I,CAAA,IACAuI,CAAA,GAAiB,GACjBE,CAAA,GAAiBT,CAAA,EACjBU,CAAA,GAA0B,IAATV,CAAA,EACjBW,CAAA,GAA0B,IAATX,CAAA,IAEI,UAAhBhI,CAAA,IACLuI,CAAA,GAAiB,GACjBE,CAAA,GAAiBT,CAAA,EACjBU,CAAA,GAA0B,IAATV,CAAA,IAEI,UAAhBhI,CAAA,KACLuI,CAAA,GAAiB,GACjBG,CAAA,GAAiBV,CAAA,EACjBS,CAAA,GAA0B,IAATT,CAAA,GAErB9K,CAAA,GAAQC,CAAA,CAAgBukE,eAAA,CAAgBtkE,CAAA,EAAOO,CAAA;YAC/C,KAAK,IAAIhB,CAAA,GAAI,GAAGA,CAAA,GAAIgB,CAAA,GAASP,CAAA,EAAO6F,CAAA,IAAiBgF,CAAA,EAAMG,CAAA,IAAiBH,CAAA,EAAM/E,CAAA,IAAiB+E,CAAA,EAAMK,CAAA,IAAiBL,CAAA,EAAMtL,CAAA,IAC5HO,CAAA,CAAMijB,IAAA,CAAKld,CAAA,KAAkBvG,CAAA,CAAOyjB,IAAA,CAAK5X,CAAA,MAAoBR,CAAA,CAAS,MAAMZ,CAAA,CAAS,IACrFjK,CAAA,CAAMijB,IAAA,CAAK/X,CAAA,KAAkB1L,CAAA,CAAOyjB,IAAA,CAAK1X,CAAA,MAAoBV,CAAA,CAAS,MAAMZ,CAAA,CAAS,IACrFjK,CAAA,CAAMijB,IAAA,CAAKjd,CAAA,KAAkBxG,CAAA,CAAOyjB,IAAA,CAAKzX,CAAA,MAAoBX,CAAA,CAAS,MAAMZ,CAAA,CAAS,IACrFjK,CAAA,CAAMijB,IAAA,CAAK7X,CAAA,KAAqC,MAApBK,CAAA,GACxB,OACCjM,CAAA,CAAOyjB,IAAA,CAAKxX,CAAA,MAAoBZ,CAAA,CAAS,MAAMZ,CAAA,CAAS,EAErE;UAAA;UAIA,OAAOjK,CAAK;QAAA,C;;;;;QC5LhBqC,MAAA,CAAO8lD,cAAA,CAAe1oD,CAAA,EAAS,cAAc;UAAEkkB,KAAA,GAAO;QAAA,IACtDlkB,CAAA,CAAQglE,eAAA,GAAkBhlE,CAAA,CAAQilE,cAAA,QAAiB;QACnD,MAAM1kE,CAAA,GAAcC,CAAA,CAAQ;QA+E5BR,CAAA,CAAQilE,cAAA,GAvEe,CAACllE,CAAA,EAAQC,CAAA;UAC5B,SAAe,MAAXD,CAAA,EACA,MAAM,IAAIqE,KAAA,CAAM;UAEpB,SAAuB,MAAnBpE,CAAA,CAAQsJ,MAAA,SAA0C,MAAlBtJ,CAAA,CAAQqJ,KAAA,EACxC,MAAM,IAAIjF,KAAA,CAAM;UAEpB,IAA6B,WAAzBpE,CAAA,CAAQykE,YAAA,EACR,MAAM,IAAIrgE,KAAA,CAAM;UAEpB;cAAMkF,MAAA,EAAE9I,CAAA;cAAM6I,KAAA,EAAE5I;YAAA,IAAUT,CAAA;YACpBgB,CAAA,GAAOhB,CAAA,CAAQ0kE,IAAA,IAAQ;cAAEC,IAAA,EAAM;cAAKjhD,IAAA,EAAM;YAAA;UAChD,IAAIziB,CAAA,EACAoC,CAAA;UAEApC,CAAA,GADuB,mBAAfD,CAAA,CAAS2jE,IAAA,GACN,CAAC3jE,CAAA,CAAK2jE,IAAA,EAAM3jE,CAAA,CAAK2jE,IAAA,EAAM3jE,CAAA,CAAK2jE,IAAA,EAAM3jE,CAAA,CAAK2jE,IAAA,IAGvC,CAAC3jE,CAAA,CAAK2jE,IAAA,CAAK,IAAI3jE,CAAA,CAAK2jE,IAAA,CAAK,IAAI3jE,CAAA,CAAK2jE,IAAA,CAAK,IAAI3jE,CAAA,CAAK2jE,IAAA,CAAK,MAAM,MAGtEthE,CAAA,GADuB,mBAAfrC,CAAA,CAAS0iB,IAAA,GACN,CAAC1iB,CAAA,CAAK0iB,IAAA,EAAM1iB,CAAA,CAAK0iB,IAAA,EAAM1iB,CAAA,CAAK0iB,IAAA,EAAM1iB,CAAA,CAAK0iB,IAAA,IAGvC,CAAC1iB,CAAA,CAAK0iB,IAAA,CAAK,IAAI1iB,CAAA,CAAK0iB,IAAA,CAAK,IAAI1iB,CAAA,CAAK0iB,IAAA,CAAK,IAAI1iB,CAAA,CAAK0iB,IAAA,CAAK,MAAM;UAE1E,MAAMjgB,CAAA,QAAiC,MAAnBzD,CAAA,CAAQiuB,MAAA,GAAuBjuB,CAAA,CAAQiuB,MAAA,GAAS;YAE9DzjB,CAAA,QAAwC,MAAzBxK,CAAA,CAAQklE,YAAA,SACC,MAAzBllE,CAAA,CAAQklE,YAAA,GAA6BllE,CAAA,CAAQklE,YAAA,GAC9C;YACE95D,CAAA,GAAS5K,CAAA,GAASC,CAAA;YAClB4K,CAAA,GAA+B,WAAjBb,CAAA,GAA0B,IAAImK,YAAA,CAAsB,IAATvJ,CAAA,IAAc,IAAIuJ,YAAA,CAAsB,IAATvJ,CAAA;UAE9F,IAAIE,CAAA,GAAO;YAAGhF,CAAA,GAAgB;YAAGmF,CAAA,GAAgB;YAAGlF,CAAA,GAAgB;YAAGoF,CAAA,GAAgB;YACnFC,CAAA,GAAiB;YAAGE,CAAA,GAAiBV,CAAA;YAAQW,CAAA,GAA0B,IAATX,CAAA;YAAYY,CAAA,IAAkB;UAE5E,UAAhBvI,CAAA,KACA6H,CAAA,GAAO,GACPhF,CAAA,GAAgB,GAChBmF,CAAA,GAAgB,GAChBlF,CAAA,GAAgB,GAChBoF,CAAA,IAAiB,IAGA,WAAjBnB,CAAA,GACAwB,CAAA,GAA0B,IAATZ,CAAA,GAEK,UAAjBZ,CAAA,IACLoB,CAAA,GAAiB,GACjBG,CAAA,GAAiBX,CAAA,EACjBU,CAAA,GAA0B,IAATV,CAAA,IAEK,UAAjBZ,CAAA,KACLuB,CAAA,GAAiB,GACjBD,CAAA,GAAiBV,CAAA,EACjBQ,CAAA,GAA0B,IAATR,CAAA;UAErB,KAAK,IAAIpL,CAAA,GAAI,GAAGA,CAAA,GAAIoL,CAAA,EAAQpL,CAAA,IAAKsG,CAAA,IAAiBgF,CAAA,EAAM/E,CAAA,IAAiB+E,CAAA,EAAMG,CAAA,IAAiBH,CAAA,EAAMK,CAAA,IAAiBL,CAAA,EACnHD,CAAA,CAAYO,CAAA,OAAqB7L,CAAA,CAAOuG,CAAA,IAAiBjD,CAAA,CAAS,MAAMpC,CAAA,CAAS,IACjFoK,CAAA,CAAYS,CAAA,OAAqB/L,CAAA,CAAO0L,CAAA,IAAiBpI,CAAA,CAAS,MAAMpC,CAAA,CAAS,IACjFoK,CAAA,CAAYU,CAAA,OAAqBhM,CAAA,CAAOwG,CAAA,IAAiBlD,CAAA,CAAS,MAAMpC,CAAA,CAAS,KACzD,MAApB+K,CAAA,KAA4C,MAAnBL,CAAA,KACzBN,CAAA,CAAYW,CAAA,OAAqBjM,CAAA,CAAO4L,CAAA,IAAiBtI,CAAA,CAAS,MAAMpC,CAAA,CAAS;UAMzF,OAFsC,WAAjBuJ,CAAA,GAA0B,IAAIjK,CAAA,CAAYyF,MAAA,CAAO,WAAWqF,CAAA,EAAa,CAAC,GAAG,GAAG7K,CAAA,EAAQC,CAAA,KACzG,IAAIF,CAAA,CAAYyF,MAAA,CAAO,WAAWqF,CAAA,EAAa,CAAC,GAAG,GAAG7K,CAAA,EAAQC,CAAA,EAC/C;QAAA,GA0IvBT,CAAA,CAAQglE,eAAA,GApIgB,OAAOjlE,CAAA,EAAOS,CAAA;UAElC,MAAMD,CAAA,GAA+C,sBAAvB4kE,gBAAA,IAAsCplE,CAAA,YAAiBolE,gBAAA;YAC/E1kE,CAAA,GAAwC,sBAAhB2kE,SAAA,IAA+BrlE,CAAA,YAAiBqlE,SAAA;YACxEpkE,CAAA,GAAyC,sBAAlBqkE,WAAA,IAAiCtlE,CAAA,YAAiBslE,WAAA;YACzEpkE,CAAA,GAA4B,mBAAVlB,CAAA;UACxB,IAAIsD,CAAA;YACAI,CAAA,GAAwBjD,CAAA,IAAW,CAAC;UAExC,IAAID,CAAA,EAAgB;YAEhB,MAAMP,CAAA,GAAS8xB,QAAA,CAASC,aAAA,CAAc;YACtC/xB,CAAA,CAAOqJ,KAAA,GAAQtJ,CAAA,CAAMsJ,KAAA,EACrBrJ,CAAA,CAAOsJ,MAAA,GAASvJ,CAAA,CAAMuJ,MAAA;YACtB,MAAM/I,CAAA,GAAkBP,CAAA,CAAO0xB,UAAA,CAAW;YAC1C,IAAuB,QAAnBnxB,CAAA,EA2BA,MAAM,IAAI6D,KAAA,CAAM;YA3BS;cACzB,IAAIpE,CAAA,GAASD,CAAA,CAAMuJ,MAAA;gBACf7I,CAAA,GAAQV,CAAA,CAAMsJ,KAAA;cAKlB,SAJgB,MAAZ7I,CAAA,SAAmD,MAA1BA,CAAA,CAAQ8kE,aAAA,SAAwD,MAAzB9kE,CAAA,CAAQ+kE,YAAA,KACxEvlE,CAAA,GAASQ,CAAA,CAAQ8kE,aAAA,EACjB7kE,CAAA,GAAQD,CAAA,CAAQ+kE,YAAA,QAEJ,MAAZ/kE,CAAA,EAAuB;gBAEvB,IADAiD,CAAA,GAAwBjD,CAAA,OACK,MAAzBA,CAAA,CAAQ0kE,YAAA,EACR,MAAM,IAAI9gE,KAAA,CAAM;gBAGhBX,CAAA,CAAsByhE,YAAA,GAAe,QAEzCzhE,CAAA,CAAsB6F,MAAA,GAAStJ,CAAA,EAC/ByD,CAAA,CAAsB4F,KAAA,GAAQ5I,CAClC;cAAA,OAEIgD,CAAA,CAAsByhE,YAAA,GAAe,QACrCzhE,CAAA,CAAsB6F,MAAA,GAAStJ,CAAA,EAC/ByD,CAAA,CAAsB4F,KAAA,GAAQ5I,CAAA;cAElCF,CAAA,CAAgBilE,SAAA,CAAUzlE,CAAA,EAAO,GAAG,IACpCsD,CAAA,GAAO9C,CAAA,CAAgBklE,YAAA,CAAa,GAAG,GAAGhlE,CAAA,EAAOT,CAAA,EAAQwjB,IAC7D;YAAA;UAIJ,OACK;YAAA,KAAI/iB,CAAA,EAkCJ;cAAA,IAAIO,CAAA,EAAe;gBAEpB,SAAgB,MAAZR,CAAA,EACA,MAAM,IAAI4D,KAAA,CAAM;gBAEpB,MAAM7D,CAAA,GAASuxB,QAAA,CAASC,aAAA,CAAc;gBACtCxxB,CAAA,CAAO8I,KAAA,GAAQtJ,CAAA,CAAMsJ,KAAA,EACrB9I,CAAA,CAAO+I,MAAA,GAASvJ,CAAA,CAAMuJ,MAAA;gBACtB,MAAM7I,CAAA,GAAkBF,CAAA,CAAOmxB,UAAA,CAAW;gBAC1C,IAAuB,QAAnBjxB,CAAA,EAAyB;kBACzB,MAAMD,CAAA,GAAST,CAAA,CAAMuJ,MAAA;oBACf/I,CAAA,GAAQR,CAAA,CAAMsJ,KAAA;kBAKpB,OAJA5I,CAAA,CAAgB+kE,SAAA,CAAUzlE,CAAA,EAAO,GAAG,GAAGQ,CAAA,EAAOC,CAAA,GAC9C6C,CAAA,GAAO5C,CAAA,CAAgBglE,YAAA,CAAa,GAAG,GAAGllE,CAAA,EAAOC,CAAA,EAAQgjB,IAAA,EACzD/f,CAAA,CAAsB6F,MAAA,GAAS9I,CAAA,EAC/BiD,CAAA,CAAsB4F,KAAA,GAAQ9I,CAAA,GACvB,GAAIP,CAAA,CAAQilE,cAAA,EAAgB5hE,CAAA,EAAMI,CAAA,CAC7C;gBAAA;gBAEI,MAAM,IAAIW,KAAA,CAAM,4BAExB;cAAA;cACK,IAAInD,CAAA,EACL,OAAO,IAAIoB,OAAA,CAAQ,CAAC7B,CAAA,EAASD,CAAA;gBACzB,MAAME,CAAA,GAASqxB,QAAA,CAASC,aAAA,CAAc;kBAChC/wB,CAAA,GAAUP,CAAA,CAAOixB,UAAA,CAAW;gBAClC,KAAK3xB,CAAA,KAAUiB,CAAA,EACX,OAAOT,CAAA;gBAEX,MAAMU,CAAA,GAAW,IAAIykE,KAAA;gBACrBzkE,CAAA,CAAS0kE,WAAA,GAAc,aACvB1kE,CAAA,CAASy8C,GAAA,GAAM39C,CAAA,EACfkB,CAAA,CAAS+pD,MAAA,GAAS;kBACdvqD,CAAA,CAAO4I,KAAA,GAAQpI,CAAA,CAASoI,KAAA,EACxB5I,CAAA,CAAO6I,MAAA,GAASrI,CAAA,CAASqI,MAAA,EACzBtI,CAAA,CAAQwkE,SAAA,CAAUvkE,CAAA,EAAU,GAAG,GAAGR,CAAA,CAAO4I,KAAA,EAAO5I,CAAA,CAAO6I,MAAA;kBACvD,MAAMvJ,CAAA,GAAMiB,CAAA,CAAQykE,YAAA,CAAa,GAAG,GAAGhlE,CAAA,CAAO4I,KAAA,EAAO5I,CAAA,CAAO6I,MAAA;kBAC5D7F,CAAA,CAAsB6F,MAAA,GAAS7I,CAAA,CAAO6I,MAAA,EACtC7F,CAAA,CAAsB4F,KAAA,GAAQ5I,CAAA,CAAO4I,KAAA,EACrC7I,CAAA,EAAQ,GAAIR,CAAA,CAAQilE,cAAA,EAAgBllE,CAAA,CAAIyjB,IAAA,EAAM/f,CAAA,EAAuB;gBAAA,CACxE;cAAA;cAIL,MAAM,IAAIW,KAAA,CAAM,iEACpB;YAAA;YA/EyB;cACrB,IAAIpE,CAAA,EACAO,CAAA;cAeJ,SAdgB,MAAZC,CAAA,SAAkD,MAAzBA,CAAA,CAAQ+kE,YAAA,SAAwD,MAA1B/kE,CAAA,CAAQ8kE,aAAA,IACvEtlE,CAAA,GAASQ,CAAA,CAAQ8kE,aAAA,EACjB/kE,CAAA,GAAQC,CAAA,CAAQ+kE,YAAA,KAGhBvlE,CAAA,GAASD,CAAA,CAAMuJ,MAAA,EACf/I,CAAA,GAAQR,CAAA,CAAMsJ,KAAA,QAEF,MAAZ7I,CAAA,KACAiD,CAAA,GAAwBjD,CAAA,GAE5BiD,CAAA,CAAsBwqB,MAAA,GAAS,QAC/BxqB,CAAA,CAAsB6F,MAAA,GAAStJ,CAAA,EAC/ByD,CAAA,CAAsB4F,KAAA,GAAQ9I,CAAA,OACd,MAAZC,CAAA,EAAuB;gBACvB,MAAMA,CAAA,GAAasxB,QAAA,CAASC,aAAA,CAAc;gBAC1CvxB,CAAA,CAAW6I,KAAA,GAAQ9I,CAAA,EACnBC,CAAA,CAAW8I,MAAA,GAAStJ,CAAA;gBACpB,MAAMS,CAAA,GAAkBD,CAAA,CAAWkxB,UAAA,CAAW;gBAC9C,IAAuB,QAAnBjxB,CAAA,EAKA,MAAM,IAAI2D,KAAA,CAAM;gBAJhB3D,CAAA,CAAgBmlE,YAAA,CAAa7lE,CAAA,EAAO,GAAG,IACvCsD,CAAA,GAAO5C,CAAA,CAAgBglE,YAAA,CAAa,GAAG,GAAGllE,CAAA,EAAOP,CAAA,EAAQwjB,IAKjE;cAAA,OAEIngB,CAAA,GAAOtD,CAAA,CAAMyjB,IAErB;YAAA;UA8CA;UACA,SAAa,MAATngB,CAAA,EACA,QAAO,GAAIrD,CAAA,CAAQilE,cAAA,EAAgB5hE,CAAA,EAAMI,CAAA;UAGzC,MAAM,IAAIW,KAAA,CAAM,iEACpB;QAAA,C;;;;;QCvNJxB,MAAA,CAAO8lD,cAAA,CAAe1oD,CAAA,EAAS,cAAc;UAAEkkB,KAAA,GAAO;QAAA,IACtDlkB,CAAA,CAAQgG,MAAA,QAAS;QACjB,MAAMzF,CAAA,GAA8BC,CAAA,CAAQ;UACtCC,CAAA,GAA2BD,CAAA,CAAQ;UACnCQ,CAAA,GAAyBR,CAAA,CAAQ;UAEjCS,CAAA,GAAwC,IAAI0C,GAAA,CAAI,CAClD,CAAC,WAAWgR,YAAA,GACZ,CAAC,SAASnF,UAAA,GACV,CAAC,QAAQmhB,SAAA,GACT,CAAC,UAAUC,WAAA,GACX,CAAC,WAAWA,WAAA,GACZ,CAAC,SAASF,UAAA,GACV,CAAC,SAAShK,UAAA,GACV,CAAC,QAAQlX,UAAA,GACT,CAAC,WAAWqhB,YAAA,GACZ,CAAC,UAAUthB,WAAA;UAGTlM,CAAA,GAAwC,IAAIM,GAAA,CAAI,CAClD,CAACgR,YAAA,EAAc,YACf,CAACnF,UAAA,EAAY,UACb,CAACmhB,SAAA,EAAW,SACZ,CAACC,WAAA,EAAa,WACd,CAACF,UAAA,EAAY,UACb,CAAChK,UAAA,EAAY,UACb,CAACmK,YAAA,EAAc,YACf,CAACthB,WAAA,EAAa;QAKlB,IAAI9L,CAAA,IAAkB;QAoJtBzD,CAAA,CAAQgG,MAAA,GApIR;UACIrD,YAAY5C,CAAA,EAAMC,CAAA,EAAMQ,CAAA;YAEpB,IAAID,CAAA,EACAE,CAAA,EACA+J,CAAA;YAEJ,IAtBY;cAChB,KAAK/G,CAAA,EAAiB;gBAClBA,CAAA,IAAkB;gBAClB,MAAM1D,CAAA,GAAoD,sBAAlBy6C,aAAA,IAA+D,qBAAvBA,aAAA,CAAcr7B,IAAA;kBACxFnf,CAAA,GAAsD,sBAAnBmhD,cAAA,IAAiE,qBAAxBA,cAAA,CAAehiC,IAAA;gBAC7Fpf,CAAA,KACAkB,CAAA,CAAsC6C,GAAA,CAAI,SAAS02C,aAAA,GACnDn3C,CAAA,CAAsCS,GAAA,CAAI02C,aAAA,EAAe,WAEzDx6C,CAAA,KACAiB,CAAA,CAAsC6C,GAAA,CAAI,UAAUq9C,cAAA,GACpD99C,CAAA,CAAsCS,GAAA,CAAIq9C,cAAA,EAAgB,UAElE;cAAA;YAAA,GAII,GAKoB,mBAATphD,CAAA;cAMP,IAFAQ,CAAA,GAAOR,CAAA,EACPyK,CAAA,GAAOhK,CAAA,EACM,aAATT,CAAA,EAAmB;gBAEnB,KAAKgG,KAAA,CAAM+oB,OAAA,CAAQ9uB,CAAA,GACf,MAAM,IAAI8hB,SAAA,CAAU;gBAIxBrhB,CAAA,GAAOT,CACX;cAAA,OACK;gBAED,MAAMQ,CAAA,GAAwBS,CAAA,CAAsCsD,GAAA,CAAIxE,CAAA;gBACxE,SAA8B,MAA1BS,CAAA,EACA,MAAM,IAAIshB,SAAA,CAAU,4BAA4B/hB,CAAA;gBAEpD,IAAIgG,KAAA,CAAM+oB,OAAA,CAAQ9uB,CAAA,GAAO;kBACrB,IAAa,cAATD,CAAA,EAIA,MAAM,IAAI+hB,SAAA,CAAU;kBAYpBrhB,CAAA,GAVc,aAATV,CAAA,IAA8B,YAATA,CAAA,GAUnBS,CAAA,CAAsB2e,IAAA,CAAKnf,CAAA,EAAM6lE,MAAA,IAKjCrlE,CAAA,CAAsB2e,IAAA,CAAKnf,CAAA,CAE1C;gBAAA,OACK;kBAAA,MAAIA,CAAA,YAAgBQ,CAAA,GAIrB,MAAM,IAAIshB,SAAA,CAAU,KAAKvhB,CAAA,kCAAsCC,CAAA;kBAH/DC,CAAA,GAAOT,CAIX;gBAAA;cACJ;YAAA,OAOA,IADAwK,CAAA,GAAOxK,CAAA,EACH+F,KAAA,CAAM+oB,OAAA,CAAQ/uB,CAAA,GAAO;cAErB,IAAoB,MAAhBA,CAAA,CAAK8B,MAAA,EACL,MAAM,IAAIigB,SAAA,CAAU;cAExB,MAAM9hB,CAAA,UAA0BD,CAAA,CAAK;cACrC,IAAyB,aAArBC,CAAA,EACAO,CAAA,GAAO,UACPE,CAAA,GAAOV,CAAA,MAEN;gBAAA,IAAyB,cAArBC,CAAA,EAQL,MAAM,IAAI8hB,SAAA,CAAU,uCAAuC9hB,CAAA;gBAP3DO,CAAA,GAAO,QAIPE,CAAA,GAAO+O,UAAA,CAAW2P,IAAA,CAAKpf,CAAA,CAI3B;cAAA;YACJ,OACK;cAED,MAAMC,CAAA,GAAaqD,CAAA,CAAsCkB,GAAA,CAAIxE,CAAA,CAAK4C,WAAA;cAClE,SAAmB,MAAf3C,CAAA,EACA,MAAM,IAAI8hB,SAAA,CAAU,qCAAqC/hB,CAAA,CAAK4C,WAAA;cAElEpC,CAAA,GAAOP,CAAA,EACPS,CAAA,GAAOV,CACX;YAAA;YAGJ,SAAa,MAATyK,CAAA,EAEAA,CAAA,GAAO,CAAC/J,CAAA,CAAKoB,MAAA,OAEZ,KAAKkE,KAAA,CAAM+oB,OAAA,CAAQtkB,CAAA,GACpB,MAAM,IAAIsX,SAAA,CAAU;YAGxB,MAAM1W,CAAA,IAAO,GAAIpK,CAAA,CAAuB8kE,aAAA,EAAet7D,CAAA;YACvD,IAAIY,CAAA,KAAS3K,CAAA,CAAKoB,MAAA,EACd,MAAM,IAAIuC,KAAA,CAAM,iBAAiBgH,CAAA,gCAAoC3K,CAAA,CAAKoB,MAAA;YAE9E,KAAK+R,IAAA,GAAOpJ,CAAA,EACZ,KAAKzF,IAAA,GAAOxE,CAAA,EACZ,KAAKijB,IAAA,GAAO/iB,CAAA,EACZ,KAAK0D,IAAA,GAAOiH,CAChB;UAAA;UACA,aAAA26D,UAAuBhmE,CAAA,EAAOC,CAAA;YAC1B,QAAO,GAAIS,CAAA,CAAyBukE,eAAA,EAAiBjlE,CAAA,EAAOC,CAAA,CAChE;UAAA;UAGA8kE,UAAU/kE,CAAA;YACN,QAAO,GAAIQ,CAAA,CAA4BikE,eAAA,EAAiB,MAAMzkE,CAAA,CAClE;UAAA;UACAimE,YAAYjmE,CAAA;YACR,QAAO,GAAIQ,CAAA,CAA4BgkE,iBAAA,EAAmB,MAAMxkE,CAAA,CACpE;UAAA;UAGA8b,QAAQ9b,CAAA;YACJ,QAAO,GAAIiB,CAAA,CAAuBilE,aAAA,EAAe,MAAMlmE,CAAA,CAC3D;UAAA;QAAA,C;;;;;QClLJ6C,MAAA,CAAO8lD,cAAA,CAAe1oD,CAAA,EAAS,cAAc;UAAEkkB,KAAA,GAAO;QAAA,IACtDlkB,CAAA,CAAQimE,aAAA,GAAgBjmE,CAAA,CAAQ8lE,aAAA,QAAgB;QAChD,MAAMvlE,CAAA,GAAcC,CAAA,CAAQ;QAoB5BR,CAAA,CAAQ8lE,aAAA,GAde/lE,CAAA;UACnB,IAAIC,CAAA,GAAO;UACX,KAAK,IAAIQ,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAK8B,MAAA,EAAQrB,CAAA,IAAK;YAClC,MAAMD,CAAA,GAAMR,CAAA,CAAKS,CAAA;YACjB,IAAmB,mBAARD,CAAA,KAAqBkB,MAAA,CAAO6iE,aAAA,CAAc/jE,CAAA,GACjD,MAAM,IAAIuhB,SAAA,CAAU,QAAQthB,CAAA,8BAA+BD,CAAA;YAE/D,IAAIA,CAAA,GAAM,GACN,MAAM,IAAIu5C,UAAA,CAAW,QAAQt5C,CAAA,0CAA2CD,CAAA;YAE5EP,CAAA,IAAQO,CACZ;UAAA;UACA,OAAOP,CAAI;QAAA,GAOfA,CAAA,CAAQimE,aAAA,GADc,CAAClmE,CAAA,EAAQC,CAAA,KAAS,IAAIO,CAAA,CAAYyF,MAAA,CAAOjG,CAAA,CAAOgF,IAAA,EAAMhF,CAAA,CAAOyjB,IAAA,EAAMxjB,CAAA,C;;;;;QC1BzF4C,MAAA,CAAO8lD,cAAA,CAAe1oD,CAAA,EAAS,cAAc;UAAEkkB,KAAA,GAAO;QAAA,IACtDlkB,CAAA,CAAQgG,MAAA,QAAS;QACjB,MAAMzF,CAAA,GAAmBC,CAAA,CAAQ;QAEjCR,CAAA,CAAQgG,MAAA,GAASzF,CAAA,CAAiByF,M;;;;;QCJlCpD,MAAA,CAAO8lD,cAAA,CAAe1oD,CAAA,EAAS,cAAc;UAAEkkB,KAAA,GAAO;QAAA,IACtDlkB,CAAA,CAAQ0C,OAAA,QAAU,GAGlB1C,CAAA,CAAQ0C,OAAA,GAAU,Q;;;QCPlB,IAAAlC,CAAA;UACID,CAAA,GAAO,UAAUR,CAAA;YACnB;;YAEA6C,MAAA,CAAO8lD,cAAA,CAAe3oD,CAAA,EAAS,cAAc;cAC3CmkB,KAAA,GAAO;YAAA,IAETnkB,CAAA,CAAQu6C,OAAA,QAAU;YAsBlB,IAAIt6C,CAAA,GAAO;YAEX;cACEA,CAAA,GAAO,IAAI6iD,WAAA,CAAYqjB,QAAA,CAAS,IAAIrjB,WAAA,CAAYsjB,MAAA,CAAO,IAAI32D,UAAA,CAAW,CAAC,GAAG,IAAI,KAAK,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,KAAK,IAAI,GAAG,KAAK,KAAK,KAAK,KAAK,GAAG,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,KAAK,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,KAAK,KAAK,KAAK,GAAG,GAAG,GAAG,KAAK,KAAK,KAAK,IAAI,KAAK,GAAG,GAAG,GAAG,KAAK,KAAK,KAAK,IAAI,KAAK,GAAG,GAAG,GAAG,KAAK,KAAK,KAAK,IAAI,KAAK,GAAG,GAAG,GAAG,KAAK,KAAK,KAAK,IAAI,KAAK,GAAG,GAAG,GAAG,KAAK,KAAK,KAAK,IAAI,KAAK,KAAK,KAAK,KAAK,GAAG,GAAG,IAAI,KAAK,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,KAAK,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,KAAK,KAAK,KAAK,IAAI,GAAG,IAAI,IAAI,KAAK,KAAK,IAAI,GAAG,IAAI,GAAG,KAAK,IAAI,IAAI,GAAG,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,KAAK,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,KAAK,KAAK,KAAK,IAAI,GAAG,IAAI,IAAI,KAAK,KAAK,IAAI,GAAG,IAAI,GAAG,KAAK,IAAI,IAAI,GAAG,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,KAAK,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,KAAK,KAAK,KAAK,IAAI,GAAG,IAAI,IAAI,KAAK,KAAK,IAAI,GAAG,IAAI,GAAG,KAAK,IAAI,IAAI,GAAG,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,KAAK,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,KAAK,KAAK,KAAK,IAAI,GAAG,IAAI,IAAI,KAAK,KAAK,IAAI,GAAG,IAAI,GAAG,KAAK,IAAI,IAAI,GAAG,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,KAAK,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,KAAK,KAAK,KAAK,IAAI,GAAG,IAAI,IAAI,KAAK,KAAK,IAAI,GAAG,IAAI,GAAG,KAAK,OAAO,CAAC,GAAGvP,OAC9sC;YAAA,CAAE,QAAOF,CAAA,GACT;YAaA,SAASS,EAAKT,CAAA,EAAKC,CAAA,EAAMQ,CAAA;cAKvB,KAAK07C,GAAA,GAAY,IAANn8C,CAAA,EAMX,KAAKo8C,IAAA,GAAc,IAAPn8C,CAAA,EAMZ,KAAKo8C,QAAA,KAAa57C,CACpB;YAAA;YAoCA,SAASD,EAAOR,CAAA;cACd,QAAsC,OAA9BA,CAAA,IAAOA,CAAA,CAAgBqmE,UAAA,CACjC;YAAA;YASA,SAAS3lE,EAAMV,CAAA;cACb,IAAIC,CAAA,GAAI+B,IAAA,CAAKskE,KAAA,CAAMtmE,CAAA,IAASA,CAAA;cAC5B,OAAOA,CAAA,GAAQ,KAAKC,CAAA,GAAIA,CAC1B;YAAA;YAzBAQ,CAAA,CAAKokD,SAAA,CAAUwhB,UAAA,EACfxjE,MAAA,CAAO8lD,cAAA,CAAeloD,CAAA,CAAKokD,SAAA,EAAW,cAAc;cAClD1gC,KAAA,GAAO;YAAA,IAgCT1jB,CAAA,CAAKqF,MAAA,GAAStF,CAAA;YAOd,IAAIS,CAAA,GAAY,CAAC;cAObC,CAAA,GAAa,CAAC;YAQlB,SAASoC,EAAQtD,CAAA,EAAOC,CAAA;cACtB,IAAIQ,CAAA,EAAKD,CAAA,EAAWE,CAAA;cAEpB,OAAIT,CAAA,IAGES,CAAA,GAAQ,MAFZV,CAAA,MAAW,MAEeA,CAAA,GAAQ,SAChCQ,CAAA,GAAYU,CAAA,CAAWlB,CAAA,KACDQ,CAAA,IAGxBC,CAAA,GAAMgK,CAAA,CAASzK,CAAA,EAAO,IAAG,IACrBU,CAAA,KAAOQ,CAAA,CAAWlB,CAAA,IAASS,CAAA,GACxBA,CAAA,KAIHC,CAAA,IAAS,QAFbV,CAAA,IAAS,MAEoBA,CAAA,GAAQ,SACnCQ,CAAA,GAAYS,CAAA,CAAUjB,CAAA,KACAQ,CAAA,IAGxBC,CAAA,GAAMgK,CAAA,CAASzK,CAAA,EAAOA,CAAA,GAAQ,KAAK,IAAI,IAAG,IACtCU,CAAA,KAAOO,CAAA,CAAUjB,CAAA,IAASS,CAAA,GACvBA,CAAA,CAEX;YAAA;YAkBA,SAASiD,EAAW1D,CAAA,EAAOC,CAAA;cACzB,IAAImiC,KAAA,CAAMpiC,CAAA,GAAQ,OAAOC,CAAA,GAAW8L,CAAA,GAAQF,CAAA;cAE5C,IAAI5L,CAAA,EAAU;gBACZ,IAAID,CAAA,GAAQ,GAAG,OAAO+L,CAAA;gBACtB,IAAI/L,CAAA,IAAS0L,CAAA,EAAgB,OAAOgL,CACtC;cAAA,OAAO;gBACL,IAAI1W,CAAA,KAAUwG,CAAA,EAAgB,OAAOmQ,CAAA;gBACrC,IAAI3W,CAAA,GAAQ,KAAKwG,CAAA,EAAgB,OAAO6F,CAC1C;cAAA;cAEA,OAAIrM,CAAA,GAAQ,IAAU0D,CAAA,EAAY1D,CAAA,EAAOC,CAAA,EAAU2a,GAAA,KAC5CnQ,CAAA,CAASzK,CAAA,GAAQuG,CAAA,GAAiB,GAAGvG,CAAA,GAAQuG,CAAA,GAAiB,GAAGtG,CAAA,CAC1E;YAAA;YAmBA,SAASwK,EAASzK,CAAA,EAASC,CAAA,EAAUO,CAAA;cACnC,OAAO,IAAIC,CAAA,CAAKT,CAAA,EAASC,CAAA,EAAUO,CAAA,CACrC;YAAA;YA1CAC,CAAA,CAAK8lE,OAAA,GAAUjjE,CAAA,EA+Bf7C,CAAA,CAAK4gE,UAAA,GAAa39D,CAAA,EAuBlBjD,CAAA,CAAK26C,QAAA,GAAW3wC,CAAA;YAShB,IAAIY,CAAA,GAAUrJ,IAAA,CAAKmZ,GAAA;YAUnB,SAAS7P,EAAWtL,CAAA,EAAKC,CAAA,EAAUQ,CAAA;cACjC,IAAmB,MAAfT,CAAA,CAAI8B,MAAA,EAAc,MAAMuC,KAAA,CAAM;cAUlC,IARwB,mBAAbpE,CAAA,IAETQ,CAAA,GAAQR,CAAA,EACRA,CAAA,IAAW,KAEXA,CAAA,KAAaA,CAAA,EAGH,UAARD,CAAA,IAAyB,eAARA,CAAA,IAA8B,gBAARA,CAAA,IAA+B,gBAARA,CAAA,EAAqB,OAAOC,CAAA,GAAW8L,CAAA,GAAQF,CAAA;cAEjH,KADApL,CAAA,GAAQA,CAAA,IAAS,MACL,KAAK,KAAKA,CAAA,EAAO,MAAMs5C,UAAA,CAAW;cAC9C,IAAIv5C,CAAA;cACJ,KAAKA,CAAA,GAAIR,CAAA,CAAIoM,OAAA,CAAQ,QAAQ,GAAG,MAAM/H,KAAA,CAAM;cAAwB,IAAU,MAAN7D,CAAA,EACtE,OAAO8K,CAAA,CAAWtL,CAAA,CAAImiC,SAAA,CAAU,IAAIliC,CAAA,EAAUQ,CAAA,EAAOma,GAAA;cAOvD,KAHA,IAAIla,CAAA,GAAegD,CAAA,CAAW2H,CAAA,CAAQ5K,CAAA,EAAO,KACzCQ,CAAA,GAAS4K,CAAA,EAEJ3K,CAAA,GAAI,GAAGA,CAAA,GAAIlB,CAAA,CAAI8B,MAAA,EAAQZ,CAAA,IAAK,GAAG;gBACtC,IAAIoC,CAAA,GAAOtB,IAAA,CAAKC,GAAA,CAAI,GAAGjC,CAAA,CAAI8B,MAAA,GAASZ,CAAA;kBAChCuJ,CAAA,GAAQy3B,QAAA,CAASliC,CAAA,CAAImiC,SAAA,CAAUjhC,CAAA,EAAGA,CAAA,GAAIoC,CAAA,GAAO7C,CAAA;gBAEjD,IAAI6C,CAAA,GAAO,GAAG;kBACZ,IAAIiI,CAAA,GAAQ7H,CAAA,CAAW2H,CAAA,CAAQ5K,CAAA,EAAO6C,CAAA;kBACtCrC,CAAA,GAASA,CAAA,CAAO6R,GAAA,CAAIvH,CAAA,EAAOwD,GAAA,CAAIrL,CAAA,CAAW+G,CAAA,EAC5C;gBAAA,OAEExJ,CAAA,IADAA,CAAA,GAASA,CAAA,CAAO6R,GAAA,CAAIpS,CAAA,GACJqO,GAAA,CAAIrL,CAAA,CAAW+G,CAAA,EAEnC;cAAA;cAGA,OADAxJ,CAAA,CAAOo7C,QAAA,GAAWp8C,CAAA,EACXgB,CACT;YAAA;YAoBA,SAASsK,EAAUvL,CAAA,EAAKC,CAAA;cACtB,OAAmB,mBAARD,CAAA,GAAyB0D,CAAA,CAAW1D,CAAA,EAAKC,CAAA,IACjC,mBAARD,CAAA,GAAyBsL,CAAA,CAAWtL,CAAA,EAAKC,CAAA,IAE7CwK,CAAA,CAASzK,CAAA,CAAIm8C,GAAA,EAAKn8C,CAAA,CAAIo8C,IAAA,EAA0B,oBAAbn8C,CAAA,GAAyBA,CAAA,GAAWD,CAAA,CAAIq8C,QAAA,CACpF;YAAA;YAdA57C,CAAA,CAAK6gE,UAAA,GAAah2D,CAAA,EAwBlB7K,CAAA,CAAKy7C,SAAA,GAAY3wC,CAAA;YASjB,IAcIhF,CAAA,GAAiB;cAOjBmF,CAAA,GAAiBnF,CAAA,GAAiBA,CAAA;cAOlCC,CAAA,GAAiBkF,CAAA,GAAiB;cAOlCE,CAAA,GAAatI,CAAA,CA5BI,KAAK;cAkCtBuI,CAAA,GAAOvI,CAAA,CAAQ;YAMnB7C,CAAA,CAAK+lE,IAAA,GAAO36D,CAAA;YAMZ,IAAIE,CAAA,GAAQzI,CAAA,CAAQ,IAAG;YAMvB7C,CAAA,CAAKgmE,KAAA,GAAQ16D,CAAA;YAMb,IAAIC,CAAA,GAAM1I,CAAA,CAAQ;YAMlB7C,CAAA,CAAKimE,GAAA,GAAM16D,CAAA;YAMX,IAAIC,CAAA,GAAO3I,CAAA,CAAQ,IAAG;YAMtB7C,CAAA,CAAKkmE,IAAA,GAAO16D,CAAA;YAMZ,IAAIE,CAAA,GAAU7I,CAAA,EAAS;YAMvB7C,CAAA,CAAKmmE,OAAA,GAAUz6D,CAAA;YAMf,IAAIE,CAAA,GAAY5B,CAAA,EAAS,GAAgB,aAAgB;YAMzDhK,CAAA,CAAKomE,SAAA,GAAYx6D,CAAA;YAMjB,IAAIqK,CAAA,GAAqBjM,CAAA,EAAS,IAAgB,IAAgB;YAMlEhK,CAAA,CAAKqmE,kBAAA,GAAqBpwD,CAAA;YAM1B,IAAIC,CAAA,GAAYlM,CAAA,CAAS,IAAG,aAAgB;YAM5ChK,CAAA,CAAKsmE,SAAA,GAAYpwD,CAAA;YAMjB,IAAIC,CAAA,GAAgBnW,CAAA,CAAKokD,SAAA;YAOzBjuC,CAAA,CAAcowD,KAAA,GAAQ;cACpB,OAAO,KAAK3qB,QAAA,GAAW,KAAKF,GAAA,KAAQ,IAAI,KAAKA,GAC/C;YAAA,GAQAvlC,CAAA,CAAcgkC,QAAA,GAAW;cACvB,OAAI,KAAKyB,QAAA,IAAkB,KAAKD,IAAA,KAAS,KAAK71C,CAAA,IAAkB,KAAK41C,GAAA,KAAQ,KACtE,KAAKC,IAAA,GAAO71C,CAAA,IAAkB,KAAK41C,GAAA,KAAQ,EACpD;YAAA,GAWAvlC,CAAA,CAAc2f,QAAA,GAAW,UAAkBv2B,CAAA;cAEzC,KADAA,CAAA,GAAQA,CAAA,IAAS,MACL,KAAK,KAAKA,CAAA,EAAO,MAAM+5C,UAAA,CAAW;cAC9C,IAAI,KAAKktB,MAAA,IAAU,OAAO;cAE1B,IAAI,KAAKC,UAAA,IAAc;gBAErB,IAAI,KAAKC,EAAA,CAAGxwD,CAAA,GAAY;kBAGtB,IAAI1W,CAAA,GAAYyD,CAAA,CAAW1D,CAAA;oBACvBS,CAAA,GAAM,KAAKsS,GAAA,CAAI9S,CAAA;oBACfO,CAAA,GAAOC,CAAA,CAAIqS,GAAA,CAAI7S,CAAA,EAAW4S,GAAA,CAAI;kBAClC,OAAOpS,CAAA,CAAI81B,QAAA,CAASv2B,CAAA,IAASQ,CAAA,CAAKwmE,KAAA,GAAQzwC,QAAA,CAASv2B,CAAA,CACrD;gBAAA;gBAAO,OAAO,MAAM,KAAK4a,GAAA,GAAM2b,QAAA,CAASv2B,CAAA,CAC1C;cAAA;cAQA,KAJA,IAAIU,CAAA,GAAegD,CAAA,CAAW2H,CAAA,CAAQrL,CAAA,EAAO,IAAI,KAAKq8C,QAAA,GAClDp7C,CAAA,GAAM,MACNC,CAAA,GAAS,MAEA;gBACX,IAAIoC,CAAA,GAASrC,CAAA,CAAI8R,GAAA,CAAIrS,CAAA;kBAEjB+J,CAAA,IADSxJ,CAAA,CAAI4R,GAAA,CAAIvP,CAAA,CAAOwP,GAAA,CAAIpS,CAAA,GAAesmE,KAAA,OAAY,GACvCzwC,QAAA,CAASv2B,CAAA;gBAE7B,KADAiB,CAAA,GAAMqC,CAAA,EACE2jE,MAAA,IAAU,OAAOx8D,CAAA,GAASvJ,CAAA;gBAChC,OAAOuJ,CAAA,CAAO3I,MAAA,GAAS,IAAG2I,CAAA,GAAS,MAAMA,CAAA;gBAEzCvJ,CAAA,GAAS,KAAKuJ,CAAA,GAASvJ,CAE3B;cAAA;YACF,GAQA0V,CAAA,CAAcwwD,WAAA,GAAc;cAC1B,OAAO,KAAKhrB,IACd;YAAA,GAQAxlC,CAAA,CAAcywD,mBAAA,GAAsB;cAClC,OAAO,KAAKjrB,IAAA,KAAS,CACvB;YAAA,GAQAxlC,CAAA,CAAc0wD,UAAA,GAAa;cACzB,OAAO,KAAKnrB,GACd;YAAA,GAQAvlC,CAAA,CAAc2wD,kBAAA,GAAqB;cACjC,OAAO,KAAKprB,GAAA,KAAQ,CACtB;YAAA,GAQAvlC,CAAA,CAAc4wD,aAAA,GAAgB;cAC5B,IAAI,KAAKN,UAAA,IACP,OAAO,KAAKC,EAAA,CAAGxwD,CAAA,IAAa,KAAK,KAAKiE,GAAA,GAAM4sD,aAAA;cAG9C,KAFA,IAAIxnE,CAAA,GAAmB,KAAb,KAAKo8C,IAAA,GAAY,KAAKA,IAAA,GAAO,KAAKD,GAAA,EAEnCl8C,CAAA,GAAM,IAAIA,CAAA,GAAM,KAAkC,MAAnBD,CAAA,GAAM,KAAKC,CAAA,GAAvBA,CAAA;cAE5B,OAAoB,KAAb,KAAKm8C,IAAA,GAAYn8C,CAAA,GAAM,KAAKA,CAAA,GAAM,CAC3C;YAAA,GAQA2W,CAAA,CAAcqwD,MAAA,GAAS;cACrB,OAAqB,MAAd,KAAK7qB,IAAA,IAA2B,MAAb,KAAKD,GACjC;YAAA,GAOAvlC,CAAA,CAAc6wD,GAAA,GAAM7wD,CAAA,CAAcqwD,MAAA,EAOlCrwD,CAAA,CAAcswD,UAAA,GAAa;cACzB,QAAQ,KAAK7qB,QAAA,IAAY,KAAKD,IAAA,GAAO,CACvC;YAAA,GAQAxlC,CAAA,CAAc8wD,UAAA,GAAa;cACzB,OAAO,KAAKrrB,QAAA,IAAY,KAAKD,IAAA,IAAQ,CACvC;YAAA,GAQAxlC,CAAA,CAAc+wD,KAAA,GAAQ;cACpB,OAA0B,MAAP,IAAX,KAAKxrB,GAAA,CACf;YAAA,GAQAvlC,CAAA,CAAcgxD,MAAA,GAAS;cACrB,OAA0B,MAAP,IAAX,KAAKzrB,GAAA,CACf;YAAA,GASAvlC,CAAA,CAAcqoD,MAAA,GAAS,UAAgBj/D,CAAA;cAErC,OADKQ,CAAA,CAAOR,CAAA,MAAQA,CAAA,GAAQuL,CAAA,CAAUvL,CAAA,KAClC,KAAKq8C,QAAA,KAAar8C,CAAA,CAAMq8C,QAAA,IAAY,KAAKD,IAAA,KAAS,MAAO,KAAKp8C,CAAA,CAAMo8C,IAAA,KAAS,MAAO,MACjF,KAAKA,IAAA,KAASp8C,CAAA,CAAMo8C,IAAA,IAAQ,KAAKD,GAAA,KAAQn8C,CAAA,CAAMm8C,GACxD;YAAA,GASAvlC,CAAA,CAAcuwD,EAAA,GAAKvwD,CAAA,CAAcqoD,MAAA,EAQjCroD,CAAA,CAAcixD,SAAA,GAAY,UAAmB7nE,CAAA;cAC3C,QAAQ,KAAKmnE,EAAA,CAEbnnE,CAAA,CACF;YAAA,GASA4W,CAAA,CAAckxD,GAAA,GAAMlxD,CAAA,CAAcixD,SAAA,EAQlCjxD,CAAA,CAAc22C,EAAA,GAAK32C,CAAA,CAAcixD,SAAA,EAQjCjxD,CAAA,CAAc+jC,QAAA,GAAW,UAAkB36C,CAAA;cACzC,OAAO,KAAK+nE,IAAA,CAEZ/nE,CAAA,IAAS,CACX;YAAA,GASA4W,CAAA,CAAc+/C,EAAA,GAAK//C,CAAA,CAAc+jC,QAAA,EAQjC/jC,CAAA,CAAcoxD,eAAA,GAAkB,UAAyBhoE,CAAA;cACvD,OAAO,KAAK+nE,IAAA,CAEZ/nE,CAAA,KAAU,CACZ;YAAA,GASA4W,CAAA,CAAcqxD,GAAA,GAAMrxD,CAAA,CAAcoxD,eAAA,EAQlCpxD,CAAA,CAAcq4C,EAAA,GAAKr4C,CAAA,CAAcoxD,eAAA,EAQjCpxD,CAAA,CAAcsxD,WAAA,GAAc,UAAqBloE,CAAA;cAC/C,OAAO,KAAK+nE,IAAA,CAEZ/nE,CAAA,IAAS,CACX;YAAA,GASA4W,CAAA,CAAcilD,EAAA,GAAKjlD,CAAA,CAAcsxD,WAAA,EAQjCtxD,CAAA,CAAc8jC,kBAAA,GAAqB,UAA4B16C,CAAA;cAC7D,OAAO,KAAK+nE,IAAA,CAEZ/nE,CAAA,KAAU,CACZ;YAAA,GASA4W,CAAA,CAAcuxD,GAAA,GAAMvxD,CAAA,CAAc8jC,kBAAA,EAQlC9jC,CAAA,CAAci7C,EAAA,GAAKj7C,CAAA,CAAc8jC,kBAAA,EASjC9jC,CAAA,CAAcwxD,OAAA,GAAU,UAAiBpoE,CAAA;cAEvC,IADKQ,CAAA,CAAOR,CAAA,MAAQA,CAAA,GAAQuL,CAAA,CAAUvL,CAAA,IAClC,KAAKmnE,EAAA,CAAGnnE,CAAA,GAAQ,OAAO;cAC3B,IAAIC,CAAA,GAAU,KAAKinE,UAAA;gBACfzmE,CAAA,GAAWT,CAAA,CAAMknE,UAAA;cACrB,OAAIjnE,CAAA,KAAYQ,CAAA,IAAkB,KAC7BR,CAAA,IAAWQ,CAAA,GAAiB,IAE5B,KAAK47C,QAAA,GAEHr8C,CAAA,CAAMo8C,IAAA,KAAS,IAAI,KAAKA,IAAA,KAAS,KAAKp8C,CAAA,CAAMo8C,IAAA,KAAS,KAAKA,IAAA,IAAQp8C,CAAA,CAAMm8C,GAAA,KAAQ,IAAI,KAAKA,GAAA,KAAQ,KAAK,IAAI,IAFtF,KAAKtpC,GAAA,CAAI7S,CAAA,EAAOknE,UAAA,MAAgB,IAAI,CAGjE;YAAA,GAUAtwD,CAAA,CAAcmxD,IAAA,GAAOnxD,CAAA,CAAcwxD,OAAA,EAOnCxxD,CAAA,CAAcyxD,MAAA,GAAS;cACrB,QAAK,KAAKhsB,QAAA,IAAY,KAAK8qB,EAAA,CAAGxwD,CAAA,IAAmBA,CAAA,GAC1C,KAAKkE,GAAA,GAAM9L,GAAA,CAAI/C,CAAA,CACxB;YAAA,GAQA4K,CAAA,CAAcgE,GAAA,GAAMhE,CAAA,CAAcyxD,MAAA,EAQlCzxD,CAAA,CAAc7H,GAAA,GAAM,UAAa/O,CAAA;cAC1BQ,CAAA,CAAOR,CAAA,MAASA,CAAA,GAASuL,CAAA,CAAUvL,CAAA;cAExC,IAAIC,CAAA,GAAM,KAAKm8C,IAAA,KAAS;gBACpB37C,CAAA,GAAkB,QAAZ,KAAK27C,IAAA;gBACX17C,CAAA,GAAM,KAAKy7C,GAAA,KAAQ;gBACnBl7C,CAAA,GAAiB,QAAX,KAAKk7C,GAAA;gBACXj7C,CAAA,GAAMlB,CAAA,CAAOo8C,IAAA,KAAS;gBACtB94C,CAAA,GAAoB,QAAdtD,CAAA,CAAOo8C,IAAA;gBACb14C,CAAA,GAAM1D,CAAA,CAAOm8C,GAAA,KAAQ;gBAErB9wC,CAAA,GAAM;gBACNC,CAAA,GAAM;gBACN/E,CAAA,GAAM;gBACNmF,CAAA,GAAM;cAYV,OAVAnF,CAAA,KADAmF,CAAA,IAAOzK,CAAA,IALgB,QAAbjB,CAAA,CAAOm8C,GAAA,OAMF,IAGf7wC,CAAA,KADA/E,CAAA,IAAO7F,CAAA,GAAMgD,CAAA,MACE,IAGf2H,CAAA,KADAC,CAAA,IAAO7K,CAAA,GAAM6C,CAAA,MACE,IAEf+H,CAAA,IAAOpL,CAAA,GAAMiB,CAAA,EAENuJ,CAAA,EANPlE,CAAA,IAAO,UAMgB,MATvBmF,CAAA,IAAO,SAQPL,CAAA,IAAO,UACiC,MAHxCC,CAAA,IAAO,QAG2C,KAAK+wC,QAAA,CACzD;YAAA,GASAzlC,CAAA,CAAc0xD,QAAA,GAAW,UAAkBtoE,CAAA;cAEzC,OADKQ,CAAA,CAAOR,CAAA,MAAaA,CAAA,GAAauL,CAAA,CAAUvL,CAAA,IACzC,KAAK+O,GAAA,CAAI/O,CAAA,CAAW4a,GAAA,GAC7B;YAAA,GASAhE,CAAA,CAAc/D,GAAA,GAAM+D,CAAA,CAAc0xD,QAAA,EAQlC1xD,CAAA,CAAc2xD,QAAA,GAAW,UAAkBvoE,CAAA;cACzC,IAAI,KAAKinE,MAAA,IAAU,OAAO;cAG1B,IAFKzmE,CAAA,CAAOR,CAAA,MAAaA,CAAA,GAAauL,CAAA,CAAUvL,CAAA,IAE5CC,CAAA,EAEF,OAAOwK,CAAA,CADGxK,CAAA,CAAU6S,GAAA,CAAE,KAAKqpC,GAAA,EAAK,KAAKC,IAAA,EAAMp8C,CAAA,CAAWm8C,GAAA,EAAKn8C,CAAA,CAAWo8C,IAAA,GACjDn8C,CAAA,CAAeuoE,QAAA,IAAK,KAAKnsB,QAAA;cAGhD,IAAIr8C,CAAA,CAAWinE,MAAA,IAAU,OAAO,KAAK5qB,QAAA,GAAWtwC,CAAA,GAAQF,CAAA;cACxD,IAAI,KAAKs7D,EAAA,CAAGxwD,CAAA,GAAY,OAAO3W,CAAA,CAAW2nE,KAAA,KAAUhxD,CAAA,GAAY9K,CAAA;cAChE,IAAI7L,CAAA,CAAWmnE,EAAA,CAAGxwD,CAAA,GAAY,OAAO,KAAKgxD,KAAA,KAAUhxD,CAAA,GAAY9K,CAAA;cAEhE,IAAI,KAAKq7D,UAAA,IACP,OAAIlnE,CAAA,CAAWknE,UAAA,KAAqB,KAAKtsD,GAAA,GAAM9H,GAAA,CAAI9S,CAAA,CAAW4a,GAAA,MAAmB,KAAKA,GAAA,GAAM9H,GAAA,CAAI9S,CAAA,EAAY4a,GAAA;cACvG,IAAI5a,CAAA,CAAWknE,UAAA,IAAc,OAAO,KAAKp0D,GAAA,CAAI9S,CAAA,CAAW4a,GAAA,IAAOA,GAAA;cAGtE,IAAI,KAAK+7C,EAAA,CAAG/qD,CAAA,KAAe5L,CAAA,CAAW22D,EAAA,CAAG/qD,CAAA,GAAa,OAAOlI,CAAA,CAAW,KAAKk3C,QAAA,KAAa56C,CAAA,CAAW46C,QAAA,IAAY,KAAKyB,QAAA;cAGtH,IAAI57C,CAAA,GAAM,KAAK27C,IAAA,KAAS;gBACpB17C,CAAA,GAAkB,QAAZ,KAAK07C,IAAA;gBACXn7C,CAAA,GAAM,KAAKk7C,GAAA,KAAQ;gBACnBj7C,CAAA,GAAiB,QAAX,KAAKi7C,GAAA;gBACX74C,CAAA,GAAMtD,CAAA,CAAWo8C,IAAA,KAAS;gBAC1B/wC,CAAA,GAAwB,QAAlBrL,CAAA,CAAWo8C,IAAA;gBACjB9wC,CAAA,GAAMtL,CAAA,CAAWm8C,GAAA,KAAQ;gBACzB51C,CAAA,GAAuB,QAAjBvG,CAAA,CAAWm8C,GAAA;gBACjBzwC,CAAA,GAAM;gBACNlF,CAAA,GAAM;gBACNwF,CAAA,GAAM;gBACNC,CAAA,GAAM;cAqBV,OAnBAD,CAAA,KADAC,CAAA,IAAO/K,CAAA,GAAMqF,CAAA,MACE,IAGfC,CAAA,KADAwF,CAAA,IAAO/K,CAAA,GAAMsF,CAAA,MACE,IACfyF,CAAA,IAAO,OAEPxF,CAAA,KADAwF,CAAA,IAAO9K,CAAA,GAAMoK,CAAA,MACE,IAGfI,CAAA,KADAlF,CAAA,IAAO9F,CAAA,GAAM6F,CAAA,MACE,IACfC,CAAA,IAAO,OAEPkF,CAAA,KADAlF,CAAA,IAAOvF,CAAA,GAAMqK,CAAA,MACE,IACf9E,CAAA,IAAO,OAEPkF,CAAA,KADAlF,CAAA,IAAOtF,CAAA,GAAMmK,CAAA,MACE,IAEfK,CAAA,IAAOjL,CAAA,GAAM8F,CAAA,GAAM7F,CAAA,GAAM4K,CAAA,GAAMrK,CAAA,GAAMoK,CAAA,GAAMnK,CAAA,GAAMoC,CAAA,EAE1CmH,CAAA,EAZPuB,CAAA,IAAO,UAYgB,MAlBvBC,CAAA,IAAO,SAiBPP,CAAA,IAAO,UACiC,MAHxClF,CAAA,IAAO,QAG2C,KAAK61C,QAAA,CACzD;YAAA,GASAzlC,CAAA,CAAc9D,GAAA,GAAM8D,CAAA,CAAc2xD,QAAA,EASlC3xD,CAAA,CAAc6xD,MAAA,GAAS,UAAgBzoE,CAAA;cAErC,IADKQ,CAAA,CAAOR,CAAA,MAAUA,CAAA,GAAUuL,CAAA,CAAUvL,CAAA,IACtCA,CAAA,CAAQinE,MAAA,IAAU,MAAM5iE,KAAA,CAAM;cAWhC,IAKE5D,CAAA,EAAQC,CAAA,EAAKO,CAAA;cAdjB,IAAIhB,CAAA,EAIF,OAAK,KAAKo8C,QAAA,KAA2B,eAAf,KAAKD,IAAA,KAAyC,MAAjBp8C,CAAA,CAAQm8C,GAAA,KAAgC,MAAlBn8C,CAAA,CAAQo8C,IAAA,GAM1E3xC,CAAA,EADI,KAAK4xC,QAAA,GAAWp8C,CAAA,CAAYyoE,KAAA,GAAIzoE,CAAA,CAAY0oE,KAAA,EAAG,KAAKxsB,GAAA,EAAK,KAAKC,IAAA,EAAMp8C,CAAA,CAAQm8C,GAAA,EAAKn8C,CAAA,CAAQo8C,IAAA,GAC/En8C,CAAA,CAAeuoE,QAAA,IAAK,KAAKnsB,QAAA,IAJrC;cAOX,IAAI,KAAK4qB,MAAA,IAAU,OAAO,KAAK5qB,QAAA,GAAWtwC,CAAA,GAAQF,CAAA;cAGlD,IAAK,KAAKwwC,QAAA,EA0BH;gBAIL,IADKr8C,CAAA,CAAQq8C,QAAA,KAAUr8C,CAAA,GAAUA,CAAA,CAAQ4oE,UAAA,KACrC5oE,CAAA,CAAQ67D,EAAA,CAAG,OAAO,OAAO9vD,CAAA;gBAC7B,IAAI/L,CAAA,CAAQ67D,EAAA,CAAG,KAAKgN,IAAA,CAAK,KACvB,OAAO58D,CAAA;gBACThL,CAAA,GAAM8K,CACR;cAAA,OAlCoB;gBAGlB,IAAI,KAAKo7D,EAAA,CAAGxwD,CAAA,GACV,OAAI3W,CAAA,CAAQmnE,EAAA,CAAGn7D,CAAA,KAAQhM,CAAA,CAAQmnE,EAAA,CAAGh7D,CAAA,IAAiBwK,CAAA,GAC1C3W,CAAA,CAAQmnE,EAAA,CAAGxwD,CAAA,IAAmB3K,CAAA,IAGrCvL,CAAA,GADe,KAAKqoE,GAAA,CAAI,GACN/1D,GAAA,CAAI/S,CAAA,EAAS+oE,GAAA,CAAI,IAExB5B,EAAA,CAAGt7D,CAAA,IACL7L,CAAA,CAAQknE,UAAA,KAAel7D,CAAA,GAAMG,CAAA,IAEpCzL,CAAA,GAAM,KAAKmS,GAAA,CAAI7S,CAAA,CAAQ8S,GAAA,CAAIrS,CAAA,IAC3BQ,CAAA,GAAMR,CAAA,CAAOsO,GAAA,CAAIrO,CAAA,CAAIqS,GAAA,CAAI/S,CAAA;gBAIxB,IAAIA,CAAA,CAAQmnE,EAAA,CAAGxwD,CAAA,GAAY,OAAO,KAAK0lC,QAAA,GAAWtwC,CAAA,GAAQF,CAAA;gBAEjE,IAAI,KAAKq7D,UAAA,IACP,OAAIlnE,CAAA,CAAQknE,UAAA,KAAqB,KAAKtsD,GAAA,GAAM7H,GAAA,CAAI/S,CAAA,CAAQ4a,GAAA,MACjD,KAAKA,GAAA,GAAM7H,GAAA,CAAI/S,CAAA,EAAS4a,GAAA;gBAC1B,IAAI5a,CAAA,CAAQknE,UAAA,IAAc,OAAO,KAAKn0D,GAAA,CAAI/S,CAAA,CAAQ4a,GAAA,IAAOA,GAAA;gBAEhE3Z,CAAA,GAAM4K,CACR;cAAA;cAiBA,KAFAnL,CAAA,GAAM,MAECA,CAAA,CAAIynE,GAAA,CAAInoE,CAAA,IAAU;gBAGvBS,CAAA,GAASuB,IAAA,CAAKwnB,GAAA,CAAI,GAAGxnB,IAAA,CAAKoX,KAAA,CAAM1Y,CAAA,CAAIk6C,QAAA,KAAa56C,CAAA,CAAQ46C,QAAA;gBAUzD,KAPA,IAAI15C,CAAA,GAAOc,IAAA,CAAKE,IAAA,CAAKF,IAAA,CAAKuY,GAAA,CAAI9Z,CAAA,IAAUuB,IAAA,CAAK87D,GAAA,GACzCx6D,CAAA,GAAQpC,CAAA,IAAQ,KAAK,IAAImK,CAAA,CAAQ,GAAGnK,CAAA,GAAO,KAG/CoK,CAAA,GAAY5H,CAAA,CAAWjD,CAAA,GACnB8F,CAAA,GAAY+E,CAAA,CAAUwH,GAAA,CAAI9S,CAAA,GAEvBuG,CAAA,CAAU2gE,UAAA,MAAgB3gE,CAAA,CAAUs1D,EAAA,CAAGn7D,CAAA,IAG5C6F,CAAA,IADA+E,CAAA,GAAY5H,CAAA,CADZjD,CAAA,IAAU6C,CAAA,EACqB,KAAK+4C,QAAA,GACdvpC,GAAA,CAAI9S,CAAA;gBAKxBsL,CAAA,CAAU27D,MAAA,OAAU37D,CAAA,GAAYU,CAAA,GACpC/K,CAAA,GAAMA,CAAA,CAAI8N,GAAA,CAAIzD,CAAA,GACd5K,CAAA,GAAMA,CAAA,CAAImS,GAAA,CAAItM,CAAA,CAChB;cAAA;cAEA,OAAOtF,CACT;YAAA,GASA2V,CAAA,CAAc7D,GAAA,GAAM6D,CAAA,CAAc6xD,MAAA,EAQlC7xD,CAAA,CAAcoyD,MAAA,GAAS,UAAgBhpE,CAAA;cAGrC,OAFKQ,CAAA,CAAOR,CAAA,MAAUA,CAAA,GAAUuL,CAAA,CAAUvL,CAAA,IAEtCC,CAAA,GAEKwK,CAAA,EADI,KAAK4xC,QAAA,GAAWp8C,CAAA,CAAYgpE,KAAA,GAAIhpE,CAAA,CAAYipE,KAAA,EAAG,KAAK/sB,GAAA,EAAK,KAAKC,IAAA,EAAMp8C,CAAA,CAAQm8C,GAAA,EAAKn8C,CAAA,CAAQo8C,IAAA,GAC/En8C,CAAA,CAAeuoE,QAAA,IAAK,KAAKnsB,QAAA,IAGzC,KAAKxpC,GAAA,CAAI,KAAKE,GAAA,CAAI/S,CAAA,EAAS8S,GAAA,CAAI9S,CAAA,EACxC;YAAA,GASA4W,CAAA,CAAcynD,GAAA,GAAMznD,CAAA,CAAcoyD,MAAA,EAQlCpyD,CAAA,CAAcuyD,GAAA,GAAMvyD,CAAA,CAAcoyD,MAAA,EAOlCpyD,CAAA,CAAciE,GAAA,GAAM;cAClB,OAAOpQ,CAAA,EAAU,KAAK0xC,GAAA,GAAM,KAAKC,IAAA,EAAM,KAAKC,QAAA,CAC9C;YAAA,GAQAzlC,CAAA,CAAcwyD,iBAAA,GAAoB;cAChC,OAAO,KAAKhtB,IAAA,GAAOp6C,IAAA,CAAKskE,KAAA,CAAM,KAAKlqB,IAAA,IAAQp6C,IAAA,CAAKskE,KAAA,CAAM,KAAKnqB,GAAA,IAAO,EACpE;YAAA,GASAvlC,CAAA,CAAcyyD,GAAA,GAAMzyD,CAAA,CAAcwyD,iBAAA,EAOlCxyD,CAAA,CAAc0yD,kBAAA,GAAqB;cACjC,OAAO,KAAKntB,GAAA,GAAMz7C,CAAA,CAAM,KAAKy7C,GAAA,IAAOz7C,CAAA,CAAM,KAAK07C,IAAA,IAAQ,EACzD;YAAA,GASAxlC,CAAA,CAAc2yD,GAAA,GAAM3yD,CAAA,CAAc0yD,kBAAA,EAQlC1yD,CAAA,CAAca,GAAA,GAAM,UAAazX,CAAA;cAE/B,OADKQ,CAAA,CAAOR,CAAA,MAAQA,CAAA,GAAQuL,CAAA,CAAUvL,CAAA,IAC/ByK,CAAA,CAAS,KAAK0xC,GAAA,GAAMn8C,CAAA,CAAMm8C,GAAA,EAAK,KAAKC,IAAA,GAAOp8C,CAAA,CAAMo8C,IAAA,EAAM,KAAKC,QAAA,CACrE;YAAA,GASAzlC,CAAA,CAAckE,EAAA,GAAK,UAAY9a,CAAA;cAE7B,OADKQ,CAAA,CAAOR,CAAA,MAAQA,CAAA,GAAQuL,CAAA,CAAUvL,CAAA,IAC/ByK,CAAA,CAAS,KAAK0xC,GAAA,GAAMn8C,CAAA,CAAMm8C,GAAA,EAAK,KAAKC,IAAA,GAAOp8C,CAAA,CAAMo8C,IAAA,EAAM,KAAKC,QAAA,CACrE;YAAA,GASAzlC,CAAA,CAAc+G,GAAA,GAAM,UAAa3d,CAAA;cAE/B,OADKQ,CAAA,CAAOR,CAAA,MAAQA,CAAA,GAAQuL,CAAA,CAAUvL,CAAA,IAC/ByK,CAAA,CAAS,KAAK0xC,GAAA,GAAMn8C,CAAA,CAAMm8C,GAAA,EAAK,KAAKC,IAAA,GAAOp8C,CAAA,CAAMo8C,IAAA,EAAM,KAAKC,QAAA,CACrE;YAAA,GASAzlC,CAAA,CAAc4yD,SAAA,GAAY,UAAmBxpE,CAAA;cAE3C,OADIQ,CAAA,CAAOR,CAAA,MAAUA,CAAA,GAAUA,CAAA,CAAQgnE,KAAA,KACf,MAAnBhnE,CAAA,IAAW,MAAkB,OAAcA,CAAA,GAAU,KAAWyK,CAAA,CAAS,KAAK0xC,GAAA,IAAOn8C,CAAA,EAAS,KAAKo8C,IAAA,IAAQp8C,CAAA,GAAU,KAAKm8C,GAAA,KAAQ,KAAKn8C,CAAA,EAAS,KAAKq8C,QAAA,IAAsB5xC,CAAA,CAAS,GAAG,KAAK0xC,GAAA,IAAOn8C,CAAA,GAAU,IAAI,KAAKq8C,QAAA,CAC7N;YAAA,GASAzlC,CAAA,CAAcmyD,GAAA,GAAMnyD,CAAA,CAAc4yD,SAAA,EAQlC5yD,CAAA,CAAc6yD,UAAA,GAAa,UAAoBzpE,CAAA;cAE7C,OADIQ,CAAA,CAAOR,CAAA,MAAUA,CAAA,GAAUA,CAAA,CAAQgnE,KAAA,KACf,MAAnBhnE,CAAA,IAAW,MAAkB,OAAcA,CAAA,GAAU,KAAWyK,CAAA,CAAS,KAAK0xC,GAAA,KAAQn8C,CAAA,GAAU,KAAKo8C,IAAA,IAAQ,KAAKp8C,CAAA,EAAS,KAAKo8C,IAAA,IAAQp8C,CAAA,EAAS,KAAKq8C,QAAA,IAAsB5xC,CAAA,CAAS,KAAK2xC,IAAA,IAAQp8C,CAAA,GAAU,IAAI,KAAKo8C,IAAA,IAAQ,IAAI,KAAK,GAAG,KAAKC,QAAA,CACrP;YAAA,GASAzlC,CAAA,CAAckyD,GAAA,GAAMlyD,CAAA,CAAc6yD,UAAA,EAQlC7yD,CAAA,CAAc8yD,kBAAA,GAAqB,UAA4B1pE,CAAA;cAE7D,OADIQ,CAAA,CAAOR,CAAA,MAAUA,CAAA,GAAUA,CAAA,CAAQgnE,KAAA,KACf,MAAnBhnE,CAAA,IAAW,MAAkB,OAC9BA,CAAA,GAAU,KAAWyK,CAAA,CAAS,KAAK0xC,GAAA,KAAQn8C,CAAA,GAAU,KAAKo8C,IAAA,IAAQ,KAAKp8C,CAAA,EAAS,KAAKo8C,IAAA,KAASp8C,CAAA,EAAS,KAAKq8C,QAAA,IACrF5xC,CAAA,CAAX,OAAZzK,CAAA,GAAgC,KAAKo8C,IAAA,GACzB,KAAKA,IAAA,KAASp8C,CAAA,GAAU,IADO,GAAG,KAAKq8C,QAAA,CAEzD;YAAA,GASAzlC,CAAA,CAAciyD,IAAA,GAAOjyD,CAAA,CAAc8yD,kBAAA,EAQnC9yD,CAAA,CAAc+yD,KAAA,GAAQ/yD,CAAA,CAAc8yD,kBAAA,EAQpC9yD,CAAA,CAAcgzD,UAAA,GAAa,UAAoB5pE,CAAA;cAC7C,IAAIC,CAAA;cAEJ,OADIO,CAAA,CAAOR,CAAA,MAAUA,CAAA,GAAUA,CAAA,CAAQgnE,KAAA,KACf,MAAnBhnE,CAAA,IAAW,MAAkB,OAClB,OAAZA,CAAA,GAAuByK,CAAA,CAAS,KAAK2xC,IAAA,EAAM,KAAKD,GAAA,EAAK,KAAKE,QAAA,IAE1Dr8C,CAAA,GAAU,MACZC,CAAA,GAAI,KAAKD,CAAA,EACFyK,CAAA,CAAS,KAAK0xC,GAAA,IAAOn8C,CAAA,GAAU,KAAKo8C,IAAA,KAASn8C,CAAA,EAAG,KAAKm8C,IAAA,IAAQp8C,CAAA,GAAU,KAAKm8C,GAAA,KAAQl8C,CAAA,EAAG,KAAKo8C,QAAA,MAIrGp8C,CAAA,GAAI,MADJD,CAAA,IAAW,KAEJyK,CAAA,CAAS,KAAK2xC,IAAA,IAAQp8C,CAAA,GAAU,KAAKm8C,GAAA,KAAQl8C,CAAA,EAAG,KAAKk8C,GAAA,IAAOn8C,CAAA,GAAU,KAAKo8C,IAAA,KAASn8C,CAAA,EAAG,KAAKo8C,QAAA,EACrG;YAAA,GASAzlC,CAAA,CAAcizD,IAAA,GAAOjzD,CAAA,CAAcgzD,UAAA,EAQnChzD,CAAA,CAAckzD,WAAA,GAAc,UAAqB9pE,CAAA;cAC/C,IAAIC,CAAA;cAEJ,OADIO,CAAA,CAAOR,CAAA,MAAUA,CAAA,GAAUA,CAAA,CAAQgnE,KAAA,KACf,MAAnBhnE,CAAA,IAAW,MAAkB,OAClB,OAAZA,CAAA,GAAuByK,CAAA,CAAS,KAAK2xC,IAAA,EAAM,KAAKD,GAAA,EAAK,KAAKE,QAAA,IAE1Dr8C,CAAA,GAAU,MACZC,CAAA,GAAI,KAAKD,CAAA,EACFyK,CAAA,CAAS,KAAK2xC,IAAA,IAAQn8C,CAAA,GAAI,KAAKk8C,GAAA,KAAQn8C,CAAA,EAAS,KAAKm8C,GAAA,IAAOl8C,CAAA,GAAI,KAAKm8C,IAAA,KAASp8C,CAAA,EAAS,KAAKq8C,QAAA,MAIrGp8C,CAAA,GAAI,MADJD,CAAA,IAAW,KAEJyK,CAAA,CAAS,KAAK0xC,GAAA,IAAOl8C,CAAA,GAAI,KAAKm8C,IAAA,KAASp8C,CAAA,EAAS,KAAKo8C,IAAA,IAAQn8C,CAAA,GAAI,KAAKk8C,GAAA,KAAQn8C,CAAA,EAAS,KAAKq8C,QAAA,EACrG;YAAA,GASAzlC,CAAA,CAAcmzD,IAAA,GAAOnzD,CAAA,CAAckzD,WAAA,EAOnClzD,CAAA,CAAcozD,QAAA,GAAW;cACvB,OAAK,KAAK3tB,QAAA,GACH5xC,CAAA,CAAS,KAAK0xC,GAAA,EAAK,KAAKC,IAAA,GAAM,KADV,IAE7B;YAAA,GAQAxlC,CAAA,CAAcgyD,UAAA,GAAa;cACzB,OAAI,KAAKvsB,QAAA,GAAiB,OACnB5xC,CAAA,CAAS,KAAK0xC,GAAA,EAAK,KAAKC,IAAA,GAAM,EACvC;YAAA,GASAxlC,CAAA,CAAcqzD,OAAA,GAAU,UAAiBjqE,CAAA;cACvC,OAAOA,CAAA,GAAK,KAAKkqE,SAAA,KAAc,KAAKC,SAAA,EACtC;YAAA,GAQAvzD,CAAA,CAAcszD,SAAA,GAAY;cACxB,IAAIlqE,CAAA,GAAK,KAAKo8C,IAAA;gBACVn8C,CAAA,GAAK,KAAKk8C,GAAA;cACd,OAAO,CAAM,MAALl8C,CAAA,EAAWA,CAAA,KAAO,IAAI,KAAMA,CAAA,KAAO,KAAK,KAAMA,CAAA,KAAO,IAAS,MAALD,CAAA,EAAWA,CAAA,KAAO,IAAI,KAAMA,CAAA,KAAO,KAAK,KAAMA,CAAA,KAAO,GACxH;YAAA,GAQA4W,CAAA,CAAcuzD,SAAA,GAAY;cACxB,IAAInqE,CAAA,GAAK,KAAKo8C,IAAA;gBACVn8C,CAAA,GAAK,KAAKk8C,GAAA;cACd,OAAO,CAACn8C,CAAA,KAAO,IAAIA,CAAA,KAAO,KAAK,KAAMA,CAAA,KAAO,IAAI,KAAW,MAALA,CAAA,EAAWC,CAAA,KAAO,IAAIA,CAAA,KAAO,KAAK,KAAMA,CAAA,KAAO,IAAI,KAAW,MAALA,CAAA,CACjH;YAAA,GAUAQ,CAAA,CAAK2pE,SAAA,GAAY,UAAmBpqE,CAAA,EAAOC,CAAA,EAAUO,CAAA;cACnD,OAAOA,CAAA,GAAKC,CAAA,CAAK4pE,WAAA,CAAYrqE,CAAA,EAAOC,CAAA,IAAYQ,CAAA,CAAK6pE,WAAA,CAAYtqE,CAAA,EAAOC,CAAA,CAC1E;YAAA,GASAQ,CAAA,CAAK4pE,WAAA,GAAc,UAAqBrqE,CAAA,EAAOC,CAAA;cAC7C,OAAO,IAAIQ,CAAA,CAAKT,CAAA,CAAM,KAAKA,CAAA,CAAM,MAAM,IAAIA,CAAA,CAAM,MAAM,KAAKA,CAAA,CAAM,MAAM,IAAIA,CAAA,CAAM,KAAKA,CAAA,CAAM,MAAM,IAAIA,CAAA,CAAM,MAAM,KAAKA,CAAA,CAAM,MAAM,IAAIC,CAAA,CAC1I;YAAA,GASAQ,CAAA,CAAK6pE,WAAA,GAAc,UAAqBtqE,CAAA,EAAOC,CAAA;cAC7C,OAAO,IAAIQ,CAAA,CAAKT,CAAA,CAAM,MAAM,KAAKA,CAAA,CAAM,MAAM,KAAKA,CAAA,CAAM,MAAM,IAAIA,CAAA,CAAM,IAAIA,CAAA,CAAM,MAAM,KAAKA,CAAA,CAAM,MAAM,KAAKA,CAAA,CAAM,MAAM,IAAIA,CAAA,CAAM,IAAIC,CAAA,CAC1I;YAAA;YAEA,IAAI4W,CAAA,GAAWpW,CAAA;YAEf,OADAT,CAAA,CAAQu6C,OAAA,GAAU1jC,CAAA,EACX,aAAa7W,CAAA,GAAUA,CAAA,CAAQu6C,OAAA,GAAUv6C,CACjD;UAAA,CAp5CU,CAo5CR,CAAC;QAAA,KACkF,OAA3BS,CAAA,GAAF;UAAe,OAAOD,CAAO;QAAA,EAAAm5D,KAAA,CAAA15D,CAAA,EAA/B,SAA+BD,CAAA,CAAAE,OAAA,GAAAO,CAAA,C;;;;;;;;QCr4CtF,IAAID,CAAA,GAAc,CAAC;QAKnBA,CAAA,CAAY+pE,MAAA,EAQZ/pE,CAAA,CAAYgqE,KAAA,EAMZhqE,CAAA,CAAYiqE,YAAA,GAAe,GAM3BjqE,CAAA,CAAYkqE,UAAA,GAAa,GAMzBlqE,CAAA,CAAYmqE,sBAAA,GAAyB,GAMrCnqE,CAAA,CAAYokC,kBAAA,GAAqB,GAKjCpkC,CAAA,CAAYoqE,QAAA,GAAW;UACrBC,UAAA,EAAY;UACZC,YAAA,EAAc;QAAA,GAOhBtqE,CAAA,CAAYklD,KAAA,GAAQ,IAAI/+B,UAAA,CAAW,IAMnCnmB,CAAA,CAAYuqE,OAAA,GAAU,IAAIn2D,YAAA,CAAapU,CAAA,CAAYklD,KAAA,CAAM92B,MAAA,GAMzDpuB,CAAA,CAAYwqE,OAAA,GAAU,IAAIl6C,YAAA,CAAatwB,CAAA,CAAYklD,KAAA,CAAM92B,MAAA,GAMzDpuB,CAAA,CAAY6O,cAAA,GAAuE,MAAtD,IAAIwhB,WAAA,CAAY,IAAIphB,UAAA,CAAW,CAAC,GAAG,IAAImf,MAAA,EAAQ,IAS5EpuB,CAAA,CAAYy7C,IAAA,GAAO,UAASj8C,CAAA,EAAKC,CAAA;UAK/B,KAAKk8C,GAAA,GAAY,IAANn8C,CAAA,EAMX,KAAKo8C,IAAA,GAAc,IAAPn8C,CACd;QAAA,GAOAO,CAAA,CAAYy7C,IAAA,CAAKxc,MAAA,GAAS,UAASz/B,CAAA,EAAKC,CAAA;UAEtC,OAAc,KAAPD,CAAA,IAAoB,KAARC,CAAA,GAAYO,CAAA,CAAYy7C,IAAA,CAAKuqB,IAAA,GAAO,IAAIhmE,CAAA,CAAYy7C,IAAA,CAAKj8C,CAAA,EAAKC,CAAA,CACnF;QAAA,GAKAO,CAAA,CAAYy7C,IAAA,CAAK4I,SAAA,CAAUomB,SAAA,GAAY;UACrC,QAAQ,KAAK9uB,GAAA,KAAQ,KAAiB,aAAZ,KAAKC,IACjC;QAAA,GAMA57C,CAAA,CAAYy7C,IAAA,CAAK4I,SAAA,CAAUoa,MAAA,GAAS,UAASj/D,CAAA;UAC3C,OAAO,KAAKm8C,GAAA,IAAOn8C,CAAA,CAAMm8C,GAAA,IAAO,KAAKC,IAAA,IAAQp8C,CAAA,CAAMo8C,IACrD;QAAA,GAMA57C,CAAA,CAAYy7C,IAAA,CAAKuqB,IAAA,GAAO,IAAIhmE,CAAA,CAAYy7C,IAAA,CAAK,GAAG,IAUhDz7C,CAAA,CAAY0qE,OAAA,GAAU,UAASlrE,CAAA;UAC7B,IAAKA,CAAA,EAGCC,CAAA,GAAeD,CAAA,MAFnB,IAAIC,CAAA,GAAe;UASrB,KAAKokC,EAAA,GAAK7jC,CAAA,CAAYihC,UAAA,CAAWlT,QAAA,CAAStuB,CAAA,GAQ1C,KAAKkrE,KAAA,GAAQlrE,CAAA,EAQb,KAAKmrE,QAAA,GAAW,GAQhB,KAAKC,MAAA,GAAS,MAQd,KAAKC,aAAA,GAAgB,GAQrB,KAAKC,QAAA,IAAW,GAQhB,KAAKC,YAAA,GAAe,GAQpB,KAAKC,OAAA,GAAU,IAQf,KAAKC,gBAAA,GAAmB,GAQxB,KAAKC,cAAA,IAAiB,CACxB;QAAA,GAEAnrE,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAU+mB,KAAA,GAAQ;UACpC,KAAKvnC,EAAA,CAAGunC,KAAA,IACR,KAAKT,KAAA,GAAQ,KAAK9mC,EAAA,CAAGwnC,QAAA,IACrB,KAAKT,QAAA,GAAW,GAChB,KAAKC,MAAA,GAAS,MACd,KAAKC,aAAA,GAAgB,GACrB,KAAKC,QAAA,IAAW,GAChB,KAAKC,YAAA,GAAe,GACpB,KAAKC,OAAA,GAAU,IACf,KAAKC,gBAAA,GAAmB,GACxB,KAAKC,cAAA,IAAiB,CACxB;QAAA,GASAnrE,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUinB,aAAA,GAAgB,UAAS9rE,CAAA;UACrD,KAAK2rE,cAAA,GAAiB3rE,CACxB;QAAA,GASAQ,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUknB,UAAA,GAAa;UACzC,OAAO,KAAK1nC,EACd;QAAA,GAQA7jC,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUmnB,YAAA,GAAe;UAC3C,OAAO,KAAK3nC,EAAA,CAAG4G,KAAA,GAAQp2B,QAAA,CAAS,KAAKwvB,EAAA,CAAGlY,QAAA,IAAY,KAAKkY,EAAA,CAAGlY,QAAA,KAAa,KAAKqd,MAAA,GAChF;QAAA,GAYAhpC,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUvb,IAAA,GAAO,UAAStpC,CAAA,EAAMC,CAAA;UAE9CD,CAAA,GAAO,KAAKorE,QAAA,KACd,KAAKA,QAAA,GAAWprE,CAAA;UAQlB,KAHA,IAAIS,CAAA,GAAwE,MAAvD,KAAK4jC,EAAA,CAAGwnC,QAAA,KAAa,KAAKV,KAAA,GAAQlrE,CAAA,IAA2BD,CAAA,GAAO,GAGlF,KAAKmrE,KAAA,GAAQ1qE,CAAA,GAAaT,CAAA,GAAOC,CAAA,GAAkB;YACxD,IAAIS,CAAA,GAAe,KAAK2jC,EAAA,CAAGwnC,QAAA;YAC3B,KAAKxnC,EAAA,GAAK7jC,CAAA,CAAY0qE,OAAA,CAAQe,cAAA,CAAe,KAAK5nC,EAAA,GAClD,KAAK8mC,KAAA,IAAS,KAAK9mC,EAAA,CAAGwnC,QAAA,KAAanrE,CACrC;UAAA;UAEA,KAAKwrE,GAAA,CAAIzrE,CAAA,CACX;QAAA,GAKAD,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUqnB,GAAA,GAAM,UAASlsE,CAAA;UAC3C,KAAK,IAAIC,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,EAAWC,CAAA,IAC7B,KAAKokC,EAAA,CAAG8nC,SAAA,GAAY,KAAKhB,KAAA,EAAO,EAEpC;QAAA,GAKA3qE,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUsnB,SAAA,GAAY,UAASnsE,CAAA;UACjD,KAAKqkC,EAAA,CAAG8nC,SAAA,CAAU,KAAKhB,KAAA,IAAS,GAAGnrE,CAAA,CACrC;QAAA,GAKAQ,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUunB,UAAA,GAAa,UAASpsE,CAAA;UAClD,KAAKqkC,EAAA,CAAG+nC,UAAA,CAAW,KAAKjB,KAAA,IAAS,GAAGnrE,CAAA,CACtC;QAAA,GAKAQ,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUtb,UAAA,GAAa,UAASvpC,CAAA;UAClD,KAAKqkC,EAAA,CAAGkF,UAAA,CAAW,KAAK4hC,KAAA,IAAS,GAAGnrE,CAAA,CACtC;QAAA,GAKAQ,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUwnB,UAAA,GAAa,UAASrsE,CAAA;UAClD,KAAKqkC,EAAA,CAAGgoC,UAAA,CAAW,KAAKlB,KAAA,IAAS,GAAGnrE,CAAA,CACtC;QAAA,GAKAQ,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUynB,YAAA,GAAe,UAAStsE,CAAA;UACpD,KAAKqkC,EAAA,CAAGioC,YAAA,CAAa,KAAKnB,KAAA,IAAS,GAAGnrE,CAAA,CACxC;QAAA,GAKAQ,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAU0nB,YAAA,GAAe,UAASvsE,CAAA;UACpD,KAAKqkC,EAAA,CAAGkoC,YAAA,CAAa,KAAKpB,KAAA,IAAS,GAAGnrE,CAAA,CACxC;QAAA,GAOAQ,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAU1V,OAAA,GAAU,UAASnvC,CAAA;UAC/C,KAAKspC,IAAA,CAAK,GAAG,IACb,KAAK6iC,SAAA,CAAUnsE,CAAA,CACjB;QAAA,GAMAQ,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAU2nB,QAAA,GAAW,UAASxsE,CAAA;UAChD,KAAKspC,IAAA,CAAK,GAAG,IACb,KAAK8iC,UAAA,CAAWpsE,CAAA,CAClB;QAAA,GAMAQ,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUrY,QAAA,GAAW,UAASxsC,CAAA;UAChD,KAAKspC,IAAA,CAAK,GAAG,IACb,KAAKC,UAAA,CAAWvpC,CAAA,CAClB;QAAA,GAMAQ,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAU/V,QAAA,GAAW,UAAS9uC,CAAA;UAChD,KAAKspC,IAAA,CAAK,GAAG,IACb,KAAK+iC,UAAA,CAAWrsE,CAAA,CAClB;QAAA,GAMAQ,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAU3T,UAAA,GAAa,UAASlxC,CAAA;UAClD,KAAKspC,IAAA,CAAK,GAAG,IACb,KAAKgjC,YAAA,CAAatsE,CAAA,CACpB;QAAA,GAMAQ,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAU4nB,UAAA,GAAa,UAASzsE,CAAA;UAClD,KAAKspC,IAAA,CAAK,GAAG,IACb,KAAKijC,YAAA,CAAavsE,CAAA,CACpB;QAAA,GAQAQ,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAU3d,YAAA,GAAe,UAASlnC,CAAA,EAASC,CAAA,EAAOQ,CAAA;UAAA,CAChE,KAAKkrE,cAAA,IAAkB1rE,CAAA,IAASQ,CAAA,MAClC,KAAK0uC,OAAA,CAAQlvC,CAAA,GACb,KAAKysE,IAAA,CAAK1sE,CAAA,EAEd;QAAA,GAOAQ,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAU8nB,aAAA,GAAgB,UAAS3sE,CAAA,EAASC,CAAA,EAAOQ,CAAA;UAAA,CACjE,KAAKkrE,cAAA,IAAkB1rE,CAAA,IAASQ,CAAA,MAClC,KAAK+rE,QAAA,CAASvsE,CAAA,GACd,KAAKysE,IAAA,CAAK1sE,CAAA,EAEd;QAAA,GAOAQ,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUjd,aAAA,GAAgB,UAAS5nC,CAAA,EAASC,CAAA,EAAOQ,CAAA;UAAA,CACjE,KAAKkrE,cAAA,IAAkB1rE,CAAA,IAASQ,CAAA,MAClC,KAAK+rC,QAAA,CAASvsC,CAAA,GACd,KAAKysE,IAAA,CAAK1sE,CAAA,EAEd;QAAA,GAOAQ,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUzd,aAAA,GAAgB,UAASpnC,CAAA,EAASC,CAAA,EAAOQ,CAAA;UAAA,CACjE,KAAKkrE,cAAA,IAAmB1rE,CAAA,CAAMg/D,MAAA,CAAOx+D,CAAA,MACvC,KAAKquC,QAAA,CAAS7uC,CAAA,GACd,KAAKysE,IAAA,CAAK1sE,CAAA,EAEd;QAAA,GAOAQ,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUlU,eAAA,GAAkB,UAAS3wC,CAAA,EAASC,CAAA,EAAOQ,CAAA;UAAA,CACnE,KAAKkrE,cAAA,IAAkB1rE,CAAA,IAASQ,CAAA,MAClC,KAAKywC,UAAA,CAAWjxC,CAAA,GAChB,KAAKysE,IAAA,CAAK1sE,CAAA,EAEd;QAAA,GAOAQ,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAU+nB,eAAA,GAAkB,UAAS5sE,CAAA,EAASC,CAAA,EAAOQ,CAAA;UAAA,CACnE,KAAKkrE,cAAA,IAAkB1rE,CAAA,IAASQ,CAAA,MAClC,KAAKgsE,UAAA,CAAWxsE,CAAA,GAChB,KAAKysE,IAAA,CAAK1sE,CAAA,EAEd;QAAA,GAOAQ,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUxf,cAAA,GAAiB,UAASrlC,CAAA,EAASC,CAAA,EAAOQ,CAAA;UAAA,CAClE,KAAKkrE,cAAA,IAAkB1rE,CAAA,IAASQ,CAAA,MAClC,KAAK+kC,SAAA,CAAUvlC,CAAA,GACf,KAAKysE,IAAA,CAAK1sE,CAAA,EAEd;QAAA,GASAQ,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUgoB,cAAA,GAAiB,UAAS7sE,CAAA,EAASC,CAAA,EAAOQ,CAAA;UAClER,CAAA,IAASQ,CAAA,KACX,KAAKqsE,MAAA,CAAO7sE,CAAA,GACZ,KAAKysE,IAAA,CAAK1sE,CAAA,EAEd;QAAA,GASAQ,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUioB,MAAA,GAAS,UAAS9sE,CAAA;UAC9C,IAAIA,CAAA,IAAO,KAAKwpC,MAAA,IACd,MAAM,IAAInlC,KAAA,CAAM,iDAEpB;QAAA,GAMA7D,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUkoB,SAAA,GAAY;UACxC,IAAI,KAAKxB,QAAA,EACP,MAAM,IAAIlnE,KAAA,CAAM,wDAEpB;QAAA,GAOA7D,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAU6nB,IAAA,GAAO,UAAS1sE,CAAA;UAC5C,KAAKqrE,MAAA,CAAOrrE,CAAA,IAAW,KAAKwpC,MAAA,EAC9B;QAAA,GAKAhpC,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUrb,MAAA,GAAS;UACrC,OAAO,KAAKnF,EAAA,CAAGwnC,QAAA,KAAa,KAAKV,KACnC;QAAA,GAcA3qE,CAAA,CAAY0qE,OAAA,CAAQe,cAAA,GAAiB,UAASjsE,CAAA;UAC5C,IAAIC,CAAA,GAAeD,CAAA,CAAG6rE,QAAA;UAGtB,IAAmB,aAAf5rE,CAAA,EACF,MAAM,IAAIoE,KAAA,CAAM;UAGlB,IAAI5D,CAAA,GAAeR,CAAA,IAAgB;YAC/BS,CAAA,GAAMF,CAAA,CAAYihC,UAAA,CAAWlT,QAAA,CAAS9tB,CAAA;UAG1C,OAFAC,CAAA,CAAIikC,WAAA,CAAYlkC,CAAA,GAAeR,CAAA,GAC/BS,CAAA,CAAIuqC,KAAA,GAAQlnC,GAAA,CAAI/D,CAAA,CAAGirC,KAAA,IAASxqC,CAAA,GAAeR,CAAA,GACpCS,CACT;QAAA,GAQAF,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUrf,SAAA,GAAY,UAASxlC,CAAA;UACjD,KAAKspC,IAAA,CAAK9oC,CAAA,CAAYkqE,UAAA,EAAY,IAClC,KAAKnhC,UAAA,CAAW,KAAKC,MAAA,KAAWxpC,CAAA,GAASQ,CAAA,CAAYkqE,UAAA,CACvD;QAAA,GAUAlqE,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAU1f,WAAA,GAAc,UAASnlC,CAAA;UACnD,KAAK+sE,SAAA,IACc,QAAf,KAAK1B,MAAA,KACP,KAAKA,MAAA,GAAS,KAEhB,KAAKC,aAAA,GAAgBtrE,CAAA;UACrB,KAAK,IAAIC,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,EAAWC,CAAA,IAC7B,KAAKorE,MAAA,CAAOprE,CAAA,IAAK;UAEnB,KAAKsrE,QAAA,IAAW,GAChB,KAAKC,YAAA,GAAe,KAAKhiC,MAAA,EAC3B;QAAA,GAOAhpC,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUjf,SAAA,GAAY;UACxC,IAAmB,QAAf,KAAKylC,MAAA,KAAmB,KAAKE,QAAA,EAC/B,MAAM,IAAIlnE,KAAA,CAAM;UAGlB,KAAKmoC,QAAA,CAAS;UAKd,KAJA,IAAIxsC,CAAA,GAAY,KAAKwpC,MAAA,IAGjBvpC,CAAA,GAAI,KAAKqrE,aAAA,GAAgB,GACtBrrE,CAAA,IAAK,KAAuB,KAAlB,KAAKorE,MAAA,CAAOprE,CAAA,GAASA,CAAA;UAItC,KAHA,IAAIQ,CAAA,GAAeR,CAAA,GAAI,GAGhBA,CAAA,IAAK,GAAGA,CAAA,IAEb,KAAKusE,QAAA,CAA2B,KAAlB,KAAKnB,MAAA,CAAOprE,CAAA,IAAUD,CAAA,GAAY,KAAKqrE,MAAA,CAAOprE,CAAA,IAAK;UAInE,KAAKusE,QAAA,CAASxsE,CAAA,GAAY,KAAKwrE,YAAA;UAC/B,IAAI9qE,CAAA,IAAOD,CAAA,GAFW,KAEuBD,CAAA,CAAYiqE,YAAA;UACzD,KAAK+B,QAAA,CAAS9rE,CAAA;UAGd,IAAIO,CAAA,GAAkB;YAClBC,CAAA,GAAM,KAAKiqE,KAAA;UACjBnrE,CAAA,EACE,KAAKC,CAAA,GAAI,GAAGA,CAAA,GAAI,KAAKwrE,OAAA,CAAQ3pE,MAAA,EAAQ7B,CAAA,IAAK;YACxC,IAAIqD,CAAA,GAAM,KAAK+gC,EAAA,CAAGwnC,QAAA,KAAa,KAAKJ,OAAA,CAAQxrE,CAAA;YAC5C,IAAIS,CAAA,IAAO,KAAK2jC,EAAA,CAAG2oC,SAAA,CAAU1pE,CAAA,GAAM;cACjC,KAAK,IAAII,CAAA,GAAIlD,CAAA,CAAYiqE,YAAA,EAAc/mE,CAAA,GAAIhD,CAAA,EAAKgD,CAAA,IAAKlD,CAAA,CAAYiqE,YAAA,EAC/D,IAAI,KAAKpmC,EAAA,CAAG2oC,SAAA,CAAU9rE,CAAA,GAAMwC,CAAA,KAAM,KAAK2gC,EAAA,CAAG2oC,SAAA,CAAU1pE,CAAA,GAAMI,CAAA,GACxD,SAAS1D,CAAA;cAGbiB,CAAA,GAAkB,KAAKwqE,OAAA,CAAQxrE,CAAA;cAC/B;YACF;UACF;UAmBA,OAjBIgB,CAAA,IAGF,KAAKkqE,KAAA,GAAQ,KAAK9mC,EAAA,CAAGwnC,QAAA,KAAa7rE,CAAA,EAGlC,KAAKqkC,EAAA,CAAGkF,UAAA,CAAW,KAAK4hC,KAAA,EAAOlqE,CAAA,GAAkBjB,CAAA,MAIjD,KAAKyrE,OAAA,CAAQzkE,IAAA,CAAK,KAAKwiC,MAAA,KAGvB,KAAKnF,EAAA,CAAGkF,UAAA,CAAW,KAAKlF,EAAA,CAAGwnC,QAAA,KAAa7rE,CAAA,EAAW,KAAKwpC,MAAA,KAAWxpC,CAAA,IAGrE,KAAKurE,QAAA,IAAW,GACTvrE,CACT;QAAA,GAUAQ,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAU3tB,MAAA,GAAS,UAASl3B,CAAA,EAAYC,CAAA,EAAqBQ,CAAA;UAC/E,IAAIC,CAAA,GAAcD,CAAA,GAAkBD,CAAA,CAAYokC,kBAAA,GAAqB;UACrE,IAAI3kC,CAAA,EAAqB;YACvB,IAAIgB,CAAA,GAAkBhB,CAAA;YAGtB,IAFA,KAAKqpC,IAAA,CAAK,KAAK8hC,QAAA,EAAU5qE,CAAA,CAAYkqE,UAAA,GACnClqE,CAAA,CAAYmqE,sBAAA,GAAyBjqE,CAAA,GACnCO,CAAA,CAAgBa,MAAA,IAAUtB,CAAA,CAAYmqE,sBAAA,EACxC,MAAM,IAAItmE,KAAA,CAAM,iDACd7D,CAAA,CAAYmqE,sBAAA;YAEhB,KAAK,IAAIzpE,CAAA,GAAIV,CAAA,CAAYmqE,sBAAA,GAAyB,GAAGzpE,CAAA,IAAK,GAAGA,CAAA,IAC3D,KAAKirE,SAAA,CAAUlrE,CAAA,CAAgB8xD,UAAA,CAAW7xD,CAAA,EAE9C;UAAA;UACA,KAAKooC,IAAA,CAAK,KAAK8hC,QAAA,EAAU5qE,CAAA,CAAYkqE,UAAA,GAAahqE,CAAA,GAClD,KAAK8kC,SAAA,CAAUxlC,CAAA,GACXU,CAAA,IACF,KAAK8rC,QAAA,CAAS,KAAKnI,EAAA,CAAGwnC,QAAA,KAAa,KAAKV,KAAA,GAE1C,KAAK9mC,EAAA,CAAGM,WAAA,CAAY,KAAKwmC,KAAA,CAC3B;QAAA,GAQA3qE,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUooB,kBAAA,GAAqB,UAAUjtE,CAAA,EAAYC,CAAA;UACvE,KAAKi3B,MAAA,CAAOl3B,CAAA,EAAYC,CAAA,GAAqB,EAC/C;QAAA,GAUAO,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUpO,aAAA,GAAgB,UAASz2C,CAAA,EAAOC,CAAA;UAC5D,IAAIQ,CAAA,GAAc,KAAK4jC,EAAA,CAAGwnC,QAAA,KAAa7rE,CAAA;YACnCQ,CAAA,GAAeC,CAAA,GAAc,KAAK4jC,EAAA,CAAGI,SAAA,CAAUhkC,CAAA;UAInD,IAHoD,KAA3C,KAAK4jC,EAAA,CAAG2oC,SAAA,CAAUxsE,CAAA,GAAeP,CAAA,GAIxC,MAAM,IAAIoE,KAAA,CAAM,wBAAwBpE,CAAA,GAAQ,eAEpD;QAAA,GAWAO,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUtf,WAAA,GAAc,UAASvlC,CAAA,EAAWC,CAAA,EAAWQ,CAAA;UACzE,KAAKssE,SAAA,IACL,KAAKrB,gBAAA,GAAmBzrE,CAAA,EACxB,KAAKqpC,IAAA,CAAK9oC,CAAA,CAAYkqE,UAAA,EAAY1qE,CAAA,GAAYC,CAAA,GAC9C,KAAKqpC,IAAA,CAAK7oC,CAAA,EAAWT,CAAA,GAAYC,CAAA,CACnC;QAAA,GASAO,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUpf,SAAA,GAAY;UAExC,OADA,KAAK8D,UAAA,CAAW,KAAKmiC,gBAAA,GACd,KAAKliC,MAAA,EACd;QAAA,GAUAhpC,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAUqoB,YAAA,GAAe,UAASltE,CAAA;UACpD,IAAIA,CAAA,YAAayP,UAAA,EACf,IAAIxP,CAAA,GAAOD,CAAA,MAEX;YAAIC,CAAA,GAAO;YAGX,KAHA,IACIQ,CAAA,GAAI,GAEDA,CAAA,GAAIT,CAAA,CAAE8B,MAAA,GAAQ;cACnB,IAAItB,CAAA;gBAGAE,CAAA,GAAIV,CAAA,CAAE+yD,UAAA,CAAWtyD,CAAA;cAAA,CAEnBD,CAAA,GADEE,CAAA,GAAI,SAAUA,CAAA,IAAK,QACTA,CAAA,IAGCA,CAAA,IAAK,MADVV,CAAA,CAAE+yD,UAAA,CAAWtyD,CAAA,OACO,YAId,MACdR,CAAA,CAAK+G,IAAA,CAAKxG,CAAA,KAENA,CAAA,GAAY,OACdP,CAAA,CAAK+G,IAAA,CAAOxG,CAAA,IAAa,IAAK,KAAQ,QAElCA,CAAA,GAAY,QACdP,CAAA,CAAK+G,IAAA,CAAOxG,CAAA,IAAa,KAAM,KAAQ,OAEvCP,CAAA,CAAK+G,IAAA,CACDxG,CAAA,IAAa,KAAM,IAAQ,KAC3BA,CAAA,IAAa,KAAM,KAAQ,MAEjCP,CAAA,CAAK+G,IAAA,CAAOxG,CAAA,IAAa,IAAK,KAAQ,OAExCP,CAAA,CAAK+G,IAAA,CAAkB,KAAZxG,CAAA,GAAoB,KAEnC;YAAA;UAjCa;UAoCf,KAAK2uC,OAAA,CAAQ,IACb,KAAK5J,WAAA,CAAY,GAAGtlC,CAAA,CAAK6B,MAAA,EAAQ,IACjC,KAAKuiC,EAAA,CAAGM,WAAA,CAAY,KAAKwmC,KAAA,IAASlrE,CAAA,CAAK6B,MAAA,GAC9BrB,CAAA,GAAI;UAAb,KAAK,IAAWQ,CAAA,GAAS,KAAKkqE,KAAA,EAAOjqE,CAAA,GAAQ,KAAKmjC,EAAA,CAAG4G,KAAA,IAASxqC,CAAA,GAAIR,CAAA,CAAK6B,MAAA,EAAQrB,CAAA,IAC7ES,CAAA,CAAMD,CAAA,MAAYhB,CAAA,CAAKQ,CAAA;UAEzB,OAAO,KAAKglC,SAAA,EACd;QAAA,GASAjlC,CAAA,CAAY0qE,OAAA,CAAQrmB,SAAA,CAAU/d,UAAA,GAAa,UAAS9mC,CAAA,EAAKC,CAAA;UACvD,OAAOO,CAAA,CAAYy7C,IAAA,CAAKxc,MAAA,CAAOz/B,CAAA,EAAKC,CAAA,CACtC;QAAA,GASAO,CAAA,CAAYihC,UAAA,GAAa,UAASzhC,CAAA;UAKhC,KAAKmtE,MAAA,GAASntE,CAAA,EAMd,KAAKotE,SAAA,GAAY,CACnB;QAAA,GAQA5sE,CAAA,CAAYihC,UAAA,CAAWlT,QAAA,GAAW,UAASvuB,CAAA;UACzC,OAAO,IAAIQ,CAAA,CAAYihC,UAAA,CAAW,IAAIhyB,UAAA,CAAWzP,CAAA,EACnD;QAAA,GAEAQ,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAU+mB,KAAA,GAAQ;UACvC,KAAKwB,SAAA,GAAY,CACnB;QAAA,GAOA5sE,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAU5Z,KAAA,GAAQ;UACvC,OAAO,KAAKkiC,MACd;QAAA,GAOA3sE,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAU14B,QAAA,GAAW;UAC1C,OAAO,KAAKihD,SACd;QAAA,GAOA5sE,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAUlgB,WAAA,GAAc,UAAS3kC,CAAA;UACtD,KAAKotE,SAAA,GAAYptE,CACnB;QAAA,GAOAQ,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAUgnB,QAAA,GAAW;UAC1C,OAAO,KAAKsB,MAAA,CAAOrrE,MACrB;QAAA,GAMAtB,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAUje,QAAA,GAAW,UAAS5mC,CAAA;UACnD,OAAO,KAAKutC,SAAA,CAAUvtC,CAAA,KAAW,MAAM,EACzC;QAAA,GAMAQ,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAUtX,SAAA,GAAY,UAASvtC,CAAA;UACpD,OAAO,KAAKmtE,MAAA,CAAOntE,CAAA,CACrB;QAAA,GAMAQ,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAUmoB,SAAA,GAAY,UAAShtE,CAAA;UACpD,OAAO,KAAKqtE,UAAA,CAAWrtE,CAAA,KAAW,MAAM,EAC1C;QAAA,GAMAQ,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAUwoB,UAAA,GAAa,UAASrtE,CAAA;UACrD,OAAO,KAAKmtE,MAAA,CAAOntE,CAAA,IAAU,KAAKmtE,MAAA,CAAOntE,CAAA,GAAS,MAAM,CAC1D;QAAA,GAMAQ,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAUpgB,SAAA,GAAY,UAASzkC,CAAA;UACpD,OAAO,KAAKmtE,MAAA,CAAOntE,CAAA,IAAU,KAAKmtE,MAAA,CAAOntE,CAAA,GAAS,MAAM,IAAI,KAAKmtE,MAAA,CAAOntE,CAAA,GAAS,MAAM,KAAK,KAAKmtE,MAAA,CAAOntE,CAAA,GAAS,MAAM,EACzH;QAAA,GAMAQ,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAU3b,UAAA,GAAa,UAASlpC,CAAA;UACrD,OAAO,KAAKykC,SAAA,CAAUzkC,CAAA,MAAY,CACpC;QAAA,GAMAQ,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAUhe,SAAA,GAAY,UAAS7mC,CAAA;UACpD,OAAO,IAAIQ,CAAA,CAAYy7C,IAAA,CAAK,KAAKxX,SAAA,CAAUzkC,CAAA,GAAS,KAAKykC,SAAA,CAAUzkC,CAAA,GAAS,GAC9E;QAAA,GAMAQ,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAUzP,UAAA,GAAa,UAASp1C,CAAA;UACrD,OAAO,IAAIQ,CAAA,CAAYy7C,IAAA,CAAK,KAAK/S,UAAA,CAAWlpC,CAAA,GAAS,KAAKkpC,UAAA,CAAWlpC,CAAA,GAAS,GAChF;QAAA,GAMAQ,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAUvU,WAAA,GAAc,UAAStwC,CAAA;UAEtD,OADAQ,CAAA,CAAYklD,KAAA,CAAM,KAAK,KAAKjhB,SAAA,CAAUzkC,CAAA,GAC/BQ,CAAA,CAAYuqE,OAAA,CAAQ,EAC7B;QAAA,GAMAvqE,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAUyoB,WAAA,GAAc,UAASttE,CAAA;UAGtD,OAFAQ,CAAA,CAAYklD,KAAA,CAAMllD,CAAA,CAAY6O,cAAA,GAAiB,IAAI,KAAK,KAAKo1B,SAAA,CAAUzkC,CAAA,GACvEQ,CAAA,CAAYklD,KAAA,CAAMllD,CAAA,CAAY6O,cAAA,GAAiB,IAAI,KAAK,KAAKo1B,SAAA,CAAUzkC,CAAA,GAAS,IACzEQ,CAAA,CAAYwqE,OAAA,CAAQ,EAC7B;QAAA,GAMAxqE,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAUsnB,SAAA,GAAY,UAASnsE,CAAA,EAAQC,CAAA;UAC5D,KAAKktE,MAAA,CAAOntE,CAAA,IAA+BC,CAC7C;QAAA,GAMAO,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAU0oB,UAAA,GAAa,UAASvtE,CAAA,EAAQC,CAAA;UAC7D,KAAKktE,MAAA,CAAOntE,CAAA,IAAUC,CACxB;QAAA,GAMAO,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAUunB,UAAA,GAAa,UAASpsE,CAAA,EAAQC,CAAA;UAC7D,KAAKktE,MAAA,CAAOntE,CAAA,IAAUC,CAAA,EACtB,KAAKktE,MAAA,CAAOntE,CAAA,GAAS,KAAKC,CAAA,IAAS,CACrC;QAAA,GAMAO,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAU2oB,WAAA,GAAc,UAASxtE,CAAA,EAAQC,CAAA;UAC5D,KAAKktE,MAAA,CAAOntE,CAAA,IAAUC,CAAA,EACtB,KAAKktE,MAAA,CAAOntE,CAAA,GAAS,KAAKC,CAAA,IAAS,CACvC;QAAA,GAMAO,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAUtb,UAAA,GAAa,UAASvpC,CAAA,EAAQC,CAAA;UAC7D,KAAKktE,MAAA,CAAOntE,CAAA,IAAUC,CAAA,EACtB,KAAKktE,MAAA,CAAOntE,CAAA,GAAS,KAAKC,CAAA,IAAS,GACnC,KAAKktE,MAAA,CAAOntE,CAAA,GAAS,KAAKC,CAAA,IAAS,IACnC,KAAKktE,MAAA,CAAOntE,CAAA,GAAS,KAAKC,CAAA,IAAS,EACrC;QAAA,GAMAO,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAU4oB,WAAA,GAAc,UAASztE,CAAA,EAAQC,CAAA;UAC5D,KAAKktE,MAAA,CAAOntE,CAAA,IAAUC,CAAA,EACtB,KAAKktE,MAAA,CAAOntE,CAAA,GAAS,KAAKC,CAAA,IAAS,GACnC,KAAKktE,MAAA,CAAOntE,CAAA,GAAS,KAAKC,CAAA,IAAS,IACnC,KAAKktE,MAAA,CAAOntE,CAAA,GAAS,KAAKC,CAAA,IAAS,EACvC;QAAA,GAMAO,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAUwnB,UAAA,GAAa,UAASrsE,CAAA,EAAQC,CAAA;UAC7D,KAAKspC,UAAA,CAAWvpC,CAAA,EAAQC,CAAA,CAAMk8C,GAAA,GAC9B,KAAK5S,UAAA,CAAWvpC,CAAA,GAAS,GAAGC,CAAA,CAAMm8C,IAAA,CACpC;QAAA,GAMA57C,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAU6oB,WAAA,GAAc,UAAS1tE,CAAA,EAAQC,CAAA;UAC5D,KAAKwtE,WAAA,CAAYztE,CAAA,EAAQC,CAAA,CAAMk8C,GAAA,GAC/B,KAAKsxB,WAAA,CAAYztE,CAAA,GAAS,GAAGC,CAAA,CAAMm8C,IAAA,CACvC;QAAA,GAMA57C,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAUynB,YAAA,GAAe,UAAStsE,CAAA,EAAQC,CAAA;UAC/DO,CAAA,CAAYuqE,OAAA,CAAQ,KAAK9qE,CAAA,EACzB,KAAKspC,UAAA,CAAWvpC,CAAA,EAAQQ,CAAA,CAAYklD,KAAA,CAAM,GAC5C;QAAA,GAMAllD,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAU0nB,YAAA,GAAe,UAASvsE,CAAA,EAAQC,CAAA;UAC/DO,CAAA,CAAYwqE,OAAA,CAAQ,KAAK/qE,CAAA,EACzB,KAAKspC,UAAA,CAAWvpC,CAAA,EAAQQ,CAAA,CAAYklD,KAAA,CAAMllD,CAAA,CAAY6O,cAAA,GAAiB,IAAI,KAC3E,KAAKk6B,UAAA,CAAWvpC,CAAA,GAAS,GAAGQ,CAAA,CAAYklD,KAAA,CAAMllD,CAAA,CAAY6O,cAAA,GAAiB,IAAI,GACjF;QAAA,GAQA7O,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAU8oB,mBAAA,GAAsB;UACrD,IAAI,KAAKR,MAAA,CAAOrrE,MAAA,GAAS,KAAKsrE,SAAA,GAAY5sE,CAAA,CAAYkqE,UAAA,GAClDlqE,CAAA,CAAYmqE,sBAAA,EACd,MAAM,IAAItmE,KAAA,CACN;UAGN,KADA,IAAIrE,CAAA,GAAS,IACJC,CAAA,GAAI,GAAGA,CAAA,GAAIO,CAAA,CAAYmqE,sBAAA,EAAwB1qE,CAAA,IACtDD,CAAA,IAAUomD,MAAA,CAAOgJ,YAAA,CACb,KAAKxoB,QAAA,CAAS,KAAKwmC,SAAA,GAAY5sE,CAAA,CAAYkqE,UAAA,GAAazqE,CAAA;UAE9D,OAAOD,CACT;QAAA,GAUAQ,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAUhgB,QAAA,GAAW,UAAS7kC,CAAA,EAAQC,CAAA;UAC3D,IAAIQ,CAAA,GAAST,CAAA,GAAS,KAAKykC,SAAA,CAAUzkC,CAAA;UACrC,OAAOC,CAAA,GAAgB,KAAK+sE,SAAA,CAAUvsE,CAAA,IAAU,KAAKusE,SAAA,CAAUvsE,CAAA,GAASR,CAAA,IAAiB,CAC3F;QAAA,GASAO,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAUrX,OAAA,GAAU,UAASxtC,CAAA,EAAGC,CAAA;UAGrD,OAFAD,CAAA,CAAEskC,MAAA,GAASrkC,CAAA,GAAS,KAAKwkC,SAAA,CAAUxkC,CAAA,GACnCD,CAAA,CAAEqkC,EAAA,GAAK,MACArkC,CACT;QAAA,GAeAQ,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAU1e,QAAA,GAAW,UAASnmC,CAAA,EAAQC,CAAA;UAC3DD,CAAA,IAAU,KAAKykC,SAAA,CAAUzkC,CAAA;UAEzB,IAAIS,CAAA,GAAS,KAAKgkC,SAAA,CAAUzkC,CAAA;YACxBU,CAAA,GAAS;YACTO,CAAA,GAAI;UAIR,IAFAjB,CAAA,IAAUQ,CAAA,CAAYkqE,UAAA,EAElBzqE,CAAA,KAAiBO,CAAA,CAAYoqE,QAAA,CAASC,UAAA,EACxC,OAAO,KAAKsC,MAAA,CAAOt4D,QAAA,CAAS7U,CAAA,EAAQA,CAAA,GAASS,CAAA;UAG/C,OAAOQ,CAAA,GAAIR,CAAA,GAAQ;YACjB,IAAIS,CAAA;cAGAoC,CAAA,GAAI,KAAKiqC,SAAA,CAAUvtC,CAAA,GAASiB,CAAA;YAChC,IAAIqC,CAAA,GAAI,KACNpC,CAAA,GAAYoC,CAAA,MACP;cACL,IAAII,CAAA,GAAI,KAAK6pC,SAAA,CAAUvtC,CAAA,GAASiB,CAAA;cAChC,IAAIqC,CAAA,GAAI,KACNpC,CAAA,IACQ,KAAJoC,CAAA,KAAa,IACV,KAAJI,CAAA,MACE;gBACL,IAAI+G,CAAA,GAAI,KAAK8iC,SAAA,CAAUvtC,CAAA,GAASiB,CAAA;gBAE9BC,CAAA,GADEoC,CAAA,GAAI,OAEE,KAAJA,CAAA,KAAa,MACT,KAAJI,CAAA,KAAa,IACV,KAAJ+G,CAAA,IAIK,IAAJnH,CAAA,KAAa,MACT,KAAJI,CAAA,KAAa,MACT,KAAJ+G,CAAA,KAAa,IACV,KALC,KAAK8iC,SAAA,CAAUvtC,CAAA,GAASiB,CAAA,GAOpC;cAAA;YACF;YAGIC,CAAA,GAAY,QACdR,CAAA,IAAU0lD,MAAA,CAAOgJ,YAAA,CAAaluD,CAAA,KAE9BA,CAAA,IAAa,OACbR,CAAA,IAAU0lD,MAAA,CAAOgJ,YAAA,CACK,SAAnBluD,CAAA,IAAa,KACkB,SAAnB,OAAZA,CAAA,GAEP;UAAA;UAEA,OAAOR,CACT;QAAA,GAOAF,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAU9f,UAAA,GAAa,UAAS/kC,CAAA;UACrD,OAAOA,CAAA,GAAS,KAAKykC,SAAA,CAAUzkC,CAAA,CACjC;QAAA,GAQAQ,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAU7f,QAAA,GAAW,UAAShlC,CAAA;UACnD,OAAOA,CAAA,GAAS,KAAKykC,SAAA,CAAUzkC,CAAA,IAAUQ,CAAA,CAAYkqE,UACvD;QAAA,GAQAlqE,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAU5f,YAAA,GAAe,UAASjlC,CAAA;UACvD,OAAO,KAAKykC,SAAA,CAAUzkC,CAAA,GAAS,KAAKykC,SAAA,CAAUzkC,CAAA,EAChD;QAAA,GAMAQ,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAUnN,gBAAA,GAAmB,UAAS13C,CAAA;UAC3D,IAAIA,CAAA,CAAM8B,MAAA,IAAUtB,CAAA,CAAYmqE,sBAAA,EAC9B,MAAM,IAAItmE,KAAA,CAAM,iDACA7D,CAAA,CAAYmqE,sBAAA;UAE9B,KAAK,IAAI1qE,CAAA,GAAI,GAAGA,CAAA,GAAIO,CAAA,CAAYmqE,sBAAA,EAAwB1qE,CAAA,IACtD,IAAID,CAAA,CAAM+yD,UAAA,CAAW9yD,CAAA,KAAM,KAAK2mC,QAAA,CAAS,KAAKwmC,SAAA,GAAY5sE,CAAA,CAAYkqE,UAAA,GAAazqE,CAAA,GACjF,QAAO;UAGX,QAAO,CACT;QAAA,GASAO,CAAA,CAAYihC,UAAA,CAAWojB,SAAA,CAAU/d,UAAA,GAAa,UAAS9mC,CAAA,EAAKC,CAAA;UAC1D,OAAOO,CAAA,CAAYy7C,IAAA,CAAKxc,MAAA,CAAOz/B,CAAA,EAAKC,CAAA,CACtC;QAAA,C;;;ICnuCI2tE,wBAAA,GAA2B,CAAC;EAGhC,SAASC,oBAAoB7tE,CAAA;IAE5B,IAAIC,CAAA,GAAe2tE,wBAAA,CAAyB5tE,CAAA;IAC5C,SAAqB,MAAjBC,CAAA,EACH,OAAOA,CAAA,CAAaC,OAAA;IAGrB,IAAIO,CAAA,GAASmtE,wBAAA,CAAyB5tE,CAAA,IAAY;MAGjDE,OAAA,EAAS,CAAC;IAAA;IAOX,OAHA4tE,mBAAA,CAAoB9tE,CAAA,EAAUolB,IAAA,CAAK3kB,CAAA,CAAOP,OAAA,EAASO,CAAA,EAAQA,CAAA,CAAOP,OAAA,EAAS2tE,mBAAA,GAGpEptE,CAAA,CAAOP,OACf;EAAA;ECrBA2tE,mBAAA,CAAoBptE,CAAA,GAAKT,CAAA;IACxB,IAAIC,CAAA,GAASD,CAAA,IAAUA,CAAA,CAAOy+D,UAAA,GAC7B,MAAOz+D,CAAA,CAAiBu6C,OAAA,GACxB,MAAMv6C,CAAA;IAEP,OADA6tE,mBAAA,CAAoBtiE,CAAA,CAAEtL,CAAA,EAAQ;MAAEiB,CAAA,EAAGjB;IAAA,IAC5BA,CAAM;EAAA,GCLd4tE,mBAAA,CAAoBtiE,CAAA,GAAI,CAACvL,CAAA,EAASC,CAAA;IACjC,KAAI,IAAIQ,CAAA,IAAOR,CAAA,EACX4tE,mBAAA,CAAoBntE,CAAA,CAAET,CAAA,EAAYQ,CAAA,MAASotE,mBAAA,CAAoBntE,CAAA,CAAEV,CAAA,EAASS,CAAA,KAC5EoC,MAAA,CAAO8lD,cAAA,CAAe3oD,CAAA,EAASS,CAAA,EAAK;MAAEohE,UAAA,GAAY;MAAMr9D,GAAA,EAAKvE,CAAA,CAAWQ,CAAA;IAAA,EAE1E;EAAA,GCNDotE,mBAAA,CAAoBntE,CAAA,GAAI,CAACV,CAAA,EAAKC,CAAA,KAAU4C,MAAA,CAAOgiD,SAAA,CAAU1/B,cAAA,CAAeC,IAAA,CAAKplB,CAAA,EAAKC,CAAA,GCClF4tE,mBAAA,CAAoBrtE,CAAA,GAAKR,CAAA;IACH,sBAAX+tE,MAAA,IAA0BA,MAAA,CAAOC,WAAA,IAC1CnrE,MAAA,CAAO8lD,cAAA,CAAe3oD,CAAA,EAAS+tE,MAAA,CAAOC,WAAA,EAAa;MAAE7pD,KAAA,EAAO;IAAA,IAE7DthB,MAAA,CAAO8lD,cAAA,CAAe3oD,CAAA,EAAS,cAAc;MAAEmkB,KAAA,GAAO;IAAA,EAAO;EAAA;ECF9D,IAAI8pD,mBAAA,GAAsBJ,mBAAA,CAAoB"},"metadata":{},"sourceType":"script","externalDependencies":[]}