{
  "version": 3,
  "sources": ["../src/index.ts", "../src/utils.ts", "../src/codecs.ts", "../src/url.ts", "../src/onnx.ts", "../src/resource.ts", "../src/feature-detect.js", "../src/schema.ts", "../package.json", "../src/inference.ts"],
  "sourcesContent": ["export default removeBackground;\nexport { preload, removeBackground, removeForeground, segmentForeground };\nexport type { Config, ImageSource };\n\nimport { memoize } from 'lodash';\nimport ndarray from 'ndarray';\nimport { initInference, runInference } from './inference';\nimport { preload as preloadResources } from './resource';\nimport { Config, validateConfig } from './schema';\nimport * as utils from './utils';\nimport { ImageSource } from './utils';\n\nconst init = memoize(initInference, (config) => JSON.stringify(config));\n\nasync function preload(configuration?: Config): Promise<void> {\n  const config = validateConfig(configuration);\n  await preloadResources(config);\n  return;\n}\n\n/**\n * Removes the background from an image.\n *\n * @param image - The image to remove the background from.\n * @param configuration - Optional configuration for the background removal process.\n * @returns A Promise that resolves to the resulting image with the background removed.\n */\nasync function removeBackground(\n  image: ImageSource,\n  configuration?: Config\n): Promise<Blob> {\n  const { config, session } = await init(configuration);\n\n  const imageTensor = await utils.imageSourceToImageData(image, config);\n  const [width, height, channels] = imageTensor.shape;\n\n  const alphamask = await runInference(imageTensor, config, session);\n  const stride = width * height;\n\n  const outImageTensor = imageTensor;\n  for (let i = 0; i < stride; i += 1) {\n    outImageTensor.data[4 * i + 3] = alphamask.data[i];\n  }\n\n  const outImage = await utils.imageEncode(\n    outImageTensor,\n    config.output.quality,\n    config.output.format\n  );\n\n  return outImage;\n}\n\n/**\n * Removes the foreground from an image.\n *\n * @param image - The image to remove the foreground from.\n * @param configuration - Optional configuration for the foreground removal process.\n * @returns A Promise that resolves to the resulting image with the foreground removed.\n */\nasync function removeForeground(\n  image: ImageSource,\n  configuration?: Config\n): Promise<Blob> {\n  const { config, session } = await init(configuration);\n\n  const imageTensor = await utils.imageSourceToImageData(image, config);\n  const [width, height, channels] = imageTensor.shape;\n\n  const alphamask = await runInference(imageTensor, config, session);\n  const stride = width * height;\n  const outImageTensor = imageTensor;\n  for (let i = 0; i < stride; i += 1) {\n    outImageTensor.data[4 * i + 3] = 255 - alphamask.data[i];\n  }\n\n  const outImage = await utils.imageEncode(\n    outImageTensor,\n    config.output.quality,\n    config.output.format\n  );\n\n  return outImage;\n}\n\n/**\n * Segments the foreground of an image using a given configuration.\n *\n * @param image - The image source to segment.\n * @param configuration - The optional configuration for the segmentation.\n * @returns A Promise that resolves to the segmented foreground as a Blob.\n */\nasync function segmentForeground(\n  image: ImageSource,\n  configuration?: Config\n): Promise<Blob> {\n  const { config, session } = await init(configuration);\n\n  const imageTensor = await utils.imageSourceToImageData(image, config);\n  const [height, width, channels] = imageTensor.shape;\n\n  const alphamask = await runInference(imageTensor, config, session);\n  const stride = width * height;\n\n  if (config.output.format === 'image/x-alpha8') {\n    const outImage = await utils.imageEncode(\n      alphamask,\n      config.output.quality,\n      config.output.format\n    );\n    return outImage;\n  } else {\n    const outImageTensor = ndarray(new Uint8Array(channels * stride), [\n      height,\n      width,\n      channels\n    ]);\n    for (let i = 0; i < stride; i += 1) {\n      const index = 4 * i + 3;\n      outImageTensor.data[index] = alphamask.data[i]; //Red\n      outImageTensor.data[index + 1] = alphamask.data[i]; //Green\n      outImageTensor.data[index + 2] = alphamask.data[i]; // Blue\n      outImageTensor.data[index + 3] = 255;\n    }\n\n    const outImage = await utils.imageEncode(\n      outImageTensor,\n      config.output.quality,\n      config.output.format\n    );\n\n    return outImage;\n  }\n}\n", "export {\n  imageDecode,\n  imageEncode,\n  tensorResizeBilinear,\n  tensorHWCtoBCHW,\n  imageBitmapToImageData,\n  calculateProportionalSize,\n  imageSourceToImageData,\n  ImageSource\n};\n\nimport ndarray, { NdArray } from 'ndarray';\nimport { imageDecode, imageEncode } from './codecs';\nimport { ensureAbsoluteURI } from './url';\nimport { Config } from './schema';\n\ntype ImageSource = ImageData | ArrayBuffer | Uint8Array | Blob | URL | string;\n\nfunction imageBitmapToImageData(imageBitmap: ImageBitmap): ImageData {\n  var canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);\n  var ctx = canvas.getContext('2d')!;\n  ctx.drawImage(imageBitmap, 0, 0);\n  return ctx.getImageData(0, 0, canvas.width, canvas.height);\n}\n\nfunction tensorResizeBilinear(\n  imageTensor: NdArray<Uint8Array>,\n  newWidth: number,\n  newHeight: number\n): NdArray<Uint8Array> {\n  const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;\n  // Calculate the scaling factors\n  const scaleX = srcWidth / newWidth;\n  const scaleY = srcHeight / newHeight;\n\n  // Create a new NdArray to store the resized image\n  const resizedImageData = ndarray(\n    new Uint8Array(srcChannels * newWidth * newHeight),\n    [newHeight, newWidth, srcChannels]\n  );\n  // Perform interpolation to fill the resized NdArray\n  for (let y = 0; y < newHeight; y++) {\n    for (let x = 0; x < newWidth; x++) {\n      const srcX = x * scaleX;\n      const srcY = y * scaleY;\n      const x1 = Math.max(Math.floor(srcX), 0);\n      const x2 = Math.min(Math.ceil(srcX), srcWidth - 1);\n      const y1 = Math.max(Math.floor(srcY), 0);\n      const y2 = Math.min(Math.ceil(srcY), srcHeight - 1);\n\n      const dx = srcX - x1;\n      const dy = srcY - y1;\n\n      for (let c = 0; c < srcChannels; c++) {\n        const p1 = imageTensor.get(y1, x1, c);\n        const p2 = imageTensor.get(y1, x2, c);\n        const p3 = imageTensor.get(y2, x1, c);\n        const p4 = imageTensor.get(y2, x2, c);\n\n        // Perform bilinear interpolation\n        const interpolatedValue =\n          (1 - dx) * (1 - dy) * p1 +\n          dx * (1 - dy) * p2 +\n          (1 - dx) * dy * p3 +\n          dx * dy * p4;\n\n        resizedImageData.set(y, x, c, Math.round(interpolatedValue));\n      }\n    }\n  }\n\n  return resizedImageData;\n}\n\nfunction tensorHWCtoBCHW(\n  imageTensor: NdArray<Uint8Array>,\n  mean: number[] = [128, 128, 128],\n  std: number[] = [256, 256, 256]\n): NdArray<Float32Array> {\n  var imageBufferData = imageTensor.data;\n  const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;\n  const stride = srcHeight * srcWidth;\n  const float32Data = new Float32Array(3 * stride);\n\n  // r_0, r_1, .... g_0,g_1, .... b_0\n  for (let i = 0, j = 0; i < imageBufferData.length; i += 4, j += 1) {\n    float32Data[j] = (imageBufferData[i] - mean[0]) / std[0];\n    float32Data[j + stride] = (imageBufferData[i + 1] - mean[1]) / std[1];\n    float32Data[j + stride + stride] =\n      (imageBufferData[i + 2] - mean[2]) / std[2];\n  }\n\n  return ndarray(float32Data, [1, 3, srcHeight, srcWidth]);\n}\n\nfunction calculateProportionalSize(\n  originalWidth: number,\n  originalHeight: number,\n  maxWidth: number,\n  maxHeight: number\n): [number, number] {\n  const widthRatio = maxWidth / originalWidth;\n  const heightRatio = maxHeight / originalHeight;\n  const scalingFactor = Math.min(widthRatio, heightRatio);\n  const newWidth = Math.floor(originalWidth * scalingFactor);\n  const newHeight = Math.floor(originalHeight * scalingFactor);\n  return [newWidth, newHeight];\n}\n\nasync function imageSourceToImageData(\n  image: ImageSource,\n  config: Config\n): Promise<NdArray<Uint8Array>> {\n  if (typeof image === 'string') {\n    image = ensureAbsoluteURI(image, config.publicPath);\n    image = new URL(image);\n  }\n  if (image instanceof URL) {\n    const response = await fetch(image, {});\n    image = await response.blob();\n  }\n  if (image instanceof ArrayBuffer || ArrayBuffer.isView(image)) {\n    image = new Blob([image]);\n  }\n  if (image instanceof Blob) {\n    image = await imageDecode(image);\n  }\n\n  return image as NdArray<Uint8Array>;\n}\nexport function convertFloat32ToUint8(\n  float32Array: NdArray<Float32Array>\n): NdArray<Uint8Array> {\n  const uint8Array = new Uint8Array(float32Array.data.length);\n  for (let i = 0; i < float32Array.data.length; i++) {\n    uint8Array[i] = float32Array.data[i] * 255;\n  }\n  return ndarray(uint8Array, float32Array.shape);\n}\n", "export { imageEncode, imageDecode };\nimport { imageBitmapToImageData } from './utils';\nimport ndarray, { NdArray } from 'ndarray';\n\nasync function imageDecode(blob: Blob): Promise<NdArray<Uint8Array>> {\n  const imageBitmap = await createImageBitmap(blob);\n  const imageData = imageBitmapToImageData(imageBitmap);\n  return ndarray(imageData.data, [imageData.height, imageData.width, 4]);\n}\n\nasync function imageEncode(\n  imageTensor: NdArray<Uint8Array>,\n  quality: number = 0.8,\n  format: string = 'image/png'\n): Promise<Blob> {\n  const [height, width, channels] = imageTensor.shape;\n\n  switch (format) {\n    case 'image/x-r8':\n      return new Blob([imageTensor.data], { type: 'image/x-alpha8' });\n    case 'image/x-rgba8':\n      return new Blob([imageTensor.data], { type: 'image/x-rgba8' });\n    case `image/png`:\n    case `image/jpeg`:\n    case `image/webp`:\n      const imageData = new ImageData(\n        new Uint8ClampedArray(imageTensor.data),\n        width,\n        height\n      );\n      var canvas = new OffscreenCanvas(imageData.width, imageData.height);\n      var ctx = canvas.getContext('2d')!;\n      ctx.putImageData(imageData, 0, 0);\n      return canvas.convertToBlob({ quality, type: format });\n    default:\n      throw new Error(`Invalid format: ${format}`);\n  }\n}\n", "export { isAbsoluteURI, ensureAbsoluteURI };\n\nfunction isAbsoluteURI(url: string): boolean {\n  const regExp = new RegExp('^(?:[a-z+]+:)?//', 'i');\n  return regExp.test(url); // true - regular http absolute URL\n}\n\nconst isNode = typeof window === 'undefined';\nconst isBrowser = typeof window !== 'undefined';\n\nfunction ensureAbsoluteURI(url: string, baseUrl: string): string {\n  if (isAbsoluteURI(url)) {\n    return url;\n  } else {\n    return new URL(url, baseUrl).href;\n  }\n}\n", "export { createOnnxSession, runOnnxSession };\n\nimport ndarray, { NdArray } from 'ndarray';\nimport * as ort from 'onnxruntime-web';\nimport { loadAsUrl } from './resource';\nimport { simd, threads } from './feature-detect';\nimport { Config } from './schema';\n\nasync function createOnnxSession(model: any, config: Config) {\n  const capabilities = {\n    simd: await simd(),\n    threads: await threads(),\n    numThreads: navigator.hardwareConcurrency ?? 4,\n    // @ts-ignore\n    webgpu: navigator.gpu !== undefined\n  };\n  if (config.debug) {\n    console.debug('Capabilities:', capabilities);\n    ort.env.debug = true;\n    ort.env.logLevel = 'verbose';\n  }\n\n  ort.env.wasm.numThreads = capabilities.numThreads;\n  ort.env.wasm.simd = capabilities.simd;\n  ort.env.wasm.proxy = config.proxyToWorker;\n\n  ort.env.wasm.wasmPaths = {\n    'ort-wasm-simd-threaded.wasm':\n      capabilities.simd && capabilities.threads\n        ? await loadAsUrl(\n            '/onnxruntime-web/ort-wasm-simd-threaded.wasm',\n            config\n          )\n        : undefined,\n    'ort-wasm-simd.wasm':\n      capabilities.simd && !capabilities.threads\n        ? await loadAsUrl('/onnxruntime-web/ort-wasm-simd.wasm', config)\n        : undefined,\n    'ort-wasm-threaded.wasm':\n      !capabilities.simd && capabilities.threads\n        ? await loadAsUrl('/onnxruntime-web/ort-wasm-threaded.wasm', config)\n        : undefined,\n    'ort-wasm.wasm':\n      !capabilities.simd && !capabilities.threads\n        ? await loadAsUrl('/onnxruntime-web/ort-wasm.wasm', config)\n        : undefined\n  };\n\n  if (config.debug) {\n    console.debug('ort.env.wasm:', ort.env.wasm);\n  }\n\n  const ort_config: ort.InferenceSession.SessionOptions = {\n    executionProviders: ['wasm'],\n    graphOptimizationLevel: 'all',\n    executionMode: 'parallel',\n    enableCpuMemArena: true\n  };\n\n  const session = await ort.InferenceSession.create(model, ort_config).catch(\n    (e: any) => {\n      throw new Error(\n        `Failed to create session: ${e}. Please check if the publicPath is set correctly.`\n      );\n    }\n  );\n  return session;\n}\n\nasync function runOnnxSession(\n  session: any,\n  inputs: [string, NdArray<Float32Array>][],\n  outputs: [string]\n) {\n  const feeds: Record<string, any> = {};\n  for (const [key, tensor] of inputs) {\n    feeds[key] = new ort.Tensor(\n      'float32',\n      new Float32Array(tensor.data),\n      tensor.shape\n    );\n  }\n  const outputData = await session.run(feeds, {});\n  const outputKVPairs: NdArray<Float32Array>[] = [];\n\n  for (const key of outputs) {\n    const output: ort.Tensor = outputData[key];\n    const shape: Number[] = output.dims as number[];\n    const data: Float32Array = output.data as Float32Array;\n    const tensor = ndarray(data, shape);\n    outputKVPairs.push(tensor);\n  }\n\n  return outputKVPairs;\n}\n", "export { loadAsBlob, loadAsUrl, preload };\n\nimport { Config } from './schema';\n\nasync function preload(config: Config): Promise<void> {\n  // load resource metadata\n  const resourceUrl = new URL('resources.json', config.publicPath);\n  const resourceResponse = await fetch(resourceUrl);\n  if (!resourceResponse.ok) {\n    throw new Error(\n      `Resource metadata not found. Ensure that the config.publicPath is configured correctly.`\n    );\n  }\n  const resourceMap = await resourceResponse.json();\n  const keys = Object.keys(resourceMap);\n\n  await Promise.all(\n    keys.map(async (key) => {\n      return loadAsBlob(key, config);\n    })\n  );\n}\n\nasync function loadAsUrl(url: string, config: Config): Promise<string> {\n  return URL.createObjectURL(await loadAsBlob(url, config));\n}\n\nasync function loadAsBlob(key: string, config: Config) {\n  // load resource metadata\n  const resourceUrl = new URL('resources.json', config.publicPath);\n  const resourceResponse = await fetch(resourceUrl);\n  if (!resourceResponse.ok) {\n    throw new Error(\n      `Resource metadata not found. Ensure that the config.publicPath is configured correctly.`\n    );\n  }\n  const resourceMap = await resourceResponse.json();\n  const entry = resourceMap[key];\n\n  if (!entry) {\n    throw new Error(\n      `Resource ${key} not found. Ensure that the config.publicPath is configured correctly.`\n    );\n  }\n\n  const chunks = entry.chunks; // list of entries\n\n  let downloadedSize = 0;\n  const responses = chunks.map(async (chunk) => {\n    const url = config.publicPath\n      ? new URL(chunk.hash, config.publicPath).toString()\n      : chunk.hash;\n    const response = await fetch(url, config.fetchArgs);\n    const blob = await response.blob();\n\n    if (chunk.size !== blob.size) {\n      throw new Error(\n        `Failed to fetch ${key} with size ${chunk.size} but got ${blob.size}`\n      );\n    }\n\n    if (config.progress) {\n      downloadedSize += chunk.size;\n      config.progress(`fetch:${key}`, downloadedSize, entry.size);\n    }\n    return blob;\n  });\n\n  // we could create a new buffer here and use the chunk entries and combine the file instead\n\n  const allChunkData = await Promise.all(responses);\n\n  const data = new Blob(allChunkData, { type: entry.mime });\n  if (data.size !== entry.size) {\n    throw new Error(\n      `Failed to fetch ${key} with size ${entry.size} but got ${data.size}`\n    );\n  }\n  return data;\n}\n", "export const bigInt = () =>\n    (async (e) => {\n      try {\n        return (\n          (await WebAssembly.instantiate(e)).instance.exports.b(BigInt(0)) ===\n          BigInt(0)\n        );\n      } catch (e) {\n        return !1;\n      }\n    })(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 1, 126, 1, 126, 3, 2, 1, 0, 7,\n        5, 1, 1, 98, 0, 0, 10, 6, 1, 4, 0, 32, 0, 11\n      ])\n    ),\n  bulkMemory = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 3, 1, 0,\n        1, 10, 14, 1, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11\n      ])\n    ),\n  exceptions = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 8, 1, 6,\n        0, 6, 64, 25, 11, 11\n      ])\n    ),\n  extendedConst = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 5, 3, 1, 0, 1, 11, 9, 1, 0, 65, 1, 65, 2,\n        106, 11, 0\n      ])\n    ),\n  gc = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 10, 2, 95, 1, 125, 0, 96, 0, 1, 107, 0,\n        3, 2, 1, 1, 10, 12, 1, 10, 0, 67, 0, 0, 0, 0, 251, 7, 0, 11\n      ])\n    ),\n  memory64 = async () =>\n    WebAssembly.validate(\n      new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 5, 3, 1, 4, 1])\n    ),\n  multiValue = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 0, 2, 127, 127, 3, 2, 1, 0,\n        10, 8, 1, 6, 0, 65, 0, 65, 0, 11\n      ])\n    ),\n  mutableGlobals = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 2, 8, 1, 1, 97, 1, 98, 3, 127, 1, 6, 6, 1,\n        127, 1, 65, 0, 11, 7, 5, 1, 1, 97, 3, 1\n      ])\n    ),\n  referenceTypes = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 7, 1, 5,\n        0, 208, 112, 26, 11\n      ])\n    ),\n  relaxedSimd = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 15,\n        1, 13, 0, 65, 1, 253, 15, 65, 2, 253, 15, 253, 128, 2, 11\n      ])\n    ),\n  saturatedFloatToInt = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 12, 1,\n        10, 0, 67, 0, 0, 0, 0, 252, 0, 26, 11\n      ])\n    ),\n  signExtensions = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 8, 1, 6,\n        0, 65, 0, 192, 26, 11\n      ])\n    ),\n  simd = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10,\n        1, 8, 0, 65, 0, 253, 15, 253, 98, 11\n      ])\n    ),\n  streamingCompilation = () =>\n    (async () => 'compileStreaming' in WebAssembly)(),\n  tailCall = async () =>\n    WebAssembly.validate(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 6, 1, 4,\n        0, 18, 0, 11\n      ])\n    ),\n  threads = () =>\n    (async (e) => {\n      try {\n        return (\n          'undefined' != typeof MessageChannel &&\n            new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),\n          WebAssembly.validate(e)\n        );\n      } catch (e) {\n        return !1;\n      }\n    })(\n      new Uint8Array([\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3,\n        1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11\n      ])\n    );\n", "export { Config, ConfigSchema, validateConfig };\n\nimport { z } from 'zod';\n\nimport pkg from '../package.json';\n\nconst ConfigSchema = z\n  .object({\n    publicPath: z\n      .string()\n      .optional()\n      .describe('The public path to the wasm files and the onnx model.')\n      .default('https://unpkg.com/${PACKAGE_NAME}@${PACKAGE_VERSION}/dist/')\n      .transform((val) => {\n        return val\n          .replace('${PACKAGE_NAME}', pkg.name)\n          .replace('${PACKAGE_VERSION}', pkg.version);\n      }),\n    debug: z\n      .boolean()\n      .default(false)\n      .describe('Whether to enable debug logging.'),\n    proxyToWorker: z\n      .boolean()\n      .default(true)\n      .describe('Whether to proxy inference to a web worker.'),\n    fetchArgs: z\n      .any()\n      .default({})\n      .describe('Arguments to pass to fetch when loading the model.'),\n    progress: z\n      .function()\n      .args(z.string(), z.number(), z.number())\n      .returns(z.void())\n      .describe('Progress callback.')\n      .optional(),\n    model: z.enum(['small', 'medium']).default('medium'),\n    output: z\n      .object({\n        format: z\n          .enum([\n            'image/png',\n            'image/jpeg',\n            'image/webp',\n            'image/x-rgba8',\n            'image/x-alpha8'\n          ])\n          .default('image/png'),\n        quality: z.number().default(0.8)\n      })\n      .default({})\n  })\n  .default({});\n\ntype Config = z.infer<typeof ConfigSchema>;\n\nfunction validateConfig(configuration?: Config): Config {\n  const config = ConfigSchema.parse(configuration ?? {});\n  if (config.debug) console.log('Config:', config);\n  if (config.debug && !config.progress) {\n    config.progress =\n      config.progress ??\n      ((key, current, total) => {\n        console.debug(`Downloading ${key}: ${current} of ${total}`);\n      });\n\n    if (!crossOriginIsolated) {\n      console.debug(\n        'Cross-Origin-Isolated is not enabled. Performance will be degraded. Please see  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer.'\n      );\n    }\n  }\n  return config;\n}\n", "{\n  \"name\": \"@imgly/background-removal\",\n  \"version\": \"1.3.0\",\n  \"description\": \"Background Removal in the Browser\",\n  \"keywords\": [\n    \"background-removal\",\n    \"client-side\",\n    \"data-privacy\",\n    \"image-segmentation\",\n    \"image-matting\",\n    \"onnx\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/imgly/background-removal-js.git\"\n  },\n  \"license\": \"SEE LICENSE IN LICENSE.md\",\n  \"author\": {\n    \"name\": \"IMG.LY GmbH\",\n    \"email\": \"support@img.ly\",\n    \"url\": \"https://img.ly\"\n  },\n  \"bugs\": {\n    \"email\": \"support@img.ly\"\n  },\n  \"source\": \"./src/index.ts\",\n  \"main\": \"./dist/index.cjs\",\n  \"module\": \"./dist/index.mjs\",\n  \"types\": \"./dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"require\": \"./dist/index.cjs\",\n      \"import\": \"./dist/index.mjs\",\n      \"types\": \"./dist/index.d.ts\"\n    }\n  },\n  \"homepage\": \"https://img.ly/showcases/cesdk/web/background-removal\",\n  \"files\": [\n    \"LICENSE.md\",\n    \"README.md\",\n    \"CHANGELOG.md\",\n    \"dist/\",\n    \"bin/\"\n  ],\n  \"scripts\": {\n    \"start\": \"npm run watch\",\n    \"clean\": \"npx rimraf dist\",\n    \"test\": \"true\",\n    \"resources\": \"node ../../scripts/package-resources.mjs\",\n    \"changelog:create\": \"node ../../scripts/changelog/create.mjs\",\n    \"changelog:generate\": \"node ../../scripts/changelog/generate.mjs\",\n    \"build\": \"npm run clean && npm run resources && npm run changelog:generate && node scripts/build.mjs\",\n    \"watch\": \"npm run clean && npm run resources && npm run changelog:generate && node scripts/watch.mjs\",\n    \"publish\": \"npm run build && npm publish --access public\",\n    \"lint\": \"npx prettier --write .\"\n  },\n  \"dependencies\": {\n    \"@types/lodash\": \"^4.14.195\",\n    \"@types/node\": \"^20.3.1\",\n    \"lodash\": \"^4.17.21\",\n    \"ndarray\": \"^1.0.19\",\n    \"onnxruntime-web\": \"^1.16.3\",\n    \"zod\": \"^3.21.4\"\n  },\n  \"devDependencies\": {\n    \"assert\": \"^2.0.0\",\n    \"esbuild\": \"^0.18.18\",\n    \"glob\": \"^10.3.3\",\n    \"npm-dts\": \"^1.3.12\",\n    \"process\": \"^0.11.10\",\n    \"ts-loader\": \"^9.4.3\",\n    \"tslib\": \"^2.5.3\",\n    \"typescript\": \"^5.1.3\",\n    \"util\": \"^0.12.5\",\n    \"webpack\": \"^5.85.1\",\n    \"webpack-cli\": \"^5.1.4\"\n  }\n}", "export { initInference, runInference };\n\nimport { tensorResizeBilinear, tensorHWCtoBCHW } from './utils';\nimport { createOnnxSession, runOnnxSession } from './onnx';\nimport { Config, validateConfig } from './schema';\n\nimport { loadAsBlob } from './resource';\nimport ndarray, { NdArray } from 'ndarray';\nimport { convertFloat32ToUint8 } from './utils';\n\nasync function initInference(config?: Config) {\n  config = validateConfig(config);\n\n  if (config.debug) console.debug('Loading model...');\n  const model = config.model;\n  const blob = await loadAsBlob(`/models/${model}`, config);\n  const arrayBuffer = await blob.arrayBuffer();\n  const session = await createOnnxSession(arrayBuffer, config);\n  return { config, session };\n}\n\nasync function runInference(\n  imageTensor: NdArray<Uint8Array>,\n  config: Config,\n  session: any\n): Promise<NdArray<Uint8Array>> {\n  if (config.progress) config.progress('compute:inference', 0, 1);\n  const resolution = 1024;\n  const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;\n\n  let tensorImage = tensorResizeBilinear(imageTensor, resolution, resolution);\n  const inputTensor = tensorHWCtoBCHW(tensorImage); // this converts also from float to rgba\n\n  // run\n  const predictionsDict = await runOnnxSession(\n    session,\n    [['input', inputTensor]],\n    ['output']\n  );\n\n  let alphamask = ndarray(predictionsDict[0].data, [resolution, resolution, 1]);\n  alphamask = convertFloat32ToUint8(alphamask);\n  alphamask = tensorResizeBilinear(alphamask, srcWidth, srcHeight);\n\n  if (config.progress) config.progress('compute:inference', 1, 1);\n  return alphamask;\n}\n"],
  "mappings": "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",
  "names": ["ndarray", "ndarray", "ndarray", "ndarray", "ndarray", "e", "ndarray", "ndarray", "ndarray", "preload", "ndarray"]
}
